<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="z217&#39;s blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/jquery.floatingscroll.css>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"
    integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src=https://z217blog.cn/js/jquery.floatingscroll.min.js></script>
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/navbutton.js></script>
<script src=https://z217blog.cn/js/lightswitcher.js></script>
<script src=https://z217blog.cn/js/toc.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn/><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>
        

        <a id="branding" href=https://z217blog.cn/>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a><br/>
        <a href="javascript:void(0)" id="scroll-top" onclick="scrollToTop()">回到顶部</a>
        <a href="javascript:void(0)" id="light-switcher">暗色模式</a>
        <div class="content">

<h1 id="title">Unix网络编程（15）：程序设计范式</h1>




<p>        开发一个<code>Unix</code>服务器程序时，我们有如下类型的进程控制可选：</p>
<ul>
<li><strong>迭代服务器</strong> ( $iterative$ $server$ ) 程序，在一个主循环内处理所有客户服务。这种类型的适用情形极为有限，因为这样的服务器在完成当前客户的服务之前无法处理后续等待的客户；</li>
<li><strong>并发服务器</strong> ( $concurrent$ $server$ ) 程序，它为每个客户调用 $fork$ 派生一个子进程。传统上大多数<code>Unix</code>服务器程序属于这种类型；</li>
<li>通过 $select$ 处理任意多个客户的服务器；</li>
<li><strong>预先派生子进程</strong> ( $preforking$ ) 程序，它让服务器在启动阶段调用 $fork$ 创建一个子进程池，每个客户请求由当前可用子进程池中的某个闲置子进程处理；</li>
<li><strong>预先创建线程</strong> ( $prethreading$ ) 程序，它让服务器在启动阶段创建一个线程池，每个客户由当前可用线程池中的某个闲置线程处理。</li>
</ul>
<p>        <code>TCP</code>客户程序则有以下范式：</p>
<ul>
<li>以停-等方式运作的客户程序，进程在被阻塞以等待用户输入期间，看不到诸如对端关闭连接等网络事件，而且批处理效率极低；</li>
<li>调用 $select$ 监听的客户程序，可以得到网络事件通知；</li>
<li>非阻塞式<code>I/O</code>客户程序；</li>
<li>多进程客户程序；</li>
<li>多线程客户程序。</li>
</ul>
<h2 id="1-tcp预先派生子进程服务器程序accept无上锁保护">1. <code>TCP</code>预先派生子进程服务器程序，<code>accept</code>无上锁保护</h2>
<p>        这种技术的优点在于无须引入父进程执行 $fork$ 的开销就能处理新客户，缺点是父进程必须在服务器启动阶段配置预先派生子进程数量。可选的改进方案是增加一些代码，让父进程监听可用子进程数，一旦降低到某个阈值就派生额外的子进程；同样的，一旦可用子进程数增加到某个阈值就终止一些过剩的子进程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;unp.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAXN 16384  </span><span class="c1">// max # bytes client can request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="n">nchildren</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">pid_t</span> <span class="o">*</span><span class="n">pids</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pid_t</span> <span class="nf">child_make</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">listenfd</span> <span class="o">=</span> <span class="nf">Tcp_listen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">.</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">listenfd</span> <span class="o">=</span> <span class="nf">Tcp_listen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;usage: serv02 [ &lt;host&gt; ] &lt;port#&gt; &lt;#children&gt;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">nchildren</span> <span class="o">=</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pids</span> <span class="o">=</span> <span class="nf">Calloc</span><span class="p">(</span><span class="n">nchildren</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">pid_t</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">child_make</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">listendfd</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>  <span class="c1">// parent returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="nf">Signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pause</span><span class="p">();</span>  <span class="c1">// everything done by children
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// terminate all children
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">kill</span><span class="p">(</span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">SIGTERM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nf">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">// wait for all children
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">ECHILD</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;wait error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">pid_t</span> <span class="nf">child_make</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">child_main</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="nf">Fork</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>  <span class="c1">// parent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="nf">child_main</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>  <span class="c1">// never returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">child_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">web_child</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">socklen_t</span> <span class="n">clilen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">cliaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">cliaddr</span> <span class="o">=</span> <span class="nf">Malloc</span><span class="p">(</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child %ld starting</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">connfd</span> <span class="o">=</span> <span class="nf">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">web_child</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// process the request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">web_child</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ntowrite</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">ssize_t</span> <span class="n">nread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">nread</span> <span class="o">=</span> <span class="nf">Realine</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>  <span class="c1">// connection closed by other end
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// line from client specifies #bytes to write back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ntowrite</span> <span class="o">=</span> <span class="nf">atol</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">ntowrite</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ntowrite</span> <span class="o">&gt;</span> <span class="n">MAXN</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;client request for %d bytes&#34;</span><span class="p">,</span> <span class="n">ntowrite</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">Writen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">ntowrite</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        父进程在派生任何子进程之前创建监听套接字，从而每次 $fork$ 时，所有描述符也被复制。服务器进程在程序启动阶段派生 $N$ 个子进程，它们各自调用 $accept$ 并处于休眠状态。当客户连接到达时，所有子进程均被唤醒，因为它们使用同一个监听描述符，但是只有最先运行的子进程会获得连接，其余子进程会重新休眠。这就是<em><strong>惊群</strong></em> ( $thundering$ $herd$ ) 问题，尽管只有一个子进程获得连接，所有的子进程却都被唤醒了，这样会导致性能受损。<br>
        与这个例子相关的另一种现象是 $select$ 冲突。如果我们通过 $select$ 来 $accept$ 新客户，那么内核会唤醒所有在阻塞在 $select$ 并且等待同一个监听套接字的进程，从而产生冲突。从以上问题，我们可以得出：如果有多个进程阻塞在引用同一个实体的描述符上，最好直接阻塞在 $accept$ 等函数中，而不是 $select$ 上。</p>
<h2 id="2-tcp预先派生子进程服务器程序accept使用文件上锁保护">2. <code>TCP</code>预先派生子进程服务器程序，<code>accept</code>使用文件上锁保护</h2>
<p>        允许多个进程在引用同一个监听套接字的描述上调用 $accept$ 仅适用于在内核中实现 $accept$ 的源自 $Berkeley$ 的内核。在其他内核，解决办法是让应用程序在调用 $accept$ 前后使用锁，从而在任意时刻最多只有一个进程阻塞在 $accept$ 调用上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 派生子进程之前初始化锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">my_lock_init</span><span class="p">(</span><span class="s">&#34;/tmp/lock.XXXXXX&#34;</span><span class="p">);</span>  <span class="c1">// one lock file for all children
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">child_make</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>  <span class="c1">// parent returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 子进程调用accept前后加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">my_lock_wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">connfd</span> <span class="o">=</span> <span class="nf">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">my_lock_release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">web_child</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// process request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;unp.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">flock</span> <span class="n">lock_it</span><span class="p">,</span> <span class="n">unlock_it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="n">lock_fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// fcntl() will fail if my_lock_init() not called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">my_lock_init</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">lock_file</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// must copy caller&#39;s string, incase is&#39;s a constant
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">strncpy</span><span class="p">(</span><span class="n">lock_file</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lock_file</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">lock_fd</span> <span class="o">=</span> <span class="nf">Mkstemp</span><span class="p">(</span><span class="n">lock_file</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">Unlink</span><span class="p">(</span><span class="n">lock_file</span><span class="p">);</span>  <span class="c1">// but lock_fd remains open
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">lock_it</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">F_WRLCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">lock_it</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">SEEK_SET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">lock_it</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">lock_it</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">unlock_it</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">unlock_it</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">SEEK_SET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">unlock_it</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">unlock_it</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        调用者将一个路径名模版指定为 $my_-lock_-init$ 函数的参数，$mktemp$ 函数根据该模版创建一个唯一路径名。本函数随后创建一个具备该路径名的文件并立即 $unlink$ 掉，这样以后程序崩溃，这个临时文件也会消失。然而只要有一个进程打开着这个文件，这个文件就不会消失。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_lock_wait</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="nf">fcntl</span><span class="p">(</span><span class="n">lock_fd</span><span class="p">,</span> <span class="n">F_SETLKW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock_it</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">      <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;fcntl error for my_lock_wait&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_lock_release</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">fcntl</span><span class="p">(</span><span class="n">lock_fd</span><span class="p">,</span> <span class="n">F_SETLKW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unlock_it</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;fcntl error for my_lock_release&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="3-tcp预先派生子进程服务器程序accept使用线程上锁保护">3. <code>TCP</code>预先派生子进程服务器程序，<code>accept</code>使用线程上锁保护</h2>
<p>        我们有多种方法实现进程上锁，<code>POSIX</code>文件上锁方法可移植到所有<code>POSIX</code>兼容系统，不过因为涉及文件操作，可能比较耗时。在不同进程之间使用线程上锁，要求：(a)互斥锁变量必须存放在由所有进程共享的内存中；(b)必须告知线程函数库这是在不同进程之间共享的互斥锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">pthread_mutex_t</span> <span class="o">*</span><span class="n">mptr</span><span class="p">;</span>  <span class="c1">// actual mutex will be in shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_lock_init</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pthread_mutexattr_t</span> <span class="n">mattr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">fd</span> <span class="o">=</span> <span class="nf">Open</span><span class="p">(</span><span class="s">&#34;/dev/zero&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">mptr</span> <span class="o">=</span> <span class="nf">Mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">pthread_mutex_t</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">Pthread_mutexattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mattr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Pthread_mutexattr_setpshared</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mattr</span><span class="p">,</span> <span class="n">PTHREAD_PROCESS_SHARED</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Pthread_mutex_init</span><span class="p">(</span><span class="n">mptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mattr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        打开 $/dev/zero$ 然后调用 $mmap$ ，映射的字节数是一个 $pthread_-mutex_-t$ 类型的变量大小。随后关闭描述，因为该描述符已经被内存映射了。在先前的互斥锁中，我们使用 $PTHREAD_-MUTEX_-INTIALIZER$ 初始化全局或静态互斥锁变量。然而对于一个存放在共享内存区的互斥锁，必须调用一些 $pthread$ 库函数告知该函数库这是一个位于共享内存区的互斥锁，用于不同进程间上锁。我们首先为该互斥锁以默认属性初始化一个 $pthread_-mutexattr_-t$ 结构，然后赋予该结构 $PTHREAD_-PROCESS_-SHARED$ 属性 ( 该结构默认属性为 $PTHREAD_-PROCESS_-PRIVATE$ ，即只能在进程内使用 )。最后调用 $pthread_-mutex_-init$ 函数初始化共享内存区的互斥锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_lock_wait</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="n">mptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">my_lock_release</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="n">mptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="4-tcp预先派生子进程服务器程序传递描述符">4. <code>TCP</code>预先派生子进程服务器程序，传递描述符</h2>
<p>        这个版本是让父进程调用 $accept$ ，然后将描述符传递给子进程。这种技术会使代码变得有点复杂，因为父进程必须跟踪子进程的忙闲状态。为了实现这个机制，我们必须为每个子进程维护一个信息结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pid_t</span> <span class="n">child_pid</span><span class="p">;</span>  <span class="c1">// process ID;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">child_pipefd</span><span class="p">;</span>  <span class="c1">// parent&#39;s stream pipe to/from child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">child_status</span><span class="p">;</span>  <span class="c1">// 0 = ready
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">long</span> <span class="n">child_count</span><span class="p">;</span>  <span class="c1">// # connections handled
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">Child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Child</span> <span class="o">*</span><span class="n">cptr</span><span class="p">;</span>  <span class="c1">// array of Child structures; calloc&#39; ed
</span></span></span></code></pre></div><p>        我们在该结构中存放子进程<code>ID</code>、父进程中连接到子进程的字节流管道描述符、子进程状态和子进程已处理客户的计数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">pid_t</span> <span class="nf">child_make</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">sockfd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">child_main</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">Socketpair</span><span class="p">(</span><span class="n">AF_LOCAL</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="nf">Fork</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span> <span class="o">=</span> <span class="n">sockfd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>  <span class="c1">// parent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">Dup2</span><span class="p">(</span><span class="n">sockfd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">STDERR_FILENO</span><span class="p">);</span>  <span class="c1">// child&#39;s stream pipe to parent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">Close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span>  <span class="c1">// child does not need this open
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">child_main</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>  <span class="c1">// never returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        $child_-make$ 函数在调用 $fork$ 前先创建一个字节流管道。派生出子进程后，父进程关闭其中一个描述符 $sockfd[1]$ ，子进程关闭另一个描述符 $sockfd[0]$ 。子进程还把流管道的自身拥有端 $sockfd[1]$ 复制到标准错误输出，这样每个子进程就通过读写标准错误输出和父进程通信。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;unp.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;child.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="n">nchildren</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">navail</span><span class="p">,</span> <span class="n">maxfd</span><span class="p">,</span> <span class="n">nsel</span><span class="p">,</span> <span class="n">connfd</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pid_t</span> <span class="nf">child_make</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">ssize_t</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">fd_set</span> <span class="n">rset</span><span class="p">,</span> <span class="n">masterset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">,</span> <span class="n">clilen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">cliaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">listenfd</span> <span class="o">=</span> <span class="nf">Tcp_listen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">listenfd</span> <span class="o">=</span> <span class="nf">Tcp_listen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;usage: serv05 [ &lt;host&gt; ] &lt;potr#&gt; &lt;#children&gt;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">masterset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">FD_SET</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">masterset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">maxfd</span> <span class="o">=</span> <span class="n">listenfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cliaddr</span> <span class="o">=</span> <span class="nf">Malloc</span><span class="p">(</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">nchildren</span> <span class="o">=</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="n">navail</span> <span class="o">=</span> <span class="n">nchildren</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cptr</span> <span class="o">=</span> <span class="nf">Calloc</span><span class="p">(</span><span class="n">nchildren</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Child</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// prefork all the children
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">child_make</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>  <span class="c1">// parent returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">FD_SET</span><span class="p">(</span><span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">masterset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">maxfd</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">maxfd</span><span class="p">,</span> <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">Signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rset</span> <span class="o">=</span> <span class="n">masterset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">navail</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">FD_CLR</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">);</span>  <span class="c1">// turn off if no available children
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">nsel</span> <span class="o">=</span> <span class="nf">Select</span><span class="p">(</span><span class="n">maxfd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// check for new connections
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">FD_ISSET</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">connfd</span> <span class="o">=</span> <span class="nf">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>  <span class="c1">// available
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nchildren</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;no available children&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// mark child as busy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">navail</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">n</span> <span class="o">=</span> <span class="nf">Write_fd</span><span class="p">(</span><span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nsel</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">continue</span><span class="p">;</span>  <span class="c1">// all done with select() results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// find any newly-available children
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nf">FD_ISSET</span><span class="p">(</span><span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="nf">Read</span><span class="p">(</span><span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;child %d terminated unexpectedly&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">navail</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nsel</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>  <span class="c1">// all done with select() results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        $navail$ 跟踪当前可用的子进程数，如果为 $0$ ，关闭 $select$ 读描述符集中监听套接字对应的位。这种情况下，内核仍然会处理外来连接，将它们入队，直到达到 $backlog$ 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">child_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">ssize_t</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">web_child</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child %ld starting</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="nf">Read_fd</span><span class="p">(</span><span class="n">STDERR_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">connfd</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;read_fd returned 0&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">connfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;no descriptor from read_fd&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">web_child</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// process request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">Write</span><span class="p">(</span><span class="n">STDERR_FILENO</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// tell parent we&#39;re ready again
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        $child_-main$ 在处理完一个客户后，通过该子进程的字节流管道拥有端向父进程写回单个字节。父进程读入这单个字节，把子进程标记为可用，并递增 $navail$ 。当子进程意外终止，它的字节流管道拥有端会被关闭，从而 $read$ 会返回 $0$ 。父进程察觉到之后就会停止运行，不过更好的办法是登记这个错误并重新派生一个子进程。</p>
<h2 id="5-tcp并发服务器程序每个客户一个线程">5. <code>TCP</code>并发服务器程序，每个客户一个线程</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="nf">doit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pthread_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">socklen_t</span> <span class="n">clilen</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">cliaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">listenfd</span> <span class="o">=</span> <span class="nf">Tcp_listen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">listenfd</span> <span class="o">=</span> <span class="nf">Tcp_listen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;usage: serv06 [ &lt;host&gt; ] &lt;port#&gt;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">cliaddr</span> <span class="o">=</span> <span class="nf">Malloc</span><span class="p">(</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">Signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">connfd</span> <span class="o">=</span> <span class="nf">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doit</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">doit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">web_child</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">Pthread_detach</span><span class="p">(</span><span class="nf">pthread_self</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="nf">web_child</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Close</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="6-tcp预先创建线程服务器程序每个线程各自accept">6. <code>TCP</code>预先创建线程服务器程序，每个线程各自<code>accept</code></h2>
<p>        在支持线程的系统上，我们有理由在服务器启动阶段先创建一个线程池。本服务器的基本设计是预先创建一个线程池，并让每个线程各自调用 $accept$ ，同时使用互斥锁保证任何时刻只有一个线程在调用 $accept$ 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pthread_t</span> <span class="n">thread_tid</span><span class="p">;</span>  <span class="c1">// thread id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">long</span> <span class="n">thread_count</span><span class="p">;</span>  <span class="c1">// # connections handled
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">Thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="o">*</span><span class="n">tptr</span><span class="p">;</span>  <span class="c1">// array of Thread structures; calloc &#39;ed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">mlock</span><span class="p">;</span>
</span></span></code></pre></div><hr>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;pthread07.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">mlock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="nf">thread_make</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">listenfd</span> <span class="o">=</span> <span class="nf">Tcp_listen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">listenfd</span> <span class="o">=</span> <span class="nf">Tcp_listen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;usage: serv07 [ &lt;host&gt; ] &lt;port#&gt; &lt;#threads&gt;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">nthreads</span> <span class="o">=</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="n">tprt</span> <span class="o">=</span> <span class="nf">Calloc</span><span class="p">(</span><span class="n">nthreads</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Thread</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">thread_make</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// only main thread returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="nf">Signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pause</span><span class="p">();</span>  <span class="c1">// everything done by threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><hr>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;pthread07.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread_make</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="nf">thread_main</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">thread_tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_main</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span><span class="p">;</span>  <span class="c1">// main thread returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">thread_main</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">web_child</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">socklen_t</span> <span class="n">clilen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">cliaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">cliaddr</span> <span class="o">=</span> <span class="nf">Malloc</span><span class="p">(</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;thread %d starting</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">connfd</span> <span class="o">=</span> <span class="nf">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">tprt</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">].</span><span class="n">thread_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">web_child</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// process request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="7-tcp预先创建线程服务器程序主线程统一accept">7. <code>TCP</code>预先创建线程服务器程序，主线程统一<code>accept</code></h2>
<p>        本设计范式的问题在于主线程如何把一个已连接套接字传递给线程池中某个可用线程。这里有多个实现手段。可以像之前那样使用描述符传递，但是没有必要，因为多个线程之间描述符是共享的，接收线程只需要知道已连接套接字描述符的值即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pthread_t</span> <span class="n">thread_tid</span><span class="p">;</span>  <span class="c1">// thread id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">long</span> <span class="n">thread_count</span><span class="p">;</span>  <span class="c1">// # connections handled
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">Thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span> <span class="o">*</span><span class="n">tptr</span><span class="p">;</span>  <span class="c1">// array of Thread structures; calloc&#39;ed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAXNCLI 32
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">clifd</span><span class="p">[</span><span class="n">MAXNCLT</span><span class="p">],</span> <span class="n">iget</span><span class="p">,</span> <span class="n">iput</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">clifd_mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_cond_t</span> <span class="n">clifd_cond</span><span class="p">;</span>
</span></span></code></pre></div><p>        $clifd$ 数组会存储线程已经接受的已连接套接字描述符，$iget$ 为下一个待取出描述符元素所在的下标，$iput$ 为下一个待写入描述符元素所在的下标。我们使用互斥锁和条件变量确保这个数组被安全地修改。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;pthread08.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="n">nthreads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">clifd_mutex</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_cond_t</span> <span class="n">clifd_cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INTIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="nf">thread_make</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">,</span> <span class="n">clilen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">cliaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">listenfd</span> <span class="o">=</span> <span class="nf">Tcp_listen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">listenfd</span> <span class="o">=</span> <span class="nf">Tcp_listen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;usage: serv08 [ &lt;host&gt; ] &lt;port#&gt; &lt;#threads&gt;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">cliaddr</span> <span class="o">=</span> <span class="nf">Malloc</span><span class="p">(</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">nthreads</span> <span class="o">=</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="n">tprt</span> <span class="o">=</span> <span class="nf">Calloc</span><span class="p">(</span><span class="n">nthreads</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Thread</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">iget</span> <span class="o">=</span> <span class="n">iput</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// create all the threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">thread_make</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// only main thread returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="nf">Signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">connfd</span> <span class="o">=</span> <span class="nf">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">clifd</span><span class="p">[</span><span class="n">iput</span><span class="p">]</span> <span class="o">=</span> <span class="n">connfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">iput</span> <span class="o">==</span> <span class="n">MAXNCLI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">iput</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">iput</span> <span class="o">==</span> <span class="n">iget</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;iput = iget = %d&#34;</span><span class="p">,</span> <span class="n">iput</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_cond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;pthread08.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread_make</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span><span class="nf">thread_main</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">thread_tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_main</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span><span class="p">;</span>  <span class="c1">// main thread returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">thread_main</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">web_child</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;thread %d starting</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">iget</span> <span class="o">==</span> <span class="n">iput</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="nf">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clifd_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">connfd</span> <span class="o">=</span> <span class="n">clifd</span><span class="p">[</span><span class="n">iget</span><span class="p">];</span>  <span class="c1">// connected socket to service
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">iget</span> <span class="o">==</span> <span class="n">MAXNCLI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">iget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">tptr</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">].</span><span class="n">thread_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">web_child</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// process request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        这个版本的慢于之前的每个线程各自 $accept$ 的版本，因为同时需要互斥锁和条件变量。</p>


<div>
    <a href="javascript:void(0);" id="tocbtn"><i class="fas fa-bars fa-lg"></i></a>
    <div id="sidetoc">
        <header>
            <h4>Unix网络编程（15）：程序设计范式</h4>
        </header>
        <nav id="TableOfContents">
            <ul></ul>
        </nav>
    </div>
    <script>
        isTocOpen = true;
    </script>
</div>


<div class="nav-next-prev">
    <div class="nav-prev">
        
        <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B14/"><i class="fas fa-chevron-left"></i></a>
        
    </div>
    <a class="nav-top" href="#">回到顶部</i></a>
    <div class="nav-next">
        
        <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/"><i class="fas fa-chevron-right"></i></a>
        
    </div>
</div>
<script type="text/javascript">
    tocInit();
</script>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:zihan.zhouchn@outlook.com">zihan.zhouchn@outlook.com</a>
            </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2024, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
    <script>
        InitLightSwitcher()
    </script>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
</main>
</body>

</html>