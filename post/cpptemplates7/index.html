<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/jquery.floatingscroll.css>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  <script src=https://z217blog.cn/js/jquery.floatingscroll.min.js></script>
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>
        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">

<h1 id="title">C&#43;&#43; Templates（7）：深入模版基础</h1>




<h2 id="1-参数化的声明">1. 参数化的声明</h2>
<p>        <code>C++</code>现在支持四种基础模版类型：类模版、函数模版、变量模版和别名模版，每个模版类型都能在命名空间作用域和类作用域中使用。在类作用域内，它们可以作为类内类模版、成员函数模版、静态数据成员模版和成员别名模版。这种模版的声明类似于普通类、函数、变量和类型别名，除了使用参数化子句开头外。<code>C++17</code>还引入了另一种使用参数化子句的结构——推导指引。<br>
        首先，让我们看一下四种模版的例子。首先是命名空间作用域：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 命名空间作用域类模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Data</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">copyable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 命名空间作用域函数模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">log</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 命名空间作用域变量模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">T</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 命名空间作用域变量模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">dataCopyable</span> <span class="o">=</span> <span class="n">Data</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">copyable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 命名空间作用域别名模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">DataList</span> <span class="o">=</span> <span class="n">Data</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">;</span>
</span></span></code></pre></div><p>        接下来是类作用域：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Collection</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 类内成员类模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 类内成员函数模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">T</span><span class="o">*</span> <span class="n">alloc</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 提供了定义，是隐式内联的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 成员变量模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="n">T</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 成员别名模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">using</span> <span class="n">NodePtr</span> <span class="o">=</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        在<code>C++17</code>，变量 ( 包括静态数据成员 ) 和变量模版可以“内联”，这意味着它们可以在翻译单元间重复定义。与成员函数不同，一个定义在封闭类中的静态数据成员不是内联的，必须在所有地方都指定 $inline$ 才行。<br>
        最后一段代码演示除别名模版外，其他模版都可以在类外定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">List</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">Handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">List</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">U</span> <span class="n">zero</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Handle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">List</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">U</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></div><p>        定义在类外的成员模版可能需要多个 $template$&lt;$\dots$&gt; 语句，从最外层到最内层的方式排列。注意一个构造函数模版会使类不生成隐式的默认构造函数，所以我们需要添加一个 $default$ 声明。<br>
        联合也可以使用模版：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">union</span> <span class="nc">AllocChunk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">object</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bytes</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        函数模版也可以有默认调用参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">report_top</span><span class="p">(</span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fill</span><span class="p">(</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="o">=</span> <span class="n">T</span><span class="p">{});</span>
</span></span></code></pre></div><p>        当 $fill$ 被调用时，如果提供了第二个参数，那么默认参数就不会实例化。这样就可以确保当 $T$ 没有默认构造函数时不会报错了。<br>
        类内除了可以声明四种基本模版类型外，你也可以让普通类成员通过成为类模版成员的方式实现参数化。它们通常被错误地称为成员模版。尽管可以被参数化，但是这种定义跟第一类模版是不同的，它们的参数是完全由它们所属的模版决定的。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CupBoard</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">Shelf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">open</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="nc">Wood</span> <span class="o">:</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">double</span> <span class="n">totalWeight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        相应的定义只会在父类模版中使用参数化子句，不会在成员中使用，因为它们不是模版：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CupBoard</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;::</span><span class="n">Shelf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">CupBoard</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;::</span><span class="n">open</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">CupBoard</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;::</span><span class="n">Wood</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Maple</span><span class="p">,</span> <span class="n">Cherry</span><span class="p">,</span> <span class="n">Oak</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">CupBoard</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;::</span><span class="n">totalWeight</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span></code></pre></div><p>        从<code>C++17</code>开始，静态 $totalWeight$ 成员可以在类内模版中使用 $inline$ ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CupBoard</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">inline</span> <span class="k">static</span> <span class="kt">double</span> <span class="n">totalWeight</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        尽管这种参数化定义通常被称为模版，但是这个名词不太适合它们。一个偶尔被建议用于称呼这些实体的名词是 $temploid$ 。从<code>C++17</code>开始，<code>C++</code>标准没有定义<strong>模版化实体</strong> ( $templated$ $entity$ ) 的概念，它通常包含模版和 $temploid$ ，以及任何在模版实体中定义和创建的实体。</p>
<h3 id="11-虚成员函数">1.1 虚成员函数</h3>
<p>        成员函数模版不能作为虚函数。因为通常虚函数调用机制是通过一个固定大小的表，表项指向每一个虚函数。然而，只有当整个程序都被翻译完成后，成员函数模版的数量才能确定。因此，虚成员函数模版的支持，需要<code>C++</code>编译器和链接器提供一种新机制。</p>
<h3 id="12-模版的链接性">1.2 模版的链接性</h3>
<p>        每个模版必须有个名字，并且在当前作用域内，这个名字必须是独一无二的，除非是可重载的函数模版。与类类型不同，类模版不允许在不同类型实体之间使用相同的名字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">X</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><p>        模版名具有链接性，但他们不能有<code>C</code>链接性。非标准的链接性可能具有依赖于实现的含义 ( 然而，我们并不知道支持模版的非标准名称链接性的实现 )：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">extern</span> <span class="s">&#34;C++&#34;</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">normal</span><span class="p">();</span>  <span class="c1">// 默认，可以省略链接性的指定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">invalid</span><span class="p">();</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="s">&#34;Java&#34;</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">javaLink</span><span class="p">();</span>  <span class="c1">// 非标准，但是可能有些编译器在将来会支持
</span></span></span></code></pre></div><p>        模版通常具有外部链接性。除了命名空间中指定为 $static$ 的函数模版、直接或间接作为匿名函数空间成员的模版 ( 具有内部链接性 ) 和匿名类成员模版 ( 没有链接性 )。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 作为另一个文件中名称相同的实体的声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">external</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 与另一个文件中名称相同模版没有关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="n">internal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 再次声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="n">internal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span>  <span class="c1">// 与另一个文件中名称相同的模版没有关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">otherInternal</span><span class="p">();</span>  <span class="c1">// 即使那个模版也在匿名命名空间内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span>  <span class="c1">// 再次声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">otherInternal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 无链接性，不能被再次声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">x</span><span class="p">;</span>
</span></span></code></pre></div><p>        注意由于最后的成员模版没有链接性，所以它必须与匿名类一起定义，因为没有办法在类外提供定义。<br>
        通常模版不能在函数作用域或者局部类作用域中声明，但是泛型<code>lambda</code>，它关联闭包类型且包含成员函数模版，可以在局部作用域中使用。<br>
        模版实例的链接性与模版的链接性相同。例如，函数 $internal$&lt;$void$&gt; 是上面声明的模版的实例化，它与模版一样具有内部链接性。对于变量模版，这会产生有趣的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">T</span><span class="p">{};</span>
</span></span></code></pre></div><p>        所有 $zero$ 的实例化都会具有外部链接性，即使是 $zero$&lt;$int$ $const$&gt; 。这可能有点反直觉，因为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="k">const</span> <span class="n">zero_int</span> <span class="o">=</span> <span class="kt">int</span><span class="p">{};</span>
</span></span></code></pre></div><p>        是具有内部链接性的，因为它声明为 $const$ 。类似的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="k">const</span> <span class="n">max_volume</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
</span></span></code></pre></div><p>        所有这个模版的实例化都具有外部链接性，尽管这些实现都具有 $const$ 限定符。</p>
<h3 id="13-主模版">1.3 主模版</h3>
<p>        一般的模版声明称为<strong>主模版</strong> ( $primary$ $templates$ )，这种模版声明没有在模版名后添加尖括号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Box</span><span class="p">;</span>  <span class="c1">// 主模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// 错误，没有特例化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">translate</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>  <span class="c1">// 主模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">translate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>  <span class="c1">// 错误，不允许这样声明函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">T</span><span class="p">{};</span>  <span class="c1">// 主模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">zero</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">{};</span>  <span class="c1">// 错误，没有特例化
</span></span></span></code></pre></div><p>        非主模版在声明类部分特例化或这变量模版时出现。</p>
<h2 id="2-模版参数">2. 模版参数</h2>
<p>        模版参数有三种基本类型：</p>
<ol>
<li>类型参数 ( 最常见的 )；</li>
<li>非类型参数；</li>
<li>模版模版参数。</li>
</ol>
<p>        任意一种类型都可以作为模版参数集合元素。模版参数在模版参数化子句中声明，如果模版中需要参数名，那么在定义时需要给出参数名。</p>
<h3 id="21-类型参数">2.1 类型参数</h3>
<p>        类型参数可以使用 $typename$ 关键字或者 $class$ 关键字，它们是等价的。关键字之后应该是一个简单的标识符，在下一个类型参数的开始之前需要使用逗号隔开。类型参数的声明使用尖括号代表开始和结束，中间可以使用 $=$ 声明默认模版参数。<br>
        在模版声明中，类型参数类似于一个类型别名。例如，当 $T$ 是一个模版参数时，你无法使用它的全名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">Allocator</span><span class="o">*</span> <span class="n">allocptr</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Allocator</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h3 id="22-非类参数">2.2 非类参数</h3>
<p>        非类模版参数代表可以在编译期或者链接期确定的常量。这样的参数必须是：</p>
<ul>
<li>整型或枚举型；</li>
<li>指针类型；</li>
<li>成员指针；</li>
<li>左值引用类型；</li>
<li>$std::nullptr_-t$ ；</li>
<li>包含 $auto$ 或 $decltype(auto)$ 的类型。</li>
</ul>
<p>        其他类型暂不支持。出乎意料的是，非类模版参数的声明有时候也可以使用 $typename$ ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">Allocator</span><span class="o">*</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">List</span><span class="p">;</span>
</span></span></code></pre></div><p>        或者使用 $class$ ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">X</span><span class="o">*&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Y</span><span class="p">;</span>
</span></span></code></pre></div><p>        这种情况很容易区分，因为它们之后都是标识符。<br>
        也可以指定函数和数组类型，但是它们会被隐式转为指针类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Lexer</span><span class="p">;</span>  <span class="c1">// 实际上是int*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span> <span class="n">buf</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Lexer</span><span class="p">;</span>  <span class="c1">// 再次声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">fun</span><span class="p">()</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">FuncWrap</span><span class="p">;</span>  <span class="c1">// 实际上是函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)()</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">FuncWrap</span><span class="p">;</span>  <span class="c1">// 再次声明
</span></span></span></code></pre></div><p>        非类模版参数的声明类似于变量，但是不能具有非类标识符，像 $static$ 、$mutable$ 等。它们可以有 $const$ 和 $volatile$ 标识符，但是如果这种标识符在最外层的模版参数类型中使用就会被忽略：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span> <span class="n">length</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Buffer</span><span class="p">;</span>  <span class="c1">// const会被忽略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">length</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Buffer</span><span class="p">;</span>  <span class="c1">// 与上一种一样
</span></span></span></code></pre></div><p>        最后，非引用的非类模版参数的地址是无法获取的，所以无法被赋值。一个左值引用非类模版参数则可以这样使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">Counter</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">LocalIncrement</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">LocalIncrement</span><span class="p">()</span> <span class="p">{</span> <span class="n">Counter</span> <span class="o">=</span> <span class="n">Counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">LocalIncrement</span><span class="p">()</span> <span class="p">{</span> <span class="n">Counter</span> <span class="o">=</span> <span class="n">Counter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        右值就不可以这样做了。</p>
<h3 id="23-模版模版参数">2.3 模版模版参数</h3>
<p>        模版模版参数是类模版或者别名模版的占位符。它们的声明方式类似于类模版，但是不能使用 $struct$ 和 $union$ ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">C</span><span class="o">&gt;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="k">union</span> <span class="nc">C</span><span class="o">&gt;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">);</span>
</span></span></code></pre></div><p>        <code>C++17</code>允许使用 $typename$ 而不是 $class$ ，这个改变可能是因为模版模版参数不仅可以被类模版代替，也可以被别名模版代替。所以，<code>C++17</code>中可以这样写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">);</span>
</span></span></code></pre></div><p>        在它们的声明中，模版模版参数就类似于其他类或者别名模版。<br>
        模版模版参数也可以有默认模版参数，当对应的参数没有指定时就会使用它们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="k">typename</span> <span class="n">A</span> <span class="o">=</span> <span class="n">MyAllocator</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Container</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Adaptation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Container</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">storage</span><span class="p">;</span>  <span class="c1">// 隐式等价于Container&lt;int, MyAllocator&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        $T$ 和 $A$ 是模版模版参数 $Container$ 的模版参数名，这个模版模版参数的名字只在其他模版的声明中使用。下面这个故意的例子展示了这个概念：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">*&gt;</span> <span class="k">class</span> <span class="nc">Buf</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Lexer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">T</span><span class="o">*</span> <span class="n">storage</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        通常，模版模版参数的模版参数名不需要在其他模版参数的声明中使用，因此也可以声明为匿名。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="k">typename</span> <span class="o">=</span> <span class="n">MyAllocator</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Container</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Adaptation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Container</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">storage</span><span class="p">;</span>  <span class="c1">// 隐式等价于Container&lt;int, MyAllocator&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h3 id="24-模版参数集合">2.4 模版参数集合</h3>
<p>        从<code>C++11</code>开始，任何类型的模版参数都可以作为模版参数集合使用，只需要在模版参数名前添加 $/dots$ 。匿名参数也可以使用模版参数集合。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Tuple</span><span class="p">;</span>
</span></span></code></pre></div><p>        一个模版参数集合的行为类似于它的底层模版参数，但是有一个重要不同之处：一个普通模版参数精准匹配一个模版传入参数，而一个模版参数集合可以匹配任意数量的模版传入参数。这意味着上面声明的 $Tuple$ 可以接收任意数量的类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">IntTuple</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">IntCharTuple</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">IntTriple</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">EmptyTuple</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">&lt;&gt;</span><span class="p">;</span>
</span></span></code></pre></div><p>        类似的，模版参数集合也可以接收任意数量非类模版参数和模版模版参数。相对的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">...</span> <span class="n">Dimensions</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MultiArray</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">TransformMatrix</span> <span class="o">=</span> <span class="n">MultiArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span> <span class="k">typename</span><span class="o">&gt;</span><span class="p">...</span> <span class="n">Containers</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">testContainers</span><span class="p">();</span>
</span></span></code></pre></div><p>        <code>C++17</code>还引入了非类模版参数的推导。<br>
        主类模版、变量模版和别名模版可以含有最多一个模版参数集合，并且模版参数集合只能在模版参数的最后。函数模版有着相对宽松的限制：允许多个模版参数集合，只要每个模版参数集合之后模版参数都有一个默认值，或者可以被推导。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Last</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LastType</span><span class="p">;</span>  <span class="c1">// 错误，模版参数集合不是最后一个模版参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TestTypes</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">runTests</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">);</span>  <span class="c1">// 模版参数集合之后的模版参数可以被推导
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">...</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">Tensor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">...</span> <span class="n">Dims1</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">...</span> <span class="n">Dims2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">compose</span><span class="p">(</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">Dims1</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Tensor</span><span class="o">&lt;</span><span class="n">Dims2</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span>
</span></span></code></pre></div><p>        类和变量模版的部分实例化声明也可以有多个参数集合，因为部分实例化的匹配机制类似于函数模版的匹配机制。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">Typelist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">Zip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Xs</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ys</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Zip</span><span class="o">&lt;</span><span class="n">Typelist</span><span class="o">&lt;</span><span class="n">Xs</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Typelist</span><span class="o">&lt;</span><span class="n">Ys</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span></code></pre></div><p>        一个类型参数集合不能在它自己的参数子句中展开，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span> <span class="n">vals</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StaticValues</span><span class="p">{};</span>
</span></span></code></pre></div><p>        然而，类内模版可以使用相似的语句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span> <span class="n">strcut</span> <span class="n">ArgList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span> <span class="n">vals</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">Vals</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ArgList</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;::</span><span class="n">Vals</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="sc">&#39;y&#39;</span><span class="o">&gt;</span> <span class="n">tada</span><span class="p">;</span>
</span></span></code></pre></div><p>        包含模版参数集合的模版称为变长模版，因为它可以接收任意数量的模版参数。</p>
<h3 id="25-默认模版参数">2.5 默认模版参数</h3>
<p>        任意种类的非模版参数集合的模版参数都可以指定默认参数，不过只能指定对应参数类型的值。默认参数不能依赖于它自己的参数，因为参数名并不在作用域内。但是可以依赖于之前的参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">List</span><span class="p">;</span>
</span></span></code></pre></div><p>        类模版、变量模版或者别名模版的模版参数都可以指定一个默认参数，如果指定了默认参数，那么后续参数也要指定默认参数 ( 类似的限制也适用于默认函数调用参数 )。后续的默认值通常在同个模版声明中提供，但是它们也可以在该模版先前声明中声明。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">typename</span> <span class="n">T4</span> <span class="o">=</span> <span class="kt">char</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T5</span> <span class="o">=</span> <span class="kt">char</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Quintuple</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span> <span class="o">=</span> <span class="kt">char</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">typename</span> <span class="n">T4</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T5</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Quintuple</span><span class="p">;</span>  <span class="c1">// 之前已经声明了T4和T5的默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span> <span class="o">=</span> <span class="kt">char</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">typename</span> <span class="n">T4</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T5</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Quintuple</span><span class="p">;</span>  <span class="c1">// 错误，T2没有默认值
</span></span></span></code></pre></div><p>        函数模版的默认模版参数不需要后续的默认参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span> <span class="o">=</span> <span class="kt">void</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">R</span><span class="o">*</span> <span class="n">addressof</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
</span></span></code></pre></div><p>        默认模版参数不能重复声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">=</span><span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Value</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><p>        有几种情况不能使用默认模版参数：</p>
<ul>
<li>部分特例化：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><ul>
<li>参数集合：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">X</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><ul>
<li>类模版成员的类外定义：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="nf">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>友类模版声明：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">struct</span> <span class="nc">F</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><ul>
<li>友元函数模版声明，除非给出定义，并且在当前翻译单元的其他地方没有再声明：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">();</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><h2 id="3-模版传入参数">3. 模版传入参数</h2>
<p>        当模版实例化时，模版参数会被模版传入参数代替。入参可以通过几种不同的机制指定：</p>
<ul>
<li>显式模版入参：模版名之后跟随一个尖括号括起来的模版入参列表，这个结果称为模版<code>id</code>；</li>
<li>类名注入：在具有 $P1$ 、$P2$ 等模版参数的的类模版 $X$ 中，$X$ 可以被视为 $X$&lt;$P1$ , $P2$ , $\dots$&gt; ；</li>
<li>默认模版入参：如果模版具有默认模版参数，那么可以忽略显式的模版入参。但是对于类或别名模版，即使所有默认参数都具有默认值，也要显式指定尖括号 ( 可以为空 )；</li>
<li>入参推导：如果没有显式指定函数模版入参，也可以从函数调用参数的类型中推导出来。如果所有模版入参都可以推导，那么可以省略尖括号。<code>C++17</code>还引入了从变量声明或者函数符号类型转换的初始化调用中推导出类模版参数的能力。</li>
</ul>
<h3 id="31-函数模版入参">3.1 函数模版入参</h3>
<p>        函数模版的模版入参可以显式指定，从模版使用方式或者默认模版入参中推导，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">max</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">max</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">);</span>  <span class="c1">// 显式指定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">);</span>  <span class="c1">// 隐式推导
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">::</span><span class="n">max</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>  <span class="c1">// 显式指定为int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        有些模版入参永远也不会被推导，因为它们相应的模版参数不在函数参数类型中出现，一些其他原因也会导致这种情况出现。相应的参数通常位域模版参数列表中的首位，从而我们可以只显式指定该入参，让其他入参隐式推导。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DstT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">SrcT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">DstT</span> <span class="n">implicit_cast</span><span class="p">(</span><span class="n">SrcT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">implicit_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        如果我们颠倒了上面模版参数的声明顺序，那么我们就需要显式指定所有模版入参。而且，这种参数不能位于模版参数集合后面，也不能部分特例化，因为这样就不能进行显式指定或者推导了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">double</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">Ts</span><span class="p">...</span> <span class="n">ps</span><span class="p">);</span>  <span class="c1">// N无法指定或推导
</span></span></span></code></pre></div><p>        因为函数模版可以重载，显式提供一个函数模版的所有入参可能还不足以确定一个函数。下面的例子就展示了这种问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Func</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Func</span> <span class="n">funcPtr</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">funcPtr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">single</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">multi</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">multi</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">single</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">multi</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        在这个例子中，第一个调用成功，因为没有歧义。第二个调用中，$multi$&lt;$int$&gt; 可以是两个版本中的任意一个，因此无法推导。<br>
        更进一步，使用模版入参代替函数模版可能会产生一个无效的<code>C++</code>类型或者表达式。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">RT1</span> <span class="n">test</span><span class="p">(</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">X</span> <span class="k">const</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">RT2</span> <span class="n">test</span><span class="p">(...);</span>
</span></span></code></pre></div><p>        这个例子中 $test$&lt;$int$&gt; 在第一个模版中是无意义的，因为它没有成员 $X$ 。但是第二个模版不存在这样的问题。因此，表达式 &amp;$test$&lt;$int$&gt; 就可以确定一个函数。这个原则称为<code>SFINAE</code> ( $substitution$ $failure$ $is$ $not$ $an$ $error$ )。</p>
<h3 id="32-类型入参">3.2 类型入参</h3>
<p>        模版类型参数指定的值就是模版类型入参。任意类型都可以作为模版类型入参，但是在使用入参替代之后的结构应该是一个有效的结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">clear</span><span class="p">(</span><span class="n">T</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 应该可以使用解引用运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">clear</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// 错误，不能使用解引用运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="33-非类入参">3.3 非类入参</h3>
<p>        非类模版参数指定的值是非类模版入参。这种值必须是下面其中一种：</p>
<ul>
<li>具有正确类型的非类模版参数；</li>
<li>一个整型或者枚举型的编译时常量，只有对应的参数类型符合或者不需要进行变窄转换时才可以；</li>
<li>应用了取地址运算符的外部变量或函数。对于函数和数组变量，可以省略 &amp; 。这种函数模版对应指针参数类型。<code>C++17</code>放宽了限制，允许使用产生一个变量或者函数指针的常量表达式表示；</li>
<li>与上一个一样的参数，但是不需要取地址运算符的非类引用参数的有效入参。<code>C++17</code>同样放宽了限制，允许使用产生一个变量或者函数的全局左值引用表达式表示；</li>
<li>成员常量指针。换句话说，一个具有 &amp;$C::m$ 形式的表达式，其中 $C$ 是类，$m$ 是一个非静态成员。这种情况只会匹配非类成员指针参数。<code>C++17</code>中不需要指定精确的语法形式，可以使用任何能产生成员指针常量的表达式表示；</li>
<li>对于非类指针参数或者非类成员指针参数，也可以指定非空指针常量。</li>
</ul>
<p>        对于非类整型参数，最常见的是可以隐式转为参数类型的入参。<code>C++11</code>引入了 $constexpr$ 函数，意味着入参在被转换前也可以是类类型。<code>C++17</code>之前，当入参是引用指针时，用户定义的转换 ( 单参数构造函数和转换运算符 ) 和子类到基类的转换是不会进行的，即使它们可以隐式进行。给参数加上 $const$ 或者 $volatile$ 的隐式转换是可以的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="n">nontypeParam</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">33</span><span class="o">&gt;*</span> <span class="n">c1</span><span class="p">;</span>  <span class="c1">// 整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="o">&gt;*</span> <span class="n">c2</span><span class="p">;</span>  <span class="c1">// 外部变量地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span> <span class="n">f</span><span class="o">&gt;*</span> <span class="n">c3</span><span class="p">;</span>  <span class="c1">// 函数名，隐式取地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">templ_func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">templ_func</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;*</span> <span class="n">c4</span><span class="p">;</span>  <span class="c1">// 实例化的函数模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">bool</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">constexpr</span> <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">X</span><span class="o">::</span><span class="n">b</span><span class="o">&gt;*</span> <span class="n">c5</span><span class="p">;</span>  <span class="c1">// 静态类成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">X</span><span class="o">::*</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">n</span><span class="o">&gt;*</span> <span class="n">c6</span><span class="p">;</span>  <span class="c1">// 成员指针常量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">C</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span> <span class="n">X</span><span class="p">{}</span><span class="o">&gt;*</span> <span class="n">c7</span><span class="p">;</span>  <span class="c1">// X通过constexpr隐式转为int，再转为long
</span></span></span></code></pre></div><p>        模版入参的一般限制是编译器或者链接器必须在程序编译时可以表示出它们的值，程序运行时才能获得的值是不行的。当然，有些值也不行：</p>
<ul>
<li>浮点数；</li>
<li>字符串常量。</li>
</ul>
<p>        字符串常量的一个问题是两个值相同的字符串可以存储在不同地址中。一个可选 ( 但是麻烦 ) 的方法是使用一个额外的变量来指代常量字符串：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">str</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">char</span> <span class="k">const</span> <span class="n">hello</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="k">const</span> <span class="n">hello11</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">char</span> <span class="k">const</span> <span class="n">hello17</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="o">&lt;</span><span class="n">hello</span><span class="o">&gt;</span> <span class="n">msg03</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="o">&lt;</span><span class="n">hello11</span><span class="o">&gt;</span> <span class="n">msg11</span><span class="p">;</span>  <span class="c1">// C++11开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Message</span><span class="o">&lt;</span><span class="n">hello17</span><span class="o">&gt;</span> <span class="n">msg17</span><span class="p">;</span>  <span class="c1">// C++17开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        在<code>C++</code>所有版本中，声明为引用或者指针的非类模版参数可以接收一个具有外部链接的常量表达式；<code>C++11</code>开始，常量表达式也可以具有内部链接；<code>C++17</code>开始，常量表达式可以具有任何链接。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="n">nontypeParam</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">derived</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">derived</span><span class="o">&gt;*</span> <span class="n">err1</span><span class="p">;</span>  <span class="c1">// 错误，不能进行子类到基类的转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">base</span><span class="p">.</span><span class="n">i</span><span class="o">&gt;*</span> <span class="n">err2</span><span class="p">;</span>  <span class="c1">// 错误，变量字段不能作为变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;*</span> <span class="n">err3</span><span class="p">;</span>  <span class="c1">// 错误，不能使用数组元素地址
</span></span></span></code></pre></div><h3 id="34-模版模版入参">3.4 模版模版入参</h3>
<p>        一个模版模版入参必须是一个与它将代替的模版模版参数类型精确匹配的类模版或者别名模版。在<code>C++17</code>之前，模版模版入参的默认模版参数会被忽略 ( 声明模版模版参数时指定的默认值不会 )。<code>C++17</code>放宽了这种限制，允许模版模版入参对应的模版模版参数是一个特例化版本。下面的代码在<code>C++17</code>之前是错误的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Cont</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Rel</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&gt;</span> <span class="n">rel</span><span class="p">;</span>  <span class="c1">// C++17之前是错误的
</span></span></span></code></pre></div><p>        因为 $std::list$ 模版参数在标准库中不止一个，所以会产生错误。尽管 $std::list$ 的第二个参数具有默认值，但是在<code>C++17</code>之前，它们还是会被忽略。<br>
        变长模版模版参数是一个例外，它不会因为上面的原因而产生错误，这个问题有一个解决方案：它们可以对模版模版参数进行一般匹配而非精确匹配。一个模版模版参数集合可以匹配任意数量的相同类型的模版参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Cont</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Rel</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&gt;</span> <span class="n">rel</span><span class="p">;</span>
</span></span></code></pre></div><p>        模版参数集合只能匹配相同种类的模版入参。例如，下面的模版参数可以被任意只具有模版类型参数的类模版或者别名模版实例化，因为模版类型参数集合可以匹配任意数量的参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">TT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AlmostAnyTmpl</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">AlmostAnyTmpl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&gt;</span> <span class="n">withVector</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">AlmostAnyTmpl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&gt;</span> <span class="n">withMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">AlmostAnyTmpl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&gt;</span> <span class="n">withArray</span><span class="p">;</span>
</span></span></code></pre></div><p>        在<code>C++17</code>之前，只有 $class$ 关键字才能声明模版模版参数，但这并不意味着模版模版参数只能是 $class$ 模版。$struct$ 、$union$ 和别名模版同样可以。</p>
<h3 id="35-等价性">3.5 等价性</h3>
<p>        当所有入参都相等时，两个模版入参集合就是等价的。对于类型入参，类型别名并没有影响，比较依赖的是底层类型。对于整型非类参数，会进行值比较，不管值怎么表示。下面的例子说明了这个概念：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Mix</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Int</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Mix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span><span class="o">&gt;*</span> <span class="n">p1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Min</span><span class="o">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span><span class="o">&gt;*</span> <span class="n">p2</span><span class="p">;</span>  <span class="c1">// p2与p1类型相同
</span></span></span></code></pre></div><p>        在模版依赖上下文中，模版入参的值不是总能被确定，这时等价性的规则就会变得稍些复杂。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">I</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">I</span><span class="o">&lt;</span><span class="n">M</span> <span class="o">+</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">M</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">I</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">+</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">I</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">+</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">);</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><p>        在第二个和第三个声明中，虽然一个声明为 $N$ 和 $M$ ，一个声明为 $M$ 和 $N$ ，但因为在函数参数中都是第一个加第二个，所以它们还是等价的。最后一个声明中，函数参数中的加法顺序是颠倒的，这导致它与上面两个声明不等价。然而，因为这样还是会产生相同的结果，即函数等价，所以会导致一个错误。错误原因是只具有函数等价的表达式不是真正的等价。然而，你的编译器不需要处理这种错误，因为一些编译器可能会直接将类似于 $N + 1 + 1$ 的表达式优化为 $N + 2$ 。<br>
        从函数模版中生成的与普通函数是永远不等价的，就算它们有着相同的名字和类型。对于类成员，这会产生两个后果：</p>
<ol>
<li>从成员函数模版中生成的函数不会覆写虚函数；</li>
<li>从构造函数模版中生成的构造函数不会作为拷贝或者移动构造函数。类似的，从赋值模版中生成的函数也不会作为拷贝或者移动赋值运算符。</li>
</ol>
<h2 id="4-变长模版">4. 变长模版</h2>
<p>        变长模版是包含至少一个模版参数集合的模版。变长模版在一个模版可以从任意数量的入参生成时十分有用。当给变长模版指定入参时，每个模版参数集合会匹配一个或多个模版参数，我们称模版入参序列为入参集合。下面的例子说明了模版参数集合怎么匹配不同入参集合：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Tuple</span><span class="o">&lt;&gt;</span> <span class="n">t0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">t2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        因为一个模版参数集合代表模版入参列表而不是一个单独的模版入参，它必须在结构支持入参集合中的所有参数的前提下使用。一个这样的结构是 $sizeof\dots$ 操作，它会返回入参集合中的参数数量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a1</span><span class="p">[</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">length</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a3</span><span class="p">[</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">long</span><span class="o">&gt;::</span><span class="n">length</span><span class="p">];</span>
</span></span></code></pre></div><h3 id="41-集合展开">4.1 集合展开</h3>
<p>        $sizeof\dots$ 表达式是集合展开的一个例子。集合展开会把入参集合中的参数拆分为单独的参数。$sizeof\dots$ 只是返回单独参数的个数，其他形式的参数集合可以在需要的时候展开为多个参数。这种集合展开会在集合之后使用 $\dots$ 符号。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyTuple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">MyTuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">t2</span><span class="p">;</span>
</span></span></code></pre></div><p>        模版参数 $Types\dots$ 是一个集合展开，生成一个模版参数序列。<br>
        一种直观的理解集合展开的方式是把它们视为语法展开，模版参数集合被确切数量的模版参数代替，集合展开被写成单独入参的形式，每个入参对应一个非集合模版参数。两个参数的展开就类似于：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyTuple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        然而，注意你不能直接通过名字单独访问参数集合中的某个元素，因为它们并没有定义名字。如果你需要得到某个类型，你只能递归地将它们传递给另一个类或者函数。<br>
        每个集合展开都具有模式，即每个入参的类型或者表达式，一般在 $\dots$ 之前。我们之前的例子只有最简单的模式，即获取参数集合元素的名字，其实模式可以更复杂。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PtrTuple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">*</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PtrTuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">t3</span><span class="p">;</span>
</span></span></code></pre></div><p>        这个模式使得 $PtrTuple$ 中的模版参数都变为指针类型。我们可以把它展开来：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PtrTuple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">*</span><span class="p">,</span> <span class="n">T2</span><span class="o">*</span><span class="p">,</span> <span class="n">T3</span><span class="o">*&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h3 id="42-集合展开的时机">4.2 集合展开的时机</h3>
<p>        集合展开可以在任意一个需要一个逗号分隔的列表的地方使用，包括：</p>
<ul>
<li>基类列表；</li>
<li>构造函数基类初始化列表；</li>
<li>调用参数列表；</li>
<li>初始化列表；</li>
<li>类、函数或者别名模版的模版参数列表；</li>
<li>函数抛出异常列表 ( <code>C++11</code>开始废弃，<code>C++17</code>中禁止 )；</li>
<li>在属性中，如果该属性支持集合展开 ( 虽然<code>C++</code>标准并没有定义这种属性 )；</li>
<li>指定声明对齐方式；</li>
<li><code>lambda</code>捕获列表；</li>
<li>函数类型的参数列表；</li>
<li>$using$ 声明 ( <code>C++17</code>开始 )。</li>
</ul>
<p>        $sizeof\dots$ 是一个集合展开机制，但是不会真正产生一个列表。<code>C++17</code>也提供了折叠表达式，这也是一个不会产生列表的机制。有些集合展开场景只是为了完整性而提及，我们实际上只需要注意那些有用的场景。因为所有场景的集合展开都遵循相同的原则和语法，你也可以根据例子来扩展。<br>
        在基类列表中使用集合展开通过<strong>混合</strong> ( $mixins$ ) 聚合外部的数据和功能，这些类会混入类层级中，提供新行为。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Mixins</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mixins</span><span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Point</span><span class="p">()</span> <span class="o">:</span> <span class="n">Mixins</span><span class="p">()...</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">visitMixins</span><span class="p">(</span><span class="n">Visitor</span> <span class="n">visitor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">visitor</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Mixins</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Color</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Label</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Point</span><span class="o">&lt;</span><span class="n">Color</span><span class="p">,</span> <span class="n">Label</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</span></span></code></pre></div><p>        $Point$ 类使用集合展开来获取提供的混合类型，并在基类列表中展开。$Point$ 的默认构造函数会应用在基类初始化列表中应用集合展开来初始化每个基类。成员函数模版 $visitMixins$ 是最有趣的，它使用集合展开的结果作为参数来进行调用，将 $\star this$ 展开为对应的混合类型。<br>
        集合展开也能在模版参数列表中创建非类或者模版参数集合：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Values</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span> <span class="n">Vs</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Holder</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Values</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">*&gt;::</span><span class="n">Holder</span><span class="o">&lt;</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">&gt;</span> <span class="n">valueHolder</span><span class="p">;</span>
</span></span></code></pre></div><p>        $Values$ 具有非类模版参数集合，每个模版参数都可以是不同类型。注意这里的 $\dots$ 有双重作用，既声明了模版参数集合，又进行集合展开。这种模版参数集合的使用很少见，相同的原理在函数参数中更常见。</p>
<h3 id="43-函数参数集合">4.3 函数参数集合</h3>
<p>        一个函数参数集合可以匹配零个或多个函数调用参数。与模版参数集合一样，函数参数集合也使用 $\dots$ 前置的方式生命，后置的方式展开。模版参数集合和函数参数集合统称为参数集合。与模版参数集合不同的是，函数参数集合总是集合展开的，这意味着他们的声明类型必须包含至少一个参数集合。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Mixins</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mixins</span><span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Point</span><span class="p">(</span><span class="n">Mixins</span><span class="p">...</span> <span class="n">mixins</span><span class="p">)</span> <span class="o">:</span> <span class="n">Mixins</span><span class="p">(</span><span class="n">mixins</span><span class="p">)...</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Color</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">read</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Label</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">Point</span><span class="o">&lt;</span><span class="n">Color</span><span class="p">,</span> <span class="n">Label</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">({</span><span class="mh">0x7F</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x7F</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;center&#34;</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Types</span><span class="p">...</span> <span class="n">values</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">welcom</span><span class="p">(</span><span class="s">&#34;Welcome to &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">print</span><span class="p">(</span><span class="n">welcome</span><span class="p">,</span> <span class="s">&#34;C++ &#34;</span><span class="p">,</span> <span class="mi">2011</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        当调用 $print$ 时，参数会被放入参数集合里，使用 $Types$ 这个参数集合类型表示，实参使用 $values$ 表示。$print$ 函数的实际实现方式是递归模版实例化，这是一种模版元编程技术。<br>
        在匿名函数参数集合和<code>C</code>风格的变长参数之间存在语法歧义，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">c_style</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="p">...);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">pack</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="p">...);</span>
</span></span></code></pre></div><p>        在第一个例子中，$T\dots$ 被视为 $T,\dots$ ，即一个类型为 $T$ 的匿名参数，后面为<code>C</code>风格的变长参数；在第二个例子中，$T\dots$ 结构会被视为一个函数参数集合，因为$T$ 是一个有效的展开表达式。可以通过在 $\dots$ 前面添加逗号的方式来消除歧义。在泛型<code>lambda</code>中，如果类型使用 $auto$ 声明，那么后置的 $\dots$ 会被视为参数集合。</p>
<h3 id="44-多重和内嵌集合展开">4.4 多重和内嵌集合展开</h3>
<p>        集合展开可以很复杂，也可以是多重或者单独的参数集合。当实例化一个包含多重参数集合的集合展开时，所有参数集合必须拥有相同的长度。类型或者值的结果序列是通过使用每个集合的第一个元素替换，再使用第二个元素的替换……以此类推的方式，生成的。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">forwardCopy</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">Types</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">Types</span><span class="p">(</span><span class="n">values</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        调用参数集合展开为两个参数集合，$Types$ 和 $values$ 。当实例化这个模版时，逐元素地展开，产生一系列对象结构。在经过语法解释后，三个参数的 $forwardCopy$ 会类似于这种：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fowardCopy</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T1</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="n">T2</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="n">T3</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">T1</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="n">T2</span><span class="p">(</span><span class="n">v2</span><span class="p">),</span> <span class="n">T3</span><span class="p">(</span><span class="n">v3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        集合展开也可以内嵌。这时每个参数集合会被离它最近的展开表达式展开。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">OuterTypes</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Nested</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">InnerTypes</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">InnerTypes</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">innerValues</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">g</span><span class="p">(</span><span class="n">OuterTypes</span><span class="p">(</span><span class="n">InnerTypes</span><span class="p">(</span><span class="n">innerValues</span><span class="p">)...)...);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        在 $g$ 函数调用中，$InnerTypes(innerValuesi)$ 是最内层的集合展开，它们会生成一个序列，交给 $OuterTypes$ 继续展开。在经过语法解释后，一个例子如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">O1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">O2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Nested</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">I1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">I2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">I3</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">I1</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">iv1</span><span class="p">,</span> <span class="n">I2</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">iv2</span><span class="p">,</span> <span class="n">I3</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">iv3</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">g</span><span class="p">(</span><span class="n">O1</span><span class="p">(</span><span class="n">I1</span><span class="p">(</span><span class="n">iv1</span><span class="p">),</span> <span class="n">I2</span><span class="p">(</span><span class="n">iv2</span><span class="p">),</span> <span class="n">I3</span><span class="p">(</span><span class="n">iv3</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">      <span class="n">O2</span><span class="p">(</span><span class="n">I1</span><span class="p">(</span><span class="n">iv1</span><span class="p">),</span> <span class="n">I2</span><span class="p">(</span><span class="n">iv2</span><span class="p">),</span> <span class="n">I3</span><span class="p">(</span><span class="n">iv3</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="45-零长度集合展开">4.5 零长度集合展开</h3>
<p>        集合展开的语法解释对于理解变长模版在不同参数数量的情况下的行为很有帮助。然而，语法解释通常在零长度参数集合时会失败。为了说明这点，我们可以延用之前的 $Point$ 类声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Point</span><span class="p">()</span> <span class="o">:</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        上面的写法是错误的，因为模版参数列表是空的，空的基类和基类初始化列表会导致只剩下一个冒号。集合展开是实际的语法构造，任意大小的参数集合替代不会影响解析。反而，当一个集合展开为一个空列表，程序行为会类似于没有提供列表。这个语义规则及时当解释一个零长度展开语法会</p>

<script src=https://z217blog.cn/js/toc.js></script>

<div>
    <a href="javascript:void(0);" id="tocbtn"><i class="fas fa-bars fa-lg"></i></a>
    <div id="sidetoc">
        <header>
            <h4>C&#43;&#43; Templates（7）：深入模版基础</h4>
        </header>
        <nav id="TableOfContents">
            <ul></ul>
        </nav>
    </div>
    <script>
        isTocOpen = true;
    </script>
</div>


<div class="nav-next-prev">
    <div class="nav-prev">
        
        <a href="https://z217blog.cn/post/cpptemplates6/"><i class="fas fa-chevron-left"></i></a>
        
    </div>
    <a class="nav-top" href="#">回到顶部</i></a>
    <div class="nav-next">
        
        <a href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/"><i class="fas fa-chevron-right"></i></a>
        
    </div>
</div>
<script type="text/javascript">
    if (isTocOpen) tocInit();
</script>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:zihan.zhouchn@outlook.com">zihan.zhouchn@outlook.com</a>
            </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2022, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
</main>
</body>

</html>