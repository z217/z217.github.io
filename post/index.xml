<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on z217&#39;s blog</title>
    <link>https://z217blog.cn/post/</link>
    <description>Recent content in Posts on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Wed, 05 Aug 2020 19:58:48 +0800</lastBuildDate>
    
	<atom:link href="https://z217blog.cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Geohash算法简介</title>
      <link>https://z217blog.cn/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 05 Aug 2020 19:58:48 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</guid>
      <description>1. Geohash算法介绍 Geohash-Wikipedia
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Geohash是一种用于公共领域的地理编码系统，其将地理位置编码为字母和数字的短字符串。Geohash允许任意精度的属性，可以通过增长或缩短字符串来改变精度。当两个区域的公共前缀越长，说明他们的联系更加紧密。但是反过来，具有短公共前缀或者没有公共前缀并不一定代表着联系很小。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Geohash算法可以将一个二维的经纬度坐标转换成一个可以比较的字符串，也就是降维。使用三十二进制，全球被划分为 \(32\) 个大块，再在每个大块内继续划分出 \(32\)个小块，因此对于越长的geohash字符串，其精度越大，代表的范围也就越小。通过Base32算法，geohash使用字母和数字表示值，如下所示：
   数字 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31     32进制 0 1 2 3 4 5 6 7 8 9 b c d e f g h j k m n p q r s t u v w x y z    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;即使用了所有 \(10\) 以内的数字，以及除 \(a\), \(i\), \(l\) 和 \(o\) 之外的所有小写字母。在计算的时候只需要在十进制和三十二进制之间转换即可，举例：</description>
    </item>
    
    <item>
      <title>Git常用指令汇总</title>
      <link>https://z217blog.cn/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/</link>
      <pubDate>Tue, 04 Aug 2020 19:36:05 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/</guid>
      <description>创建仓库/init git init 创建成功后当前目录下会生成一个.git目录，用于跟踪和管理版本库。
添加文件/add git add . 自动添加本地所有修改。
提交/commit git commit \(-m\) 增加提交信息。
\(-a\) 自动寻找修改的文件并提交。
状态查看/status git status \(-s\) 简短输出。
改动查看/diff&amp;amp;blame git diff \(--cached\) 显示暂存区的改动。
\(HEAD\) 查看所有改动。
\(--stat\) 显示摘要。
git blame 文件修改记录。
历史查看/log git log 按时间由近到远排序，列出最近的三次提交。
\(-p\;[filename]\) 文件最后一次提交信息。
\(--pretty=oneline\) 可以列出简略的信息。
\(--graph\) 拓扑图显示。
\(--reverse\) 逆向显示。
\(--author=\) 查找指定作者。
\(--since\), \(--before\), \(--util\), \(--after\) 指定日期。
\(--decorate\) 显示标签。
提交撤销/revert git revert 回退版本/reset git reset --hard HEAD^ git reset --hard HEAD~2 git reset --hard 56e7 \(HEAD\) 表示当前版本。^ 表示回退一个版本，可以输入多个 ^。\(\sim\) 之后可以输入任意数字，表示回退对应数量的版本。也可以直接输入版本号，版本号通过 \(git\;log\) 命令查询，使用版本号不仅可以回退版本，在错误回退版本之后，也可以前进到指定的版本，版本号可以不写全，但一定要写到Git能识别出唯一一个版本为止。</description>
    </item>
    
    <item>
      <title>JWT简介</title>
      <link>https://z217blog.cn/post/jwt%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 04 Aug 2020 16:41:22 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jwt%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34;&gt;JWT-Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;JWT&lt;/code&gt;( &lt;span  class=&#34;math&#34;&gt;\(JSON\;Web\;Token\)&lt;/span&gt; )是一种基于&lt;code&gt;JSON&lt;/code&gt;的用于创建可选签名或可选加密的数据的互联网标准。&lt;code&gt;Token&lt;/code&gt;使用一个私钥或者公钥进行签名，持有私钥或者公钥的一方可以验证令牌的合法性。&lt;code&gt;Token&lt;/code&gt;被设计为紧凑且安全的，尤其适用于&lt;code&gt;Web&lt;/code&gt;浏览器单点登录 ( &lt;code&gt;Single-sign-on&lt;/code&gt;, &lt;span  class=&#34;math&#34;&gt;\(SSO\)&lt;/span&gt; ) 场景。&lt;code&gt;JWT&lt;/code&gt;声明一般用于在身份提供者和服务提供者之间传递用户身份信息，或者用于业务流程要求的任何其他类型的声明。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dijkstra算法原理及其实现</title>
      <link>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 03 Mar 2020 17:27:28 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</guid>
      <description>参考书籍：《算法（第4版）》
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\(Dijkstra\) 算法应用于带权有向图中求最短路径问题。通俗来讲就是不断选择权值最小的边加入集合直到所有顶点都在集合中，属于贪心算法。需要注意的是，\(Dijkstra\) 算法只能用于解决边权非负的图类问题。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;假设对于一个带权有向图 \(G(V,E)\) 以邻接矩阵表示，其所有边存储在一个二维整型数组 \(matrix[\ \ ][\ \ ]\) 中， \(matrix[i][j]\) 表示从顶点 \(i\) 到顶点 \(j\) 之间的边，值为边的权值，若值为 \(∞\) ，说明该边不存在。为了实现 \(Dijkstra\) 算法，我们需要一个布尔值数组 \(visit[\ \ ]\) ，用于判断顶点是否访问过，或者说是否在集合中；一个整型数组 \(distance[\ \ ]\) 用于储存原点到每个点的最短距离。定义了基本的结构，就可以实现算法了，步骤为：
 从 \(V\) 中选择一个点 \(s\) 作为原点，将邻接矩阵中的 \(matrix[s]\) 数组复制到 \(distance[s]\) （复制后 \(distance[s]\) 应为 \(0\) ），建立一个 \(visit[\ \ ]\) 数组并清零。 从 \(V\) 中选择一个顶点 \(u\) 加入集合，其中点 \(u\) 满足：
 之前未曾访问过点 \(u\) （即 \(visit[u] = false\) ）。 与 \(s\) 距离最短（即 \(distance[u]\) 的值最小）。  以 \(u\) 为中心点，对于每个与 \(u\) 相邻的顶点 \(k\) ，令 \(distance[k] = Min(distance[k], distance[u] + matrix[u][k])\) ，这一步也称为松弛( \(relaxation\) )。 重复2、3直到所有顶点加入集合。  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\(Dijkstra\) 算法类似于 \(Prim\) 算法，实质上都是构造了一颗树。经过以上步骤之后，我们得到了一个 \(distance[\ \ ]\) 数组，其中的值为从原点 \(s\) 到图中其他所有点的最短距离。在使用代码实现的过程中，有些情况下我们可以使用优先队列来简化寻找最小权值的这一过程。如果我们确认了一幅图是无环图，那么我们也可以不使用 \(visit[\ \ ]\) ，而是通过拓扑排序的顺序依次遍历顶点。</description>
    </item>
    
  </channel>
</rss>