<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on z217&#39;s blog</title>
    <link>https://z217blog.cn/post/</link>
    <description>Recent content in Posts on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Wed, 19 Aug 2020 19:42:28 +0800</lastBuildDate>
    
	<atom:link href="https://z217blog.cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JVM（1）：技术体系与内存区域</title>
      <link>https://z217blog.cn/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Wed, 19 Aug 2020 19:42:28 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid>
      <description>1. Java技术体系 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从广义上来讲，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序都属于Java技术体系中的一员。从传统意义上来看，JCP官方所定义的Java技术体系包括以下几个部分：
 Java程序设计语言 各种硬件平台上的Java虚拟机实现 Class文件格式 Java类库API 来自商业机构和开源社区的第三方Java类库  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们可以把Java程序设计语言、Java虚拟机、Java类库这三部分统称为JDK ( \(Java\;Development\;Kit\) ) ，JDK是用于支持Java程序开发的最小环境。可以把Java类库API中的Java SE API子集和Java虚拟机这两部分统称为JRE ( \(Java\;Runtime\;Environment\) )，JRE是支持Java程序运行的标准环境。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;以上是按照Java组成部分来进行划分，如果按照技术领域来划分，则可以分为以下四条：
 Java Card Java ME Java SE Java EE  2. 自动内存管理 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JVM在执行Java程序的过程中会将内存划分为若干个不同的数据区域。
2.1 程序计数器 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;程序计数器 ( \(Program\;Counter\;Register\) ) 是一块比较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。程序的分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器。在JVM中，一个处理器只会处理一个线程，多线程通过轮流切换来实现，因此每个线程都会有一个程序计数器。对于每个线程之间独立存储的内存，我们称之为“线程私有”内存。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java中存在 \(native\) 关键字，用于指示本地方法。通过 \(native\) 关键字，Java程序可以调用本地应用（或库），也可以被其他程序调用。对于本地方法，在执行过程中，程序计数器的值为空 ( \(Undefined\) )。而对于Java方法 ( 也就是字节码 ) ，程序计数器的值为正在执行的虚拟机字节码的指令地址。
2.2 Java虚拟机栈 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Java虚拟机栈 ( \(Java\;Virtual\;Machine\;Stack\) ) 描述的是Java方法执行的线程内存模型。与程序计数器一样，它也是线程私有的。在每个方法被执行时，JVM都会同步创建一个栈帧 ( \(Stack\;Frame\) ) 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。在方法被调用时，这个栈帧会被压入Java虚拟机栈。当方法执行完毕时，其对应的栈帧也会被从Java虚拟机栈中弹出。如果将Java的内存区域像C/C++那样简单地划分为堆内存 ( \(Heap\) ) 和栈内存 ( \(Stack\) )，那么这里的虚拟机栈就可以视为栈内存。</description>
    </item>
    
    <item>
      <title>从零开始的JDK编译</title>
      <link>https://z217blog.cn/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84jdk%E7%BC%96%E8%AF%91/</link>
      <pubDate>Wed, 19 Aug 2020 05:40:45 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84jdk%E7%BC%96%E8%AF%91/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先从获取JDK源码开始。以OpenJDK为例，点击 OpenJDK 进入，选择对应的JDK版本，在此以JDK12为例，选择 \(jdk12\) 。进入后在左侧选择 \(browse\) ，然后再选择 \(zip\) 即可下载。源码下载完毕之后解压，可以在解压后的文件目录下的 \(/doc/building.html\) 中阅读编译文档。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;源码下载完毕之后开始准备Linux环境，要注意在Linux环境中，文件夹请尽量使用英文名，名称中不要出现空格。我使用的是WSL Ubuntu，在刚开始使用时要记得切换镜像源。
vi /etc/apt/sources.list &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 \(vi\) 打开配置文件，然后替换为镜像源，在此我使用的是阿里云的镜像源，\(sources.list\) 文件内容如下：
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.</description>
    </item>
    
    <item>
      <title>Geohash算法简介</title>
      <link>https://z217blog.cn/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 05 Aug 2020 19:58:48 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</guid>
      <description>1. Geohash算法介绍 Geohash-Wikipedia
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Geohash是一种用于公共领域的地理编码系统，其将地理位置编码为字母和数字的短字符串。Geohash允许任意精度的属性，可以通过增长或缩短字符串来改变精度。当两个区域的公共前缀越长，说明他们的联系更加紧密。但是反过来，具有短公共前缀或者没有公共前缀并不一定代表着联系很小。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Geohash算法可以将一个二维的经纬度坐标转换成一个可以比较的字符串，也就是降维。使用三十二进制，全球被划分为 \(32\) 个大块，再在每个大块内继续划分出 \(32\)个小块，因此对于越长的geohash字符串，其精度越大，代表的范围也就越小。通过Base32算法，geohash使用字母和数字表示值，如下所示：
   数字 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31     32进制 0 1 2 3 4 5 6 7 8 9 b c d e f g h j k m n p q r s t u v w x y z    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;即使用了所有 \(10\) 以内的数字，以及除 \(a\), \(i\), \(l\) 和 \(o\) 之外的所有小写字母。在计算的时候只需要在十进制和三十二进制之间转换即可，举例：</description>
    </item>
    
    <item>
      <title>Git常用指令汇总</title>
      <link>https://z217blog.cn/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/</link>
      <pubDate>Tue, 04 Aug 2020 19:36:05 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/</guid>
      <description>创建仓库/init git init 创建成功后当前目录下会生成一个.git目录，用于跟踪和管理版本库。
添加文件/add git add . 自动添加本地所有修改。
提交/commit git commit \(-m\) 增加提交信息。
\(-a\) 自动寻找修改的文件并提交。
状态查看/status git status \(-s\) 简短输出。
改动查看/diff&amp;amp;blame git diff \(--cached\) 显示暂存区的改动。
\(HEAD\) 查看所有改动。
\(--stat\) 显示摘要。
git blame 文件修改记录。
历史查看/log git log 按时间由近到远排序，列出最近的三次提交。
\(-p\;[filename]\) 文件最后一次提交信息。
\(--pretty=oneline\) 可以列出简略的信息。
\(--graph\) 拓扑图显示。
\(--reverse\) 逆向显示。
\(--author=\) 查找指定作者。
\(--since\), \(--before\), \(--util\), \(--after\) 指定日期。
\(--decorate\) 显示标签。
提交撤销/revert git revert 回退版本/reset git reset --hard HEAD^ git reset --hard HEAD~2 git reset --hard 56e7 \(HEAD\) 表示当前版本。^ 表示回退一个版本，可以输入多个 ^。\(\sim\) 之后可以输入任意数字，表示回退对应数量的版本。也可以直接输入版本号，版本号通过 \(git\;log\) 命令查询，使用版本号不仅可以回退版本，在错误回退版本之后，也可以前进到指定的版本，版本号可以不写全，但一定要写到Git能识别出唯一一个版本为止。</description>
    </item>
    
    <item>
      <title>JWT简介</title>
      <link>https://z217blog.cn/post/jwt%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 04 Aug 2020 16:41:22 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jwt%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34;&gt;JWT-Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;JWT&lt;/code&gt;( &lt;span  class=&#34;math&#34;&gt;\(JSON\;Web\;Token\)&lt;/span&gt; )是一种基于&lt;code&gt;JSON&lt;/code&gt;的用于创建可选签名或可选加密的数据的互联网标准。&lt;code&gt;Token&lt;/code&gt;使用一个私钥或者公钥进行签名，持有私钥或者公钥的一方可以验证令牌的合法性。&lt;code&gt;Token&lt;/code&gt;被设计为紧凑且安全的，尤其适用于&lt;code&gt;Web&lt;/code&gt;浏览器单点登录 ( &lt;code&gt;Single-sign-on&lt;/code&gt;, &lt;span  class=&#34;math&#34;&gt;\(SSO\)&lt;/span&gt; ) 场景。&lt;code&gt;JWT&lt;/code&gt;声明一般用于在身份提供者和服务提供者之间传递用户身份信息，或者用于业务流程要求的任何其他类型的声明。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://z217blog.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 10 Jul 2020 16:57:11 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;设计模式常用的七大原则：
 单一职责原则——一个类应该只负责一项职责。 接口隔离原则——一个类对应另一个类的依赖应该建立在最小的接口上。 依赖倒转原则  高层模块不应依赖于低层模块 抽象不应该依赖于细节 面向接口编程（中心思想）  里氏替换原则——所有引用基类的地方必须能透明的使用子类。 开闭原则——软件实体对扩展开放，对修改关闭，用抽象构建框架，用实现扩展细节。 迪米特法则——一个类应该将逻辑封装在内部，不对外泄露。 合成复用原则——尽量使用合成/聚合方式  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;23种设计模式的三种类型：
 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式； 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式； 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）。  1 单例模式 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;单例模式，即采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（通常为静态方法）。单例模式有八种方式：
 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举  1.1 饿汉式（静态常量）  构造器私有化（即不能通过 \(new\) 创建实例） 类内部创建对象 向外暴露一个静态公共方法 代码实现  class Singleton { private final static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; } } 优点：写法简单，在类装载时实例化，避免了线程同步问题。
缺点：不是懒加载，可能存在内存资源的浪费。</description>
    </item>
    
    <item>
      <title>数据库系统（9）：事务管理</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 13 Jun 2020 17:55:26 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DBMS应该具备的功能中，有三个密切相关的功能，用以保证数据库的可靠性和一致性，即事务支持、并发控制服务和恢复服务。它们之间是相互依赖的。并发控制和恢复主要用于保护数据库，避免数据库发生数据不一致或者数据丢失。许多DBMS都允许用户对数据库进行并发操作。如果对这些操作不加控制，对数据库的访问将互相干扰，使得数据库出现不一致的情况。为了解决这个问题，DBMS实现了并发控制 ( \(concurrency\;control\) ) 协议，来阻止数据库访问之间的相互干扰。数据库恢复 ( \(Database\;recovery\) ) 是指在故障以后将数据库还原到正确状态的过程。
1. 支持事务处理 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;事务 ( \(Transaction\) ) 是由单个用户或者应用程序执行的，完成读取或者更新数据库内容的一个或者一串操作。事务是数据库的逻辑操作单位 ( \(logical\;unit\;of\;work\) ) 。它可以是整个程序、部分程序或者一条命令，也可以是涉及数据库的任意多个操作。从数据库的角度来看，应用程序的一次执行就是一个事务或者多个事务，若看成多个事务，在事务与事务之间只会出现非数据库操作。复杂的事务由很多操作构成。若并非所有操作都被执行，那么可能会出现不一致状态 ( \(inconsistent\;state\) ) 。在事务处理过程中，尽管我们允许数据库的一致性遭到暂时破坏，但是事务应该总是能将数据库从一种一致的状态转移到另一种一致的状态。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;事务可能有以下两种结果中的一种。如果执行成功，也就是说事务最终被提交 ( \(committed\) )，数据库也将到达一种新的一致状态。另一种情况下，事务没有执行成功，则会被撤销 ( \(aborted\) )。如果事务被撤销，则数据库必须要还原到事务开始之前的一致的状态。我们称这样的事务被回滚 ( \(rolled\;back\) ) /撤销 ( \(undone\) )。已经提交的事务无法撤销。如果发现已提交的事务存在错误，必须执行另一个补偿事务 ( \(compensating\;transaction\) ) 来消除该事务已经产生的影响。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DBMS无法得知哪些更新操作将被组合在一起以构成一个独立的逻辑事务。因此很多数据操作语言中都使用关键字 \(BEGIN\), \(TRANSACTION\), \(COMMIT\), \(ROLLBACK\) 来划定界限。如果不使用，通常会将整个程序视为一个事务。

1.1 事务的性质  原子性 ( \(Atomicity\) )：事务是一个不可分割的单元，要么全执行，要么全不执行。事务的原子性由DBMS的恢复子系统负责保证。 一致性 ( \(Consistency\) )：事务必须将数据库从一种一致的状态转换到另一种一致的状态。事务的一致性是由DBMS和应用程序的开发者共同保证的。DBMS可以通过强制实施所有在数据库模式中定义的约束（如完整性约束和企业自定义约束）来保证一致性。 隔离性 ( \(Isolation\) )：事务的执行是相互独立的，即未完成事务的中间结果对其他事务来说应该是不可见的。事务的隔离性由并发控制子系统负责保证。 持久性 ( \(Durability\) )：成功完成的事务的结果要永久地记录在数据库中。事务的持久性由恢复子系统负责保证。  1.2 数据库体系结构</description>
    </item>
    
    <item>
      <title>数据库系统（8）：规范化</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/</link>
      <pubDate>Fri, 22 May 2020 16:13:29 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;规范化 ( \(Normalization\) ) 是一种数据库设计技术，从分析属性之间的联系入手。规范化使用一系列测试，描述为范式 ( \(normal\;forms\) ) 帮助我们确定这些属性的最佳组合，最终生成一组适当关系。
1. 目的 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;规范化的目的是确定一组合适的关系以支持企业的数据需求。该关系具有以下性质：
 属性的个数最少，且是必需的 具有紧密逻辑联系，描述为函数依赖 ( \(functional\;dependency\) ) 的所有属性均在一个关系中 最少的冗余，即每个属性仅出现一次，除了作为外键的属性，因为连接相关关系必须用到外键  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;具有一组合适的关系，数据库会易于用户访问，数据易于维护，在计算机上也会占有较小的存储空间。
2. 支持 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;规范化有两种使用方法。方法 $1$ 将规范化视为一种自下而上 ( \(bottom-up\) ) 的独立的数据库设计技术。方法 \(2\) 将规范化作为一种确认技术使用，即用规范化检验关系的结构，而这些关系的建立可能采用自上而下的方法，如ER建模等。
3. 数据冗余与更新异常 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;关系数据库设计的一个目的就是将属性组合成关系时保证最少的数据冗余。当然，关系数据库的运行也依赖于一定的数据冗余的存在，一般是以主键或者候选键的多个副本的形式出现，作为外键表示数据间联系。存在冗余数据的关系可能存在一些问题，如更新异常 ( \(update\;anomalies\) )。更新异常又可分为插入异常、删除异常和修改异常。

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\(Staff\) 和 \(Branch\) 是不存在数据冗余的两个表。\(StaffBranch\) 是将上两个表合起来的存在数据冗余的表，同一个分公司的信息会重复出现。
3.1 插入异常 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;插入异常主要有两类：
 在向 \(StaffBranch\) 中插入新员工时，若同一家分公司信息不同，则会产生一致性问题； 在向 \(StaffBranch\) 中插入新的分公司时，由于没有员工，因此员工信息都应设为 \(null\) 。但是主键 \(staffNo\) 不能为空，否则会违反实体完整性约束。  3.2 删除异常 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从 \(StaffBranch\) 中删除元组时，若该元组中的员工信息是某个分公司的最后的员工，则该分公司的信息也会被删除。
3.3 修改异常 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当要修改 \(StaffBranch\) 中某个分公司的属性值时，必须依次修改所有包含该分公司信息的元组。</description>
    </item>
    
    <item>
      <title>数据库系统（7）：ER模型</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 21 May 2020 15:51:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ER模型是一种自上而下 ( \(top-down\) ) 的数据库设计方法，该方法首先确定那些被称为实体的重要数据和这些数据之间的联系，实体和联系时ER模式中必备的元素。然后添加更多的细节信息，如属性、约束等。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;统一建模语言 ( \(Unified\;Modeling\;Language\), \(UML\) ) 是软件工程项目的工业标准建模语言，我们使用UML的符号集来绘制ER模型。
1 实体类型 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;实体类型 ( \(Entity\;types\) ) 是被企事业单位认可的、能够独立存在的一组具有相同属性的对象，是ER模型的基本概念。实体类型既可以是物理 ( 真实 ) 存在的，也可以是概念 ( 抽象 ) 存在的对象。实体出现 ( \(entity\;occurrence\) ) 是实体类型中可唯一标识的一个对象。在没有歧义的时候，实体类型和实体出现都可以直接简称为实体。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在UML中，实体类型通过一个标有名字的矩形标识，每个实体名字的首字母是大写的。

2. 联系类型 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;联系类型 ( \(Relationship\;types\) ) 是实体类型间一组有意义的关联。每个联系类型都被赋予一个能够描述其功能的名字。联系出现 ( \(Relationship\;occurrence\) ) 是由参与该联系的各个实体类型的一个出现组成的可被唯一标识的关联。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在UML中，每个联系类型都表现为用线将相关的实体类型联系起来，并在线上标上联系的名字，通常使用一个动词或者动词短语命名。同样的，首字母也应该大写。一个联系还要标识方向，意味着这个联系仅在一个方向上有意义。可以在名字旁边添加一个箭头符号，如 \(\blacktriangleleft\) 来标识方向。当我们要表示 \(A\;Has\;B\) ( \(A\)，\(B\) 为实体，\(Has\) 为联系类型 ) 时可以用如下方法：

2.1 联系类型的度 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;联系类型的度 ( \(degree\) ) 是指参与联系的实体类型的个数。包含在某个联系类型中的实体被看作参与者 ( \(participants\) )，参与者的数目就是度。度为 \(2\) 的联系称为二元联系。上例中的 \(Has\) 就是一个典型的二元 ( \(binary\) ) 联系，该联系的参与者是 \(A\) 和 \(B\) 。同理，度为 \(3\) 的联系称为三元 ( \(ternary\) ) 联系。度大于 \(2\) 的联系称为复杂联系。</description>
    </item>
    
    <item>
      <title>数据库系统（6）：SQL数据定义</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Wed, 20 May 2020 16:46:30 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</guid>
      <description>1. 数据类型 1.1 标识符 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SQL标识符 ( \(identifier\) ) 用于表示数据库中的对象，如表名、列名、视图名等。用户定义标识符所用的字符必须是字符集 ( \(character\;set\) ) 中存在的。默认的字符集包括 \(A-Z\), \(a-z\) 和 \(\_\) ，也可以另外指定其他字符集。标识符的限制有：
 不能长于 \(128\) 个字符（在一些方言中会更短） 必须以字母开头 不能有空格  1.2 数据类型    数据类型 声明     布尔型 \(BOOLEAN\)   字符型 \(CHAR\), \(VARCHAR\)   位类型 \(BIT\), \(BIT\;VARYING\)   定点数型 \(NUMERIC\), \(DECIMAL\), \(INTEGER\), \(SMALLINT\), \(BIGINT\)   浮点数型 \(FLOAT\), \(REAL\), \(DOUBLE\;PRECISION\)   日期时间型 \(DATE\), \(TIME\), \(TIMESTAMP\)   间隔型 \(INTERVAL\)   大对象型 \(CHARACTER\;LARGE\;OBJECT\), \(BINARY\;LARGE\;OBJECT\)    1.</description>
    </item>
    
    <item>
      <title>数据库系统（5）：SQL数据操作</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 20 May 2020 14:17:14 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</guid>
      <description>1. SQL简介 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SQL是关系模型发展过程中出现的一种特殊语言，已经成为了标准的关系数据库语言。SQL是面向转换语言 ( \(transform-oriented\;language\) ) 的例子，将输入关系转换为所需的输出关系，包括两个主要部分：DML和DDL。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SQL具有许多实现版本，每个实现称为方言 ( \(dialect\) ) ，供应商在标准之外提供的特性称为扩展 ( \(extensions\) )。
1.1 优点  满足数据库语言的思想 易于学习 结构简洁、轻便 存在SQL标准 可以通过终端或者嵌入式访问 所有人都可以使用  1.2 缺点  混合了编程规范和嵌入式访问 缺乏正交性，有多种表达方式 语言越来越复杂和庞大 聚合函数中对空的处理问题 结果表中可以有重复元组，对表中的行和列都强加了一个顺序  2. SQL命令 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SQL语言包括保留字 ( \(reserved\;words\) ) 和用户自定义字 ( \(user-defined\;words\) ) 。保留字是SQL语言的固定部分，有固定含义。用户自定义字由用户定义，用于表示表、列、视图和索引等数据库对象的名称。虽然标准并没有要求，但是SQL的许多实现版本要求用句子终结符来表示SQL语句的结束。SQL语句的多数组成部分是不区分大小写的，除了字符数据常量外。
2.1 数据操作 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DML语句有以下几种：
 \(SELECT\), \(INSERT\), \(UPDATE\), \(DELETE\).  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;常量 ( \(Literals\) ) 是指SQL语句中的不变量 ( \(constants\) )。不同的数据具有不同的常量形式，所有的非数值型数据必须使用引号，而所有的非数值型数据不能使用引号。
2.2 查询 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;查询形式：
SELECT [DISTINCT|ALL] {*|[columnExpression [AS newName]][...]} FROM TableName [alias][.</description>
    </item>
    
    <item>
      <title>数据库系统（4）：关系代数</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</link>
      <pubDate>Sun, 17 May 2020 16:05:13 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;关系代数 ( \(Relational\;Algebra\) ) 可以看成一种过程式语言，可用于构造新关系。关系代数是一种纯理论语言，它定义了一些操作，运用这些操作可以从一个或多个关系中得到另一个关系而不改变原关系。关系代数的一个表达式可以嵌套另一个表达式，这种性质称为闭包 ( \(closure\) )，即关系在关系代数下是封闭的。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;关系代数是一种每次一关系/集合的语言，即用一条不带循环的语句处理，结果也是由所有元组组成的整个关系。关系代数中包含了许多运算，其中五个基本运算是选择 ( \(Selection\) ) 、投影 ( \(Projection\) ) 、笛卡尔乘积 ( \(Cartesian\;product\) ) 、集合并 ( \(Union\) ) 、集合差 ( \(Set\;difference\) ) 。选择和投影都是一元运算，其他的运算则是二元运算。除此之外，还有连接 ( \(Join\) ) 、集合交 ( \(Intersection\) ) 、除 ( \(Division\) ) 等，它们都能通过五个基本运算表示。
1. 一元运算 1.1 选择 \[ \sigma_{predicate}(R) \]
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;作用于单个关系 \(R\) ，得到一个新关系，该关系由满足谓词 \(predicate\) 的元组组成。可以理解为从表中选出符合条件的行构成一个新表。
1.2 投影 \[ \prod\nolimits_{a_1,a_2,...,a_n}(R) \]
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;作用于单个关系 \(R\) ，得到一个由 \(R\) 的垂直子集构成的新关系，该子集抽取 \(R\) 中指定属性上的值并去掉重复元组。可以理解为从表中选出指定的列构成一个新表。
2. 集合运算 2.1 并 \[ R \cup S \]</description>
    </item>
    
    <item>
      <title>数据库系统（3）：关系模型</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 15 May 2020 13:08:11 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在目前使用的数据处理软件中，关系数据库管理系统 ( \(Relational\;Database\;Management\;System\), \(RDBMS\) ) 占据了统治地位。RDBMS基于关系数据模型。在关系模型中，所有数据逻辑上被组织成关系（表）结构。
1. 基本术语 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;关系模型基于数学中的关系 ( \(relation\) )。
1.1 关系数据结构 1.1.1 关系 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;关系是由行和列组成的表。在关系模型中，用关系保存数据库所描述对象的信息，关系用二维表表示。用户主要接触的就是表，但这只限于逻辑结构，即外部层和概念层。对于物理结构，由于是通过多种存储结构实现的，因此并不适用。
1.1.2 属性 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;属性 ( \(Attribute\) ) 是关系中命名的列。在关系的二维表中，每一行对应一个单独的记录，每一列则对应一个属性。
1.1.3 域 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;域 ( \(Domain\) ) 是一个或多个属性的取值集合，必须给每一个属性定义一个域。不同属性的域可以互不相同，也可以共用。通过使用域，用户可以集中定义属性的取值范围和含义。
1.1.4 元组 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;元组 ( \(Tuple\) ) 是关系中的行。关系的结构、域说明以及所有取值约束统称为关系的内涵 ( \(intension\) )。它通常是固定的，除非关系的意义改变，需要加入新的属性。元组的集合称为外延 ( \(extension\) ) /状态 ( \(state\) )，它经常发生改变。
1.1.5 维数 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;维数 ( \(Degree\) ) 是关系所包含的属性个数。只有一个属性的关系称为一元关系或者一元组，两个属性的关系称为二元关系，以此类推，\(n\) 个属性的关系称为 \(n\) 元组。维数是内含的性质之一。
1.1.6 基数 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;基数 ( \(Cardinality\) ) 是关系所包含的元组的个数。基数是外延的性质之一。
1.1.7 关系数据库 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;关系数据库是具有不同关系名的规范化的关系的集合。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;事实上，关系模型的术语并不统一，下表为常见的关系术语的别名及其对应的正式术语。
   正式术语 可选术语     关系 表、文件   元组 行、记录   属性 列、字段    1.</description>
    </item>
    
    <item>
      <title>数据库系统（2）：数据库环境</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 14 May 2020 11:09:00 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/</guid>
      <description>1. ANSI-SPARC三层体系结构 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;三层体系结构 ( \(Three\;Level\;Architecture\) )，包括外部层 ( \(External\) )、概念层 ( \(Conceptual\) ) 和内部层 ( \(Internal\) )。用户从外部层观察数据，DBMS和操作系统从内部层观察数据。在内部层，数据使用定义的数据结构和文件组织方法进行存储。概念层则提供内部层和外部层的映射 ( \(Mapping\) ) 以及必要的独立性 ( \(Independence\) )。三层体系结构的目的是将用户的数据库视图与数据库的物理描述分离。
1.1 外部层 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;外部层是数据库的用户视图，这一层描述数据库中与用户相关的部分。对于每一个用户，数据库中都存储着其对用的视图。并且对于同一个数据，在不同的视图中可能有着不同的表达方式。
1.2 概念层 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;概念层是数据库的整体视图，这一层描述哪些数据存储在数据库中，以及这些数据之间的联系。概念层描述：
 所有的实体、实体的属性和实体间的联系 数据的约束 数据的语义信息 安全性和完整性信息  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;概念层支持每一个外部视图，凡是用户可访问的数据必定包含在概念层或者由概念层导出。
1.3 内部层 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;内部层是数据库在计算机上的物理表示，这一层描述数据是如何存储在数据库中的。内部层与如下工作相关：
 数据和索引的存储空间分配 存储记录的描述 存储记录 数据压缩和加密  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在内部层之下是物理层 ( \(Physical\;Level\) ) ，物理层可能在DBMS的指导下受操作系统的控制。
1.4 模式、映射和实例 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对数据库的整体描述称为数据库模式 ( \(Database\;Schema\) ) 。在数据库中存在三种不同类型的，在外部层有若干外部模式 ( \(External\;Schema\) ) /子模式 ( \(Subschema\) )，与不同的数据视图对应。在概念层有概念模式 ( \(Conceptual\;Schema\) )，描述所有实体、属性和联系及其之间的完整性约束。在内部层，有内部模式 ( \(Internal\;Schema\) )，是内部模型的完整描述，包括存储记录的定义、表示方法、数据域，必要时还有所使用的索引和散列方案。一个数据库可以有多个外部模式，但只能有一个概念模式和内部模式。</description>
    </item>
    
    <item>
      <title>数据库系统（1）：数据库简介</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 13 May 2020 14:23:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 基于文件的系统 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;基于文件的系统 ( \(Traditional\;File-Based\;Systems\) ) 是一组为终端用户提供服务的应用程序，每一个程序定义和管理它自己的数据。相较于使用纸质文件进行管理的手工文件系统，基于文件的系统更加高效。但是它未能集中存储组织机构的运行数据，而是采用了分散的方法，即每一个部门在数据处理 ( \(DP\) ) 人员的帮助下存储和控制它们的数据。通过编写应用程序来管理和查询数据，具有程序-数据依赖性 ( \(Program-data\;Dependence\) ) 。
1.1 术语 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;文件 ( \(File\) ) 是一些记录 ( \(Records\) ) 的简单集合，这些记录中包含逻辑上相关的数据。每一条记录包含一组逻辑上相关的一个或多个数据项/域 ( \(Fields\) ) 。
1.2 局限性  数据被分离和孤立
数据被孤立在分离的文件中，如果要访问处于不同文件之间的数据，需要创建一个临时文件。 数据存在冗余
由于文件间的分离，有时需要重复记录一些数据。 数据存在依赖性
数据文件的物理结构和存储方式是由应用程序定义的，很难做出改变，也即程序-数据依赖性。 文件格式不相容
文件结构嵌入应用程序，因此由应用程序语言决定。难以兼容其他使用不同语言的文件结构。 需要不断更改应用程序
完全依赖于开发人员，要求开发人员以编程方式实现所有查询和表。如果查询需求发生了变化，需要重新编写程序或更改文件。  2. 数据库方法 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;基于文件的系统存在许多问题，总结原因是：
 数据内嵌应用程序 无法实现程序规定之外的操作  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因此我们需要一种更加高效的方法，数据库 ( \(Database\) ) 和 数据库管理系统 ( \(Database\;Management\;System,\;DBMS\) ) 应运而生。
2.1 数据库 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;数据库是为满足某个组织机构的信息要求而设计的一个逻辑相关数据及其描述的共享集合。在数据库内，所有的数据项都被集中起来，具有很少的冗余，为所有部门共享的资源。在其内部不仅含有组织的运行数据，还含有对这些数据的描述。因此，有时数据库也被定义为一组集成记录的自描述的集合。
2.1.1 术语 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;对数据的描述称为系统目录 ( \(system\;catalog\) ) /数据字典 ( \(Data\;Dictionary\) ) /元数据 ( \(Metadata\) ) 。也正是因为该功能，数据库具有程序-数据独立性 ( \(Program-data\;Independence\) ) 。</description>
    </item>
    
    <item>
      <title>Redis笔记</title>
      <link>https://z217blog.cn/post/redis%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 10 May 2020 17:20:42 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/redis%E7%AC%94%E8%AE%B0/</guid>
      <description>1. Redis简介 NoSQL即 \(Not-Only\;SQL\) ，是RDBMS的补充。
Redis是一种NoSQL数据库，是一个使用C语言开发的开源的高性能键值对数据库，内部使用单线程机制进行工作。
 \(set\;[key]\;[value]\)&amp;nbsp;&amp;nbsp;添加信息, \(get\;[key]\) &amp;nbsp;&amp;nbsp; 查询信息，为空返回 \(nil\) , \(del\;[key]\)&amp;nbsp;&amp;nbsp;删除信息，\(1\) 代表删除成功, \(clear\)&amp;nbsp;&amp;nbsp;清屏, \(help\;[op]\)&amp;nbsp;&amp;nbsp;帮助, \(time\)&amp;nbsp;&amp;nbsp;获取时间.  2. 数据类型 Redis采用键值对的方式存储，\(key\) 为字符串，\(value\) 则允许多种类型。
2.1 string 最简单的数据类型，最大存储量 \(512MB\) ， 可以作为数字使用，最大值为 \(java.lang.Long\) 类型的最大值， 允许以JSON对象的方式存储数据，值中间不能有空白符
 \(mset/mget\)&amp;nbsp;&amp;nbsp;获取多个数据 \(strlen\)&amp;nbsp;&amp;nbsp;获取字符个数 \(append\)&amp;nbsp;&amp;nbsp;追加，返回总长度，也可以用于添加信息 \(incr/incrby/incrbyfloat\)&amp;nbsp;&amp;nbsp;指定数据增加指定值，允许负数，返回数值 \(decr/decrby\)&amp;nbsp;&amp;nbsp;指定数据减少指定的值，允许负数，返回数值 \(setex/psetex\)&amp;nbsp;&amp;nbsp;设定数据周期，秒/毫秒  2.2 hash hash 属于 \(value\) ，其中包含多组键值对，键称为 \(field\) ，键值对较少时为类数组结构，较多时为 \(HashMap\) 结构，\(value\) 只能为 string ，且最多只能有 \(2^{32} - 1\) 组。
 \(hset/hmset\) , \(hget/hmget/hgetall\) , \(hdel\) , \(hlen\)&amp;nbsp;&amp;nbsp;字段数量, \(hexists\)&amp;nbsp;&amp;nbsp;字段存在, \(hkeys\)&amp;nbsp;&amp;nbsp;获取所有 \(key\) , \(hvals\)&amp;nbsp;&amp;nbsp;获取所有 \(value\) , \(hincrby/hincrbyfloat\) , \(hsetnx\)&amp;nbsp;&amp;nbsp;当前 \(key\) 的 \(field\) 不存在时才设置.</description>
    </item>
    
    <item>
      <title>JavaWeb（4）：Spring简介</title>
      <link>https://z217blog.cn/post/javaweb4spring%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 21 Apr 2020 15:48:49 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb4spring%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
Maven依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.inject&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.inject&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.annotation&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.annotation-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring Framework是一个Java应用程序容器，它提供了许多有用的特性，如反转控制（IoC）、依赖注入（DI）、抽象数据访问、事务管理等。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IoC是一个软件设计模式，即组装器（Spring Framework)在运行时才会绑定对象，也就是运行时才会实例化依赖的组件。这使得开发者可以针对接口进行编程，无需重新编译代码。DI是IoC的一种实现方式，通过DI，一个类可以通过声明其依赖的接口类型，然后利用组装器在运行时注入其依赖的实例。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring Framework提供了一个MVC（模型-视图-控制）模式框架，利用它可以简化创建Web应用程序的过程，不用手动处理复杂的Servlet、HttpServletRequest等。控制器类的每个方法都被映射到了一个不同的请求URL、方法或请求的其他属性上，模型可以通过 \(Map\)&amp;lt;\(String, Object\)&amp;gt;的形式从控制器传递到视图，控制器返回的视图或视图名称将把模型转发到合适的JSP视图。通过这些特性，Spring Framework极大地简化了Servlet容器的工作内容。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用MVC框架时，控制器类中的每个方法都可以拥有一个指向特定URL、请求方法、参数存在性、头的值、内容类型或期望响应类型的唯一映射。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring Framework容器以一个或多个应用上下文的形式存在，由 \(org.springframework.context.ApplicationContext\) 接口表示。一个应用上下文管理着一组bean、执行业务逻辑的Java对象、执行任务等。由Spring管理的bean可以自动进行DI、消息通知、bean验证等服务。一个Spring程序至少需要一个应用上下文，也可以使用多个应用上下文组成层次结构。在层次结构中应用上下文间有着类似于树的父子兄弟关系，一个子应用上下文的bean可以访问父应用上下文的bean，但无法访问兄弟应用上下文的bean。许多类都继承了 \(ApplicationContext\) ，也有许多实现了它：
   类 描述     \(ConfigurableApplication\) 可配置的应用上下文   \(WebApplicationContext\) 用于Java EE Web应用程序，提供了对 \(ServletContext\) 和 \(ServletConfig\) 的访问   \(ConfigurableWebApplicationContext\) 可配置的 \(WebApplicationContext\)   \(XmlApplicationContext\) 用于在Java EE Web应用程序中从XML文件加载Spring配置   \(AnnotationConfigWebApplicationContext\) 用于在Java EE Web应用程序中以编程方式配置Spring    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring使用 \(DispatcherServlet\) 处理Web请求，该Servlet将请求委托给合适的控制器，并按需求对请求和响应实体进行转换。在Web应用程序中，我们可以使用任意数量的 \(DispatcherServlet\) 。每个 \(DispatcherServlet\) 类都有自己的应用上下文，包含了对Web应用程序的 \(ServletContext\) 和自己的 \(ServletConfig\) 的引用。</description>
    </item>
    
    <item>
      <title>使用WebSocket实现的一个简单的多人聊天室</title>
      <link>https://z217blog.cn/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Sun, 19 Apr 2020 17:25:57 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>环境：JDK1.8, tomcat-8.5.51
源码可以在GitHub上查阅：ChatRoom
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WebSocket最常用的地方就是聊天室，所以我用Servlet+WebSocket实现了一个简单的多人聊天室。这个多人聊天室改一改就能作为一对一的聊天室使用，毕竟实现方法都是差不多的。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先是maven依赖，在此只展示几个要注意的依赖项：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.18.12&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; ...... ...... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.datatype&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-datatype-jsr310&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Lombok简化实体的编写（虽然只有一个实体），然后jackson相关的依赖用于Java实例和JSON对象之间的相互转化。为了避免兼容问题，我这里选择依赖基本上都是最新版本。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;然后是实体，\(ChatMessage\) 用于存储消息相关的信息，使用lombok简化了编写：
import lombok.AllArgsConstructor; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.Setter; import java.time.OffsetDateTime; @Getter @Setter @AllArgsConstructor @NoArgsConstructor public class ChatMessage { private String username; private String message; private OffsetDateTime timestamp; } &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有了实体之后再建立仓库，用于存储聊天信息以及用户信息：
import java.util.LinkedList; import java.util.List; import java.util.concurrent.CopyOnWriteArraySet; public class ChatRepository { private static List&amp;lt;ChatMessage&amp;gt; repository = new LinkedList&amp;lt;&amp;gt;(); private static CopyOnWriteArraySet&amp;lt;String&amp;gt; users = new CopyOnWriteArraySet&amp;lt;&amp;gt;(); public static List&amp;lt;ChatMessage&amp;gt; getRepository() { /*.</description>
    </item>
    
    <item>
      <title>JSON序列化传输过程中中文乱码问题的解决方法</title>
      <link>https://z217blog.cn/post/json%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 18 Apr 2020 22:13:49 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/json%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天在用WebSocket和Servlet写聊天室的时候发现传输中文会乱码的问题，起初以为是在用jackson的 \(ObjectMapper\) 将对象转化为字节流的时候出现的问题，但是经过检查后发现不是。又检查了一遍编码，确认了网页的编码是utf-8，输入的字符串也是utf-8，然后发现问题是出在了JSON对象传输的过程中。最后在 stackoverflow 上找到了解法。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我的问题出在将经过JSON序列化之后的消息对象字符串转换为 \(Uint8Array\) 以及将 \(Uint8Array\) 转为消息对象的过程中，对此可以采用 \(TextEncoder\) 和 \(TextDecoder\) 对象。如下所示：
let encoder = new TextEncoder(&amp;#39;utf-8&amp;#39;); let decoder = new TextDecoder(&amp;#39;utf-8&amp;#39;); let message = { username: &amp;#39;用户&amp;#39;, content: &amp;#39;你好，世界！&amp;#39; }; let array = encoder.encode(JSON.stringify(message)); let newMessage = JSON.parse(decoder.decode(array));  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在上例中，我们分别使用 \(TextEncoder\) 和 \(TextDecoder\) 以utf-8作为编码方式创建了编码器和译码器，之后声明了一个 \(message\) 对象存储我们要传递的消息，使用JSON序列化该对象，并使用编码器进行编码，编码后得到的是可以进行传输的 \(Uint8Array\) 对象，而对其使用译码器进行译码可以得到另一个 \(newMessage\) 对象，该对象内存储的值与之前的 \(message\) 相同，并且没有出现中文乱码的现象。</description>
    </item>
    
    <item>
      <title>JavaWeb（3）：WebSocket简介</title>
      <link>https://z217blog.cn/post/javaweb3websocket%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 06 Apr 2020 14:57:01 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb3websocket%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WebSocket用于解决浏览器和服务器的通信问题。在现有体系中，如果只是简单的使用Ajax进行通信的话，容易出现的问题是只有浏览器发送请求时才能得到响应。也即当有新数据时，浏览器不能得知新数据的存在，也就不能及时发送请求获取新数据。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WebSocket使用了HTTP/1.1 升级特性。该特性的使用很简单，只需要在请求中包含头名称和值 \(Connection: Upgrade\) ，并在额外的 \(Upgrade\) 头中指定一个或多个协议的列表。如果服务器接收升级请求，那么将返回 \(101\;Switching\;Protocols\) 。HTTP升级提供的最重要的特性是我们可以使用任意协议，并且在升级完成后就不再使用HTTP连接，我们可以用一个Socket来代替，由此产生了WebSocket协议。WebSocket协议将使用心跳消息（分别称为 \(ping\) 和 \(pong\) ）保持连接活跃，即周期性地发送小数据包。在连接升级为WebScoket协议之后，文本和二进制消息可以持续在两个方向上发送且不需要关闭和重连了；而且HTTP规范要求对应同一个主机名，只允许有两个并发连接，但由于我们升级为WebScoket连接了，因此该规范也不存在了。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用WebSocket协议之前需先以HTTP协议向服务器发送特殊请求，访问一个特殊的URL，该URL以ws或者wss开头，分别对应http和https，并且除了 \(Connection: Upgrade\) 头之外，还包含一个 \(Connection: websocket\) 头，用于指定服务器将连接升级为 WebSocket协议。
 HTML5(JavaScript)客户端API &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WebSocket并不是只能用于浏览器和服务器的通信中，理论上可以将其应用于任何支持其的应用程序中。但如果要编写使用WebSocket进行连接的浏览器客户端终端，我们就要用到JavaScript，尽管我们使用JavaScript编写，但实际上WebSocket是HTML5的一部分。使用JavaScript创建WebSocket对象十分简单：
var connection = new WebSocket(&amp;#39;ws://www.example.com/chat&amp;#39;, {&amp;#39;chat.v1&amp;#39;, &amp;#39;chat.v2&amp;#39;});  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WebSocket构造函数第一个参数为连接所使用的URL，第二个参数可选，为连接所使用的一个或多个协议，这些协议都是自己创建的，不受WebSocket管理。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;WebSocket接口中包含 \(readyState\) 属性表示当前状态，值为 \(CONNECTING\), \(OPEN\), \(CLOSING\), \(CLOSED\) 中的一个，包含四个事件：\(onopen\), \(onclose\), \(onerror\), \(onmessage\) ，前两者分别在 \(readyState\) 由 \(CLOSING\) 变为 \(CLOSED\) 时和 \(readyState\) 由 \(CONNECTING\) 变为 \(OPEN\) 时触发。传入 \(onclose\) 方法的事件包含三个属性：\(wasClean\), \(code\), \(reason\) ，传入 \(onopen\) 的是普通的事件，传入 \(onerror\) 和 \(onmessage\) 的事件包含一个 \(data\) 属性，在前者中是错误对象，而在后者则根据消息类型转变：消息为字符串，则 \(data\) 也为字符串；消息为二进制数据，并且 \(WebSocket.</description>
    </item>
    
    <item>
      <title>JavaWeb（2）：Session简介</title>
      <link>https://z217blog.cn/post/javaweb2session%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 26 Mar 2020 15:41:52 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb2session%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
注：演示所用 Java 版本为 Java8 ，所用容器为 Tomcat8.5.51
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;会话用于处理维持请求和请求之间的状态。在没有使用会话时，HTTP请求是无状态的，在浏览器打开第一个连接到服务器的套接字时开启，在服务器返回最后一个数据包时结束。而有些时候，我们希望保持状态，如用户登录或者在线编辑时，这时我们就要用到会话。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在Web中，会话是由服务器或Web应用程序管理的某些文件、内存片段、对象或者容器。服务器在第一次接收到请求时，会随机生成一串字符串，称为会话ID，并返回用户浏览器中。之后所有从该用户浏览器中发出的请求都需要包含该会话ID，服务器接收到会话ID后可以将会话与请求关联起来。HTTP cookie用于将会话ID发送到服务器，但是如果用户浏览器禁止了cookie，那么就需要将会话ID内嵌在URL中，很明显，这种方式使得其他人可以轻松地获得会话，因此是不安全的。不过由于如今许多网站都要求用户在访问时启用cookie，因此我们可以不用顾虑这点。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;会话也是有漏洞的。但是由于描述起来篇幅过长，因此不做赘述，如果感兴趣的话可以在 Session hijacking -Wikipedia 中查看。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;大部分情况下我们可以直接使用会话，不需要添加显式配置，但是出于安全目的，我们应该进行配置。使用&amp;lt;\(session-config\)&amp;gt;标签进行配置，同时在&amp;lt;\(session-config\)&amp;gt;标签内，我们也可以使用&amp;lt;\(cookie-config\)&amp;gt;标签进行cookie的配置。所有在&amp;lt;\(session-config\)&amp;gt;标签和&amp;lt;\(cookie-config\)&amp;gt;标签内的标签都是可选的。下面列出了所有的可选标签：
&amp;lt;session-config&amp;gt; &amp;lt;session-timeout&amp;gt;30&amp;lt;/session-timeout&amp;gt; &amp;lt;cookie-config&amp;gt; &amp;lt;name&amp;gt;JSESSIONID&amp;lt;/name&amp;gt; &amp;lt;domain&amp;gt;example.org&amp;lt;/domain&amp;gt; &amp;lt;path&amp;gt;/path&amp;lt;/path&amp;gt; &amp;lt;comment&amp;gt;&amp;lt;! [CDATA[Keeps you logged in. See our privacy policy for more information.]]&amp;gt;&amp;lt;/comment&amp;gt; &amp;lt;http-only&amp;gt;true&amp;lt;/http-only&amp;gt; &amp;lt;secure&amp;gt;false&amp;lt;/secure&amp;gt; &amp;lt;max-age&amp;gt;180&amp;lt;/max-age&amp;gt; &amp;lt;/cookie-config&amp;gt; &amp;lt;tracking-mode&amp;gt;COOKIE&amp;lt;/tracking-mode&amp;gt; &amp;lt;tracking-mode&amp;gt;URL&amp;lt;/tracking-mode&amp;gt; &amp;lt;tracking-mode&amp;gt;SSL&amp;lt;/tracking-mode&amp;gt; &amp;lt;/session-config&amp;gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;下面为每个标签的作用：
   标签 作用     &amp;lt;\(session-timeout\)&amp;gt; 会话在无效前可以保持不活跃状态的时间，以分钟为单位，为 \(0\) 表示永远不过期。   &amp;lt;\(tracking-mode\)&amp;gt; 表示容器使用哪种技术追踪会话ID，可以配置多个值，按照配置顺序使用。URL表示容器将在URL中内嵌会话ID，COOKIE表示使用cookie，SSL表示使用SSL会话，但要求所有请求均是HTTPS请求。   &amp;lt;\(name\)&amp;gt; 可以自定义会话cookie的名字，通常不用设置。   &amp;lt;\(domain\)&amp;gt; 设置cookie的Domain特性，通常不用设置。   &amp;lt;\(path\)&amp;gt; 设置cookie的Path特性，通常不用设置。   &amp;lt;\(comment\)&amp;gt; 可以添加任意文本，用于解释cookie。   &amp;lt;\(http-only\)&amp;gt; 设置cookie的HttpOnly特性，为了提高安全性，一般都设置为 \(true\) 。   &amp;lt;\(secure\)&amp;gt; 设置cookie的Secure特性，如果使用的是HTTPS，就应设置为 \(true\) 。   &amp;lt;\(max-age\)&amp;gt; 设置cookie的Max-Age特性，控制cookie何时过期，以秒为单位，通常不用设置。    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;学习了如何配置会话之后，就该学习如何使用会话了。为了获取会话，我们可以调用 \(HttpServletRequest.</description>
    </item>
    
    <item>
      <title>JavaWeb（1）：Servlet入门</title>
      <link>https://z217blog.cn/post/javaweb1servlet%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 14 Mar 2020 19:20:22 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb1servlet%E5%85%A5%E9%97%A8/</guid>
      <description>参考书籍：Pro Java for Web Apps
注：以下内容需要HTTP基础，演示所用Java版本为Java8，所用容器为Tomcat8.5.51
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Servlet是一个运行在Web服务器中的Java小程序，用于接收和响应来自Web客户端的请求，使用HTTP进行通信，是所有Web应用程序的核心类，也是唯一的既可以直接处理和响应用户请求，也可以将处理工作委托给应用中的其他部分的类。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Servlet只是一个简单的接口，包含了相关的方法。大多数情况下Servlet都继承自 \(javax.servlet.GenericServlet\) 类，该类只包含一个抽象的 \(service\) 方法以及一些辅助方法。\(service\) 方法会处理所有请求，然后返回对应的响应。我们可以使用\(javax.servlet.http.HttpServlet\) 类用于响应HTTP请求，它继承自 \(GenericServlet\) 并实现其 \(service\) 方法，而对于响应HTTP请求的方法只是空实现。在 \(HttpServlet\) 类中，HTTP请求包括 \(GET,HEAD,POST,PUT,DELETE,OPTIONS,TRACE\) 对应的响应方法名称为 \(do +\) 首字母大写的请求名称。如 \(GET\) 对应 \(doGet()\) ，\(POST\) 对应 \(doPost()\) 等。除了响应方法之外，Servlet类中还包含 \(init\) 方法和 \(destroy\) 方法，分别在启用和关闭Servlet时调用，不过通常这些方法什么也不做。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 大多数情况下我们的Servlet类都是继承 \(HttpServlet\) 类。对于上述提到的所有方法，它们都接收两个参数，一个是 \(javax.servlet.http.HttpServletRequest\) 类型的参数，另一个是 \(javax.servlet.http.HttpServletResponse\) 类型。顾名思义，\(HttpServletRequest\) 指向客户端请求，对其我们有如下常用方法：
   方法 作用     \(getParameter\) 返回参数的单个值   \(getParameterValues\) 返回参数的值的数组   \(getParameterMap\) 返回一个包含所有参数名值对的\(java.util.Map&amp;lt;String, String[\ \ ]&amp;gt;\)   \(getParameterNames\) 返回所有可用参数的名字的枚举   \(getContentLength\) 返回请求正文的长度（小于 \(2\) GB）   \(getContentLengthLong\) 返回请求正文的长度（大于 \(2\) GB）   \(getCharacterEncoding\) 返回请求内容的字符编码   \(getReader\) 返回一个 \(java.</description>
    </item>
    
    <item>
      <title>Dijkstra算法原理及其实现</title>
      <link>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 03 Mar 2020 17:27:28 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</guid>
      <description>参考书籍：《算法（第4版）》
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\(Dijkstra\) 算法应用于带权有向图中求最短路径问题。通俗来讲就是不断选择权值最小的边加入集合直到所有顶点都在集合中，属于贪心算法。需要注意的是，\(Dijkstra\) 算法只能用于解决边权非负的图类问题。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;假设对于一个带权有向图 \(G(V,E)\) 以邻接矩阵表示，其所有边存储在一个二维整型数组 \(matrix[\ \ ][\ \ ]\) 中， \(matrix[i][j]\) 表示从顶点 \(i\) 到顶点 \(j\) 之间的边，值为边的权值，若值为 \(∞\) ，说明该边不存在。为了实现 \(Dijkstra\) 算法，我们需要一个布尔值数组 \(visit[\ \ ]\) ，用于判断顶点是否访问过，或者说是否在集合中；一个整型数组 \(distance[\ \ ]\) 用于储存原点到每个点的最短距离。定义了基本的结构，就可以实现算法了，步骤为：
 从 \(V\) 中选择一个点 \(s\) 作为原点，将邻接矩阵中的 \(matrix[s]\) 数组复制到 \(distance[s]\) （复制后 \(distance[s]\) 应为 \(0\) ），建立一个 \(visit[\ \ ]\) 数组并清零。 从 \(V\) 中选择一个顶点 \(u\) 加入集合，其中点 \(u\) 满足：
 之前未曾访问过点 \(u\) （即 \(visit[u] = false\) ）。 与 \(s\) 距离最短（即 \(distance[u]\) 的值最小）。  以 \(u\) 为中心点，对于每个与 \(u\) 相邻的顶点 \(k\) ，令 \(distance[k] = Min(distance[k], distance[u] + matrix[u][k])\) ，这一步也称为松弛( \(relaxation\) )。 重复2、3直到所有顶点加入集合。  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\(Dijkstra\) 算法类似于 \(Prim\) 算法，实质上都是构造了一颗树。经过以上步骤之后，我们得到了一个 \(distance[\ \ ]\) 数组，其中的值为从原点 \(s\) 到图中其他所有点的最短距离。在使用代码实现的过程中，有些情况下我们可以使用优先队列来简化寻找最小权值的这一过程。如果我们确认了一幅图是无环图，那么我们也可以不使用 \(visit[\ \ ]\) ，而是通过拓扑排序的顺序依次遍历顶点。</description>
    </item>
    
    <item>
      <title>JavaScript中的数组</title>
      <link>https://z217blog.cn/post/javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 01 Mar 2020 15:05:01 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</guid>
      <description>参考书籍：《JavaScript高级程序设计（第3版）》
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;作为一种可以说是最常用的类型，EMCAScript当中的数组与其他语言的数组有很大区别，例如数组元素可以是不同类型，数组长度可以动态调整等，因此我总结了一下EMCAScript中的数组类型，即 \(Array\) 类型（主要集中于与其他语言不同的地方）。
 数组创建 数组长度 数组方法  判定方法 转换方法 栈方法 队列方法 排序方法 操作方法 位置方法 迭代方法 归并方法   1. 数组创建 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;EMCAScript中数组是一个特殊的类型，有自己的构造函数，我们可以通过 \(new\) 运算符来调用数组的构造函数。
var array = new Array(); //建立一个空数组  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当然，你也可以通过传参来调用带参构造函数。
var array1 = new Array(10); //大小为10的数组 var array2 = new Array(1, 2, 3); //包含1,2,3三个元素的数组 var array2 = new Array(&amp;#34;A&amp;#34;); //包含一个&amp;#34;A&amp;#34;的数组  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;但是在这里要注意的是，如果你只给构造函数传一个数字，则会创建对应大小的数组,其中每一项的值都是 \(undefined\) ；如果传的是多个数字，则会创建包含这些数字的数组。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;除了调用构造函数之外，我们还可以使用字面量语法。如下所示：
var array1 = []; //空数组 var array2 = [1]; //包含一个1的数组 var array3 = [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;]; //包含三个元素的数组   2.</description>
    </item>
    
    <item>
      <title>Leetcode题解（2）：二分搜索</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A32%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sat, 29 Feb 2020 17:23:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A32%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</guid>
      <description>原题地址: Problem 4
参考题解
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;题目不用多解释，如果没有要求时间复杂度的话可以直接用双指针法遍历即可，但既然题目要求对数级的复杂度，再加上是排序数组，那么很容易就可以想到是二分法，接下来的问题就是怎么二分了。回忆下中位数的概念，中位数是一组顺序排序的数据中居于中间位置的数。也就是说，如果我们知道一组数据的中位数，我们就可以顺势以中位数为基准，将这组数据分成相同大小的两部分，其中一部分中的数总是小于（或等于）另一部分。再回到题目来，如果我们知道这两个数组的中位数，那么我们就可以将这两个数组以中位数为基准将每个数组分为两部分，如下所示：

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;其中左边两部分中所有的值永远小于或等于右边两部分。这时很明显中位数为
\[ median = \frac{max(nums1[i - 1], nums2[j - 1])\ +\ min(nums1[i] + nums2[j])}{2} \]
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这样我们的目标就从找中位数变成了寻找一个 \(i\) 和 \(j\) ，满足如下条件（假设 \(i\) 和 \(j\) 总是存在）：
 &amp;nbsp;\(i + j = \Large\frac{nums1.length\ +\ nums2.length}{2}\normalsize;\) &amp;nbsp;\(nums1[i - 1]  &amp;nbsp;\(nums2[j - 1]   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;根据上述条件，如果我们要进行二分搜索，第一步必须先将两个数组分别二分，保证条件1为真。
if (nums1.length &amp;gt; nums2.length) return findMedianSortedArrays(nums2, nums1); int len1 = nums1.length, len2 = nums2.length, halfLen = (len1 + len2 + 1) / 2, i = len1 / 2, j = halfLen - i; } &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可以发现我们在开始判断了下\(nums1[\ \ ]\)和\(nums2[\ \ ]\)的长度，确保 \(nums1.</description>
    </item>
    
    <item>
      <title>JavaScript的对象构造</title>
      <link>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/</link>
      <pubDate>Fri, 28 Feb 2020 12:48:51 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/</guid>
      <description>参考书籍：《JavaScript高级程序设计》（第3版）
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaScript是一门面向对象的语言，即拥有类的概念。但ECMAScript中没有类的概念，因此它的对象与其他基于类的语言不同，我们可以把ECMAScript中的对象想象成散列表，由一组组键值对构成，值可以是数据或者函数。
 \(object\) 构造函数模式 对象字面量 工厂模式 构造函数模式 原型模式  什么是原型对象  寄生构造函数模式 稳妥构造函数模式 属性类型   1.object构造函数模式 var person = new object(); person.name = &amp;#34;A&amp;#34;; person.sayName = function() { alert(this.name); };  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;上例创建了一个 \(person\) 对象，并为其添加了 \(name\) 属性和 \(sayName(\ )\) 方法，是最简单的构造对象的方法。
 2.对象字面量 var person = { name: &amp;#34;XiaoMing&amp;#34;, sayName: function() { alert(this.name); } };  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;上例创建了相同的 \(person\) 对象，不同之处在于它是使用对象字面量定义的。以花括号表示开始和结束，属性名+冒号+值的格式定义属性，用逗号隔开多个不同的属性。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在使用对象字面量时，属性名也可以使用字符串。需要注意的是，JSON只支持此种语法。
var person = { &amp;#34;name&amp;#34;: &amp;#34;XiaoMing&amp;#34;, &amp;#34;sayName&amp;#34;: function() { alert(this.name); } };  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一般情况下，由于对象字面量语法的代码量少，开发人员大多采用此种方式构造对象。</description>
    </item>
    
    <item>
      <title>Leetcode周赛：177</title>
      <link>https://z217blog.cn/post/leetcode%E5%91%A8%E8%B5%9B177/</link>
      <pubDate>Thu, 27 Feb 2020 11:18:21 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E5%91%A8%E8%B5%9B177/</guid>
      <description>第 177 场周赛
 Problem 1360: 日期之间间隔几天 Problem 1361: 验证二叉树 Problem 1362: 最接近因数 Problem 1363: 形成三的最大倍数   Problem 1360: 日期之间间隔几天
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;直接调用库函数即可。
import java.time.LocalDate; import java.time.temporal.ChronoUnit; class Solution { public int daysBetweenDates(String date1, String date2) { return (int) Math.abs(LocalDate.parse(date1).until(LocalDate.parse(date2), ChronoUnit.DAYS)); } } &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用 \(LocalDate\) 类及其 \(until(\ )\) 方法，使用 \(ChronoUnit.DAYS\) 常量表明以天为单位计算。在此要注意的是Leetcode并没有默认导入 \(java.time\) 类，因此要自己导入。
 Problem 1361: 验证二叉树
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;利用二叉树的性质可以知道，二叉树根节点外每个节点有且只有一个父节点，并且有且只有一个根节点。通过这个性质，我们可以遍历数组，找到所有的节点的父节点，再验证是否符合上述性质。
class Solution { public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) { int[] parent = new int[n]; //储存每个节点的父节点  Arrays.</description>
    </item>
    
    <item>
      <title>Leetcode题解：一道”难“题</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A3%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98/</link>
      <pubDate>Mon, 17 Feb 2020 17:44:43 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A3%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98/</guid>
      <description>原题地址：Problem 1332 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;题目很直(mo)白(hu)，就是从一个字符串中删除回文子列直到字符串为空。但是我——没看示例，盯着题目描述和左上角的“简单”，陷入了长时间的思考，最终怀疑人生。毕竟如果你要找回文串的话就得遍历一遍得到子串，然后删除，再遍历，再循环……如此反复，时间复杂度很高，完全不是简单难度，毫无办法的我最终只能看向题解，然后在惊叹中一分钟提交了答案。
class Solution { public int removePalindromeSub(String s) { if (s.length() == 0) return 0; else if (s.equals(new StringBuilder(s).reverse().toString())) return 1; else return 2; } } &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;总之这道题很沙雕，沙雕之处就在于它的子序列可以不连续。所以，如果不是空串或者回文串的话，先删掉所有的 \(a\) 再删掉所有的 \(b\) 就行了。由于让我卡了很久，专门写了一篇博客，特此留念。</description>
    </item>
    
    <item>
      <title>Leetcode题解（1）：动态规划</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A31%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Wed, 12 Feb 2020 20:42:30 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A31%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>原题地址：Problem 62 参考题解 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;第一眼看到这道题就联想到了离散数学里的排列的相关知识，从而可以很容易的得出排列数为 \(C(m+n-2,m-1)\) 或者 \(C(m+n-2,n-1)\)，可以直接利用该公式进行计算。但问题是阶乘的增长量级过大，很快就产生了溢出的问题，这时可以通过使用 \(BigInteger\) 类型对象解决。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;虽然问题解决了，但显然这种偏暴力方式的解法不是我们的目的，因此我们还要寻找另一种解法。通过观察题目，我们可以很明显的发现：由于只能右移或者下移，因此到达每一块方格的路径数（不包括第一行和第一列） = 到达其左边方格的路径数 + 到达其上边方格的路径数。以此规律，我们可以运用动态规划来解决该问题。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先先设
int[][] dp = new int[m][n]; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dp数组为二维数组，储存到达每个方格的路径数。由于达到第一列和第一行中所有方格的路径数有且仅有一条，因此可以
for (int i = 0; i &amp;lt; m; i++) dp[i][0] = 1; for (int i = 1; i &amp;lt; n; i++) dp[0][i] = 1;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之后仅需双循环进行赋值即可：
for (int i = 1; i &amp;lt; m; i++) for (int j = 1; j &amp;lt; n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在此，无论是按行还是按列，结果都是一样的。最后 \(dp[m - 1][n - 1]\) 即为答案。将上述代码合并起来即为：</description>
    </item>
    
    <item>
      <title>JavaScript的对象继承</title>
      <link>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 06 Dec 2019 22:58:43 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/</guid>
      <description>参考书籍：《JavaScript高级程序设计》（第3版）
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;继承是OO语言（面对对象语言）中的概念。许多OO语言都支持两种继承方式：接口继承（继承方法签名）和实现继承（继承实际方法）。但由于JavaScript中没有签名，因此在ECMAScript中只能实现方法继承。
 原型链 借用构造函数 组合继承 原型式继承 寄生式继承 寄生组合式继承   1. 原型链 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;原型链（ \(prototype\;chaining\) ）是实现继承的主要方法。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
function SuperType() { this.property = true; } SuperType.property.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; } //继承SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; }  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;上述代码中定义了两种类型—— \(SuperType\) 和 \(SubType\) ，其中 \(SubType\) 继承了 \(SuperType\) 。实现的本质是重写 \(SubType\) 的原型对象，即将一个 \(SuperType\) 对象赋给 \(SubType.property\) ，从而使得 \(SuperType\) 中所有的属性和方法均存在于 \(SubType\) 中。在实例中，我们也给 \(SubType\) 添加了一个新方法。此外，还要注意，以此种方式实现的继承中， \(SubType.</description>
    </item>
    
  </channel>
</rss>