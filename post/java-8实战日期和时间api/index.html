<!DOCTYPE html>
<html><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
        
        <a href="http://123.57.12.189"  target="_blank" >
            <i class="fas fa-link fa-sm"></i>
            <span>二站</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">

<h1 id="title">Java 8实战：日期和时间API</h1>


<p>        在<code>Java 1.0</code>中，对日期和时间的支持只能依赖 $java.util.Date$ 类。这个类无法表示日期，只能以毫秒的精度表示时间。而且由于某些原因未知的设计决策，这个类的易用性也不高。例如一个表示 $2014$ 年 $3$ 月 $18$ 日的 $Date$ 需要用以下方式创建：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Date</span> <span class="n">date</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Date</span><span class="o">(</span><span class="n">114</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
</code></pre></div><p>        此外，$Date.toString$ 方法的返回值中虽然包含时区，但 $Date$ 并不支持时区。所以，在<code>Java 1.1</code>中，$Date$ 的许多方法被废弃，取而代之的是 $java.util.Calendar$ 类，但是这个类同样也存在着很多问题。比如月份依旧是从 $0$ 开始，而且没有提供 $DateFormat$ 方法。如果使用 $DateFormat$ 方法，那么又会带来并发问题，因为它不是线程安全的。为了解决上述问题，<code>Java 8</code>中新增的 $java.time$ 包中添加了新的日期和时间<code>API</code>。<br/>
        $java.time$ 包中提供了一些新类：$LocalDate$ 、$LocalTime$ 、$Instant$ 、$Duration$ 和 $Period$ 。<br/></p>
<h2 id="1-localdatelocaltimelocaldatetime">1. <code>LocalDate</code>/<code>LocalTime</code>/<code>LocalDateTime</code></h2>
<p>        $LocalDate$ 的实例是一个不可变对象，它只提供了简单的日期，并不包含当天的时间信息。另外，它也不附带任何与时区相关的信息。可以通过静态工厂方法 $of$ 创建一个 $LocalDate$ 实例，或者通过 $now$ 方法从系统时钟中获取当前日期，并通过 $getYear$ 、$getMonth$ 、$getDayOfMonth$ 等方法读取常用值。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span><span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getYear</span><span class="o">();</span> <span class="c1">// 2014
</span><span class="c1"></span><span class="n">Month</span> <span class="n">month</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getMonth</span><span class="o">();</span> <span class="c1">// MARCH
</span><span class="c1"></span><span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getDayOfMonth</span><span class="o">();</span> <span class="c1">// 18
</span><span class="c1"></span><span class="n">DayOfWeek</span> <span class="n">dow</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getDayOfWeek</span><span class="o">();</span> <span class="c1">// TUESDAY
</span><span class="c1"></span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">lengthOfMonth</span><span class="o">();</span> <span class="c1">// 31
</span><span class="c1"></span><span class="kt">boolean</span> <span class="n">leap</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">isLeapYear</span><span class="o">();</span> <span class="c1">// false
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">today</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
</code></pre></div><p>        $TemporalField$ 是一个接口，定义了如何访问 $temporal$ 对象某个字段的值。$ChronoField$ 枚举实现了这一接口，通过 $get$ 方法可以获取对应字段的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">YEAR</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTH_OF_YEAR</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">DAY_OF_MONTH</span><span class="o">);</span>
</code></pre></div><p>        类似的，一天中的时间可以使用 $LocalTime$ 表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalTime</span> <span class="n">time</span> <span class="o">=</span> <span class="n">LocalTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">,</span> <span class="n">20</span><span class="o">);</span> <span class="c1">// 13:45:20
</span><span class="c1"></span><span class="kt">int</span> <span class="n">hour</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">getHour</span><span class="o">();</span> <span class="c1">// 13
</span><span class="c1"></span><span class="kt">int</span> <span class="n">minute</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">getMinute</span><span class="o">();</span> <span class="c1">// 45
</span><span class="c1"></span><span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">getSecond</span><span class="o">();</span> <span class="c1">// 20
</span></code></pre></div><p>        $LocalDate$ 和 $LocalTime$ 都可以通过解析字符串的形式创建。一旦传递的字符串参数无法被解析为合法的对象时就会抛出一个 $DateTimeParseException$ 异常。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2014-03-18&#34;</span><span class="o">);</span>
<span class="n">LocalTime</span> <span class="n">time</span> <span class="o">=</span> <span class="n">LocalTime</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;13:45:20&#34;</span><span class="o">);</span>
</code></pre></div><p>        $LocalDateTime$ 是 $LocalDate$ 和 $LocalTime$ 的复合体，既可以表示日期，也可以表示时间，但不带有时区信息。通过 $atTime$ 或者 $atDate$ 方法传递一个时间或者日期对象，可以创建一个 $LocalDateTime$ 。此外，也可以通过 $toLocalDate$ 和 $toLocalTime$ 方法，从 $LocalDateTime$ 中创建 $LocalDate$ 和 $LocalTime$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDateTime</span> <span class="n">dt1</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">,</span> <span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">,</span> <span class="n">20</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt2</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">date</span><span class="o">,</span> <span class="n">time</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt3</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">atTime</span><span class="o">(</span><span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">,</span> <span class="n">20</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt4</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">atTime</span><span class="o">(</span><span class="n">time</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt5</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">atDate</span><span class="o">(</span><span class="n">date</span><span class="o">);</span>

<span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">dt1</span><span class="o">.</span><span class="na">toLocalDate</span><span class="o">();</span>
<span class="n">LocalTime</span> <span class="n">time1</span> <span class="o">=</span> <span class="n">dt1</span><span class="o">.</span><span class="na">toLocalTime</span><span class="o">();</span>
</code></pre></div><h2 id="2-instant">2. <code>Instant</code></h2>
<p>        从计算机的角度来看，建模时间最自然的格式是表示一个持续时间段某个点的单一大整形数，这也是 $Instant$ 类对时间建模的方式，基本上它是以<code>Unix</code>元年时间（传统的设定为<code>UTC</code>时区 $1970$ 年 $1$ 月 $1$ 日午夜时分）开始所经历的秒数进行计算。<br/>
        静态工厂方法 $ofEpochSecond$ 接收秒数，创建 $Instant$ 实例。此外，它还提供了一个重载版本，额外接收一个纳秒。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Instant</span><span class="o">.</span><span class="na">ofEpochSecond</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
<span class="n">Instant</span><span class="o">.</span><span class="na">ofEpochSecond</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="n">1_000_000_000</span><span class="o">);</span>
<span class="n">Instant</span><span class="o">.</span><span class="na">ofEpochSecond</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="o">-</span><span class="n">1_000_000_000</span><span class="o">);</span>
<span class="n">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
</code></pre></div><p>        虽然 $Instant$ 也支持 $now$ 方法，但是它包含的是由秒及纳秒所构成的数字，目的是方便机器使用，所以无法处理一些时间单位。但是我们可以通过 $Duration$ 和 $Period$ 类使用 $Instant$ 。<br/></p>
<h2 id="3-durationperiod">3. <code>Duration</code>/<code>Period</code></h2>
<p>        到目前为止的所有类都实现了 $Temporal$ 接口，该接口定义了如何读取和操纵为时间建模的对象的值。$Duration$ 类表示两个 $Temporal$ 对象之间的时间，提供了一个静态工厂方法 $between$ 用于创建该类型实例。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Duration</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">time1</span><span class="o">,</span> <span class="n">time2</span><span class="o">);</span>
<span class="n">Duration</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">dateTime1</span><span class="o">,</span> <span class="n">dateTime2</span><span class="o">);</span>
<span class="n">Duration</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">instant1</span><span class="o">,</span> <span class="n">instant2</span><span class="o">);</span>
</code></pre></div><p>        由于 $Duration$ 类主要用于以秒和纳秒衡量时间的长短，所以不能只接收 $LocalDate$ 作为参数。而且由于 $LocalDateTime$ 和 $Instant$ 是为不同的目的而设计的，所以也不能将二者同时作为参数传入，否则会抛出 $DateTimeException$ 异常。<br/>
        $Period$ 类与 $Duration$ 类相对，接收两个 $LocalDate$ ，表示它们之间的时长。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Period</span> <span class="n">tenDays</span> <span class="o">=</span> <span class="n">Period</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">8</span><span class="o">),</span>
                                <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">));</span>
</code></pre></div><p>        除了 $between$ 之外，$Duration$ 和 $Period$ 也提供了很多方便的工厂类，用于直接创建实例。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">是否为静态方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$between$</td>
<td align="center">是</td>
<td align="center">创建两个时间点之间的间隔</td>
</tr>
<tr>
<td align="center">$from$</td>
<td align="center">是</td>
<td align="center">由一个临时时间点创建间隔</td>
</tr>
<tr>
<td align="center">$of$</td>
<td align="center">是</td>
<td align="center">由它的组成部分创建间隔</td>
</tr>
<tr>
<td align="center">$parse$</td>
<td align="center">是</td>
<td align="center">由字符串创建间隔</td>
</tr>
<tr>
<td align="center">$addTo$</td>
<td align="center">否</td>
<td align="center">创建间隔副本并叠加到指定对象上</td>
</tr>
<tr>
<td align="center">$get$</td>
<td align="center">否</td>
<td align="center">读取间隔</td>
</tr>
<tr>
<td align="center">$isNegative$</td>
<td align="center">否</td>
<td align="center">检查间隔是否为负值</td>
</tr>
<tr>
<td align="center">$isZero$</td>
<td align="center">否</td>
<td align="center">检查间隔是否为零</td>
</tr>
<tr>
<td align="center">$minus$</td>
<td align="center">否</td>
<td align="center">减去一定时间创建间隔副本</td>
</tr>
<tr>
<td align="center">$multipliedBy$</td>
<td align="center">否</td>
<td align="center">将间隔值乘以某个标量创建副本</td>
</tr>
<tr>
<td align="center">$negated$</td>
<td align="center">否</td>
<td align="center">忽略某个时长的方式创建间隔副本</td>
</tr>
<tr>
<td align="center">$plus$</td>
<td align="center">否</td>
<td align="center">增加某个时长的方式创建间隔副本</td>
</tr>
<tr>
<td align="center">$subtractFrom$</td>
<td align="center">否</td>
<td align="center">从指定对象中减去间隔</td>
</tr>
</tbody>
</table>
<h2 id="4-操作日期">4. 操作日期</h2>
<p>        $with$ 方法允许我们创建对象的副本，并按照需要修改它的属性。此外，也可以使用类似于四则运算的方法来创建对象副本。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">withYear</span><span class="o">(</span><span class="n">2011</span><span class="o">);</span> <span class="c1">// 2011-03-18
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date3</span> <span class="o">=</span> <span class="n">date2</span><span class="o">.</span><span class="na">withDayOfMonth</span><span class="o">(</span><span class="n">25</span><span class="o">);</span> <span class="c1">// 2011-03-25
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date4</span> <span class="o">=</span> <span class="n">date3</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTH_OF_YEAR</span><span class="o">,</span> <span class="n">9</span><span class="o">);</span> <span class="c1">// 2011-09-25
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date5</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">plusWeeks</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="c1">// 2014-03-25;
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date6</span> <span class="o">=</span> <span class="n">date5</span><span class="o">.</span><span class="na">minusYear</span><span class="o">(</span><span class="n">3</span><span class="o">);</span> <span class="c1">// 2011-03-25
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date7</span> <span class="o">=</span> <span class="n">date6</span><span class="o">.</span><span class="na">plus</span><span class="o">(</span><span class="n">6</span><span class="o">,</span> <span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTHS</span><span class="o">);</span> <span class="c1">// 2011-09-25
</span></code></pre></div><p>        此外，$LocalDate$ 、$LocalTime$ 、$LocalDateTime$ 以及 $Instant$ 中都提供了大量通用方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">是否为静态方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$from$</td>
<td align="center">是</td>
<td align="center">根据对象创建实例</td>
</tr>
<tr>
<td align="center">$now$</td>
<td align="center">是</td>
<td align="center">根据系统时钟创建实例</td>
</tr>
<tr>
<td align="center">$of$</td>
<td align="center">是</td>
<td align="center">根据对象的某部分创建实例</td>
</tr>
<tr>
<td align="center">$parse$</td>
<td align="center">是</td>
<td align="center">根据字符串创建实例</td>
</tr>
<tr>
<td align="center">$atOffset$</td>
<td align="center">否</td>
<td align="center">将对象和某个时区偏移结合</td>
</tr>
<tr>
<td align="center">$atZone$</td>
<td align="center">否</td>
<td align="center">将对象和某个时区结合</td>
</tr>
<tr>
<td align="center">$format$</td>
<td align="center">否</td>
<td align="center">使用某个格式器将对象转换为字符串（$Instant$ 类不支持）</td>
</tr>
<tr>
<td align="center">$get$</td>
<td align="center">否</td>
<td align="center">读取对象某部分值</td>
</tr>
<tr>
<td align="center">$minus$</td>
<td align="center">否</td>
<td align="center">将对象减去一定时长创建副本</td>
</tr>
<tr>
<td align="center">$plus$</td>
<td align="center">否</td>
<td align="center">将对象加上一定时长创建副本</td>
</tr>
<tr>
<td align="center">$with$</td>
<td align="center">否</td>
<td align="center">对对象某些部分进行修改创建副本</td>
</tr>
</tbody>
</table>
<h2 id="5-temporaladjuster">5. <code>TemporalAdjuster</code></h2>
<p>        $with$ 方法可以接收一个 $TemporalAdjuster$ 对象，允许我们更加灵活地处理日期。对于一些常见的用例，日期和时间<code>API</code>已经提供了大量预定义的 $TemporalAdjuster$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">TemporalAdjusters</span><span class="o">.</span><span class="na">nextOrSame</span><span class="o">(</span><span class="n">DayOfWeek</span><span class="o">.</span><span class="na">SUNDAY</span><span class="o">));</span> <span class="c1">// 2014-03-23
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date3</span> <span class="o">=</span> <span class="n">date2</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">TemporalAdjusters</span><span class="o">.</span><span class="na">lastDayOfMonth</span><span class="o">());</span> <span class="c1">// 2014-03-31
</span></code></pre></div><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$dayOfWeekInMonth$</td>
<td align="center">同月份同星期中每周第几天</td>
</tr>
<tr>
<td align="center">$firstDayOfMonth$</td>
<td align="center">当月第一天</td>
</tr>
<tr>
<td align="center">$firstDayOfNextMonth$</td>
<td align="center">下月第一天</td>
</tr>
<tr>
<td align="center">$firstDayOfNextYear$</td>
<td align="center">下年第一天</td>
</tr>
<tr>
<td align="center">$firstDayInMonth$</td>
<td align="center">同月份第一个星期几</td>
</tr>
<tr>
<td align="center">$lastDayOfMonth$</td>
<td align="center">当月最后一天</td>
</tr>
<tr>
<td align="center">$lastDayOfNextMonth$</td>
<td align="center">下月最后一天</td>
</tr>
<tr>
<td align="center">$lastDayOfNextYear$</td>
<td align="center">下年最后一天</td>
</tr>
<tr>
<td align="center">$lastDayOfYear$</td>
<td align="center">今年最后一天</td>
</tr>
<tr>
<td align="center">$lastInMonth$</td>
<td align="center">同月份最后一个星期几</td>
</tr>
<tr>
<td align="center">$next$ / $previous$</td>
<td align="center">之前或之后第一个星期几</td>
</tr>
<tr>
<td align="center">$nextOrSame$ / $previousOrSame$</td>
<td align="center">之前或之后第一个星期几，包括当前日期</td>
</tr>
</tbody>
</table>
<p>        如果预定义的 $TemporalAdjuster$ 不能满足需求，我们可以定义更加复杂的操作，即创建自定义的 $TemporalAdjuster$ 。实际上，$TemporalAdjuster$ 接收是一个函数式接口，只声明了一个方法。我们可以将其视为 $UnaryOperator$&lt;$Temporal$&gt; 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TemporalAdjuster</span> <span class="o">{</span>
    <span class="n">Temporal</span> <span class="nf">adjustInto</span><span class="o">(</span><span class="n">Temporal</span> <span class="n">temporal</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>        由于该接口为函数式接口，所以我们可以通过<code>Lambda</code>表达式进行传递。实现一个计算下一个工作日的 $TemporalAdjuster$ 的例子如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">date</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">temporal</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">DayOfWeek</span> <span class="n">dow</span> <span class="o">=</span> <span class="n">DayOfWeek</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">temporal</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">DAY_OF_WEEK</span><span class="o">));</span>
    <span class="kt">int</span> <span class="n">dayToAdd</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dow</span> <span class="o">==</span> <span class="n">DayOfWeek</span><span class="o">.</span><span class="na">FRIDAY</span><span class="o">)</span> <span class="n">dayToAdd</span> <span class="o">=</span> <span class="n">3</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">dow</span> <span class="o">==</span> <span class="n">DayOfWeek</span><span class="o">.</span><span class="na">SATURDAY</span><span class="o">)</span> <span class="n">dayToAdd</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">temporal</span><span class="o">.</span><span class="na">plus</span><span class="o">(</span><span class="n">dayToAdd</span><span class="o">,</span> <span class="n">ChronoField</span><span class="o">.</span><span class="na">DAYS</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div><p>        $TemporalAdjusters.ofDateAdjuster$ 方法接收一个 $UnaryOperator$&lt;$LocalDate$&gt; 类型的参数，返回一个 $TemporalAdjuster$ 。我们也可以使用该方法利用<code>Lambda</code>表达式创建 $TemporalAdjuster$ 。</p>
<h2 id="6-datetimeformatter">6. <code>DateTimeFormatter</code></h2>
<p>        $java.time.format$ 专门用于格式化以及解析日期-时间对象，而 $DateTimeFormatter$ 类是其中最重要的类。所有的 $DateTimeFormatter$ 实例都能用于以一定的格式创建代表特定日期或时间的字符串。此外，在解析过程中也可以通过指定格式的形式使用不同的字符串创建日期。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">BASIC_ISO_DATE</span><span class="o">);</span> <span class="c1">// 20140318
</span><span class="c1"></span><span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ISO_LOCAL_DATE</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span>
<span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;20140318&#34;</span><span class="o">,</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">BASIC_ISO_DATE</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2014-03-18&#34;</span><span class="o">,</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ISO_LOCAL_DATE</span><span class="o">);</span>
</code></pre></div><p>        除了使用已经定义好的格式外，通过 $ofPattern$ 方法，我们也可以自定义格式。$ofPattern$ 还提供了一个重载版本，允许我们创建某个 $Locale$ 的格式器。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DateTimeFormatter</span> <span class="n">formatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">&#34;dd/MM/yyyy&#34;</span><span class="o">);</span>
<span class="n">DateTimeFormatter</span> <span class="n">italianFormatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">&#34;d. MMMM yyyy&#34;</span><span class="o">,</span> <span class="n">Locale</span><span class="o">.</span><span class="na">ITALIAN</span><span class="o">);</span>
</code></pre></div><p>        如果需要更加细粒度的控制，$DateTimeFormatter$ 还提供了更复杂的格式器。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DateTimeFormatter</span> <span class="n">italianFormatter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DateTimeFormatterBuilder</span><span class="o">()</span>
                                        <span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">DAY_OF_MONTH</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendLiteral</span><span class="o">(</span><span class="s">&#34;. &#34;</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTH_OF_YEAR</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendLiteral</span><span class="o">(</span><span class="s">&#34; &#34;</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">YEAR</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">parseCaseInsensitive</span><span class="o">()</span>
                                        <span class="o">.</span><span class="na">toFormatter</span><span class="o">(</span><span class="n">Locale</span><span class="o">.</span><span class="na">ITALIAN</span><span class="o">);</span>
</code></pre></div><p>        相较于 $java.util.DateFormat$ ，所有的 $DateTimeFormatter$ 都是线程安全的，所以可以以单例模式创建格式器实例，并在多个线程之间共享。</p>
<h2 id="7-时区和历法">7. 时区和历法</h2>
<p>        $java.time.ZoneId$ 类是老版的 $java.util.TimeZone$ 的替代品，与其他日期和时间类一样，它也是无法修改的。$ZoneRules$ 类中包含了 $40$ 个实例，可以通过 $ZoneId.getRules(\ )$ 可以获取指定时区的规则。每个特定的 $ZoneId$ 对象都由一个<code>ID</code>标识。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ZoneId</span> <span class="n">romeZone</span> <span class="o">=</span> <span class="n">ZoneId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;Europe/Rome&#34;</span><span class="o">);</span>
</code></pre></div><p>        <code>Java 8</code>中为 $TimeZone$ 提供了一个新方法 $toZoneId$ ，通过该方法，我们可以将一个老时区对象转换为 $ZoneId$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ZoneId</span> <span class="n">zoneId</span> <span class="o">=</span> <span class="n">TimeZone</span><span class="o">.</span><span class="na">getDefault</span><span class="o">().</span><span class="na">toZoneId</span><span class="o">();</span>
</code></pre></div><p>        一旦得到 $ZoneId$ ，我们就可以将其与 $LocalDate$ 、$LocalDateTime$ 或者是 $Instant$ 结合，构造为一个 $ZonedDateTime$ 实例。通过 $ZoneId$ ，我们还可以实现 $LocalDateTime$ 和 $Instant$ 之间的互相转换。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">ZonedDateTime</span> <span class="n">zdt1</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">atStartOfDay</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>

<span class="n">LocalDateTime</span> <span class="n">dateTime</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">,</span> <span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">);</span>
<span class="n">ZonedDateTime</span> <span class="n">zdt2</span> <span class="o">=</span> <span class="n">dateTime</span><span class="o">.</span><span class="na">atZone</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>

<span class="n">Instant</span> <span class="n">instant</span> <span class="o">=</span> <span class="n">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
<span class="n">ZonedDateTime</span> <span class="n">zdt3</span> <span class="o">=</span> <span class="n">instant</span><span class="o">.</span><span class="na">atZone</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>

<span class="n">Instant</span> <span class="n">instantFromDateTime</span> <span class="o">=</span> <span class="n">dateTime</span><span class="o">.</span><span class="na">toInstant</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">timeFromInstant</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">ofInstant</span><span class="o">(</span><span class="n">instant</span><span class="o">,</span> <span class="n">romeZone</span><span class="o">);</span>
</code></pre></div><p>        另一种比较通用的表示时区的方式是利用当前时区和<code>UTC</code>/格林尼治的固定偏差，我们可以通过 $of$ 方式创建。要注意，使用这种方式定义的 $ZoneOffset$ 并未考虑任何日光时的影响，所以在大部分情况下不推荐使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ZoneOffset</span> <span class="n">newYorkOffset</span> <span class="o">=</span> <span class="n">ZoneOffset</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;-05:00&#34;</span><span class="o">);</span>
</code></pre></div><p>        虽然<code>ISO-8601</code>日历系统是世界文明日历系统的事实标准。但是<code>Java 8</code>中另外还提供了 $4$ 种其他的日历系统，这些日历系统中的每一个都有一个对应的日志类，分别是 $ThaiBuddhistDate$ 、$MinguoDate$ 、$JapaneseDate$ 以及 $HijrahDate$ 。所有这些类以及 $LocalDate$ 都实现了 $ChronoLocalDate$ 接口，能够对公历的日期进行建模。我们可以通过 $from$ 方法从 $LocalDate$ 中创建，或者先创建一个日历系统，接着再创建该日期实例。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">JapaneseDate</span> <span class="n">japaneseDate</span> <span class="o">=</span> <span class="n">JapaneseDate</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">date</span><span class="o">);</span>

<span class="n">Chronology</span> <span class="n">japaneseChronology</span> <span class="o">=</span> <span class="n">Chronology</span><span class="o">.</span><span class="na">ofLocale</span><span class="o">(</span><span class="n">Locale</span><span class="o">.</span><span class="na">JAPAN</span><span class="o">);</span>
<span class="n">ChronoLocalDate</span> <span class="n">now</span> <span class="o">=</span> <span class="n">japaneseChronology</span><span class="o">.</span><span class="na">dateNow</span><span class="o">();</span>
</code></pre></div><p>        日期及时间<code>API</code>的设计者建议使用第一种方式进行创建，因为开发者在代码中可能会进行一些假设，但这些假设在不同的日历系统中有可能不成立，比如一个月最多有 $31$ 天，一年有 $12$ 个月等。除非需要将程序的输入或者输出本地化，否则不要使用 $ChronoLocalDate$ 类。</p>


<a href="javascript:void(0)" id="tocbtn"><i class="fas fa-bars fa-lg"></i></a>
<div id="sidetoc">
    <header>
        <h4>Java 8实战：日期和时间API</h4>
    </header>
    
    <nav id="TableOfContents">
        <ul></ul>
    </nav>
</div>
<script src=https://z217blog.cn/js/toc.js></script>



<div class="nav-next-prev">
    <div class="nav-prev">
        
        <a href="https://z217blog.cn/post/java-8%E5%AE%9E%E6%88%98%E6%B5%81%E5%A4%84%E7%90%86/"><i class="fas fa-chevron-left"></i></a>
        
    </div>
    <a class="nav-top" href="#">回到顶部</i></a>
    <div class="nav-next">
        
        <a href="https://z217blog.cn/post/mysql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"><i class="fas fa-chevron-right"></i></a>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
        if (tocFlag) tocInit();
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>