<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="z217&#39;s blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/jquery.floatingscroll.css>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"
    integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src=https://z217blog.cn/js/jquery.floatingscroll.min.js></script>
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/navbutton.js></script>
<script src=https://z217blog.cn/js/lightswitcher.js></script>
<script src=https://z217blog.cn/js/toc.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn/><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>
        

        <a id="branding" href=https://z217blog.cn/>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a><br/>
        <a href="javascript:void(0)" id="scroll-top" onclick="scrollToTop()">回到顶部</a>
        <a href="javascript:void(0)" id="light-switcher">暗色模式</a>
        <div class="content">

<h1 id="title">C&#43;&#43;协程（5）：理解编译器转换</h1>




<h2 id="介绍">介绍</h2>
<p>        之前的“理解C++协程”文章中讲到了编译器会对协程，以及它的 $co_-await$、$co_-yield$、$co_-return$ 表达式执行的不同类型的转换。这些文档描述了编译器如何将每个表达式翻译成底层的对多种自定义的点 / 用户定义的方法调用。</p>
<ol>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/">协程理论</a></li>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/">理解 $co_-await$</a></li>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B3%E7%90%86%E8%A7%A3promise/">理解 $promise$</a></li>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B4%E7%90%86%E8%A7%A3%E5%AF%B9%E7%A7%B0%E8%BD%AC%E7%A7%BB/">理解对称转移</a></li>
</ol>
<p>        然而，这些描述还有一部分你可能不太满意。它们对于“挂起点”的概念一笔带过，含糊地说成“协程在这里挂起”、“协程在这里恢复”，并没有详细说明它的含义，以及编译器是怎么实现的。<br>
        在这篇文章，我会把之前文章的所有概念更深入地讲解。我会把一个协程转换为底层等价的非协程、命令式的<code>C++</code>代码，来展示当协程执行到挂起点时发生了什么。<br>
        注意我不会描述某个特定编译器怎么把协程编译成机器码 ( 编译器在这方面会有些额外技巧 )，而是只描述一种可能的把协程转化成可移植的<code>C++</code>代码的方式。<br>
        警告：这次讨论会有点深！</p>
<h2 id="设置场景">设置场景</h2>
<p>        对于初学者，我们假设有一个基本的 $task$ 类型，同时作为 $awaitable$ 和协程的返回类型。为了简化，假设这个协程类型异步生成一个 $int$ 类型结果。<br>
        在这篇文章，我们会描述怎么把下面的协程代码转换为不包含任何协程关键字 $co_-await$、$co_-return$的<code>C++</code>代码，以便我们更好理解它的含义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// Forward declaration of some other function. Its implementation is not relevant.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">task</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// A simple coroutine that we are going to translate to non-C++ code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_return</span> <span class="n">fx</span> <span class="o">*</span> <span class="n">fx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="定义-task-类型">定义 task 类型</h2>
<p>        首先，我们声明一个会被用到的 $task$ 类。<br>
        为了理解协程怎么转化成底层代码，我们不需要明白这个类型的方法定义。对它们的调用会被插入转换中。<br>
        这些方法的定义并不复杂，我会把它们作为读者理解以前文章的练习实践。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">task</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">awaiter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">promise_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">promise_type</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">promise_type</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">final_awaiter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">task</span> <span class="nf">get_return_object</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span> <span class="n">initial_suspend</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">final_awaiter</span> <span class="nf">final_suspend</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">unhandled_exception</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">return_value</span><span class="p">(</span><span class="kt">int</span> <span class="n">result</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">continuation_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">monostate</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&gt;</span> <span class="n">result_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">task</span><span class="p">(</span><span class="n">task</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">task</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">task</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">task</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">awaiter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">awaiter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">awaite_ready</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">coro_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span> <span class="k">operator</span> <span class="nf">co_await</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">coro_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        这个 $task$ 类型的定义与<a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B3%E7%90%86%E8%A7%A3promise/">理解 $promise$</a>的相似。</p>
<h2 id="第一步确定-promise-类型">第一步：确定 promise 类型</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_return</span> <span class="n">fx</span> <span class="o">*</span> <span class="n">fx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        当编译器看到这个函数包含三个协程关键字 ( $co_-await$、$co_-yield$、$co_-return$ ) 中的一个时，它开始执行协程转换步骤。<br>
        第一步是确定协程的 $promise$ 类型。<br>
        这一步是通过把函数签名的返回类型和参数类型作为 $std$::$coroutine_traits$ 类型的模板参数判断的。<br>
        例如，我们的函数 $g$，返回类型为 $task$，有一个参数类型是 $int$，编译器会使用 $std$::$coroutine_-traits$&lt;$task$, $int$&gt;::$promise_-type$ 判断。<br>
        让我们定义个别名，方便以后使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">__g_promise_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_traits</span><span class="o">&lt;</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span></code></pre></div><p>        <strong>注意：我使用了两个下划线开始的类型名，表示这个符号是编译器内部生成的。这种符号是实现时保留的，并且不应该在你的代码中使用。</strong><br>
        现在，因为我们没有特例化 $std$::$coroutine_-traits$，这会导致主模板实例化，而主模板只是把内嵌的 $promise_-type$ 作为返回类型的 $promise_-type$ 的别名，在我们的例子中也就是解析为 $task$::$promise_-type$。</p>
<h2 id="第二步创建协程状态">第二步：创建协程状态</h2>
<p>        一个协程函数需要在挂起时保存协程状态、参数和局部变量，以便在后续恢复时保持可用。<br>
        这个状态，在<code>C++</code>标准中，被称为协程状态，通常分配在堆上。<br>
        让我们开始给协程 $g$ 定义个协程状态结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        协程状态包含了一系列不同的东西：</p>
<ul>
<li>$promise$ 对象</li>
<li>所有函数参数的副本</li>
<li>协程当前挂起所在的挂起点信息，以及如何恢复 / 销毁它</li>
<li>所有局部变量 / 跨挂起点的临时变量存储</li>
</ul>
<p>        让我们加上 $promise$ 对象和参数副本存储。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_promise_t</span> <span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        接着，我们加个构造函数来初始化这些数据成员。<br>
        回想一下，编译器会先尝试使用参数副本的左值引用来调用 $promise$ 的构造函数，如果不行，就会调用 $promise$ 的默认构造函数。<br>
        让我们创建一个简单的 $helper$ 来帮忙：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Params</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Promise</span> <span class="n">construct_promise</span><span class="p">(</span><span class="na">[[maybe_unused]]</span> <span class="n">Params</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">constructible_from</span><span class="o">&lt;</span><span class="n">Promise</span><span class="p">,</span> <span class="n">Params</span><span class="o">&amp;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Promise</span><span class="p">(</span><span class="n">params</span><span class="p">...);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">Promise</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        因此，协程状态构造器看起来可能会像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">,</span> <span class="n">__promise</span><span class="p">(</span><span class="n">construct_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_promise_t</span> <span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        现在我们有了一个表示协程状态的类型雏形，我们可以通过在堆上分配一个 __$g_-state$ 实例，传递函数参数给它拷贝 / 移动的方式，构建出 $g\left(\right)$ 底层实现的雏形。<br>
        一些术语：我使用“启动函数” ( $ramp$ $function$ ) 指代协程初始化协程状态和准备开始执行协程的逻辑，就像一条进入协程体执行的坡道。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... implement rest of the ramp function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        注意我们的 $promise$ 类型没有重载 $operator$ $new$，所以我们会调用全局的 ::$operator$ $new$。<br>
        如果 $promise$ 类型重载了 $operator$ $new$，我们不会调用全局的 ::$operator$ $new$，而是先确认参数列表 $\left(size, paramLvalues&hellip;\right)$ 是否可以作为 $operator$ $new$ 的参数，如果可以的话，就使用这个参数列表调用；否则，我们只会使用 $\left(size\right)$ 参数列表调用。$operator$ $new$ 的访问协程函数参数列表的能力有时被称为“参数预览” ( $parameter$ $preview$ )，在你想要使用 $allocator$ 作为参数来给协程状态分配空间时很有用。<br>
        如果编译器发现 __$g_-promise_-t$::$operator$ $new$ 的实现，逻辑会被转换为以下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="n">__promise_allocate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="na">[[maybe_unused]]</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="k">requires</span> <span class="p">{</span> <span class="n">Promise</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">args</span><span class="p">...);</span> <span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Promise</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">args</span><span class="p">...);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Promise</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span><span class="o">*</span> <span class="n">state_mem</span> <span class="o">=</span> <span class="n">__promise_allocate</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">__g_state</span><span class="p">),</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="o">*</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span> <span class="o">=</span> <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="n">state_mem</span><span class="p">)</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">__g_promise_t</span><span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">state_mem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... implement rest of the ramp function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        同样，这个 $promise$ 类型没有定义静态函数成员 $get_-return_-object_-on_-allocation_-failure\left(\right)$。如果 $promise$ 类型定义了这个函数，这里的分配会使用 $std$::$nothrow_-t$ 形式的 $operator$ $new$，并且当分配返回 $nullptr$ 时返回 __$g_-promise_-t$::$get_-return_-object_-on_-allocation_-failure\left(\right)$。<br>
        即，看起来会像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nothrow</span><span class="p">)</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">__g_promise_t</span><span class="o">::</span><span class="n">get_return_object_on_allocation_failure</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... implement rest of the ramp function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        为了简化剩下的例子，我们使用最简单的调用全局 ::$operator$ $new$ 内存分配函数。</p>
<h2 id="第三步调用-get_return_object">第三步：调用 get_return_object()</h2>
<p>        启动函数要做的下一件事是调用 $promise$ 对象的 $get_-return_-object\left(\right)$ 方法，获取启动函数的返回值。<br>
        返回值会作为局部变量存储，并在启动函数结束返回 ( 在其他步骤完成后 )。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... implement rest of ramp function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">return_value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        然而，$get_-return_-object\left(\right)$ 的调用可能抛出异常，这时我们想要释放协程状态分配的内存。一种比较好的方法是使用 $std$::$unique_-ptr$ 来管理，这样在后续操作抛出异常时，它会被释放：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">(</span><span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... implement rest of ramp function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">return_value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="第四步初始化挂起点">第四步：初始化挂起点</h2>
<p>        启动函数在调用 $get_-return_-object\left(\right)$ 之后的下一件事是开始执行协程体，协程体执行的第一件事是初始化挂起点，即等价于 $co_-await$ $promise.initial_-suspend\left(\right)$。<br>
        现在，理想的话，我们只需要让协程初始化挂起，然后实现恢复一个初始化挂起协程的启动。然而，初始化挂起点在处理协程以及协程状态的生命周期问题上，有一些奇怪的细节。这些是<code>C++20</code>发布前对初始化挂起点语义的一些后期调整，目的是修复一些存在的问题。<br>
        根据初始化挂起点的定义，如果一个异常从这些地方抛出：</p>
<ul>
<li>$initial_-suspend\left(\right)$ 的调用，</li>
<li>对返回的 $awaitable$ 的 $operator$ $co_-await\left(\right)$ ( 如果有定义 )，</li>
<li>调用 $awaiter$ 的 $await_-ready\left(\right)$，或者</li>
<li>调用 $awaiter$ 的 $await_-suspend\left(\right)$</li>
</ul>
<p>        那么异常会传播到启动函数的调用方，协程状态会被自动销毁。<br>
        如果一个异常从以下地方抛出：</p>
<ul>
<li>$await_-resume\left(\right)$ 调用，</li>
<li>$operator co_-await\left(\right)$ 返回对象的析构函数 ( 如果可用 )，或者</li>
<li>$initial_-suspend\left(\right)$ 返回对象的析构函数</li>
</ul>
<p>        那么异常会被协程体捕获，然后调用 $promise.unhandled_-exception\left(\right)$。<br>
        这意味着我们需要注意这部分的转换，一部分需要实现在启动函数，另一部分需要放在协程体。<br>
        而且，因为 $initial_-suspend\left(\right)$ 返回的对象和 $operator$ $co_-await$ 返回的对象 ( 可选的 ) 具有跨挂起点的生命周期 ( 它们会在协程挂起点前创建，恢复后销毁 )，这些对象的存储需要放在协程状态里。<br>
        在我们特别的例子中，$initial_-suspend\left(\right)$ 返回类型是 $std$::$suspend_-always$，后者是一个空的、平凡构造类型。然而，逻辑上我们还是需要在协程状态里保存这个对象的实例，所以我们会一直加上这部分存储，展示它如何工作。<br>
        这个对象只在调用 $initial_-suspend\left(\right)$ 的位置构造，所以我们需要新增一个确定类型的数据成员，允许我们显示地控制它的生命周期。<br>
        为了支持这些功能，我们先定义一个 $helper$ 类 $manual_-lifetime$，后者具有平凡的构造和析构函数，我们会在需要的时候显式地构造 / 析构存储在其中的值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">manual_lifetime</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">manual_lifetime</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Not copyable/movable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">manual_lifetime</span><span class="p">(</span><span class="k">const</span> <span class="n">manual_lifetime</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="p">(</span><span class="n">manual_lifetime</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">manual_lifetime</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">manual_lifetime</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Factory</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">requires</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">invocable</span><span class="o">&lt;</span><span class="n">Factory</span><span class="o">&amp;&gt;</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">Factory</span><span class="o">&amp;&gt;</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">&amp;</span> <span class="n">construct_from</span><span class="p">(</span><span class="n">Factory</span> <span class="n">factory</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_nothrow_invocable_v</span><span class="o">&lt;</span><span class="n">Factory</span><span class="o">&amp;&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storage</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span><span class="n">factory</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">destroy</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_nothrow_destructible_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launder</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storage</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">launder</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storage</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">byte</span> <span class="n">storage</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        注意 $construct_-from\left(\right)$ 方法设计成接受<code>lambda</code>而不是接受构造函数参数。这让我们可以使用拷贝消除特性，就地通过函数调用结果初始化构造对象。如果使用构造函数参数，我们就需要进行一次不必要的移动构造函数。<br>
        现在我们可以通过 $manual_-lifetime$ 声明 $promise.initial_-suspend\left(\right)$ 返回的临时对象数据成员。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_promise_t</span> <span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        $std$::$suspend_-always$ 类型没有定义 $operator$ $co_-await\left(\right)$，所以我们不需要额外的内存保存其返回的临时对象。<br>
        一旦我们通过 $initial_-suspend\left(\right)$ 构造这个对象，我们就需要调用 $await_-ready\left(\right)$、$await_-suspend\left(\right)$ 和 $await_-resume\left(\right)$ 实现 $co_-await$ 表达式。<br>
        当调用 $await_-suspend\left(\right)$ 时，我们需要传递当前协程句柄。现在我们可以通过直接把 $promise$ 引用作为参数调用 $std$::$coroutine_-handle$&lt;__$g_-promise_-t$&gt;::$from_-promise\left(\right)$ 的方式实现。我们稍后再看看它的内部结构。<br>
        同样，$.await_-suspend\left(handle\right)$ 调用的结果类型是 $void$，因此不需要像 $bool$ 返回或者 $coroutine_-handle$ 返回那样考虑是否恢复当前协程或者另一个协程。<br>
        最终，所有 $std$::$suspend_-always$ $awaiter$ 的方法都是 $noexcept$ 的，我们不需要担心异常。如果它们可能会抛出异常，我们需要添加额外的代码保证临时的 $std$::$supsend_-always$ 对象在异常传播到启动函数之外前被销毁。<br>
        一旦 $await_-suspend\left(\right)$ 成功返回或者协程体准备开始执行时，如果有异常抛出，我们就不再需要自动销毁协程状态。所以我们可以调用持有协程状态的 $std$::$unique_-ptr$ 的 $release\left(\right)$ 来避免当我们从函数返回时协程状态的自动销毁。<br>
        所以现在我们可以实现初始化挂起表达式的第一部分：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">(</span><span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ... suspend-coroutine here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// fall through to return statement below.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Coroutine did not suspend.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ... start executing the coroutine body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">__return_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        $await_-resume\left(\right)$ 调用和 __$tmp1$ 的析构函数会在协程体出现，所以不会在启动函数出现。<br>
        现在我们有了一个 ( 大部分 ) 功能等价的初始化挂起点逻辑，但启动函数仍然有一系列 TODO。为了解决这些，我们首先需要绕道研究一下挂起然后恢复一个协程的策略。</p>
<h2 id="第五步记录挂起点">第五步：记录挂起点</h2>
<p>        当协程挂起时，需要确保恢复点与之前的挂起点相同。<br>
        此外，还需要跟踪每个挂起点上自动生命周期对象的存活状态，以便之后协程如果被销毁而不是挂起时，知道需要销毁哪些对象。<br>
        一种实现方式是给每个挂起点一个唯一编号，然后在协程状态使用一个整型数据成员存储。<br>
        无论什么时候，当一个协程挂起，它需要把当前挂起点编号写入协程状态，在之后恢复 / 销毁的时候，根据这个整型来找到之前的挂起点。<br>
        注意这不是通过协程状态存储挂起点的唯一方法，然而，主流的三个编译器 ( <code>MSVC</code>、<code>Clang</code>和<code>GCC</code> ) 在这篇文章发布 ( $2022$ 年 ) 的时候都采用了这个方法。另一个可能的解决办法是每个挂起点都使用不同的恢复 / 销毁函数指针，但这篇文章不会讲解这个办法。<br>
        那么让我们来扩展协程状态，使用一个整型数据成员来保存挂起点下标，并初始化为 $0$ ( 我们把使用值表示初始化挂起点 )。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_promise_t</span> <span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// &lt;-- add the suspend-point index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h2 id="第六步实现-coroutine_handleresume-和-coroutine_handledestory">第六步：实现 coroutine_handle::resume() 和 coroutine_handle::destory()</h2>
<p>        当协程被 $coroutine_-handle$::$resume\left(\right)$ 调用恢复时，我们需要调用某些函数实现被挂起协程的剩余部分，被调用的函数查找挂起点下标，然后跳转到控制流中的适当位置。<br>
        此外，我们需要实现 $coroutine_-handle$::$destroy\left(\right)$ 函数，通过合适的逻辑销毁当前挂起点作用内的对象。然后我们需要实现 $coroutine_-handle$::$done\left(\right)$ 来确认当前挂起点是否为最终挂起点。<br>
        $coroutine_-handle$ 方法接口不知道协程状态的具体类型，$coroutine_-handle$&lt;$void$&gt; 类型可以指向任何协程实例。这意味着我们需要以类型被擦除的协程状态实现。<br>
        我们可以存储指向协程类型的恢复 / 销毁函数指针，并让 $coroutine_-handle$::$resume$ / $destroy\left(\right)$ 调用这些函数指针。<br>
        $coroutine_-handle$ 类型同样需要实现通过 $coroutine_-handle$::$address\left(\right)$ 转换为 $void*$，和通过 $coroutine_-handle$::$from_-address\left(\right)$ 转换为 $void*$。<br>
        进一步，协程可以被任意一个指向它的句柄恢复 / 销毁，不只是最近一个传给 $await_-suspend\left(\right)$ 调用的。<br>
        这些要求让我们定义的 $coroutine_-handle$ 类型只能包含一个指向协程状态的指针，在状态里通过数据成员存储恢复 / 销毁函数指针，而不是把恢复 / 销毁函数指针存在 $coroutine_-handle$ 里。<br>
        同样，因为我们需要 $coroutine_-handle$ 能够指向任意协程状态对象，所以所有协程状态类型的函数指针数据成员应该保持一致。<br>
        一种直接方法是让协程状态类型继承一些包含这些数据成员的基类。<br>
        例如，我们可以定义以下类型作为所有协程状态类型的基类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__coroutine_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__resume_fn</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__destroy_fn</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">__resume_fn</span><span class="o">*</span> <span class="n">__resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__destroy_fn</span><span class="o">*</span> <span class="n">__destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        这样 $coroutine_-handle$::$resume\left(\right)$ 可以直接叫 __$resume\left(\right)$，使用 __$coroutine_-state$ 指针作为参数。$coroutine_-handle$::$destroy\left(\right)$ 和 __$destroy\left(\right)$ 函数指针也是一样。<br>
        对于 $coroutine_-handle$::$done\left(\right)$ 方法，我们选择一个空 __$resume\left(\right)$ 函数指针表示最终挂起点。这种方法很方便，因为最终挂起点不支持 $resume\left(\right)$，只支持 $destroy\left(\right)$。如果尝试对一个在最终挂起点挂起的协程调用 $resume\left(\right)$ ( 这是未定义行为 )，那么会调用一个空函数指针，这会失败并且能快速指出错误。<br>
        基于这些，我们可以实现 $coroutine_-handle$&lt;$void$&gt;：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">coroutine_handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_handle</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_handle</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_handle</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">state_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">coroutine_handle</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">h</span><span class="p">.</span><span class="n">state_</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">coroutine_handle</span> <span class="n">a</span><span class="p">,</span> <span class="n">coroutine_handle</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">state_</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">resume</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state_</span><span class="o">-&gt;</span><span class="n">__resume</span><span class="p">(</span><span class="n">state_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state_</span><span class="o">-&gt;</span><span class="n">__destroy</span><span class="p">(</span><span class="n">state_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state_</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">state_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="第七步实现-coroutine_handlepromisepromise-和-from_promise">第七步：实现 coroutine_handle&lt;Promise&gt;::promise() 和 from_promise()</h2>
<p>        对于更通用的 $coroutine_-handle$&lt;$Promise$&gt; 特例化，大部分实现都可以复用 $coroutine_-handle$&lt;$void$&gt; 实现。然而，我们也需要通过 $promise\left(\right)$ 方法的返回，访问协程状态的 $promise$ 对象，以及从 $promise$ 对象引用构造出一个 $coroutine_-handle$ 。<br>
        然而，因为 $coroutine_-handle$&lt;$Promise$&gt; 类型必须能指向任何 $promise$ 类型是 $Promise$ 的协程状态，因此我们无法简单从指针获取具体协程类型。<br>
        我们需要定义一个新的协程状态基类继承 __$coroutine_-state$，前者应当包含 $promise$ 对象，这样我们就可以定义所有使用特定 $promise$ 类型的协程状态类型，并让它们继承基类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__coroutine_state_with_promise</span> <span class="o">:</span> <span class="n">__coroutine_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__coroutine_state_with_promise</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__coroutine_state_with_promise</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Promise</span> <span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        你可能好奇为什么 __$promise$ 成员会定义在一个匿名的 $union$ 里面……<br>
        原因是派生类是为特定的包含参数副本数据成员的协程函数创建的。派生类的数据成员默认会在所有基类数据成员后初始化，所以把 $promise$ 对象声明为普通数据成员意味着它会在参数副本数据成员之前被构造。<br>
        然而，我们需要 $promise$ 的构造函数在参数副本构造函数之后调用，因为参数副本引用可能会被传给 $promise$ 构造函数。<br>
        因此，我们在基类中为 $promise$ 对象保留空间，这样它们就在协程状态内部有一个一致的偏移量，并在参数副本被初始化后的合适点位，调用派生类的构造 / 析构函数。这种控制是通过把 $promise$ 声明为 $union$ 成员实现的。<br>
        让我们更新 __$g_-state$ 类型，继承新的基类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">__x</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Use placement-new to intialise the promise object in the base-class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">::</span><span class="k">new</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="n">__g_promise_t</span><span class="p">(</span><span class="n">construct_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__g_state</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Also need to manually call the promise destructor before the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// argument objects are destroyed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="o">~</span><span class="n">__g_promise_t</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        现在我们已经定义了 $promise$ 基类，可以开始实现 $std$::$coroutine_-handle$&lt;$Promise$&gt; 类模板。<br>
        大部分实现都很像 $coroutine_-handle$&lt;$void$&gt;，除了使用 __$coroutine_-state_-with_-promise$&lt;$Promise$&gt; 指针而不是 __$coroutine_-state$ 指针。<br>
        新增部分只有 $promise\left(\right)$ 和 $from_-promise\left(\right)$ 函数。</p>
<ul>
<li>$promise\left(\right)$ 方法直接返回协程状态的 __$promise$ 成员。</li>
<li>$from_-promise\left(\right)$ 方法需要我们从 $promise$ 对象地址计算出协程状态对象地址。我们只需要从 $promise$ 对象地址中减去 __$promise$ 成员的偏移量就可以了。</li>
</ul>
<p>        $coroutine_-handle$&lt;$Promise$&gt; 的实现是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">coroutine_handle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">state_t</span> <span class="o">=</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">Promise</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_handle</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_handle</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_hanlde</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">operator</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">from_address</span><span class="p">(</span><span class="n">address</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">coroutine_handle</span> <span class="n">a</span><span class="p">,</span> <span class="n">coroutine_handle</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">state_</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">state_</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">coroutine_handle</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">h</span><span class="p">.</span><span class="n">state_</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">state_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state_</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_promise</span><span class="p">(</span><span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">coroutine_handle</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// We know the address of the __promise member, so calculate the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// address of the coroutine-state by subtracting the offset of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the __promise field from this address.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">h</span><span class="p">.</span><span class="n">state_</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">state_t</span><span class="o">*&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">promise</span><span class="p">)</span> <span class="o">-</span>
</span></span><span class="line"><span class="cl">        <span class="n">offsetof</span><span class="p">(</span><span class="n">state_t</span><span class="p">,</span> <span class="n">__promise</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Define these in terms of their coroutine_handle&lt;void&gt; implementations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">resume</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">done</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">state_t</span><span class="o">*</span> <span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        现在已经定义了协程恢复机制，我们可以回到启动函数，并实现初始化我们往协程状态新加的函数指针数据成员。</p>
<h2 id="第八步函数体开始部分">第八步：函数体开始部分</h2>
<p>        现在我们前向声明具有正确签名的恢复/销毁函数，并更新 __$g_-state$ 构造函数来初始化协程状态，以便恢复/销毁函数指针指向它们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">__x</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialise the function-pointers used by coroutine_handle methods.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__g_resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__destroy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__g_destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Use placement-new to intialise the promise object in the base-class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">::</span><span class="k">new</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="n">__g_promise_t</span><span class="p">(</span><span class="n">construct_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ... rest omitted for brevity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">(</span><span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// fall through to return statement below.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Coroutine did not suspend. Start executing the body immediately.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__g_resume</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">return_value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        完成了启动函数部分后，我们可以开始看 $g\left(\right)$ 的恢复/销毁函数。<br>
        让我们继续转换初始化挂起表达式。<br>
        当 __$g_-resume\left(\right)$ 被调用且 __$suspend_-point$ 的下标是 $0$，我们就需要调用 __$tmp1$ 的 $await_-resume\left(\right)$，并在之后调用 $tmp1$ 的析构函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// We know that &#39;s&#39; points to a __g_state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Generate a jump-table to jump to the correct place in the code based
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on the value of the suspend-point index.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO: Implement rest of coroutine body.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// int fx = co_await f(x);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// co_return fx * fx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        当 __$g_-destroy\left(\right)$ 被调用且 __$suspend_-point$ 下标是 $0$，我们要在销毁和释放协程状态前销毁 __$tmp1$。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO: Add extra logic for other suspend-points here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">destroy_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="第九步转换-co_await-表达式">第九步：转换 <code>co_await</code> 表达式</h2>
<p>        接着，我们看看怎么转换 $co_-await$ $f\left(x\right)$ 表达式。<br>
        首先我们来看看一个返回 $task$ 临时对象的 $f\left(x\right)$。<br>
        因为临时的 $task$ 直到语句结尾的分号才会被销毁，而且语句含有 $co_-await$ 表达式，$task$ 的生命周期会扩散出挂起点，因此它需要存储在协程状态中。<br>
        当计算这个临时 $task$ 的 $co_-await$ 表达式时，我们需要调用返回临时 $awaiter$ 对象的 $operator$ $co_-await\left(\right)$ 方法。这个对象的生命周期也扩散出挂起点，所以也要保存在协程状态中。<br>
        让我们给 __$g_-state$ 类型加上必要成员：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__g_state</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&gt;</span> <span class="n">__tmp2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="o">&gt;</span> <span class="n">__tmp3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        然后我们可以更新 __$g_-resume\left(\right)$ 函数来初始化这些临时对象，接着再计算 $co_-await$ 表达式包含的 $await_-ready$、$await_-suspend$ 和 $await_-resume$ 这 $3$ 个调用。<br>
        注意 $task$::$awaiter$::$await_-suspend\left(\right)$ 方法返回协程句柄，因此我们需要生成恢复返回句柄的代码。<br>
        我们也需要再调用 $await_-suspend\left(\right)$ 之前更新挂起点下标 ( 使用下标 $1$ )，然后给跳表添加额外的条目，确保在正确的位置恢复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// We know that &#39;s&#39; points to a __g_state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Generate a jump-table to jump to the correct place in the code based
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on the value of the suspend-point index.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>  <span class="c1">// &lt;-- add new jump-table entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// int fx = co_await f(x);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">construct_from</span><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">get</span><span class="p">()).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// mark the suspend-point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Resume the returned coroutine_handle before returning.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">h</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TOOD: Implement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// co_return fx * fx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        注意 $int$ $fx$ 局部变量生命周期没有扩散出挂起点，因此它不需要存储在协程状态中。我们可以把它作为一个普通的 __$g_-resume$ 函数局部变量。<br>
        我们也需要给 __$g_-destroy\left(\right)$ 函数添加必要的条目来处理协程在挂起点销毁的情况。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>  <span class="c1">// &lt;-- add new jump-table entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO: Add extra logic for other suspend-ponits here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">destroy_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        这样我们就完成了语句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span></code></pre></div><p>        然而，函数 $f\left(\right)$ 并没有标为<code>noexcept</code>，意味着它可能抛出异常。同样，$awaiter$::$await_-resume\left(\right)$ 方法也没有标为<code>noexcept</code>，也可能抛出异常。<br>
        当协程体抛出异常时，编译器生成代码来捕获，然后调用 $promise$.$unhandled_-exception\left(\right)$ 来给 $promise$ 机会对异常做些事情。我们来看看这方面的实现。</p>
<h2 id="第十步实现-unhandled_exception">第十步：实现 <code>unhandled_exception()</code></h2>
<p>        协程定义规范 <a href="https://eel.is/c++draft/dcl.fct.def.coroutine">dcl.fct.def.coroutine</a> 中说，协程的行为就好像它的函数体被替换为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">promise</span><span class="o">-</span><span class="n">type</span> <span class="n">promise</span> <span class="n">promise</span><span class="o">-</span><span class="n">constructor</span><span class="o">-</span><span class="n">arguments</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">function</span><span class="o">-</span><span class="n">body</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intiali</span><span class="o">-</span><span class="n">await</span><span class="o">-</span><span class="n">resume</span><span class="o">-</span><span class="n">called</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span><span class="o">-</span><span class="nl">suspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        我们已经单独处理了启动函数中的 $initial-await_-resume-called$ 分支，所以我们不需要关注这块。<br>
        来让我们调整 __$g_-resume\left(\right)$ 函数体，插入<code>try/catch</code>块。<br>
        注意我们需要小心放置 $switch$，跳转到<code>try</code>块的正确位置，因为我们不允许通过 $goto$ 进入一个<code>try</code>块。<br>
        同样，我们需要谨慎地对 $await_-suspend\left(\right)$ 返回的在<code>try/catch</code>块外的协程句柄调用 $.resume\left(\right)$。如果一个返回的协程的 $.resume\left(\right)$ 抛出了异常，它不应被当前协程捕获，而是传播给调用 $resume\left(\right)$ 恢复它的协程。因此我们在函数开头声明一个存储协程句柄的变量，然后 $goto$ 到<code>try/catch</code>之外的位置，执行 $.resume\left(\right)$ 调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">coro_to_resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>  <span class="c1">// &lt;-- add new jump-table entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// int fx = co_await f(x);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">get</span><span class="p">()).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">coro_to_resume</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">resume_coro</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Implement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// co_return fx * fx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">final_suspend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">final_suspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO: Implement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// co_await promise.final_suspend();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">resume_coro</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">coro_to_resume</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        上面的代码有个 bug。当 __$tmp3$.$get\left(\right)$.$await_-resume\left(\right)$ 调用因为异常退出，我们会在没有调用 __$tmp3$ 和 __$tmp2$ 的析构函数情况下捕获异常。<br>
        注意我们不能简单地捕获异常，调用析构函数然后重新抛出异常，因为这样会改变这些析构函数的行为，相当于在调用 $std$::$unhandled_-exceptions\left(\right)$ 前“处理”了异常。如果在异常展开时调用析构函数，那么 $std$::$unhandled_-exceptions\left(\right)$ 应该返回非零值。<br>
        我们可以定义个<code>RAII</code>辅助类确保当异常抛出，退出作用域时析构函数被调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">destructor_guard</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">destructor_guard</span><span class="p">(</span><span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// non-movable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">destructor_guard</span><span class="p">(</span><span class="n">destructor_guard</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">destructor_guard</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">destructor_guard</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">destructor_guard</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_nothrow_destructible_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ptr_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ptr_</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">cancel</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">ptr_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">ptr_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Partial specialisation for types that don&#39;t need their destructors called.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_trivially_destrcutible_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">destructor_guard</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">destructor_guard</span><span class="p">(</span><span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">cancel</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Class-template argument deduction to simplify usage
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">destructor_guard</span><span class="p">(</span><span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">destructor_guard</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</span></span></code></pre></div><p>        通过这个工具，我们现在可以确保当异常抛出时协程状态中的变量被正确析构。<br>
        让我们对其他变量也使用这个类，确保当退出作用域时它们的析构函数也会被调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">coro_to_resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>  <span class="c1">// &lt;-- add new jump-table entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp1_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// int fx = co_await f(x);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp2_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">get</span><span class="p">()).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp3_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">coro_to_resume</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// A coroutine suspends without exiting scopes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// So cancel the destructor-guards.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">tmp3_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp2_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">resume_coro</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Don&#39;t exit the scope here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// We can&#39;t &#39;goto&#39; a label that enters the scope of a variable with a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// non-trivial destructor. So we have to exit the scope of the destructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// guards here without calling the destructors and then recreate them after
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the `suspend_point_1` label.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">tmp3_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">tmp2_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp2_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp3_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Implement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// co_return fx * fx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">final_suspend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">final_suspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO: Implement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// co_await promise.final_suspend();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">resume_coro</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">coro_to_resume</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        现在我们的协程体会在任何异常出现的地方正确销毁局部变量，并且会在这些异常传播出协程体时正确调用 $promise$.$unhandled_-exception\left(\right)$。<br>
        要注意的是，如果 $promise$.$unhandled_-exception\left(\right)$ 方法自身因为异常退出 ( 例如重新抛出当前异常 ) 时，可能需要特殊处理。<br>
        在这种情况，协程需要捕获异常，标记为在最终挂起点挂起，然后重抛异常。<br>
        例如，__$g_-resume\left(\right)$ 函数的<code>catch</code>块会像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// mark as final-suspend-point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        然后我们需要给 __$g_-destroy$ 函数跳表增加额外条目：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>  <span class="c1">// no variables in scope that need to be destroyed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                             <span class="c1">// just destroy the coroutine-state object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        注意这个例子中，最终挂起点并不是必须跟 $co_-await$ $promise$.$final_-suspend\left(\right)$ 的挂起点一样。<br>
        这是因为 $promise$.$final_-suspend\left(\right)$ 挂起点通常有些额外的与 $co_-await$ 表达式相关的临时对象，这些对象需要在 $coroutine_-handle$::$destroy\left(\right)$ 调用时销毁。而在这里，如果 $promise$.$unhandled_-exception\left(\right)$ 因为异常退出，这些对象不再存活，所以不需要被 $coroutine_-handle$::$destroy\left(\right)$ 销毁。</p>
<h2 id="第十一步实现-co_return">第十一步：实现 <code>co_return</code></h2>
<p>        下一步是实现 $co_-return$ $fx$ $*$ $fx;$ 语句。<br>
        与前面相比，这一步相对简单。<br>
        $co_-return$ &lt;$expr$&gt; 语句会映射成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">promise</span><span class="p">.</span><span class="n">return_value</span><span class="p">(</span><span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">goto</span> <span class="k">final</span><span class="o">-</span><span class="n">suspend</span><span class="o">-</span><span class="n">point</span><span class="p">;</span>
</span></span></code></pre></div><p>        所以我们可以简单地把 TODO 注释替换成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">return_value</span><span class="p">(</span><span class="n">fx</span> <span class="o">*</span> <span class="n">fx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">goto</span> <span class="n">final_suspend</span><span class="p">;</span>
</span></span></code></pre></div><p>        简单。</p>
<h2 id="第十二步实现-final_suspend">第十二步：实现 <code>final_suspend()</code></h2>
<p>        代码的最后一个 TODO 是实现 $co_-await$ $promise$.$final_-suspend\left(\right)$ 语句。<br>
        $final_-suspend\left(\right)$ 方法返回一个临时的 $task$::$promise_-type$::$final_-awaiter$ 类型，后者存储在协程状态中，并在 __$g_-destroy$ 内销毁。<br>
        这个类型没有重载 $operator$ $co_-await\left(\right)$，所以我们不需要额外的临时对象存储调用结果。<br>
        就像 $task$::$awaiter$ 类型，它也通过 $await_-suspend\left(\right)$ 返回协程句柄。所以我们需要确保对返回的句柄调用 $resume\left(\right)$。<br>
        如果协程没有在最终挂起点挂起，那么协程状态会被隐式销毁。所以我们需要在执行到协程结束时，删除状态对象。<br>
        而且，因为所有的最终挂起逻辑需要是<code>noexcept</code>的，我们不需要担心这里的子表达式会抛出异常。<br>
        我们先给 __$g_-state$ 类型加上数据成员。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__g_state</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&gt;</span> <span class="n">__tmp2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="o">&gt;</span> <span class="n">__tmp3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">promise_type</span><span class="o">::</span><span class="n">final_awaiter</span><span class="o">&gt;</span> <span class="n">__tmp4</span><span class="p">;</span>  <span class="c1">// &lt;---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        然后我们可以像下面这样实现最终挂起表达式体：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="nl">final_suspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// co_await promise.final_suspend
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">destructor_guard</span> <span class="n">tmp4_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// mark as final suspend-point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">coro_to_resume</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">tmp4_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">resume_coro</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Destroy coroutine-state if execution flows off end of coroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span><span class="p">;</span>
</span></span></code></pre></div><p>        接着我们需要更新 __$g_-destroy$ 函数来处理新的挂起点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">destroy_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        现在我们有了一个完整的 $g\left(\right)$ 协程函数转换结果。<br>
        结束了！<br>
        还是……</p>
<h2 id="第十三步实现对称转移和无操作协程">第十三步：实现对称转移和无操作协程</h2>
<p>        我们上面实现的 __$g_-resume\left(\right)$ 函数方式有个问题。<br>
        之前的文章中有详细讨论过，所以如果你想了解更多，可以查看<a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B4%E7%90%86%E8%A7%A3%E5%AF%B9%E7%A7%B0%E8%BD%AC%E7%A7%BB/">C++协程（4）：理解对称转移</a>。<br>
        <a href="https://eel.is/c++draft/expr.await">expr.await</a> 规范给了一点关于我们应该怎么处理返回协程句柄的 $await_-suspend$ 的线索：</p>
<blockquote>
<p>如果 $await_-suspend$ 类型时 $std$::$coroutine_-handle$&lt;$Z$&gt;，会调用 $.resume\left(\right)$。<br>
备注1：这会恢复 $await_-suspend$ 返回的协程。可以用这种方式连续恢复任意数量的协程，最终控制流会返回给现在协程的调用者/恢复者。</p></blockquote>
<p>        这个备注，虽然不是规范，也不是约束，但是十分鼓励编译器以尾调用方式实现恢复协程，而不是递归方式。因为在协程循环恢复对方的过程中，递归方式很容易导致栈无限制增长。<br>
        问题原因是我们是在 __$g_-resume\left(\right)$ 函数体内调用下一个协程的 $.resume\left(\right)$ 然后返回，因此 __$g_-resume\left(\right)$ 的栈帧会在下一个协程挂起返回后才会释放。<br>
        编译器可以把恢复下一个协程优化为尾调用。以这种方式，编译器生成的代码会先弹出当前栈帧，保留返回地址，然后执行 $jmp$ 指令跳转到下一个协程的恢复函数。<br>
        因为<code>C++</code>并没有机制让尾部位置的函数调用变成尾调用，我们需要从恢复函数中返回来释放栈空间，然后让调用者恢复下一个协程。<br>
        下一个协程也可能需要在挂起时恢复另一个协程，而且这种恢复可能会无限下去，所以调用者需要在循环中恢复协程。<br>
        这种循环通常叫做<em><strong>蹦床循环</strong></em> ( $trampoline$ $loop$ )，因为我们从一个协程回到循环然后再跳到下一个协程。<br>
        如果我们把恢复函数的签名改成返回指向下个协程状态的指针，而不是 $void$，那么 $coroutine_-handle$::$resume\left(\right)$ 函数可以立即调用下个协程的 __$resume\left(\right)$ 指针来恢复它。<br>
        我们改一下 __$coroutine_-state$ 的 __$resume_-fn$ 的签名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__coroutine_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__resume_fn</span> <span class="o">=</span> <span class="n">__coroutine_state</span><span class="o">*</span> <span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__destroy_fn</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">__resume_fn</span><span class="o">*</span> <span class="n">__resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__destroy_fn</span><span class="o">*</span> <span class="n">__destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        然后我们可以像这样编写 $coroutine_-handle$::$resume\left(\right)$：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">resume</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">__resume</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="cm">/*some condition*/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        下个问题是：“循环条件是什么？”<br>
        这时就轮到 $std$::$noop_-coroutine\left(\right)$ 帮忙了。<br>
        $std$::$noop_-coroutine$ 是一个工厂函数，返回一个特殊协程句柄，具有无操作的 $resume\left(\right)$ 和 $destroy\left(\right)$ 方法。如果一个协程挂起，并且 $await_-suspend\left(\right)$ 返回无操作句柄，意味着没有协程需要恢复，它的 $coroutine_-handle$::$resume\left(\right)$ 会返回给调用者。<br>
        所以我们需要实现 $std$::$noop_-coroutine\left(\right)$ 以及 $coroutine_-handle$::$resume\left(\right)$ 条件，让 __$coroutine_-state$ 指针指向无操作协程状态时变为 $false$ 并退出循环。<br>
        一种策略是定义一个静态 __$coroutine_-state$ 变量，作为无操作协程状态。$std$::$noop_-coroutine\left(\right)$ 函数可以返回一个指向该对象的协程句柄，然后我们可以比较 __$coroutine_-state$ 指针和那个对象的地址，判断协程句柄是否为无操作协程。<br>
        首先我们定义这个特殊的无操作协程状态对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__coroutine_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__resume_fn</span> <span class="o">=</span> <span class="n">__coroutine_state</span><span class="o">*</span> <span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__destroy_fn</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">__resume_fn</span><span class="o">*</span> <span class="n">__resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__destroy_fn</span><span class="o">*</span> <span class="n">__destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">__coroutine_state</span><span class="o">*</span> <span class="nf">__noop_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">state</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span> <span class="nf">__noop_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">const</span> <span class="n">__coroutine_state</span> <span class="n">__noop_coroutine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="k">const</span> <span class="n">__coroutine_state</span> <span class="n">__coroutine_state</span><span class="o">::</span><span class="n">__noop_coroutine</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">&amp;</span><span class="n">__coroutine_state</span><span class="o">::</span><span class="n">__noop_resume</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="o">&amp;</span><span class="n">__coroutine_state</span><span class="o">::</span><span class="n">__noop_destroy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        然后我们可以特例化实现 $std$::$coroutine_-handle$&lt;$noop_-coroutine_-promise$&gt;。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">noop_coroutine_promise</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">noop_coroutine_handle</span> <span class="o">=</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">noop_coroutine_promise</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">noop_coroutine_handle</span> <span class="nf">noop_coroutine</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">coroutine_handle</span><span class="o">&lt;</span><span class="n">noop_coroutine_promise</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="n">coroutine_handle</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=*</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">coroutine_handle</span><span class="p">,</span> <span class="n">coroutine_handle</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">operator</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">from_address</span><span class="p">(</span><span class="n">address</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">noop_coroutine_promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">static</span> <span class="n">noop_coroutine_promise</span> <span class="n">promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">resume</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__coroutine_state</span><span class="o">::</span><span class="n">__noop_coroutine</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="n">coroutine_handle</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">noop_coroutine_handle</span> <span class="nf">noop_coroutine</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        然后我们可以更新 $coroutine_-handle$::$resume\left(\right)$，在返回无操作协程状态时退出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">resume</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">__resume</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">__coroutine_state</span><span class="o">::</span><span class="n">__noop_coroutine</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        最后，我们可以更新 __$g_-resume\left(\right)$ 返回 __$coroutine_-state*$。<br>
        这部分只涉及更新签名并替换：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">coro_to_resume</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl"><span class="k">goto</span> <span class="n">resume_coro</span><span class="p">;</span>
</span></span></code></pre></div><p>        以及</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">address</span><span class="p">());</span>
</span></span></code></pre></div><p>        并在函数的最后面 ( $delete$ $state;$ 语句之后 ) 添加：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">noop_coroutine</span><span class="p">().</span><span class="n">address</span><span class="p">());</span>
</span></span></code></pre></div><h2 id="最后一件事">最后一件事</h2>
<p>        细心的人可能发现了，协程状态类型 __$g_-state$ 要比需要的大。<br>
        $4$ 个存储临时值的数据成员分别为它们的值保留了空间。然而，一些临时值的生命周期并不重叠，所以理论上可以通过在对象生命周期结束后，给下一个对象重复使用空间的方式，节省空间。<br>
        为了利用这点，我们可以把数据成员定义在一个合适的匿名<code>union</code>中。<br>
        看一下我们现在的临时变量生命周期：</p>
<ul>
<li>__$tmp1$ - 只在 $co_-await$ $promise$.$initial_-suspend\left(\right);$ 语句存活</li>
<li>__$tmp2$ - 只在 $int$ $fx$ $=$ $co_-await$ $f\left(x\right);$ 语句存活</li>
<li>__$tmp3$ - 只在 $int$ $fx$ $=$ $co_-await$ $f\left(x\right);$ 语句存活 - 生命周期内嵌于 __$tmp2$</li>
<li>__$tmp4$ - 只在 $co_-await$ $promise$.$final_-suspend\left(\right);$ 语句存活</li>
</ul>
<p>        因为 __$tmp2$ 和 __$tmp3$ 的生命周期重启，我们必须把它们一起放在同一个<code>struct</code>，保证同时间它们都存活。<br>
        然而，__$tmp1$ 和 __$tmp4$ 成员生命周期不重叠，所以可以一起放在匿名<code>union</code>中。<br>
        因此，我们可以把数据成员定义改成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__g_state</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">__scope1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&gt;</span> <span class="n">__tmp2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">manula_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="o">&gt;</span> <span class="n">__tmp3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">manul_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__scope1</span> <span class="n">__s1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">promise_type</span><span class="o">::</span><span class="n">final_awaiter</span><span class="o">&gt;</span> <span class="n">__tmp4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        然后，因为 __$tmp2$ 和 __$tmp3$ 变量都内嵌在 __$s1$ 对象，我们需要把它们的引用改成例如 $state$-&gt;__$s1$.$tmp2$ 的方式。不过其他代码不用变。<br>
        这样协程状态可以节省 $16$ 字节，因为 __$tmp1$ 和 __$tmp4$ 数据成员不再需要额外的空间对齐，它们会被对齐到指针大小，即使是空类型。</p>
<h2 id="放到一起">放到一起</h2>
<p>        好的，让我们看看下面协程函数生成的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_return</span> <span class="n">fx</span> <span class="o">*</span> <span class="n">fx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        是下面这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/////
</span></span></span><span class="line"><span class="cl"><span class="c1">// The coroutine promise-type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">__promise_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_traits</span><span class="o">&lt;</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__coroutine_state</span><span class="o">*</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/////
</span></span></span><span class="line"><span class="cl"><span class="c1">// The coroutine-state definition
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialise the function-pointers used by coroutine-handle methods.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__g_resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__destroy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__g_destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Used placement-new to initialise the promise object in the base-class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// after we&#39;ve intialised the argument copies.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">::</span><span class="k">new</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="n">__g_promise_t</span><span class="p">(</span><span class="n">construct_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__g_state</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="o">~</span><span class="n">__g_promise_t</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Argument copies
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Local variables/temporaries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">__scope1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&gt;</span> <span class="n">__tmp2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="o">&gt;</span> <span class="n">__tmp3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__scope</span> <span class="n">__s1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">promise_type</span><span class="o">::</span><span class="n">final_awaiter</span><span class="o">&gt;</span> <span class="n">__tmp4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/////
</span></span></span><span class="line"><span class="cl"><span class="c1">// The &#34;ramp&#34; function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">(</span><span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// fall through to return statement below.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Coroutine did not suspend. Start excuting the body immediately.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__g_resume</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">return_value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/////
</span></span></span><span class="line"><span class="cl"><span class="c1">// The &#34;resume&#34; function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">__coroutine_state</span><span class="o">*</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>  <span class="c1">// &lt;-- add new jump-table entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp1_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// int fx = co_await f(x);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp2_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">get</span><span class="p">()).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp3_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// A coroutine suspends without exiting scopes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// So cancel the destructor-guards.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">tmp3_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp2_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">address</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Don&#39;t exit the scope here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// We can&#39;t &#39;goto&#39; a label that enters the scope of a variable with a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// non-trivial destructor. So we have to exit the scope of the destructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// guards here without calling the destructors and then recreate them after
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the `suspend_point_1` label.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">tmp3_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">tmp2_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp2_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp3_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// co_return fx * fx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">return_value</span><span class="p">(</span><span class="n">fx</span> <span class="o">*</span> <span class="n">fx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">final_suspend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">final_suspend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">final_suspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// co_await promise.final_suspend
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">destructor_guard</span> <span class="n">tmp4_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// mark as final suspend-point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="n">tmp4_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">address</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Destroy coroutine-state if execution flows off end of coroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">noop_coroutine</span><span class="p">().</span><span class="n">address</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/////
</span></span></span><span class="line"><span class="cl"><span class="c1">// The &#34;destroy&#34; function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">destroy_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        最终代码的完全可编译版本可以看<a href="https://godbolt.org/z/xaj3Yxabn">https://godbolt.org/z/xaj3Yxabn</a>。<br>
        有关<code>C++</code>协程机制的 $5$ 部分系列文章到此结束。<br>
        这些信息可能比你想要了解的还要多，希望它能帮助你理解和揭开协程的神秘面纱。<br>
        感谢您坚持到最后！<br>
        下次再见，Lewis.</p>


<div>
    <a href="javascript:void(0);" id="tocbtn"><i class="fas fa-bars fa-lg"></i></a>
    <div id="sidetoc">
        <header>
            <h4>C&#43;&#43;协程（5）：理解编译器转换</h4>
        </header>
        <nav id="TableOfContents">
            <ul></ul>
        </nav>
    </div>
    <script>
        isTocOpen = true;
    </script>
</div>


<div class="nav-next-prev">
    <div class="nav-prev">
        
        <a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B4%E7%90%86%E8%A7%A3%E5%AF%B9%E7%A7%B0%E8%BD%AC%E7%A7%BB/"><i class="fas fa-chevron-left"></i></a>
        
    </div>
    <a class="nav-top" href="#">回到顶部</i></a>
    <div class="nav-next">
        
        <a class="grayed-out" href="javascript:void()"><i class="fas fa-chevron-right"></i></a>
        
    </div>
</div>
<script type="text/javascript">
    tocInit();
</script>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:zihan.zhouchn@outlook.com">zihan.zhouchn@outlook.com</a>
            </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2025, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
    <script>
        InitLightSwitcher()
    </script>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
</main>
</body>

</html>