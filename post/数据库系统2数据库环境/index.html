<!DOCTYPE html>
<html><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css"
    integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <title>z217&#39;s blog</title>
</head><body><aside id="sidenav">
    <header>
    
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>
        
    

    <a id="branding" href=https://z217blog.cn>
        
            z217&#39;s blog
        
    </a>
    </header>

    <nav>
        
            		
            <a href="/"
                
            >
                <i class="fas fa-home fa-ms"></i>
                <span>首页</span>
            </a>
        
            		
            <a href="/post/"
                
            >
                <i class="fas fa-keyboard fa-ms"></i>
                <span>文章</span>
            </a>
        
            		
            <a href="/tags"
                
            >
                <i class="fas fa-tags fa-sm"></i>
                <span>标签</span>
            </a>
        
            		
            <a href="/about"
                
            >
                <i class="fas fa-user fa-ms"></i>
                <span>关于</span>
            </a>
        
            		
            <a href="https://github.com/z217"
                
                    target="_blank"
                
            >
                <i class="fab fa-github fa-ms"></i>
                <span>Github</span>
            </a>
        
            		
            <a href="/index.xml"
                
            >
                <i class="fas fa-rss fa-sm"></i>
                <span>RSS</span>
            </a>
        
            		
            <a href="http://123.57.12.189"
                
                    target="_blank"
                
            >
                <i class="fas fa-link fa-sm"></i>
                <span>二站</span>
            </a>
        
    </nav>
</aside>
<main id="main">
            <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
            <div class="content">

<h1 id="title">数据库系统（2）：数据库环境</h1>



<div style="position:fixed; right:8px; max-width:300px; overflow:auto; top:130px; width:12vw; bottom:130px">
    <header>
        <h4>数据库系统（2）：数据库环境</h4>
    </header>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-ansi-sparc三层体系结构">1. <code>ANSI-SPARC</code>三层体系结构</a>
      <ul>
        <li><a href="#11-外部层">1.1 外部层</a></li>
        <li><a href="#12-概念层">1.2 概念层</a></li>
        <li><a href="#13-内部层">1.3 内部层</a></li>
        <li><a href="#14-模式映射和实例">1.4 模式、映射和实例</a></li>
        <li><a href="#15-数据库独立性">1.5 数据库独立性</a></li>
      </ul>
    </li>
    <li><a href="#2-数据库语言">2. 数据库语言</a>
      <ul>
        <li><a href="#21-数据定义语言ddl">2.1 数据定义语言/<code>DDL</code></a></li>
        <li><a href="#22-数据操作语言dml">2.2 数据操作语言/<code>DML</code></a></li>
        <li><a href="#23-第四代语言">2.3 第四代语言</a></li>
      </ul>
    </li>
    <li><a href="#3-数据模型">3. 数据模型</a>
      <ul>
        <li><a href="#31-基于对象的数据模型">3.1 基于对象的数据模型</a></li>
        <li><a href="#32-基于记录的数据模型">3.2 基于记录的数据模型</a></li>
        <li><a href="#33-物理数据模型">3.3 物理数据模型</a></li>
      </ul>
    </li>
    <li><a href="#4-dbms的功能">4. <code>DBMS</code>的功能</a></li>
    <li><a href="#5-多用户dbms结构">5. 多用户<code>DBMS</code>结构</a>
      <ul>
        <li><a href="#51-远程处理">5.1 远程处理</a></li>
        <li><a href="#52-文件服务器结构">5.2 文件服务器结构</a></li>
        <li><a href="#53-传统的两层客户-服务器结构">5.3 传统的两层客户-服务器结构</a></li>
        <li><a href="#54-三层客户-服务器结构">5.4 三层客户-服务器结构</a></li>
        <li><a href="#55-n层客户-服务器结构">5.5 N层客户-服务器结构</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>


<h2 id="1-ansi-sparc三层体系结构">1. <code>ANSI-SPARC</code>三层体系结构</h2>
<p>        <strong>三层体系结构</strong> ( $Three\ \ Level\ \ Architecture$ )，包括<strong>外部层</strong> ( $External$ )、<strong>概念层</strong> ( $Conceptual$ ) 和<strong>内部层</strong> ( $Internal$ )。用户从外部层观察数据，<code>DBMS</code>和操作系统从内部层观察数据。在内部层，数据使用定义的数据结构和文件组织方法进行存储。概念层则提供内部层和外部层的<strong>映射</strong> ( $Mapping$ ) 以及必要的<strong>独立性</strong> ( $Independence$ )。三层体系结构的目的是将用户的数据库视图与数据库的物理描述分离。</p>
<h3 id="11-外部层">1.1 外部层</h3>
<p>        外部层是数据库的用户视图，这一层描述数据库中与用户相关的部分。对于每一个用户，数据库中都存储着其对用的视图。并且对于同一个数据，在不同的视图中可能有着不同的表达方式。</p>
<h3 id="12-概念层">1.2 概念层</h3>
<p>        概念层是数据库的整体视图，这一层描述哪些数据存储在数据库中，以及这些数据之间的联系。概念层描述：</p>
<ol>
<li>所有的实体、实体的属性和实体间的联系</li>
<li>数据的约束</li>
<li>数据的语义信息</li>
<li>安全性和完整性信息</li>
</ol>
<p>        概念层支持每一个外部视图，凡是用户可访问的数据必定包含在概念层或者由概念层导出。</p>
<h3 id="13-内部层">1.3 内部层</h3>
<p>        内部层是数据库在计算机上的物理表示，这一层描述数据是如何存储在数据库中的。内部层与如下工作相关：</p>
<ol>
<li>数据和索引的存储空间分配</li>
<li>存储记录的描述</li>
<li>存储记录</li>
<li>数据压缩和加密</li>
</ol>
<p>        在内部层之下是<strong>物理层</strong> ( $Physical\ \ Level$ ) ，物理层可能在<code>DBMS</code>的指导下受操作系统的控制。</p>
<h3 id="14-模式映射和实例">1.4 模式、映射和实例</h3>
<p>        对数据库的整体描述称为<strong>数据库模式</strong> ( $Database\ \ Schema$ ) 。在数据库中存在三种不同类型的，在外部层有若干<strong>外部模式</strong> ( $External\ \ Schema$ ) /<strong>子模式</strong> ( $Subschema$ )，与不同的数据视图对应。在概念层有<em><strong>概念模式</strong></em> ( $Conceptual\ \ Schema$ )，描述所有实体、属性和联系及其之间的完整性约束。在内部层，有<strong>内部模式</strong> ( $Internal\ \ Schema$ )，是内部模型的完整描述，包括存储记录的定义、表示方法、数据域，必要时还有所使用的索引和散列方案。一个数据库可以有多个外部模式，但只能有一个概念模式和内部模式。<br>
        例如，对于一个数据库，其内部存储两张表 $A$, $B$ ，这是其概念模式；而 $A$, $B$ 内部行列的定义以及约束等是其内部模式；查询 $A$, $B$ 所使用的视图 $V1$, $V2&hellip;$ 是其外部模式。<br>
        <code>DBMS</code>负责着三类模式之间的映射。概念模式通过概念层到内部层的映射与内部模式关联，每一个外部模式通过外部层到概念层的映射与概念模式关联。<br>
        数据库模式是在数据库设计过程中定义的，不会轻易改变。数据库中的数据是一个<strong>数据库实例</strong> ( $Database\ \ Instance$ )，许多数据库实例可以与相同的数据库模式对应。模式有时称为数据库的<strong>内含</strong> ( $Intension$ )，实例称为数据库的<strong>外延</strong> ( $Extension$ ) /<strong>状态</strong> ( $State$ )。</p>
<h3 id="15-数据库独立性">1.5 数据库独立性</h3>
<p>        三层体系结构的一个主要目的是保证数据独立性，即低层的修改不会影响高层。数据独立性分为<strong>逻辑数据独立性</strong> ( $Logical\ \ Data\ \ Independence$ ) 和<strong>物理数据独立性</strong> ( $Physical\ \ Data\ \ Independence$ )。逻辑数据独立性指的是外部模式不受概念模式的变化的影响。物理数据独立性指的是概念模式不受内部模式的变化的影响。<br>
        虽然两段映射可能降低效率，但提高了数据独立性。为了高效地映射，<code>ANSI-SPARC</code>模式也允许外部模式直接映射到内部模式，忽略概念模式。当然这降低了数据独立性。</p>
<h2 id="2-数据库语言">2. 数据库语言</h2>
<p>        数据库语言包括<strong>数据定义语言</strong> ( $DDL$ ) 和<strong>数据操作语言</strong> ( $DML$ )。<code>DDL</code>用于说明数据库模式，<code>DML</code>用于读取和更新数据库。这些语言称为<em>数据子语言</em> ( $Data\ \ Sublanguages$ )，因为它们不包括所有计算所需的成分。</p>
<h3 id="21-数据定义语言ddl">2.1 数据定义语言/<code>DDL</code></h3>
<p>        <code>DDL</code>是一种供<code>DBA</code>或用户描述和命名应用所需实体、属性和联系及其相关的完整性约束和安全约束的语言。数据库模式是<code>DDL</code>表达的一组定义。虽然<code>DDL</code>可以用于定义或修改模式，但不能用于操作数据。<br>
        <code>DDL</code>的编译结果是一组表格，存储在称为<strong>系统目录</strong>/<strong>数据字典</strong>/<strong>数据目录</strong>的特殊文件中。<strong>元数据</strong>存储在系统目录中，用于描述数据库中的对象。<br>
        理论上，<code>DDL</code>可以分为外部模式<code>DDL</code>、概念模式<code>DDL</code>和内部模式<code>DDL</code>，区分用于不同层中的<code>DDL</code>。但实际上只需提供一个足以说明外部模式和概念模式的<code>DDL</code>即可。</p>
<h3 id="22-数据操作语言dml">2.2 数据操作语言/<code>DML</code></h3>
<p>        <code>DML</code>提供了一组基本操作，支持对数据库中存储数据进行各种处理操作，通常是增删改查，其中涉及数据检索的部分称为<strong>查询语言</strong>。查询语言被定义为一个高级的、具有特殊用途的语言，用于满足检索需要。<br>
        根据检索机制，可以将<code>DML</code>分为<strong>过程化</strong> ( $Procedural$ ) 的和<strong>非过程化</strong> ( $Nonprocedural$ ) 的。过程化<code>DML</code>要求用于既告诉系统需要什么数据又要说明如何检索这些数据，通常用于<strong>网状</strong> ( $Network$ ) /<strong>层次</strong> ( $Hierarchical$ ) 数据库。而非过程化语言只需要用户告诉系统需要哪些数据，不需要说明如何检索它们，也称为<em>说明性语言</em> ( $Declarative\ \ Languages$ )，通常用于<strong>关系</strong> ( $Relational$ ) 数据库。典型的例子是，过程化语言单个处理记录，非过程化语言成组处理记录。</p>
<h3 id="23-第四代语言">2.3 第四代语言</h3>
<p>        <strong>第四代语言</strong> ( $4GL$ ) 的组成目前并没有统一的认识，它实际上是一种快捷的编程语言，可以极大程度上减少操作。与过程化<code>3GL</code>相比，<code>4GL</code>一般是非过程化的。</p>
<h2 id="3-数据模型">3. 数据模型</h2>
<p>        模式一般用某种<code>DDL</code>描述，实际上它一定是使用某个具体<code>DBMS</code>的<code>DDL</code>编写的。但是，这种方式不能被用户广泛理解，因此我们需要更高层次的模式描述，即<strong>数据模型</strong> ( $Data\ \ Model$ )。<br>
        数据模型是一组集成概念，用于描述和操作数据、数据间的联系以及对数据的约束。数据模型包含下列三个组件：</p>
<ol>
<li>结构部分，由创建数据库的规则组成；</li>
<li>操纵部分，定义允许对数据进行的操作的种类；</li>
<li>一组完整性约束，确保数据的准确性。</li>
</ol>
<p>        数据模型的目的是表示数据，并让其更容易理解。结合<code>ANSI-SPARC</code>体系结构，可以发现三种数据模型：</p>
<ol>
<li>外部数据模型，表示每一个用户的视图，有时称为<strong>论域</strong> ( $Universe\ \ of\ \ Discoures,\ \ UoD$ )；</li>
<li>概念数据模型，表示独立于<code>DBMS</code>的逻辑/整体视图；</li>
<li>内部数据模型，表示<code>DBMS</code>能理解的概念模式。</li>
</ol>
<p>        可以将数据模型划分为三类：<strong>基于对象的</strong> ( $Object-based$ ) 、<strong>基于记录的</strong> ( $Record-based$ ) 和<strong>物理的</strong> ( $Physical$ ) ，前两者用于在概念层和外部层描述数据，最后一个在内部层描述数据。</p>
<h3 id="31-基于对象的数据模型">3.1 基于对象的数据模型</h3>
<p>        基于对象的数据模型用到实体、属性和联系等概念。<strong>实体</strong>是可区分的对象，在数据库中被描述；<strong>属性</strong>是对象的性质，描述对象的某个方面；<strong>联系</strong>是实体之间的关联。常见的基于对象的数据模型有：</p>
<ul>
<li>实体-联系 ( $ER$ ) 模型</li>
<li>语义 ( $Semantic$ ) 模型</li>
<li>函数模型</li>
<li>面向对象模型</li>
</ul>
<p>        <code>ER</code>模型已经是数据库设计的重要技术之一。面向对象的数据模型扩展了实体的定义，不仅包含了描述对象<strong>状态</strong>的属性，还包含了对象相关的动作/<strong>行为</strong> ( $behavior$ )。对象被认为同时包含状态和行为。</p>
<h3 id="32-基于记录的数据模型">3.2 基于记录的数据模型</h3>
<p>        在基于记录的数据模型中，数据库由若干不同类型的固定格式记录组成。每个记录类型有固定数量的字段，每个字段字段有固定的长度。基于记录的逻辑数据模型基本有三类：<strong>关系</strong>/<strong>网状</strong>/<strong>层次</strong>数据模型。现代商业系统大多数是基于关系模型的，早期的数据库系统是基于网状或者层次数据模型的。前者提供了较好的数据独立性，后两者要求用户了解物理数据库。因此关系系统采用<strong>说明性</strong> ( $declarative$ ) 方法，即只需说明要检索的数据。网状和层次系统采用<strong>导航</strong> ( $Navigational$ ) 方法，即要说明如何检索数据。</p>
<h4 id="321-关系数据模型">3.2.1 关系数据模型</h4>
<p>        关系数据模型基于数学上关系的概念。在关系模型中数据和联系均以表格的形式表示，每个表格有若干具有唯一名称的列。关系数据模型要求用户将数据库只看做表格，然而这种方式只适用于外部层和概念层，不适用于内部层。</p>
<h4 id="322-网状数据模型">3.2.2 网状数据模型</h4>
<p>        在网状数据模型中，数据被表示成一组<strong>记录</strong>，联系被表示成<strong>络</strong> ( $Set$ )。与关系数据模型相比更能体现联系，一般使用指针实现。记录被组织成图结构，记录是图的<strong>节点</strong> ( $Node$ ) /段 ( $Segment$ )，络是图的<strong>边</strong> ( $Edge$ )。</p>
<p><img src="/image/2020-5-14-1.png" alt="网状模式实例"></p>
<h4 id="323-层次数据模型">3.2.3 层次数据模型</h4>
<p>        层次数据模型是网状数据模型的一种受限形式。数据被表示成一组记录，联系被表示成络。层次数据模型被表示为树形结构。记录作为节点，络作为边。</p>
<p><img src="/image/2020-5-14-2.png" alt="层次模式实例"></p>
<h3 id="33-物理数据模型">3.3 物理数据模型</h3>
<p>        物理数据模型描述数据如何存储在计算机中，涉及记录结构、记录顺序和访问路径等。最常见的是<em>统一模型</em> ( $Unifying\ \ Model$ ) 和<em>帧存储</em> ( $Frame\ \ Memory$ )。</p>
<h2 id="4-dbms的功能">4. <code>DBMS</code>的功能</h2>
<ol>
<li>数据存储、检索和更新</li>
<li>用户访问目录<br>
<code>ANSI-SPARC</code>体系结构提供了一个集成的系统目录，存储元数据，对于用户和<code>DBMS</code>都是可访问的。通常情况下，系统目录存储的元数据包括：
<ul>
<li>数据项的名字、类型和大小</li>
<li>联系的名字</li>
<li>数据的完整性约束</li>
<li>授权访问的用户</li>
<li>用户能访问的数据以及课执行的操作</li>
<li>外部、概念和内部模式及模式间映射</li>
<li>统计量，如访问频率和次数等<br>
<code>DBMS</code>系统目录是系统的基本组件，使用系统目录的优点有：</li>
<li>集中存放数据的信息，有助于控制数据资源</li>
<li>帮助用户了解数据的用途</li>
<li>简化信息通信，还可以确定用户权限</li>
<li>数据集成，减少冗余和不一致性</li>
<li>记录修改</li>
<li>可以在修改进行前确定其可能的影响</li>
<li>提高安全性</li>
<li>保证完整性</li>
<li>提供审计信息</li>
</ul>
</li>
<li>事务支持<br>
事务是由用户或者应用程序进行的一系列动作，这些动作将访问或者修改数据。<code>DBMS</code>提供了一个机制，用于确保事务内的所有操作全部进行或者不进行。</li>
<li>并发控制服务<br>
并发是使用<code>DBMS</code>的一个目的。<code>DBMS</code>必须保证多用户并行更新数据库时的同步。</li>
<li>恢复服务</li>
<li>授权服务</li>
<li>数据通信<br>
大多数用户是通过工作站访问数据库的。<code>DBMS</code>需要提供与通信软件集成的功能，能够以通信消息的方式接受和回复请求。对于用户远程访问数据库的行为，一般称为<em>分布式处理结构</em> ( $distributed\ \ processing$ )。</li>
<li>完整性服务<br>
完整性即存储数据的正确性和一致性，通常以约束的形式实现。</li>
<li>提高数据独立性</li>
<li>实用服务程序<br>
使用程序能帮助<code>DBA</code>更加高效地管理数据库。<code>DBMS</code>应该提供一组实用服务程序，例如输入机制、监控机制、统计分析程序等。</li>
</ol>
<h2 id="5-多用户dbms结构">5. 多用户<code>DBMS</code>结构</h2>
<p>        多用户<code>DBMS</code>常见结构包括远程处理 ( $teleprocessing$ ) 、文件-服务器 ( $file-server$ ) 和客户-服务器 ( $client-server$ ) 结构。</p>
<h3 id="51-远程处理">5.1 远程处理</h3>
<p>        远程处理是传统的多用户系统结构。在该类系统中有一台由单个<code>CPU</code>和若干终端组成的计算机。所有的处理都交由该计算机进行，用户终端无处理能力，通过线缆连接，轮流使用<code>DBMS</code>服务。显然在这种结构下中央计算机将会有很大压力。</p>
<p><img src="/image/2020-5-14-3.png" alt="远程处理的拓扑结构"></p>
<h3 id="52-文件服务器结构">5.2 文件服务器结构</h3>
<p>        <strong>文件服务器</strong>是一台在网络上的计算机，主要用于提供共享存储服务。在文件服务器环境中，数据处理通常在局域网 ( $LAN$ ) 上分布进行，文件服务器负责保管应用程序和<code>DBMS</code>所需的文件。应用程序和<code>DBMS</code>运行在各个工作站点上，必要时向文件服务器请求文件。文件服务器指示扮演了一个共享硬盘驱动器的角色。</p>
<p><img src="/image/2020-5-14-4.png" alt="文件服务器结构"></p>
<p>        文件服务器结构的缺点：</p>
<ol>
<li>造成网络拥塞 ( $traffic$ )</li>
<li>每台工作站上都要求有一个<code>DBMS</code>的副本</li>
<li>并发、恢复和完整性控制变得复杂，因为多个<code>DBMS</code>可以访问同一个文件</li>
</ol>
<h3 id="53-传统的两层客户-服务器结构">5.3 传统的两层客户-服务器结构</h3>
<p>        客户-服务器指的是软组件相互作用形成系统的一种方式。客户是一个请求资源的进程，服务器提供资源。通常，服务器位于<code>LAN</code>的一个站点，而客户位于另外一些站点。</p>
<p><img src="/image/2020-5-14-5.png" alt="客户-服务器结构"></p>
<p>        数据密集型的业务应用程序一般由四个主要部分组成：数据库、事务逻辑、业务及数据应用逻辑和用户界面。在传统的两层客户-服务器结构中，客户端（第一层）主要负责针对用户的数据<em>表示</em>，服务器端（第二层）主要负责为客户端提供<em>数据服务</em>。表示服务负责处理用户交互活动和主要的业务及数据应用逻辑。数据服务负责提供优先的业务应用逻辑。<br>
        客户端和服务器之间交互的典型过程是，客户端接收用户的请求，产生数据库请求，然后将其传递给服务器。服务器接收和处理数据库请求，并将结果回传给客户端。客户端将响应格式化并传递给终端用户。</p>
<table>
<thead>
<tr>
<th align="center">客户端</th>
<th align="center">服务器</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">管理用户界面</td>
<td align="center">接受和处理来自客户端的数据库请求</td>
</tr>
<tr>
<td align="center">接受和检查用户输入的语法</td>
<td align="center">检查授权</td>
</tr>
<tr>
<td align="center">处理应用逻辑</td>
<td align="center">确保不违反完整性约束</td>
</tr>
<tr>
<td align="center">产生数据库请求并传递给服务器</td>
<td align="center">执行查询/更新操作并将结果返回给客户端</td>
</tr>
<tr>
<td align="center">将结果返回给用户</td>
<td align="center">维护系统目录</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">提供并发的数据库访问</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">提供恢复控制</td>
</tr>
</tbody>
</table>
<p>        这种结构具有许多优点：</p>
<ol>
<li>广泛支持对现存数据库的访问</li>
<li>增强性能，<code>CPU</code>可以并行处理应用程序</li>
<li>降低硬件费用，服务器只需要提供一定的存储空间和处理能力来管理数据库</li>
<li>降低通信费用，只有数据库访问请求需要传递</li>
<li>增强一致性，服务器可以处理完整性检查，无需在每个客户端进行</li>
<li>能自然地映射到开放系统结构上</li>
</ol>
<h3 id="54-三层客户-服务器结构">5.4 三层客户-服务器结构</h3>
<p>        随着应用程序越来越复杂，传统的两层客户-服务器结构已经不能满足需求。因此三层客户-服务器结构出现了。三层分别是：</p>
<ol>
<li>用户界面层，运行在终端用户的计算机上（客户端）</li>
<li>业务逻辑和数据处理层，运行在服务器上，通常称之为<em>应用服务器</em></li>
<li><code>DBMS</code>层，存储中间层所需的数据，通常运行在<em>数据库服务器</em>上</li>
</ol>
<p>        在三层结构中，客户端仅仅负责应用程序的用户界面和一些简单的业务逻辑。应用程序的核心业务逻辑分离出来，处于一个单独的层上，通过<code>LAN</code>或者<code>WAN</code> (广域网) 物理连接到客户端和数据库服务器。一个应用服务器可以为多个客户端提供服务。<br>
        与传统的两层和单层相比，三层的优点有：</p>
<ol>
<li>降低对硬件设备的需求</li>
<li>业务逻辑转移到专门的服务器上使得维护可以集中进行</li>
<li>修改一层并不会影响其他层</li>
<li>核心业务逻辑和数据库功能的分离使得负载均衡更容易进行</li>
</ol>
<h3 id="55-n层客户-服务器结构">5.5 N层客户-服务器结构</h3>
<p>        通过扩展，三层结构可以升级为 $N$ 层结构，进一步提高灵活性和可伸缩性。扩展主要是在中间层上，可以将原来的应用服务器扩展为<code>Web</code>服务器和应用服务器。在高流量的环境下，单个<code>Web</code>服务器可以进一步扩展为一组<code>Web</code>服务器，提供更加高效的负载均衡。</p>


<div class="nav-next-prev">
    <div class="nav-prev">
        
        <a href="https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/"><i class="fas fa-chevron-left"></i></a>
        
    </div>
    <a class="nav-top" href="#">回到顶部</i></a>
    <div class="nav-next">
        
        <a href="https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"><i class="fas fa-chevron-right"></i></a>
        
    </div>
</div>


            </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
    </body>
    <script src=https://z217blog.cn/js/navbutton.js></script>
</html>
