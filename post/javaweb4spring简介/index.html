<!DOCTYPE html>
<html><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">

<h1 id="title">JavaWeb（4）：Spring简介</h1>


<p><strong>参考书籍：《Pro Java for Web Apps》</strong></p>
<p><code>Maven</code>依赖</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>javax.inject<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.inject<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>compile<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>

<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>javax.annotation<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.annotation-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.3.2<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>runtime<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>

<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-webmvc<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.2.4.RELEASE<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>compile<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div><hr>
<p>        <code>Spring Framework</code>是一个<code>Java</code>应用程序容器，它提供了许多有用的特性，如反转控制（<code>IoC</code>）、依赖注入（<code>DI</code>）、抽象数据访问、事务管理等。<br>
        <code>IoC</code>是一个软件设计模式，即组装器（<code>Spring Framework</code>)在运行时才会绑定对象，也就是运行时才会实例化依赖的组件。这使得开发者可以针对接口进行编程，无需重新编译代码。<code>DI</code>是<code>IoC</code>的一种实现方式，通过<code>DI</code>，一个类可以通过声明其依赖的接口类型，然后利用组装器在运行时注入其依赖的实例。<br>
        <code>Spring Framework</code>提供了一个<code>MVC</code>（模型-视图-控制）模式框架，利用它可以简化创建<code>Web</code>应用程序的过程，不用手动处理复杂的<code>Servlet</code>、<code>HttpServletRequest</code>等。控制器类的每个方法都被映射到了一个不同的请求<code>URL</code>、方法或请求的其他属性上，模型可以通过 $Map$&lt;$String, Object$&gt;的形式从控制器传递到视图，控制器返回的视图或视图名称将把模型转发到合适的<code>JSP</code>视图。通过这些特性，<code>Spring Framework</code>极大地简化了<code>Servlet</code>容器的工作内容。<br>
        使用<code>MVC</code>框架时，控制器类中的每个方法都可以拥有一个指向特定<code>URL</code>、请求方法、参数存在性、头的值、内容类型或期望响应类型的唯一映射。<br>
        <code>Spring Framework</code>容器以一个或多个应用上下文的形式存在，由 $org.springframework.context.ApplicationContext$ 接口表示。一个应用上下文管理着一组<code>bean</code>、执行业务逻辑的<code>Java</code>对象、执行任务等。由<code>Spring</code>管理的<code>bean</code>可以自动进行<code>DI</code>、消息通知、<code>bean</code>验证等服务。一个<code>Spring</code>程序至少需要一个应用上下文，也可以使用多个应用上下文组成层次结构。在层次结构中应用上下文间有着类似于树的父子兄弟关系，一个子应用上下文的<code>bean</code>可以访问父应用上下文的<code>bean</code>，但无法访问兄弟应用上下文的<code>bean</code>。许多类都继承了 $ApplicationContext$ ，也有许多实现了它：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$ConfigurableApplication$</td>
<td style="text-align:center">可配置的应用上下文</td>
</tr>
<tr>
<td style="text-align:center">$WebApplicationContext$</td>
<td style="text-align:center">用于<code>Java EE Web</code>应用程序，提供了对 $ServletContext$ 和 $ServletConfig$ 的访问</td>
</tr>
<tr>
<td style="text-align:center">$ConfigurableWebApplicationContext$</td>
<td style="text-align:center">可配置的 $WebApplicationContext$</td>
</tr>
<tr>
<td style="text-align:center">$XmlApplicationContext$</td>
<td style="text-align:center">用于在<code>Java EE Web</code>应用程序中从<code>XML</code>文件加载<code>Spring</code>配置</td>
</tr>
<tr>
<td style="text-align:center">$AnnotationConfigWebApplicationContext$</td>
<td style="text-align:center">用于在<code>Java EE Web</code>应用程序中以编程方式配置<code>Spring</code></td>
</tr>
</tbody>
</table>
<p>        <code>Spring</code>使用 $DispatcherServlet$ 处理<code>Web</code>请求，该<code>Servlet</code>将请求委托给合适的控制器，并按需求对请求和响应实体进行转换。在<code>Web</code>应用程序中，我们可以使用任意数量的 $DispatcherServlet$ 。每个 $DispatcherServlet$ 类都有自己的应用上下文，包含了对<code>Web</code>应用程序的 $ServletContext$ 和自己的 $ServletConfig$ 的引用。</p>
<hr>
<h2 id="启动spring-framework">启动<code>Spring Framework</code></h2>
<p>        配置和启动<code>Spring framework</code>是不同的，且相互独立，都可以用多种方式实现。在<code>Java SE</code>中只能通过在应用程序的 $main$ 方法中以编程方式启动。而在<code>Java EE</code>中，可以使用<code>XML</code>创建部署描述符（ $web.xml$ ）或者在 $javax.servlet.ServletContainerInitializer$ 中通过编程方式启动。</p>
<h3 id="部署描述符方式">部署描述符方式</h3>
<p>        传统的<code>Spring Framework</code>应用程序总是通过部署描述符启动。以部署描述符方式启动要求在配置文件中创建 $DispatcherServlet$ 实例，然后以 $contextConfigLocation$ 启动参数的形式为它提供配置文件，并指示<code>Spring</code>在启动时加载。</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;context_param&gt;</span>
    <span class="nt">&lt;param-name&gt;</span>contextConfigLocation<span class="nt">&lt;/param-name&gt;</span>
    <span class="nt">&lt;param-value&gt;</span>/WEB-INF/rootContext.xml<span class="nt">&lt;/param-value&gt;</span>
<span class="nt">&lt;/context-param&gt;</span>
<span class="nt">&lt;listener&gt;</span>
    <span class="nt">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="nt">&lt;/listener-class&gt;</span>
<span class="nt">&lt;/listener&gt;</span>

<span class="nt">&lt;servlet&gt;</span>
    <span class="nt">&lt;servlet-name&gt;</span>springDispatcher<span class="nt">&lt;/servlet-name&gt;</span>
    <span class="nt">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="nt">&lt;/servlet-class&gt;</span>
    <span class="nt">&lt;init-param&gt;</span>
        <span class="nt">&lt;param-name&gt;</span>contextConfigLocation<span class="nt">&lt;/param-name&gt;</span>
        <span class="nt">&lt;param-value&gt;</span>/WEB-INF/servletContext.xml<span class="nt">&lt;/param-value&gt;</span>
    <span class="nt">&lt;/init-param&gt;</span>
    <span class="nt">&lt;load-on-startup&gt;</span>1<span class="nt">&lt;/load-on-startup&gt;</span>
<span class="nt">&lt;/servlet&gt;</span>
<span class="nt">&lt;servlet-mapping&gt;</span>
    <span class="nt">&lt;servlet-name&gt;</span>springDispatcher<span class="nt">&lt;/servlet-name&gt;</span>
    <span class="nt">&lt;url-pattern&gt;</span>/<span class="nt">&lt;/url-pattern&gt;</span>
<span class="nt">&lt;/servlet-mapping&gt;</span>
</code></pre></div><p>        $ContextLoaderListener$ 将在<code>Web</code>应用程序启动时初始化，然后从 $contextConfigLocation$ 中指定的 $rootContext.xml$ 中加载根应用上下文并启动。同样的，$springDispatcher$ 也从指定的 $servletContext.xml$ 中加载应用上下文。</p>
<h3 id="编程方式">编程方式</h3>
<p>        <code>Java EE 6</code>提供了一个新接口 $ServletContainerInitializer$ ，实现其的类将在应用程序开始时启动，并在所有监听器启动之前调用它们的 $onStartup$ 方法。要使用该接口，需要在 $/META-INF/services/javax.servlet.ServletContainerInitializer$ 文件中列出实现它的类。<code>Spring Framework</code>提供了一个桥接口，简化了这一步：$org.springframework.web.SpringServletContainerInitializer$ 类实现了 $ServletContainerInitializer$ 接口，然后该类会扫描程序并寻找 $org.framework.web.WebApplicationInitializer$ 接口的实现，调用其 $onStartup$ 方法。因此我们可以在 $WebApplicationInitializer$ 实现类中以编程方式配置监听器、<code>Servlet</code>和过滤器。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bootstrap</span> <span class="kd">implements</span> <span class="n">WebApplicationInitializer</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStartup</span><span class="o">(</span><span class="n">ServletContext</span> <span class="n">container</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">AnnotationConfigWebApplicationContext</span> <span class="n">rootContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnnotationConfigWebApplicationContext</span><span class="o">();</span>
        <span class="n">rootContext</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">RootContextConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">container</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">ContextLoaderListener</span><span class="o">(</span><span class="n">rootContext</span><span class="o">));</span>

        <span class="n">AnnotationConfigWebApplicationContext</span> <span class="n">servletContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnnotationConfigWebApplicationContext</span><span class="o">();</span>
        <span class="n">servletContext</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">ServletContextConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">ServletRegistration</span><span class="o">.</span><span class="na">Dynamic</span> <span class="n">dispatcher</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="na">addServlet</span><span class="o">(</span><span class="s">&#34;springDispatcher&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="n">DispatcherServlet</span><span class="o">(</span><span class="n">servletContext</span><span class="o">));</span>
        <span class="n">dispatcher</span><span class="o">.</span><span class="na">setLoadOnStartup</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
        <span class="n">dispatcher</span><span class="o">.</span><span class="na">addMapping</span><span class="o">(</span><span class="s">&#34;/&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        上面的代码实现了与之前的<code>XML</code>文件一样的配置，其中 $RootContextConfiguration$ 和 $ServletContextConfiguration$ 是自定义的配置应用上下文的类。在此要注意的是，不要把 $DispatcherServlet$ 映射到 $/\star$ ，因为映射到 $/\star$ 也会把内部<code>JSP</code>请求发送到该<code>Servlet</code>。<br>
        我们也不必只使用一种方式配置，可以混合使用，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bootstrap</span> <span class="kd">implements</span> <span class="n">WebApplicationInitializer</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStartup</span><span class="o">(</span><span class="n">ServletContext</span> <span class="n">container</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">XmlWebApplicationContext</span> <span class="n">rootContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">XmlWebApplicationContext</span><span class="o">();</span>
        <span class="n">rootContext</span><span class="o">.</span><span class="na">setConfigLocation</span><span class="o">(</span><span class="s">&#34;/WEB-INF/rootContext.xml&#34;</span><span class="o">);</span>
        <span class="n">container</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">ContextLoaderListener</span><span class="o">(</span><span class="n">rootContext</span><span class="o">));</span>

        <span class="n">XmlWebApplicationContext</span> <span class="n">servletContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">XmlWebApplicationContext</span><span class="o">();</span>
        <span class="n">servletContext</span><span class="o">.</span><span class="na">setConfigLocation</span><span class="o">(</span><span class="s">&#34;/WEB-INF/servletContext.xml&#34;</span><span class="o">);</span>
        <span class="n">ServletRegistration</span><span class="o">.</span><span class="na">Dynamic</span> <span class="n">dispatcher</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="na">addServlet</span><span class="o">(</span><span class="s">&#34;springDispatcher&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="n">DispatcherServlet</span><span class="o">(</span><span class="n">servletContext</span><span class="o">));</span>
        <span class="n">dispatcher</span><span class="o">.</span><span class="na">setLoadOnStartup</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
        <span class="n">dispatcher</span><span class="o">.</span><span class="na">addMapping</span><span class="o">(</span><span class="s">&#34;/&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><hr>
<h2 id="配置spring-framework">配置<code>Spring Framework</code></h2>
<p>        与启动相同，配置<code>Spring Framework</code>同样可以通过<code>XML</code>和编程方式。配置<code>Spring Framework</code>的主要步骤就是配置<code>bean</code>。<code>Spring Framework</code>本身提供了默认<code>bean</code>，在此基础上，我们需要自己再编写一些<code>bean</code>。</p>
<h3 id="xml配置方式"><code>XML</code>配置方式</h3>
<p>        通过在上面的引用的 $servletContext.xml$ 文件中添加如下内容进行配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
    <span class="na">xmlns:mvc=</span><span class="s">&#34;http://www.springframework.org/schema/mvc&#34;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span><span class="s">        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
</span><span class="s">        http://www.springframework.org/schema/mvc
</span><span class="s">        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;mvc:annotation-driven</span> <span class="nt">/&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">&#34;fooImpl&#34;</span> <span class="na">class=</span><span class="s">&#34;FooImpl&#34;</span><span class="nt">/&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">&#34;barController&#34;</span> <span class="na">class=</span><span class="s">&#34;BarController&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&#34;foo&#34;</span> <span class="na">ref=</span><span class="s">&#34;fooImpl&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;/beans&gt;</span>
</code></pre></div><p>        我们使用 &lt;$beans$&gt; 命名空间配置<code>bean</code>。上述<code>XML</code>文件将实例化 $FooImpl$ 和 $BarController$ ，并将 $FooImpl$ 注入 $BarController$ 的 $foo$ 属性中。&lt;$mvc:annotation-driven$&gt; 指示<code>Spring</code>使用 $@RequestsMapping$, $@RequestBody$, $@RequestParam$, $@PathParam$, $@ResponseBody$ 这样的注解将请求映射到控制器方法上。</p>
<h3 id="混合配置方式">混合配置方式</h3>
<p>        在<code>XML</code>的基础上，我们可以通过使用组件扫描和注解进行配置。组件扫描将扫描所有标注了 $org.springframework.stereotype.Component$ 的类，并将他们变成<code>bean</code>交由<code>Spring</code>进行管理。任何标注了 $@Component$ 的注解都将变成组件注解，因此 $@Controller$, $@Repository$, $@Service$ 也都是组件注解。当然，也可以创建自己的组件注解。$@org.springframework.beans.factory.annotation.Autowired$ 注解，以及它的同义词 $@javax.inject.Inject$ 和 $@javax.annotation.Resource$ 用于声明<code>Spring</code>应该注入的依赖，可以用于标注字段、方法、方法参数或者构造器。通常<code>bean</code>应该具有无参构造器，但对于一个标注了 $@Autowired$ 的构造器的类，<code>Spring</code>将注入所有构造器参数并使用该构造器构造实例。当存在多个匹配的<code>bean</code>时，可以通过使用 $@org.springframework.beans.factory.annotation.Qualifier$ 或者 $@javax.inject.Named$ 指定使用的<code>bean</code>的名字，或者使用 $@org.springframework.context.annotation.Primary$ 标记组件指定优先使用的<code>bean</code>的名字。除了上述注解之外，还有两个特殊的用于<code>bean</code>的注解，$@javax.annotation.PostConstruct$ 注解和 $@javax.annotation.PreDestroy$ 注解，用于标注一个 $public\ \ void$ 的无参方法，前者会在<code>bean</code>构造完成后调用，后者会在<code>bean</code>关闭前调用。<br>
        通过使用注解，我们可以简化我们的<code>Spring</code>配置。在 $rootContext.xml$ 中可以添加如下配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
    <span class="na">xmlns:mvc=</span><span class="s">&#34;http://www.springframework.org/schema/mvc&#34;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span><span class="s">        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
</span><span class="s">        http://www.springframework.org/schema/mvc
</span><span class="s">        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&#34;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;context:annotation-config/&gt;</span>
    <span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">&#34;org.example&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;context:exclude-filter</span> <span class="na">type=</span><span class="s">&#34;annotation&#34;</span> <span class="na">expression=</span><span class="s">&#34;org.springframework.stereotype.Controller&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/context:component-scan&gt;</span>

<span class="nt">&lt;/beans&gt;</span>
</code></pre></div><p>        &lt;$context:annotation-config$&gt; 启用注解配置，&lt;$context:component-scan$&gt; 启用组件扫描，$base-package$ 特性指定要扫描的包，在其命名空间内，我们使用了 &lt;$context:exclude-filter$&gt; 标签排除了对 $@Controller$ 组件的扫描。因为在之前的 $servletContext.xml$ 中我们已经配置了 $barController$ ，如果不排除的话，它将会被实例化两次。或者，我们可以修改 $servletContext.xml$ 配置为如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
    <span class="na">xmlns:mvc=</span><span class="s">&#34;http://www.springframework.org/schema/mvc&#34;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span><span class="s">        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
</span><span class="s">        http://www.springframework.org/schema/mvc
</span><span class="s">        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&#34;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;mvc:annotation-driven/&gt;</span>

    <span class="nt">&lt;context:annotation-config/&gt;</span>
    <span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">&#34;org.example&#34;</span> <span class="na">use-default-filters=</span><span class="s">&#34;false&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;context:include-filter</span> <span class="na">type=</span><span class="s">&#34;annotation&#34;</span> <span class="na">expression=</span><span class="s">&#34;org.springframework.stereotype.Controller&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/context:component-scan&gt;</span>

<span class="nt">&lt;/beans&gt;</span>
</code></pre></div><p>        使用 &lt;$context:include-filter$&gt; 设置应该扫描的包，注意这里使用了 $use-default-filters$ 该属性表示是否使用标准扫描模式，默认为 $true$ 。</p>
<h3 id="编程配置方式">编程配置方式</h3>
<p>        使用编程方式配置时，我们要创建自定义的配置类，然后为这些类标上 $@org.springframework.context.annotation.Configuration$ 注解。在自定义的配置类内，我们还可以通过使用 $@org.springframework.context.annotation.Bean$ 注解标注无参方法注册<code>bean</code>。不仅如此，我们在混合配置中所提到的所有注解都能在配置类内使用，而且由于 $@Configuration$ 是标注了 $@Component$ 的注解，因此也能被组件扫描所扫描到，但这可能产生意料之外的行为，如<code>bean</code>被实例化两次。使用配置类时，可以通过结合使用 $@org.springframework.context.annotation.Import$ 注解导入其他配置类中的配置，或者使用 $@org.springframework.context.annotation.ImportResource$ 注解导入<code>XML</code>配置来实现将配置分布在多个地方。<br>
        还记得我们在混合配置中保留的命名空间吗？现在我们可以使用注解来代替它们了。</p>
<table>
<thead>
<tr>
<th style="text-align:center">注解</th>
<th style="text-align:center">命名空间</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$@ComponentScan$</td>
<td style="text-align:center">&lt;$context:component-scan$&gt;</td>
<td style="text-align:center">指定启用组件扫描的包</td>
</tr>
<tr>
<td style="text-align:center">$@EnableAsync$</td>
<td style="text-align:center">&lt;$task:*$&gt;</td>
<td style="text-align:center">启用<code>Spring</code>的 $@Aysnc$ 异步方法执行</td>
</tr>
<tr>
<td style="text-align:center">$@EnableScheduling$</td>
<td style="text-align:center">&lt;$task:*$&gt;</td>
<td style="text-align:center">启用<code>Spring</code>的 $@Scheduled$ 计划方法的执行</td>
</tr>
<tr>
<td style="text-align:center">$@EnableCaching$</td>
<td style="text-align:center">&lt;$cache:*$&gt;</td>
<td style="text-align:center">启用<code>Spring</code>的注解驱动缓存管理特性</td>
</tr>
<tr>
<td style="text-align:center">$@EnableTransactionManagement$</td>
<td style="text-align:center">&lt;$tx:annotation-driven$&gt;</td>
<td style="text-align:center">为 $@Transactional$ 方法启用事务管理</td>
</tr>
<tr>
<td style="text-align:center">$@EnableWebMvc$</td>
<td style="text-align:center">&lt;$mvc:annotation-driven$&gt;</td>
<td style="text-align:center">通常需要对该注解进行自定义配置，通过继承 $WebMvcConfigurerAdapter$ 来自定义需要的部分</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Configuration</span>
<span class="nd">@EnableWebMvc</span>
<span class="nd">@ComponentScan</span><span class="o">(</span>
    <span class="n">basePackage</span> <span class="o">=</span> <span class="s">&#34;org.example&#34;</span><span class="o">,</span>
    <span class="n">useDefaultFilters</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span>
    <span class="n">includeFilters</span> <span class="o">=</span> <span class="nd">@ComponentScan.Filter</span><span class="o">(</span><span class="n">Controller</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServletContextConfiguration</span> <span class="o">{}</span>
</code></pre></div><p>        上例是一个简单的配置类，它没有包含任何<code>bean</code>，一切都通过组件扫描和 $@EnableWebMvc$ 进行配置。</p>


<a href="javascript:void(0)" id="tocbtn"><i class="fas fa-bars fa-lg"></i></a>
<div id="sidetoc">
    <header>
        <h4>JavaWeb（4）：Spring简介</h4>
    </header>
    
    <nav id="TableOfContents">
        <ul></ul>
    </nav>
</div>
<script src=https://z217blog.cn/js/toc.js></script>



<div class="nav-next-prev">
    <div class="nav-prev">
        
        <a href="https://z217blog.cn/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/"><i class="fas fa-chevron-left"></i></a>
        
    </div>
    <a class="nav-top" href="#">回到顶部</i></a>
    <div class="nav-next">
        
        <a href="https://z217blog.cn/post/redis%E7%AC%94%E8%AE%B0/"><i class="fas fa-chevron-right"></i></a>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2021, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
    <script type="text/javascript">
        if (tocFlag) tocInit();
    </script>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>