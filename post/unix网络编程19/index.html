<!DOCTYPE html>
<html><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">

<h1 id="title">Unix网络编程（19）：信号量</h1>


<p>        <strong>信号量</strong> ( $semaphore$ ) 是一种用于不同进程间或一个进程内的不同线程间同步的原语。<code>POSIX</code>信号量不必在内核中维护，可能使用文件系统中的某个文件来标识。</p>
<h2 id="1-有名信号量操作">1. 有名信号量操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回信号量指针，出错返回SEM_FAILED
</span><span class="c1"></span><span class="n">sem_t</span> <span class="o">*</span><span class="nf">sem_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="p">...</span>
  <span class="cm">/* mode_t mode, unsigned int value */</span> <span class="p">);</span>
</code></pre></div><p>        $sem_-open$ 创建一个有名信号量或者打开一个有名信号量。有名信号量既可以用于线程间同步，又可以用于进程间同步。$oflag$ 参数可以是 $0$ 、$O_-CREAT$ 或 $O_-CREAT$ | $O_-EXCL$ 。如果指定了 $O_-CREAT$ ，那么也要指定权限位 $mode$ 和信号量初始值 $value$ 。信号量初始值不能超过 $SEM_-VALUE_-MAX$ ( 这个常值至少为 $32767$ )。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">sem_close</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_unlink</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div><p>        当进程终止时，内核会对仍然打开着的有名信号量执行关闭操作。关闭一个信号量只是减少其引用计数，并不会删除。如果想要删除一个信号量，需要调用 $sem_-unlink$ 函数。类似于 $unlink$ ，如果在调用 $sem_-unlink$ 时该信号量引用计数不为 $0$ ，依然会进行删除，但是析构会等到引用计数为 $0$ 时才会发生。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_trywait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_getvalue</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">valp</span><span class="p">);</span>
</code></pre></div><p>        $sem_-wait$ 测试指定信号量的值，如果大于 $0$ ，就将其减 $1$ 并返回；如果不大于 $0$ ，就会阻塞直到该值大于 $0$ ，然后减 $1$ 并返回。如果在阻塞的过程中被中断，$sem_-wait$ 会返回并设置 $EINTR$ 错误。考虑到可能使用同一信号量的其他线程的存在，测试并减 $1$ 这个过程是原子的。$sem_-trywait$ 是 $sem_-wait$ 的非阻塞版本，如果值不大于 $0$ ，它会返回并设置 $EAGAIN$ 错误。<br>
        当一个线程使用完信号量后，应该调用 $sem_-post$ 函数将信号值加 $1$ 。$sem_-getvalue$ 会在 $valp$ 中返回信号量的当前值。如果信号量非正值，那么返回值可能是 $0$ ，也可能是一个负数，其绝对值为阻塞在该信号量上的线程数。</p>
<h2 id="2-生产者-消费者问题">2. 生产者-消费者问题</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp">#define SEM_MUTEX &#34;mutex&#34;
</span><span class="cp">#define SEM_NEMPTY &#34;nempty&#34;
</span><span class="cp">#define SEM_NSTORED &#34;nstored&#34;
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">;</span>  <span class="c1">// read-only by producer and consumer
</span><span class="c1"></span><span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producer and consumer
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="n">sem_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="o">*</span><span class="n">nempty</span><span class="p">,</span> <span class="o">*</span><span class="n">nstored</span><span class="p">;</span>
<span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">,</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons1 &lt;#items&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// create three semaphores
</span><span class="c1"></span>  <span class="n">shared</span><span class="p">.</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Sem_open</span><span class="p">(</span><span class="n">SEM_MUTEX</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span>
                          <span class="n">FILE_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">shared</span><span class="p">.</span><span class="n">nempty</span> <span class="o">=</span> <span class="n">Sem_open</span><span class="p">(</span><span class="n">SEM_NEMPTY</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span>
                           <span class="n">FILE_MODE</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">shared</span><span class="p">.</span><span class="n">nstored</span> <span class="o">=</span> <span class="n">Sem_open</span><span class="p">(</span><span class="n">SEM_NSTORED</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span>
                            <span class="n">FILE_MODE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// create one producer thread and one consumer thread
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// wait for the two threads
</span><span class="c1"></span>  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// remove the semaphores
</span><span class="c1"></span>  <span class="n">Sem_unlink</span><span class="p">(</span><span class="n">SEM_MUTEX</span><span class="p">);</span>
  <span class="n">Sem_unlink</span><span class="p">(</span><span class="n">SEM_NEMPTY</span><span class="p">);</span>
  <span class="n">Sem_unlink</span><span class="p">(</span><span class="n">SEM_NSTORED</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// store i into circular buffer
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">[</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        上述程序声明 $3$ 个信号量。$mutex$ 保护共享缓冲区；$nempty$ 统计共享缓冲区中的空槽数；$nstored$ 统计共享缓冲区中的元素数。</p>
<h2 id="3-匿名信号量操作">3. 匿名信号量操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shared</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_destroy</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div><p>        匿名信号量是存储在内存中的信号量。匿名信号量通过 $sem_-init$ 初始化，如果 $shared$ 为 $0$ ，那么待初始化的信号量是在同一进程的各个线程间共享的，否则该信号量是在进程间共享的。当 $shared$ 为非零值时，信号量必须存放在某种类型的共享内存区中，从而能让多个进程访问。与 $sem_-open$ 一样，$value$ 指定信号量初始值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">;</span>  <span class="c1">// read-only by producer and consumer
</span><span class="c1"></span><span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores, not pointers
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">,</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons2 &lt;#items&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// initialize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">Set_concurrency</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="4-生产者-消费者问题多生产者和单个消费者">4. 生产者-消费者问题：多生产者和单个消费者</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp">#define MAXNTHREADS 100
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">,</span> <span class="n">nproducers</span><span class="p">;</span>  <span class="c1">// read-only by producer and consumer
</span><span class="c1"></span>
<span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producers and consumer
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">nput</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nputval</span><span class="p">;</span>
  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores, not pointers
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">];</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">],</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons3 &lt;#items&gt; &lt;#producers&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">nproducers</span> <span class="o">=</span> <span class="n">mi</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">MAXNTHREADS</span><span class="p">);</span>

  <span class="c1">// initialize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// create all producers and one consumer
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="n">nproducers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// wait for all producers and the consumer
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;count[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">&gt;=</span> <span class="n">nitems</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// all done
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nput</span><span class="o">++</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="p">;</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>    <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error: buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]);</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        相较于单生产者单消费者的情况，生产者的循环会在放置了 $nitems$ 个值后终止。</p>
<h2 id="5-生产者-消费者问题多生产者和多消费者">5. 生产者-消费者问题：多生产者和多消费者</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp">#define MAXNTHREADS 100
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">,</span> <span class="n">nproducers</span><span class="p">,</span> <span class="n">nconsumers</span><span class="p">;</span>  <span class="c1">// read-only
</span><span class="c1"></span>
<span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producers and consumers
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">nput</span><span class="p">;</span>  <span class="c1">// item number
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">nputval</span><span class="p">;</span>  <span class="c1">// value to store in buff[]
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">nget</span><span class="p">;</span>  <span class="c1">// item number
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">ngetval</span><span class="p">;</span>  <span class="c1">// value fetched from buff[]
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">prodcount</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">],</span> <span class="n">conscount</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">];</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">],</span> <span class="n">tid_consume</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons4 &lt;#items&gt; &lt;#producers&gt; &lt;#consumers&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">nproducers</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">MAXNTHREADS</span><span class="p">);</span>
  <span class="n">nconsumers</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">MAXNTHREADS</span><span class="p">);</span>

  <span class="c1">// initalize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// create all producers and all consumers
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="n">nproducers</span> <span class="o">+</span> <span class="n">nconsumers</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">prodcount</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prodcount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nconsumers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">conscount</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conscont</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="c1">// wait for all producers and all consumers
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;producer count[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">prodcount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nconsumers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;consumer count[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">conscount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">&gt;=</span> <span class="n">nitems</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// let consumers terminate
</span><span class="c1"></span>      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// all done
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nput</span><span class="o">++</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="o">++</span><span class="p">;</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>    <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shard</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nget</span> <span class="o">&gt;=</span> <span class="n">nitems</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// all done
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">nget</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">shared</span><span class="p">.</span><span class="n">ngetval</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error: buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nget</span><span class="o">++</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">ngetval</span><span class="o">++</span><span class="p">;</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>    <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        这里的生产者函数增添了一行，在检测到已经生产了 $nitems$ 个数据后，为了唤醒阻塞在 $nstored$ 上的线程，会在线程终止前递增 $nstored$ 信号值。同时我们修改消费者函数，每次消费前比较 $nget$ 和 $nitems$ ，确定是否完成所有消费。</p>
<h2 id="6-多缓冲区">6. 多缓冲区</h2>
<p>        在一些处理数据的程序中，我们可能会用到以下形式的循环：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fdin</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* process the data */</span>
  <span class="n">write</span><span class="p">(</span><span class="n">fdout</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        以上循环读入一行文件，并对其处理，然后写回一行输出。我们可以考虑将这个操作分为两个线程，一个线程负责读，另一个负责写。表面上看这可以改善程序的运行，其实不然，因为我们使用的还是同一个缓冲区，写线程还是要等待读线程完成。为了解决这个问题，我们可以使用两个缓冲区。同时，要注意大多数<code>Unix</code>内核检测出对一个文件的顺序读之后，不仅会读出我们需要的磁盘块的内容，还会顺便读取下一个磁盘块的内容，从而可以改善下次读取的操作时间。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 8
</span><span class="cp"></span>
<span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producer and consumer
</span><span class="c1"></span>  <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">BUFFSIZE</span><span class="p">];</span>  <span class="c1">// a buffer
</span><span class="c1"></span>    <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">// count of #bytes in the buffer
</span><span class="c1"></span>  <span class="p">}</span> <span class="n">buff</span> <span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>  <span class="c1">// NBUFF of these buffers/counts
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>  <span class="c1">// input file to copy to stdout
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">,</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mycat2 &lt;pathname&gt;&#34;</span><span class="p">);</span>

  <span class="n">fd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>

  <span class="c1">// initalize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// one producer thread, one consumer thread
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// reader thread
</span><span class="c1"></span>  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// writer thread
</span><span class="c1"></span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">.</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="c1">// critical region
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span> <span class="o">=</span> <span class="n">Read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">NBUFF</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// circular buffer
</span><span class="c1"></span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="c1">// critical region
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">NBUFF</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// circular buffer
</span><span class="c1"></span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        本例子中由 $mutex$ 锁住的临界区是空的，如果我们的数据以链表形式而不是数组形式存储，那么这块区域可用于操作链表。</p>
<h2 id="7-信号量限制">7. 信号量限制</h2>
<p>        <code>POSIX</code>定义了两个信号量限制：</p>
<ul>
<li>$SEM_-NSEMS_-MAX$ ：一个进程可同时打开着的最大信号量 ( <code>POSIX</code>要求至少为 $256$ )；</li>
<li>$SEM_-VALUE_-MAX$ ：一个信号量的最大值 ( <code>POSIX</code>要求至少为 $32767$ )。</li>
</ul>
<p>        这两个常值通常定义在 &lt;$unistd.h$&gt; 头文件中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;SEM_NSEMS_MAX = %ld, SEM_VALUE_MAX = %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
    <span class="n">Sysconf</span><span class="p">(</span><span class="n">_SC_SEM_NSEMS_MAX</span><span class="p">),</span> <span class="n">Sysconf</span><span class="p">(</span><span class="n">_SC_SEM_VALUE_MAX</span><span class="p">));</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<script src=https://z217blog.cn/js/toc.js></script>

<div>
    <a href="javascript:void(0);" id="tocbtn"><i class="fas fa-bars fa-lg"></i></a>
    <div id="sidetoc">
        <header>
            <h4>Unix网络编程（19）：信号量</h4>
        </header>
        <nav id="TableOfContents">
            <ul></ul>
        </nav>
    </div>
    <script>
        isTocOpen = true;
    </script>
</div>


<div class="nav-next-prev">
    <div class="nav-prev">
        
        <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B18/"><i class="fas fa-chevron-left"></i></a>
        
    </div>
    <a class="nav-top" href="#">回到顶部</i></a>
    <div class="nav-next">
        
        <a class="grayed-out" href="javascript:void()"><i class="fas fa-chevron-right"></i></a>
        
    </div>
</div>
<script type="text/javascript">
    if (isTocOpen) tocInit();
</script>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2022, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>