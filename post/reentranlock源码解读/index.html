<!DOCTYPE html>
<html lang="zh-CN"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/jquery.floatingscroll.css>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  <script src=https://z217blog.cn/js/jquery.floatingscroll.min.js></script>
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>
        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">

<h1 id="title">ReentranLock源码解读</h1>




<p>        $ReentrantLock$ 是一个可重入的独占锁，与 $synchronized$ 行为类似，但提供了额外的功能。</p>
<h2 id="1-构造函数">1. 构造函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 默认为非公平锁
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">()</span> <span class="o">{</span> <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span> <span class="o">}</span>

<span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span> <span class="n">sync</span> <span class="o">=</span> <span class="n">fair</span> <span class="o">?</span> <span class="k">new</span> <span class="n">FairSync</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span> <span class="o">}</span>
</code></pre></div><h2 id="2-内部类">2. 内部类</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Sync</span> <span class="kd">extends</span> <span class="n">AbstractQueuedSynchronizer</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="n">5179523762034025860L</span><span class="o">;</span>

    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">();</span>

    <span class="c1">// 非公平上锁, tryAcquire方法在子类中实现
</span><span class="c1"></span>    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">nonfairTryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 锁未被占有
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 尝试获取锁
</span><span class="c1"></span>                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span> <span class="c1">// 设置独占线程
</span><span class="c1"></span>                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 当前线程已经占有锁
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;Maximum lock count exceeded&#34;</span><span class="o">);</span>
            <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span> <span class="c1">// 添加上锁次数
</span><span class="c1"></span>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">()</span> <span class="o">-</span> <span class="n">releases</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="c1">// 当前线程非独占线程
</span><span class="c1"></span>            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
        <span class="kt">boolean</span> <span class="n">free</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 锁被释放
</span><span class="c1"></span>            <span class="n">free</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// 取消独占状态
</span><span class="c1"></span>        <span class="o">}</span>
        <span class="n">setState</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">free</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 当前实现是否持有锁
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">getExclusiveOwnerThread</span><span class="o">()</span> <span class="o">==</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="n">ConditionObject</span> <span class="nf">newCondition</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ConditionObject</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 返回持有者线程
</span><span class="c1"></span>    <span class="kd">final</span> <span class="n">Thread</span> <span class="nf">getOwner</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">getState</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">getExclusiveOwnerThread</span><span class="o">();</span> <span class="o">}</span>

    <span class="c1">// 返回当前线程上锁次数
</span><span class="c1"></span>    <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getHoldCount</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">isHeldExclusively</span><span class="o">()</span> <span class="o">?</span> <span class="n">getState</span><span class="o">()</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isLocked</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">getState</span><span class="o">()</span> <span class="o">!=</span> <span class="n">0</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">ObjectInputStream</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* 省略 */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 非公平锁
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">NonfairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="n">7316153563782823691L</span><span class="o">;</span>

    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">1</span><span class="o">))</span> <span class="c1">// 尝试上锁
</span><span class="c1"></span>            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
        <span class="k">else</span> <span class="c1">// 自旋获取锁
</span><span class="c1"></span>            <span class="n">acquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">nonfairTryAcquire</span><span class="o">(</span><span class="n">acquires</span><span class="o">);}</span> <span class="c1">// 调用父类方法
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 公平锁
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="n">3000897897090466540L</span><span class="o">;</span>

    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span> <span class="n">acquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="o">}</span> <span class="c1">// 公平方式获取锁，获取失败则自旋
</span><span class="c1"></span>
    <span class="c1">// 公平方式获取锁
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">hasQueuedPredecessors</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="c1">// 没有前驱节点
</span><span class="c1"></span>                <span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 尝试获取锁
</span><span class="c1"></span>                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 当前线程为独占线程
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span> <span class="c1">// 添加获取次数
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;Maximum lock count exceeded&#34;</span><span class="o">);</span>
            <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        其中 $acquire$ 方法的实现可以在<a href="https://z217blog.cn/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#3-%E8%8E%B7%E5%8F%96%E9%94%81">这里</a>查看。</p>
<h2 id="3-上锁和解锁">3. 上锁和解锁</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 声明了一个内部类字段作为同步器
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">final</span> <span class="n">Sync</span> <span class="n">sync</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="n">lock</span> <span class="o">{</span> <span class="n">sync</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="o">}</span> <span class="c1">// 调用lock方法，该方法在子类中被实现
</span><span class="c1"></span>
<span class="c1">// 响应中断式上锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">lockInterruptibly</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">acquireInterruptibly</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// AQS中实现
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquireInterruptibly</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
        <span class="n">doAcquireInterruptibly</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 尝试以非公平方式获取锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">nonfairTryAcquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryAcquireNanos</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// AQS中实现
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">tryAcquireNanos</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">nanosTimeout</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">||</span>
        <span class="n">doAcquireNanos</span><span class="o">(</span><span class="n">arg</span><span class="o">,</span> <span class="n">nanosTimeout</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 每次只能解一个锁，所以如果多次上锁就需要多次解锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span> <span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="o">}</span>
</code></pre></div><p>        其中 $doAcquireInterruptibly$ 方法和 $doAcquireNanos$ 方法的实现可以在<a href="https://z217blog.cn/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#33-%E5%85%B6%E4%BB%96">这里</a>查看。</p>
<h2 id="4-条件">4. 条件</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 创建条件
</span><span class="c1"></span><span class="kd">public</span> <span class="n">Condition</span> <span class="nf">newCondition</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否有线程在条件上等待
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasWaiters</span><span class="o">(</span><span class="n">Condition</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">condition</span> <span class="k">instanceof</span> <span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">))</span>
        <span class="c1">// 非AQS中定义的ConditionObject类型对象
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;not owner&#34;</span><span class="o">);</span>
    <span class="c1">// 使用AQS中的方法判断，检查条件队列中是否有状态为CONDITION的节点
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">hasWaiters</span><span class="o">((</span><span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">)</span><span class="n">condition</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 获取条件上等待的线程数量
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">getWaitQueueLength</span><span class="o">(</span><span class="n">Condition</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">condition</span> <span class="k">instanceof</span> <span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">))</span>
        <span class="c1">// 非AQS中定义的ConditionObject类型对象
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;now owner&#34;</span><span class="o">);</span>
    <span class="c1">// 使用AQS中的方法统计，遍历条件队列并统计CONDITION节点数量
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getWaitQueueLength</span><span class="o">((</span><span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">)</span><span class="n">condition</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 获取条件上等待的线程集合
</span><span class="c1"></span><span class="kd">protected</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="nf">getWaitingThreads</span><span class="o">(</span><span class="n">Condition</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">condition</span> <span class="k">instanceof</span> <span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">))</span>
        <span class="c1">// 非AQS中定义的ConditionObject类型对象
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;not owner&#34;</span><span class="o">);</span>
    <span class="c1">// 使用AQS中的方法统计，遍历条件队列并返回CONDITION节点中持有的线程集合
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getWaitingThreads</span><span class="o">((</span><span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">)</span><span class="n">condition</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><h2 id="5-其他方法">5. 其他方法</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 当前线程上锁次数
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">getHoldCount</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getHoldCount</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否被当前线程持有
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHeldByCurrentThread</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isHeldExclusively</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否上锁，即状态是否非零
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isLocked</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isLocked</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否公平锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isFair</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span> <span class="k">instanceof</span> <span class="n">FairSync</span><span class="o">;</span> <span class="o">}</span>

<span class="c1">// 获取持有者线程
</span><span class="c1"></span><span class="kd">protected</span> <span class="n">Thread</span> <span class="nf">getOwner</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getOwner</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否有等待中的线程
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedThreads</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">hasQueuedThreads</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// AQS中实现
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedThreads</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">head</span> <span class="o">!=</span> <span class="n">tail</span><span class="o">;</span> <span class="c1">// 首节点为哑节点，因此只要首尾不等即可
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// 线程是否在队列中等待，从尾部遍历等待队列，判断线程是否在其中
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedThread</span><span class="o">(</span><span class="n">Thread</span> <span class="n">thread</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isQueued</span><span class="o">(</span><span class="n">thread</span><span class="o">);</span> <span class="o">}</span>

<span class="c1">// 获取等待线程的数量，从尾部遍历等待队列，统计等待线程数
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getQueueLength</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getQueueLength</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 获取等待线程的集合，从尾部遍历等待队列，返回等待线程集合
</span><span class="c1"></span><span class="kd">protected</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="nf">getQueuedThreads</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getQueuedThreads</span><span class="o">();</span> <span class="o">}</span>
</code></pre></div>
<script src=https://z217blog.cn/js/toc.js></script>

<div>
    <a href="javascript:void(0);" id="tocbtn"><i class="fas fa-bars fa-lg"></i></a>
    <div id="sidetoc">
        <header>
            <h4>ReentranLock源码解读</h4>
        </header>
        <nav id="TableOfContents">
            <ul></ul>
        </nav>
    </div>
    <script>
        isTocOpen = true;
    </script>
</div>


<div class="nav-next-prev">
    <div class="nav-prev">
        
        <a href="https://z217blog.cn/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"><i class="fas fa-chevron-left"></i></a>
        
    </div>
    <a class="nav-top" href="#">回到顶部</i></a>
    <div class="nav-next">
        
        <a href="https://z217blog.cn/post/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/"><i class="fas fa-chevron-right"></i></a>
        
    </div>
</div>
<script type="text/javascript">
    if (isTocOpen) tocInit();
</script>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2022, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
</main>
</body>

</html>