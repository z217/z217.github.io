<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>z217&#39;s blog</title>
    <link>https://z217blog.cn/</link>
    <description>Recent content on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2021, z217 and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Tue, 07 Sep 2021 22:20:53 +0800</lastBuildDate><atom:link href="https://z217blog.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>秋招面试总结</title>
      <link>https://z217blog.cn/post/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 07 Sep 2021 22:20:53 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
      <description>1. 腾讯-WXG-微信支付 1.1 一面  C++了解吗 ( 不了解就没问了 ) 算法题：无序数组有序排列的最大相邻差值 ( 跟我说不能排序，搜了下答案是桶排序，迷惑 ) 算法题：$100$ 个样本找病毒 算法题：二叉树深度 ( 递归和迭代 ) 实习项目 Linux了解吗 ( 怕他往下问就说不了解了 ) 协程了解吗？ 什么时候用协程比较好 协程切换的时候变化的东西和不变的东西 ( 没听懂啥意思 ) 唠家常 ( 哪里人，想在哪工作 ) 算法题：数组中的重复元素  总结：因为跟他说技术栈是Go所以就问协程了，第一道算法题没做出来，中间问题没听懂，但是莫名其妙地过了。
1.2 面委会一面  实习项目 数据库索引 为什么要用B+树 Redis和MySQL区别 Redis的I/O模型 $epoll$ ， $LT$ 和 $ET$ Redis持久化 其他存储有了解吗 ( 跟他说Kafka，他说Kafka不是存储😂 ) Kafka介绍下 代码：直播间有热度，可以创建删除直播间，运营人员半小时一次查看 $Top 100$ 的直播间 代码题展开，$Map$ 的实现，常用并发结构的实现 学过C++吗  总结：被干碎了，代码题还看漏了，写成实时排序了，其实半小时一次并不用实时维护。
1.3 面委会二面  实习项目的技术难题和挑战 实习项目继续问 RPC的理解 Redis的LRU LRU和LFU 海量数据排序 ( 内存装不下 ) 参加了啥竞赛 ( 没有 ) 在学校时候的优势和劣势 学习心得 ( 你项目实践比较少啊😂 )  总结：不知道面了个啥，感觉更像是个懂技术的HR。</description>
    </item>
    
    <item>
      <title>ThreadPoolExecutor原理</title>
      <link>https://z217blog.cn/post/threadpoolexecutor%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 26 Aug 2021 17:13:59 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/threadpoolexecutor%E5%8E%9F%E7%90%86/</guid>
      <description>1. 线程池介绍  为什么使用线程池？
 创建/销毁线程需要消耗系统资源，线程池可以复用已经创建的线程； 控制并发数； 统一管理线程。  2. 构造方法 /* @param corePoolSize 核心线程数最大值 @param maximumPoolSize 线程总数最大值 @param keepAliveTime 非核心线程超时时长 @param unit keepAliveTime的时间单位 @param workQueue 维护待执行的Runnable对象的阻塞队列 @param threadFactory 线程工厂 @param handler 拒绝处理策略 */ public ThreadPoolExecutor(@Range(from = 0, to = java.lang.Integer.MAX_VALUE) int corePoolSize, @Range(from = 1, to = java.lang.Integer.MAX_VALUE) int maximumPoolSize, @Range(from = 0, to = java.lang.Long.MAX_VALUE) long keepAliveTime, @NotNull TimeUnit unit, @NotNull BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, @NotNull ThreadFactory threadFactory, @NotNull RejectedExecutionHandler handler) { if (corePoolSize &amp;lt; 0 || maximumPoolSize &amp;lt;= 0 || maximumPoolSize &amp;lt; corePoolSize || keepAliveTime &amp;lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.</description>
    </item>
    
    <item>
      <title>进程、线程和协程</title>
      <link>https://z217blog.cn/post/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Wed, 25 Aug 2021 17:25:27 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</guid>
      <description>进程 线程 协程     CPU 系统负责执行线程 一个进程含有多个线程，系统分配线程在不同的CPU上执行 线程上执行   内存 进程管理自己的内存区域 多线程共享进程的内存区域 同线程   栈  系统负责在内存中分配调用栈，默认为 $8MB$ 用户程序在堆上分配栈，切换的时候修改 $SP$ 、$PC$ 、$BP$   切换方式  时间片耗尽后触发中断处理程序，内核负责切换线程 主动切换，让出CPU   切换内容 通用寄存器，$PC$ 寄存器，页表寄存器，TLB，CPU缓存 通用寄存器，$PC$ 寄存器，CPU缓存 通用寄存器，$PC$ 寄存器   上下文 $task_-struct$ ，页表 $task_-struct$ ，页表 运行栈，寄存器    1. CPU和内存  操作系统为进程分配了一个专门的数据结构称为进程控制块 ( $Process\ \ Control\ \ Block$ ，$PCB$ )。系统利用PCB来描述进程基本情况和运行状态，进而实现对进程的控制和管理。程序段、相关数据段和PCB构成了进程实体。PCB内的信息包括：
 进程描述信息：进程标识符 ( $PID$ ) 和用户标识符 ( $UID$ )； 进程控制和管理信息：进程状态信息，进程优先级，代码运行入口，程序外存地址，处理机占用时间等； 资源分配清单：代码段指针、数据段指针、堆栈段指针和文件描述符等； 处理机相关信息：通用寄存器，地址寄存器，控制寄存器，状态字等。   线程的最直接理解就是轻量级进程，是CPU的基本执行单元，也是程序执行的最小单元，包括：</description>
    </item>
    
    <item>
      <title>HashMap源码解读</title>
      <link>https://z217blog.cn/post/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Mon, 23 Aug 2021 15:01:55 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>1. 字段  字段设置为 $transient$ ，因为 $HashMap$ 通过 $Object.hashCode(\ )$ 获取哈希值，并通过哈希值与桶个数取模确定对象。$Object.hashCode(\ )$ 是一个本地方法，依赖于JVM实现，存在跨平台问题，所有 $HashMap$ 在序列化时会先保存所有 $Key$ ，再在反序列化时重新插入。
// 最大容量 static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; // 默认负载因子，大小/容量超过这个比例就会扩容 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶中节点数不小于该值时树化 // 树节点大小是常规节点两倍，应该在有足够的节点后树化 static final int TREEIFY_THRESHOLD = 8; // 当桶中节点数小于该值时链表化 // 不设为TREEIFY_THRESHOLD，避免抖动 static final int UNTREEIFY_THRESHOLD = 6; // 当容量不小于该值时才会树化，否则会优先扩容 // 应当至少为 4 * TREEIFY_THRESHOLD static final int MIN_TREEIFY_CAPACITY = 64; // 初次使用时初始化，长度为 2 的幂次 transient Node&amp;lt;K,V&amp;gt;[] table; // entrySet() 缓存 transient Set&amp;lt;Map.</description>
    </item>
    
    <item>
      <title>I/O多路复用</title>
      <link>https://z217blog.cn/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Sun, 22 Aug 2021 15:30:25 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>1. 基本概念  操作系统内核 ( $kernel$ ) 是操作系统的核心，独立于普通应用程序，可以访问受保护的内存空间，也有权访问所有底层硬件设备。为了保证用户进程不能直接操作内核，操作系统将内存空间划为两部分，内核空间和用户空间。对于linux系统，如果是 $32$ 位系统，虚拟内存中最高的 $1G$ 字节 ( $0xC0000000 \sim 0xFFFFFFFF$ ) 为内核空间；如果是 $64$ 位系统，指针的前 $16$ 位保留，从而只有 $48$ 位寻址空间，于是最高的 $128T$ 字节 ( $0x0000000000000000 \sim 0x00007FFFFFFFF000$ ) 作为系统空间，中间部分 ( $0x00007FFFFFFFFFFF \sim 0xFFFF800000000000$ ) 作为保留，其余部分为用户空间。
正在执行的进程由于某些期待的事件未发生，如资源请求失败或者等待某些操作完成等，会自动执行阻塞原语，使自己由运行态变为阻塞态。进程的阻塞是一种主动行为，只有处于运行态的进程才可以触发，并且阻塞后不占用CPU资源。
文件描述符 ( $fd$ ) 是一个指向文件引用的概念，在形式上是一个非负整数，实际上是一个索引值，指向内核打开文件表中的对应记录。打开文件表中记录了文件的属性，包括磁盘位置、访问权限、文件位置指针以及打开计数。
缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux中，操作系统会将I/O数据缓存在文件系统的 $Page\ \ Cache$ 中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
在BIO模式下，当线程接收一个请求后，在等待I/O的时间内，调用会被阻塞，无法接受其他请求。在多线程环境下，如果想要接受大量请求，就需要创建大量线程，占用大量系统空间，并且线程切换会带来很大的开销。$10000$ 个线程真正发生读写的实际的线程数不会超过 $20\%$ 。
在NIO模式下，当线程接收一个请求后，会加入 $fd_-set$ 集合，每次轮询集合接收数据，如果没有数据会返回错误。每次都要轮询所有集合，包括未发生实际读写的 $fd$ ，会浪费CPU资源。
在I/O多路复用模式下，服务端通过 $select$ / $poll$ / $epoll$ 等系统调用获取 $fd$ 列表，遍历有事件的 $fd$ 进行数据接收，可以支持更多并发连接请求。
 I/O多路复用是一种同步I/O模型，多路指网络连接，复用指一个线程，即一个线程可以监视多个文件句柄； 一旦某个文件句柄就绪，就可以通知应用程序进行相应的读写操作； 没有文件句柄就会阻塞线程。  2.</description>
    </item>
    
    <item>
      <title>缓存一致性协议MESI</title>
      <link>https://z217blog.cn/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/</link>
      <pubDate>Mon, 16 Aug 2021 11:02:05 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/</guid>
      <description>高速缓冲存储器一致性 ( $Cache\ \ coherence$ )，也称缓存一致性，是指在采用层次结构存储系统的计算机系统中，保证告诉缓冲存储器中数据与主存储器中数据相同的机制。在有多个CPU的多处理机系统中特别容易出现高速缓存中数据不一致的问题。
在CPU缓存设计中，L1高速缓存包含指令缓存和数据缓存，位于CPU芯片上，访问速度几乎和寄存器一样快。L2高速缓存在L1和主存之间，连接到存储器总线或者高速缓存总线上。有些高性能系统还会在存储器总线上设置L3高速缓存。L1和L2是每个CPU内核间独立的，L3是所有CPU内核间共享的。
对于单核CPU来说，数据更新时缓存更新只用考虑自己的就行了，主要有两种处理方法。写回法 ( $write\ \ back$ )，是当处理器执行写操作时，信息只写入cache，当cache中的数据被替换出去时写回主存。为了减少内存写操作，cache中通常还会设置一个脏位 ( $dirty\ \ bit$ )，标识该块在被载入后是否发生了更新。直写法 ( $write\ \ through$ ) 是当处理器执行写操作时，既向cache中写入也向主存中写入。直写法会造成大量写内存操作，需要设置一个缓冲来减少硬件冲突，称为写缓冲器 ( $write\ \ buffer$ )，通常不超过 $4$ 个缓存块的大小，也适用于写回法。
相比于单核CPU，多核CPU除了要保证L1和L2最新外还要考虑到其他核中L1和L2的实时性和有效性。MESI协议是一个基于失效的缓存一致性协议，是支持写回缓存的最常用协议。该协议对总线上的操作进行监听，即核 $A$ 可以窥探到核 $B$ 对过期值的读操作，并更新主存中的过期值。MESI把cache中的数据分为几个状态：
   状态 描述 监听     $Invalid$ 该cache字段失效 无   $Shared$ 字段数据一致并且多核cache共享该字段 监听其他缓存使该字段无效或者变为 $Exclusive$ 的请求，监听到对应事件后会将该字段设为 $Invalid$   $Exclusive$ 字段数据一致并且只在当前核cache中独有 监听其他缓存读主存中该字段的操作，监听到对应事件后将该字段变为 $Shared$   $Modified$ 该字段有效但是与主存不一致，只存在于当前核cache中 监听所有试图读该字段对应主存字段的操作，该操作会被延迟到当前缓存字段写回主存并将状态设为 $Shared$ 之后执行       事件 描述     $Local\ \ Read$ 读取本地cache字段   $Local\ \ Write$ 写入本地cache字段   $Remote\ \ Read$ 其他cache读取字段   $Remote\ \ Write$ 其他cache写入字段     对于 $Modified$ 和 $Exclusive$ 状态，数据是精确的，而 $Shared$ 状态可能是非一致的。如果一个处于 $Shared$ 的缓存字段作废了，另一个缓存实际上可能已经独享了该缓存字段，但是该缓存不会转为 $Exclusive$ ，因为其他缓存并不会广播他们作废该缓存字段的通知。如果一个CPU想修改一个处于 $Shared$ 状态的缓存字段，总线事务需要将所有该缓存字段的副本变为 $Invalid$ 状态，而修改 $Exclusive$ 状态的缓存字段不需要总线事务。</description>
    </item>
    
    <item>
      <title>MySQL笔记</title>
      <link>https://z217blog.cn/post/mysql%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 21 Jun 2021 20:33:31 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/mysql%E7%AC%94%E8%AE%B0/</guid>
      <description>1. 架构  大体来说，MySQL可以分为Server层和存储引擎层两部分。Server层包括连接器、查询缓存、分析器、优化器、执行器等，以及所有的内置函数，所有跨存储引擎功能都在这一层实现。而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个引擎。不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。
 连接器：连接器负责跟客户端建立连接、获取权限、维持和管理连接。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接。建立连接的过程通常比较复杂，所以应尽量使用长连接。但是全部使用长连接后，有时候MySQL内存占用会很高，因为MySQL在执行过程中临时使用的内存是在连接对象里的，只有在断开连接时才释放。 查询缓存：MySQL会在执行语句之前先在查询缓存中查询。但是查询缓存的失效很频繁，只要有一个表更新，表上所有缓存都会失效。对于更新压力大的数据库来讲，命中率会很低。MySQL在 $8.0$ 版本移除了查询缓存功能。 分析器：分析器会对语句做语法分析，判断语句是否存在错误，同时理解语句要执行的操作。 优化器：优化器是在表中存在多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联时，决定表的连接顺序。 执行器：在开始执行之前，会检查是否对表具有查询权限。如果有权限，就打开表执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。   一个InnoDB表包含两个部分，即表结构定义和数据。表结构定义的占用空间很小，在MySQL 8.0版本以前，表结构是存在以 $.frm$ 为后缀的文件里，而MySQL 8.0版本已经允许把表结构定义放在系统数据表中了。表数据既可放在共享表空间里，也可以是单独的文件，从MySQL 5.6.6开始，默认是存储在一个以 $.ibd$ 为后缀的文件中的。对于放在共享表空间中的表，即使通过 $DROP$ 命令删除后，空间也不会回收。在删除的过程中，InnoDB会查找聚簇索引，将对应的记录标记为删除，而不是真正删除，目的是为以后插入新数据时的复用。记录的复用与数据页的复用不同，记录的复用只允许对应范围的新记录复用，而如果删除整个数据页后，数据页的复用可以允许复用到任何位置。如果相邻的两个数据页的利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另一个数据页就被标记为可复用。
重建表即将原来表的记录读取出来，一行一行地插入到新表中。原来的表在删除和插入时会产生很多空洞，数据利用率不高，而重建表就可以解决这个问题。MySQL 5.6引入了 $Online\ \ DDL$ ，会先建立一个临时文件，保存原来表中的聚簇索引。在建立临时文件的过程中，在之后对原表的操作会被记录到日志文件中，并在临时文件建立完成后重新应用到临时文件中，从而允许重建表过程中的读写。
在不同的引擎中，$COUNT(*)$ 有不同的实现方式，MyISAM把表的行数存在了磁盘上，可以直接返回；InnoDB会把数据一行一行地读出来然后计数。由于MVCC的存在，在某个时间段表有多少行是不确定的，因此InnoDB并不能简单地将行数存起来。MySQL对此的优化策略是，如果表存在多个索引，那么会选择较小的一颗索引树进行扫描。
MySQL会给每个线程分配一块内存用于排序，称为 $sort_-buffer$。在 $sort_-buffer$ 里面的字段，会每次从数据库中取出数据并存到里面。当取出所有数据后再进行快速排序，如果内存空间不足，会使用外部排序。如果单行长度超过排序的最大长度，那么会将要排序的字段与ID关联，在排序完成后再通过ID回查。如果现有索引覆盖了需要排序的字段，那么会直接使用索引。对于使用聚集函数的排序，MySQL可能会使用临时表。临时表默认是在内存中的，如果超过了内存临时表的大小，就会转成磁盘临时表。
内存表指的是使用Memory引擎的表，这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。临时表可以使用各种引擎类型，如果是使用InnoDB或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的。一个临时表只能被创建它的 $session$ 访问，可以与普通表同名。
2. 日志  更新语句的执行过程其实与查询语句一样，但是会涉及日志模块。
redo log记录将要修改的记录，使用了WAL ( $Write-Ahead\ \ Logging$ ) 技术，即先写日志，再写磁盘。当有一条记录需要更新时，InnoDB会先把记录写到redo log中，并更新内存，之后在适当的时候，将这个操作记录更新到磁盘中，往往是在磁盘比较空闲的时候。
InnoDB的redo log是固定大小的，写到末尾时就循环回到开头重新写。$write\ \ pos$ 是当前记录的位置，随着数据写入后移。$check\ \ point$ 是当前要擦除的位置，在擦除之前要把记录更新到数据文件。$write\ \ pos$ 和 $check\ \ point$ 之间的部分可以记录新的操作。如果之间没有空白部分，需要等待执行记录。
InnoDB通过redo log，可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，称为 $crash-safe$ 。</description>
    </item>
    
    <item>
      <title>CSAPP笔记</title>
      <link>https://z217blog.cn/post/csapp%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 19 May 2021 15:06:19 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/csapp%E7%AC%94%E8%AE%B0/</guid>
      <description>1. 计算机系统漫游 #include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;#34;hello, world\n&amp;#34;); return 0; }  $hello$ 程序生命周期的一开始是一个高级C程序，因为处于这种形式时，它是能够被人读懂的。为了运行 $hello.c$ ，每条C语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序 ( $executable\ \ object\ \ program$ ) 的格式打包，并以二进制磁盘文件的形式存放起来。在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序 ( $compiler\ \ driver$ ) 完成的，这个过程可以分成四个阶段，执行这四个阶段的程序一起构成了编译系统：
 预处理阶段。预处理器 ( $cpp$ ) 根据以字符 $\#$ 开头的命令 ( $directives$ )，修改原始的C程序。修改完成后得到另一个C程序，通常是以 $.i$ 作为文件扩展名； 编译阶段：编译器 ( $ccl$ ) 将文本文件 $hello.i$ 翻译成文本文件 $hello.s$ ，它包含一个汇编语言程序； 汇编阶段：汇编器 ( $as$ ) 将 $hello.s$ 翻译成机器语言指令，并把这些指令打包成一种叫做可重定位 ( $relocatable$ ) 目标程序的格式，将结果保存在目标文件 $hello.o$ 中； 链接阶段：$hello.c$ 调用了C库函数 $printf$ ，后者存在于名为 $printf.</description>
    </item>
    
    <item>
      <title>操作系统笔记</title>
      <link>https://z217blog.cn/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 10 May 2021 20:54:33 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</guid>
      <description>计算机操作系统概述
1. 概述  操作系统 ( $Operating\ \ System$, $OS$ ) 是指控制和管理整个计算机系统的硬件和软件资源，以提供给用户和其他软件方便的接口和环境的程序集合，是计算机系统中最基本的系统软件。没有任何软件支持的计算机称为裸机。裸机在最里层，外面是操作系统。
操作系统是计算机系统资源的管理者：
 处理机管理：处理机的分配和运行以进程（或线程）为基本单位，因为对处理机的管理可以归结为对进程的管理； 存储器管理：对内存的管理； 文件管理：文件系统； 设备管理：I/O。   操作系统还提供了用户接口：
 命令接口：使用命令接口进行作业控制的方式有两种：联机控制方式和脱机控制方式。进一步的，按照控制方式，可以将命令接口分为联机命令接口和脱机命令接口。  联机命令接口适用于分时或实时系统的接口，由一组键盘操作命令组成。用户通过控制台或者终端输入命令； 脱机命令接口又称批处理命令接口，适用于批处理系统，由一组作业控制命令组成，用户不能直接干预作业运行，实现用相应的作业控制命令做成一份作业操作说明书，连同作业一起提交给系统。   程序接口由一组系统调用组成，用户通过在程序中使用这些系统调用命令来请求操作系统为其提供服务。   计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统内核程序，另一种是用户自编程序或者系统外层的应用程序。对于操作系统而言，前者是后者的管理者。内核程序可以执行一些特权指令，如I/O、中断、管理程序状态字寄存器等，出于安全考虑，这些程序不能被用户直接使用。操作系统在实现上划分了核心态（管态）和用户态（目态）以严格区分两类程序。
内核是计算机上配置的底层软件，大多数操作系统的内核包括四个方面的内容：
 时钟管理：时钟的第一功能是计时，通过时钟可以提供系统时间。此外，通过时钟中断，也可以实现进程切换； 中断机制：现代操作系统是靠中断驱动的软件。中断机制中，只有一小部分功能属于内核，负责保护和恢复中断现场信息，转移控制权，这样可以减少中断的处理时间； 原语 ( $Atomic\ \ Operation$ ) ：原语是一些可以被调用的小程序，处于操作系统的最底层，是最接近硬件的部分，具有原子性，且运行时间短、调用频繁； 系统控制的数据结构及处理：操作系统中存在许多记录状态信息的数据结构，如作业控制块、进程控制块、内存分配表等，操作系统需要一些对这些数据结构进行管理的基本操作。   从上述内容可知，核心态指令包括系统调用类指令和一些针对时钟、中断和原语的操作指令。
操作系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能。因此，需要实现核心态和用户态之间的转换。在实际操作系统中，CPU运行上层程序时的唯一转换途径是通过中断或异常。当中断或异常发生时，运行用户态的CPU会立即进入核心态，这是通过硬件实现的（例如用一个特殊寄存器表示）。
中断 ( $Interruption$ ) 指来自CPU执行指令以外的事件的发生，如设备I/O中断、时钟中断等。访管指令是一条可以在用户态下执行的指令，用于产生一个中断，称为访管中断，系统会根据访管指令的操作数执行对应的访管中断处理程序。异常 ( $Exception$ )，也称为陷入 ( $Trap$ ) ，指来自CPU执行指令内部的事件的发生，如程序的非法操作码、地址越界、内存缺页以及专门的陷入指令等。对异常的处理一般要依赖于当前程序的运行现场，并且异常不能被屏蔽，一旦出现应立即处理。
系统调用是用户在程序中调用操作系统提供的一些子功能，可以把系统调用看作是特殊的公共子程序。在用户程序中，凡是与资源有关的操作，都必须通过系统调用向操作系统提出服务请求，并由操作系统代为完成。系统调用大致可以分为如下几类：
 设备管理：设备请求、启动以及释放等； 文件管理：对文件的读写、创建和删除等； 进程控制：对进程的创建、销毁、阻塞和唤醒等； 进程通信：进程之间的消息传递； 内存管理：对内存的分配、回收以及获取内存区大小和地址等。   用户通过操作系统运行上层程序，上层程序依赖于操作系统的底层管理程序提供服务支持。当需要管理程序服务时，系统通过硬件中断机制进入核心态；当程序运行出现异常时，系统通过异常处理机制进入核心态。当管理程序结束时，用户程序继续运行，通过之前中断处理程序或者异常处理程序保存的中断现场，返回断点处继续执行。</description>
    </item>
    
    <item>
      <title>Leetcode题解（7）：股票问题</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A37%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 24 Apr 2021 19:11:33 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A37%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</guid>
      <description>I LeetCode121.买卖股票的最佳时机
 题目很简单，所以直接写了。思路就是遍历数组，维护一个最小值，以及一个最大差值。在遍历过程中不断计算差值，如果当前值比最小值小则更新最小值，如果当前差值比最大差值大则更新差值。
func maxProfit(prices []int) int { min, res := prices[0], 0 for _, v := range prices { if v &amp;lt; min { min = v } else if res &amp;lt; v - min { res = v - min } } return res } II LeetCode122.买卖股票的最佳时机II
 与上一题不同的是这次可以多次购买，但是同样很简单，只要差值是正数就可以直接加在结果上。
func maxProfit(prices []int) int { min, res := prices[0], 0 for _, v := range prices { if v &amp;lt; min { min = v } else { res += v-min min = v } } return res }  我们可以把第二题看成维护两个状态，买入 $buy$ 和卖出 $sell$ ，从而第二题可以这样实现：</description>
    </item>
    
    <item>
      <title>StampedLock源码解读</title>
      <link>https://z217blog.cn/post/stampedlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Tue, 30 Mar 2021 14:05:51 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/stampedlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>1. 字段 // 处理器数量 private static final int NCPU = Runtime.getRuntime().availableProcessors(); // 入队前的最大重试次数 private static final int SPINS = (NCPU &amp;gt; 1) ? 1 &amp;lt;&amp;lt; 6 : 0; // 作为首节点阻塞前的最大重试次数 private static final int HEAD_SPINS = (NCPU &amp;gt; 1) ? 1 &amp;lt;&amp;lt; 10 : 0; // 再次阻塞前的最大重试次数 private static final int MAX_HEAD_SPINS = (NCPU &amp;gt; 1) ? 1 &amp;lt;&amp;lt; 16 : 0; // 等待自旋上溢的闲置时期，必须为2的幂次-1 private static final int OVERFLOW_YIELD_RATE = 7; // 在上溢前记录读锁的位数，占据低位 private static final int LG_READERS = 7; // 每次读增加的单位 private static final long RUNIT = 1L; // 写锁所在位数 // 1000 0000 private static final long WBIT = 1L &amp;lt;&amp;lt; LG_READERS; // 读锁所在位数 // 0111 1111 private static final long RBITS = WBIT - 1L; // 读锁上限 // 0111 1110 private static final long RFULL = RBITS - 1L; // 掩码 // 1111 1111 private static final long ABTIS = RBITS | WBITS; // 读锁反数 // 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1000 0000 private static final long SBITS = ~RBITS; // 锁状态初始值 // 0001 0000 0000 private static final long ORIGIN = WBIT &amp;lt;&amp;lt; 1; // 取消获取锁时的特殊状态，表示中断 private static final long INTERRUPTED = 1L; // 等待状态 private static final int WAITING = -1; // 取消状态 private static final int CANCELLED = 1; // 节点读模式 private static final int RMODE = 0; // 节点写模式 private static final int WMODE = 1; // CLH队列首节点 private transient volatile WNode whead; // CLH队列尾节点 private transient volatile WNode wtail; // 视图 transient ReadLockView readLockView; transient WriteLockView writeLockView; transient ReadWriteLockView readWriteLockView; // 锁队列状态 // 高24位为版本号，每次获取和释放写锁都会+1，25位为写锁标志，剩余7位为读锁计数，记录当前读锁数量 private transient volatile long state; // 额外的读锁计数 private transient int readerOverflow; 2.</description>
    </item>
    
    <item>
      <title>Leetcode题解（6）：用Rand7实现Rand10</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A36%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/</link>
      <pubDate>Fri, 26 Mar 2021 20:08:53 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A36%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/</guid>
      <description>LeetCode470
 在解决这道题之前，我们可以先查看一个反过来的情况——用 $Rand10()$ 实现 $Rand7()$ ，可以直接发现实现方式就是不断用 $Rand10()$ 生成随机数，直到生成的数字处于 $1 \sim 7$ 之间即可。也就是说，如果可以生成的数字范围要大于待生成的数字范围，可以通过不断循环直到获取落在生成范围里面的数字的方式实现。 利用上述思想，我们可以很容易的想出这道题的解法——利用 $Rand7()$ 构造一个生成的数字范围大于 $1 \sim 10$ 的随机数生成器即可。要想构造这样的生成器，我们可以再观察下 $Rand10()$ 。如果我们想要用 $Rand10()$ 构造一个生成数字范围在 $1 \sim 99$ 之间的随机数生成器，可以使用如下算法 $(Rand10() - 1) * 10 + Rand10()$ ，也就是生成两次，一个作为十位一个作为个位。可以很容易发现这种算法生成的数字是随机均匀分布的。 使用 $Rand10()$ 的例子生成的是 $10$ 进制二位数，利用同样的思想我们也可以生成 $7$ 进制二位数，即 $(Rand7() - 1) * 7 + Rand7()$ ，使用这种方式生成的数字也是随机均匀分布的。将其转为 $10$ 进制后，数字范围落在 $1 \sim 49$ 之间，如果直接抛弃 $11 \sim 49$ 之间的数字，那么可能需要重复调用很多次。因此我们可以只抛弃 $41 \sim 49$ 之间的数字，对剩余的数字采用取模运算，实现方式如下：
class Solution extends SolBase { public int rand10() { int num; do { num = (rand7() - 1) * 7 + rand7(); } while (num &amp;gt; 40); return num % 10 + 1; } }  上述的实现方式是抛弃了 $41 \sim 49$ 之间的数字，抛弃了 $9$ 个数字的实现方式还是有点多的。从我们之前的讲解来看，可以不局限于生成两位数，三位数、四位数也是可以的，因此我们也可以这样实现：首先生成 $7$ 进制两位数，如果不大于 $40$ ，返回，否则利用两位数再次生成 $3$ 位数、$4$ 位数。对于 $Rand7()$ ，我们只需要生成到 $7$ 进制 $4$ 位数就行了，因为 $7^3=243$ ，$7^4=1701$ ，也就是 $4$ 位数最多只需要抛弃 $1$ 个数字，而如果是 $5$ 位数，则又要抛弃 $7$ 个数字才行。 我们也可以利用取模 $10$ 这个点来进一步简化算法。如果生成的数字在 $41 \sim 49$ 之间，没有必要直接用该数字进行计算，因为 $40$ 在取模这一步会被消掉，无论乘以哪个数字，所以我们可以将生成的数字减去 $40$ 再进行计算。减去 $40$ 后生成的数字范围在 $1 \sim 63$ 之间，同样的，如果生成了 $61 \sim 63$ 之间的数字，也可以减去 $60$ 后再计算。实现方式如下：</description>
    </item>
    
    <item>
      <title>Redis底层数据结构实现</title>
      <link>https://z217blog.cn/post/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 25 Mar 2021 23:02:23 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>1. 对象  Redis中的每个键值对都是由两个对象结构表示，定义在 $server.h$ 文件中。
// 对象类型 #define OBJ_STRING 0 #define OBJ_LIST 1 #define OBJ_SET 2 #define OBJ_ZSET 3 #define OBJ_HASH 4 #define OBJ_MODULE 5 #define OBJ_STREAM 6 // 对象编码 #define OBJ_ENCODING_RAW 0 // SDS #define OBJ_ENCODING_INT 1 // 长整型 #define OBJ_ENCODING_HT 2 // 字典 #define OBJ_ENCODING_ZIPMAP 3 #define OBJ_ENCODING_LINKEDLIST 4 #define OBJ_ENCODING_ZIPLIST 5 // 压缩列表 #define OBJ_ENCODING_INTSET 6 // 整数集合 #define OBJ_ENCODING_SKIPLIST 7 // 跳表 #define OBJ_ENCODING_EMBSTR 8 // embstr编码的SDS #define OBJ_ENCODING_QUICKLIST 9 #define OBJ_ENCODING_STREAM 10 // 对象结构 typedef struct redisObject { unsigned type:4; // 类型  unsigned encoding:4; // 编码  unsigned lru:LRU_BITS; // 最后一次访问时间  int refcount; // 引用计数  void *ptr; // 底层指针 } robj; 1.</description>
    </item>
    
    <item>
      <title>ReentranLock源码解读</title>
      <link>https://z217blog.cn/post/reentranlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 20 Mar 2021 22:27:10 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/reentranlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>$ReentrantLock$ 是一个可重入的独占锁，与 $synchronized$ 行为类似，但提供了额外的功能。
1. 构造函数 // 默认为非公平锁 public ReentrantLock() { sync = new NonfairSync(); } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 2. 内部类 abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; abstract void lock(); // 非公平上锁, tryAcquire方法在子类中实现  final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { // 锁未被占有  if (compareAndSetState(0, acquires)) { // 尝试获取锁  setExclusiveOwnerThread(current); // 设置独占线程  return true; } } else if (current == getExclusiveOwnerThread()) { // 当前线程已经占有锁  int nextc = c + acquires; if (nextc &amp;lt; 0) throw new Error(&amp;#34;Maximum lock count exceeded&amp;#34;); setState(nextc); // 添加上锁次数  return true; } return false; } protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.</description>
    </item>
    
    <item>
      <title>AQS源码解读</title>
      <link>https://z217blog.cn/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Fri, 19 Mar 2021 20:14:24 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>AQS提供了一个实现阻塞锁和相关的基于FIFO队列的同步器的框架。该类作为大部分依赖于一个状态字段的同步器的基础。子类必须定义 $protected$ 方法来改变状态，其他方法用于管理队列和实现阻塞机制。子类也可以包含其他状态字段，但必须通过原子性操作维护状态。
1. 成员变量 // 等待队列的头节点，懒加载，只能通过setHead方法修改 private transient volatile Node head; // 等待队列的尾部，懒加载，只能通过enq方法添加新节点 private transient volatile Node tail; // 同步状态 private volatile int state; // 如果超时时间大于该值，中断，单位为纳秒 static final long spinForTimeoutThreshold = 1000L; 2. 内部类Node static final class Node { // 节点在共享模式等待的标志  static final Node SHARED = new Node(); // 节点在独占模式等待的标志  static final Node EXCLUSIVE = null; // 表示线程被取消  static final int CANCELLED = 1; // 表示线程在释放资源后需要唤醒后继节点  static final int SIGNAL = -1; // 表示线程在等待condition  static final int CONDITION = -2; // 共享模式下表示无条件传播  static final int PROPAGATE = -3; // 等待状态  volatile int waitStatus; // 前驱节点  volatile Node prev; // 后继节点  volatile Node next; // 节点对应的线程  volatile Thread thread; // 下一个在condition上等待的节点，或者表示共享模式  Node nextWaiter; final boolean isShared() { return nextWaiter == SHARED; } final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() {} // 用于创建头节点或者共享标记  Node(Thread thread, Node mode) { this.</description>
    </item>
    
    <item>
      <title>进程间通信</title>
      <link>https://z217blog.cn/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Thu, 18 Mar 2021 19:44:57 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</guid>
      <description>进程经常需要与其他进程通信。进程间通信 ( $Inter\ \ Process\ \ Communication$, $IPC$ ) 最好使用一种结构良好的方式并且不要使用中断。进程间通信存在三个问题：一个进程如何把信息传递给另一个，如何确保两个或更多的进程在关键活动中不会出现交叉，以及进程之间执行顺序的正确性。 在一些操作系统中，协作的进程可能共享一些彼此都能读写的公用存储区，可能是一块内存，也可能是一个共享文件。当两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，就称为竞争条件 ( $race\ \ condition$ )。包含有竞争条件的程序在大多数情况下都不会出错，但在极少数情况下会产生一些奇怪的现象，尤其是在多核环境中更为明显。而要避免竞争条件带来的错误，关键是要找出某种途径来阻止多个进程同时读写共享数据。换言之，我们需要的是互斥 ( $mutual\ \ exclusion$ )，即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。 避免竞争条件的问题也可以用一种抽象的方式进行描述。一个进程的一部分时间做内部计算或另外一些不会引发竞争条件的操作。在某些时候进程可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作。我们把对共享内存进行访问的程序片段称作临界区域 ( $critical\ \ region$ ) 或临界区 ( $critical\ \ section$ )。如果我们能适当地安排，使得两个进程不可能同时处于临界区中，就能避免竞争条件。 尽管这样的要求避免了竞争条件，但它还不能保证使用共享数据的并发进程能够正确和高效地进行协作。对于一个好的解决方案，需要满足以下 $4$ 个条件：
 任何两个进程不能同时处于临界区； 不应对CPU的速度和数量做任何假设； 临界区外运行的进程不得阻塞其他进程； 不得使进程无限期等待进入临界区。  1. 互斥 1.1 屏蔽中断  在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽。CPU只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断后CPU将不会被切换到其他进程。于是，一旦某个进程屏蔽中断后，它就可以检查和修改共享内存，而不必担心其他进程介入。 但是这个方案并不好，因为屏蔽中断的权力交给了用户进程。而且对于多处理器系统，屏蔽中断指令仅仅对执行 $disable$ 指令的那个CPU有效，其他CPU仍然可以运行。另一方面，对于内核来说，屏蔽中断指令是非常方便的。所以屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。
1.2 锁变量  设想有一个共享锁变量，其初始值为 $0$ 。当一个进程想进入临界区时，会首先测试锁。如果锁的值为 $0$ ，则进程将其设置为 $1$ 并进入临界区。否则，进程等待直到值变为 $0$ 。虽然实现简单，但是却存在着多个进程同时读到 $0$ 的可能。
1.3 严格轮换法 // 进程a while (1) { while (turn !</description>
    </item>
    
    <item>
      <title>Leetcode题解（5）：LRU与LinkedHashMap</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A35lru%E4%B8%8Elinkedhashmap/</link>
      <pubDate>Tue, 16 Mar 2021 18:05:19 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A35lru%E4%B8%8Elinkedhashmap/</guid>
      <description>LeetCode146
 为了记录访问顺序，我们可以使用一个双向链表，首节点为最近最少访问的数据，尾节点为最近访问的数据。为了快速获取值，我们可以额外使用一个 $Map$ 存储键值映射。
public class LRUCache { private int capacity; private int size; private Map&amp;lt;Integer, Node&amp;gt; map; private Node head; private Node tail; public LRUCache(int capacity) { this.capacity = capacity; size = 0; map = new HashMap&amp;lt;&amp;gt;(); } public int get(int key) { Node node = getNode(key); return node == null ? -1 : node.val; } public void put(int key, int value) { Node node = getNode(key); if (node !</description>
    </item>
    
    <item>
      <title>Leetcode题解（4）：字符串相加</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A34%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Tue, 16 Mar 2021 15:50:38 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A34%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</guid>
      <description>LeetCode415
 题目挺简单的，也没有什么难点和要注意的点，正常写就行了。
public class Solution { public String addStrings(String num1, String num2) { int n1 = num1.length() - 1, n2 = num2.length() - 1, carry = 0; StringBuilder sb = new StringBuilder(); while (n1 &amp;gt;= 0 || n2 &amp;gt;= 0 || carry != 0) { int a = n1 &amp;gt;= 0 ? num1.charAt(n1) - &amp;#39;0&amp;#39; : 0; int b = n2 &amp;gt;= 0 ? num2.charAt(n2) - &amp;#39;0&amp;#39; : 0; int sum = a + b+ carry; carry = sum / 10; sb.</description>
    </item>
    
    <item>
      <title>Leetcode题解（3）：接雨水</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A33%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link>
      <pubDate>Sun, 14 Mar 2021 17:49:16 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A33%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid>
      <description>LeetCode42 参考题解
1. 动态规划  对于任意一个条形块 $height[i]$ ，能蓄水的必要条件是存在 $i &amp;gt; l &amp;gt; 0$ ，$i&amp;lt; r &amp;lt; n$ 使得 $height[l] &amp;gt; height[i]$ 并且 $height[r] &amp;gt; height[i]$ 。当上述条件成立时，这个条形块的蓄水量就等于 $min(height[l],\ height[r]) - height[i]$ 。所以我们可以记录每个条形块对应的左右两边最高的条形块，然后每次遍历时比较左右两边的最高条形块，并取其中较小者。
class Solution { public int trap(int[] height) { int n = height.length; if (n == 0) return 0; int[] left = new int[n]; int[] right = new int[n]; left[0] = height[0]; right[n - 1] = height[n - 1]; for (int i = 1; i &amp;lt; n; i++) left[i] = Integer.</description>
    </item>
    
    <item>
      <title>String.indexOf方法和KMP算法简介</title>
      <link>https://z217blog.cn/post/string.indexof%E6%96%B9%E6%B3%95%E5%92%8Ckmp%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 13 Mar 2021 21:14:45 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/string.indexof%E6%96%B9%E6%B3%95%E5%92%8Ckmp%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</guid>
      <description>1. String.indexOf  子字符串查找是字符串的一种基本操作：给定一段长度为 $N$ 的文本和一个长度为 $M$ 的模式 ( $pattern$ ) 字符串，在文本中找到一个和该模式相符的子字符串。对于一般的暴力式方法，在最坏的情况下运行时间与 $MN$ 成正比，但是在处理许多应用程序中的字符串时 ( 除了一些极端情况外 )，它的实际运行时间一般与 $M + N$ 成正比。另外，它很好地利用了大多数计算机系统中标准的结构特性，因此即使是更加巧妙的算法也很难超越它经过优化后的版本的性能。
public static int search(String pat, String txt) { int M = pat.length(); int N = txt.length(); for (int i = 0; i &amp;lt;= N; i++) { int j; for (j = 0; j &amp;lt; M; j++) if (txt.charAt(i + j) != pat.charAt(j)) break; if (j == M) return i; } return N; }  $String.</description>
    </item>
    
    <item>
      <title>TCP、UDP和DNS简介</title>
      <link>https://z217blog.cn/post/tcpudp%E5%92%8Cdns%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 06 Mar 2021 15:36:09 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/tcpudp%E5%92%8Cdns%E7%AE%80%E4%BB%8B/</guid>
      <description>1. TCP  TCP是一种面向连接的 ( $connection-oriented$ ) 协议，在一个应用进程向另一个应用进程发送数据之前，这两个进程必须先相互握手。TCP建立的连接是一条逻辑链接，其共同状态仅保留在两个通信端系统的TCP程序中。由于TCP协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持TCP连接状态。事实上，中间路由器看到的是数据报，而非TCP连接。 一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。TCP接收到数据后，会将数据引导到连接的发送缓存 ( $send\ \ buffer$ ) 里，发送缓存是发起三次握手期间设置的缓存之一。接下来TCP就会时不时从发送缓存里取出一块数据，并将数据传递到网络层。TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度 ( $Maximum\ \ Segment\ \ Size$ ，$MSS$ )。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度( 即所谓的最大传输单元 ( $Maximum\ \ Transmission\ \ Unit$ ，$MTU$ )) 来设置。以太网和PPP链路层协议都具有 $1500$ 字节的MTU，再加上TCP/IP首部长度 ( 通常为 $40$ 字节 ) ，因此MSS的典型值为 $1460$ 字节。 TCP为每块客户端数据配上一个TCP首部，从而形成多个TCP报文段 ( $TCP\ \ segment$ )。这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段之后，该报文段的数据就被放入该TCP连接的接收缓存中。
1.1 序号和确认号  TCP报文段首部中两个最重要的字段是序号字段和确认号字段。TCP把数据看成一个无结构的、有序的字节流。序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个报文段的序号 ( $sequence\ \ number\ \ for\ \ a\ \ segment$ ) 是该报文段首字节的字节流编号。 TCP是全双工协议，因此主机 $A$ 在向主机 $B$ 发送数据的同时，也许也接收来自主机 $B$ 的数据。从主机 $B$ 到达的每个报文段中都有一个序号用于从 $B$ 流向 $A$ 的数据。主机 $A$ 填充进报文段的确认号是主机 $A$ 期望从主机 $B$ 收到的下一字节的序号。假设主机 $A$ 已收到一个来自主机 $B$ 的包含字节 $0 \sim 535$ 的报文段，以及另一个包含字节 $900 \sim 1000$ 的报文段。由于某种原因，主机 $A$ 还没有收到字节 $536 \sim 899$ 的报文段。在这个例子中，主机 $A$ 为了重新构建主机 $B$ 的数据流，仍在等待字节 $536$ 。因此 $A$ 到 $B$ 的下一个报文段将在确认号字段中包含 $536$ 。因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供累计确认 ( $cumulative\ \ acknowledge$ )。当主机 $A$ 在收到第二个报文段 ( $536 \sim 899$ ) 之前收到第三个报文段 ( $900 \sim 1000$ )，这时候的处理方式TCP RFC并没有明确规定任何规则，编程人员有两种处理方式：丢弃或者缓存。显然，后一种选择对网络带宽而言更为有效，也是实践中采用的方法。 主机 $A$ 和主机 $B$ 之间数据的确认可以承载在数据的报文段中，而不需要重新发一个独立的确认报文段，这种确认称为捎带 ( $piggybacked$ )。主机之间也可以发送空报文段，通常用于确认已经收到数据。对于空报文段，虽然没有数据，但仍然需要分配一个序号，因为TCP中存在序号字段，报文段需要填入序号。</description>
    </item>
    
    <item>
      <title>HTTP协议介绍</title>
      <link>https://z217blog.cn/post/http%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 05 Mar 2021 22:19:56 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/http%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</guid>
      <description>1. HTTP  HTTP协议用于客户端和服务端之间的通信，通过请求和响应的交换达成通信。HTTP本身是一种不保存状态的协议，即无状态协议，每当有新请求发送，就会对应着有响应的产生。 请求报文和响应报文的首部内容由以下数据组成：
 请求行：包含请求方法、请求URI和HTTP版本； 状态行：包含表明响应结果的状态码、原因短语和HTTP版本； 首部字段：包含表示请求和响应的各种条件和属性的各类首部，一般有四类首部：通用首部、请求首部、响应首部和实体首部； 其他：可能包含HTTP的RFC里未定义的首部 ( 如Cookie等 )。   HTTP在传输数据时可以那招数据原貌直接传输，也可以在传输的过程中通过编码提升传输速率。报文 ( $message$ ) 是HTTP通信中的基本单位，由字节流组成；实体 ( $entity$ ) 是请求或响应的有效载荷数据，由实体首部和实体主体组成。通常报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容才会发生变化。 在传输大容量数据时，HTTP允许将数据分割，这种功能称为分块传输编码 ( $Chunked\ \ Transfer\ \ Coding$ )，允许将实体主体分块，每块使用十六进制标记大小，最后一块会使用 $0(CR+LF)$ 标记。为了发送多种类型实体，HTTP还采用了多部份对象集合，包含如下对象：$multipart/form-data$ 、$multipart/byteranges$ 。在使用时，需要在首部字段里加上 $Content-type$ 。 HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。
 代理：代理扮演了位于服务器和客户端的中间人的角色，接收请求和响应并进行转发。使用代理的理由有：利用缓存技术减少网络带宽流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等； 网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，就像自己拥有资源的服务器一样处理。使用网关能提高通信的安全性； 隧道是在相隔甚远的客户端和服务器之间进行中转，并保持双方通信连接的应用程序。隧道的目的是确保客户端能与服务器进行安全的通信。  1.1 请求 GET /index.htm HTTP/1.1 Host: xxxx.com  起始行开头的 $GET$ 表示请求访问服务器的类型，称为方法。$/index.htm$ 是请求访问的资源对象，也叫做请求URI ( $Request\ \ URI$ ) 。最后的 $HTTP/1.1$ 即HTTP版本号，指明客户端使用的HTTP协议版本。 HTTP使用URI定位互联网上的资源，可以指定完整路径，也可以通过与 $Host$ 字段结合指定相对路径。如果不是访问特定资源而是对服务器本身发起请求，可以使用 $*$ 代替请求URI，如下：
OPTIONS * HTTP/1.</description>
    </item>
    
    <item>
      <title>MySQL索引介绍</title>
      <link>https://z217blog.cn/post/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 04 Mar 2021 22:16:20 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</guid>
      <description>索引 ( 在MySQL中也叫做键 ( $key$ )) 是存储引擎用于快速找到记录的一种数据结构。索引优化是查询性能优化最有效的手段。
1. 基础  MySQL中，索引引擎首先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。
1.1 类型  索引有很多类型。在MySQL中，索引是在存储引擎层而不是服务层实现的，所以并没有统一的索引标准。
1.1.1 B-Tree  如果没有特别指明类型，那么通常所说的索引都是B-Tree索引，顾名思义，即使用B-Tree数据结构来存储数据。大多数MySQL引擎都支持这种索引。不过，底层的存储引擎也可能使用不同的存储结构，例如InnoDB使用的是B+Tree。存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。 B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。 B-Tree索引适用于全键值、键值范围或键值前缀查找。其中键值前缀查找只适用于根据最左前缀的查找。上述的索引对如下类型的查询有效：
 全值匹配 匹配最左前缀 匹配列前缀 匹配范围值 精确匹配某一列并范围匹配另外一列 只访问索引的查询   因为索引树的节点是有序的，所以除了按值查找外，索引还可以用于查询中的 $ORDER\ \ BY$ 操作。一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。
1.2 哈希索引  哈希索引 ( $hash\ \ index$ ) 基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，并存储在索引中，同时在哈希表中保存指向每个数据行的指针。在MySQL中，只有Memory引擎显式支持哈希索引，同时也是默认索引类型。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。 InnoDB引擎有一个特殊的功能叫做自适应哈希索引 ( $adaptive\ \ hash\ \ index$ )。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引。 如果存储引擎不支持哈希索引，可以模拟创建哈希索引，即增加一列，存储哈希值。MySQL提供了 $CRC32$ 函数用于计算哈希值，通过设置触发器，可以在每次插入时自动插入索引。不要使用 $SHA1$ 和 $MD5$ 作为哈希函数，因为这两个函数计算出来的哈希值是非常长的字符串。如果数据表非常大，$CRC32$ 会出现大量哈希冲突，这时也可以考虑自己实现哈希函数。
2. 优点  索引可以让服务器快速地定位到表的指定位置，但并非唯一作用。最常见的B-Tree索引，按照顺序存储数据，可以用于 $ORDER\ \ BY$ 和 $GROUP\ \ BY$ 操作。利用数据有序的特点，索引有如下三个优点：</description>
    </item>
    
    <item>
      <title>MySQL架构介绍</title>
      <link>https://z217blog.cn/post/mysql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 04 Mar 2021 22:16:10 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/mysql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</guid>
      <description>1. MySQL逻辑架构  最上层服务并不是MySQL独有，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构，比如连接处理、授权认证、安全等； 第二层架构是MySQL比较有意思的部分。大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等； 第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。存储引擎多种多样，服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含了几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析SQL ( InnoDB会解析外键定义 ) ，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。  1.1 连接管理与安全性  每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。在连接建立后，服务器会验证客户端是否具有执行某个特定查询的权限。
1.2 优化与执行  MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准。 对于 $SELECT$ 语句，在解析查询之前，服务器会先检查查询缓存 ( $Query\ \ Cache$ )，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。
2. 并发控制  在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL会通过锁定防止其他用户读取统一数据。大多数时候，MySQL的内部管理都是透明的。 所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。大多数商业数据库系统没有提供更多的选择，一般都是在表上施加行级锁 ( $row-level\ \ lock$ )，并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能地提供更好的性能。而MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。在存储引擎的设计中，锁管理是个非常重要的决定。将锁粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能，但同时却会失去对另外一些应用场景的良好支持。好在MySQL支持多个存储引擎的架构，所以不需要单一的通用解决方案。
 表锁 ( $table\ \ lock$ )：表锁是MySQL中最基本的锁策略，并且是开销最小的策略，它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他的读取的用户才能获得读锁，读锁之间是不相互阻塞的。尽管存储引擎可以管理自己的锁，但MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如 $ALTER\ \ TABLE$ 之类的语句使用表锁，而忽略存储引擎锁机制； 行级锁 ( $row\ \ lock$ )：行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。众所周知，在InnoDB和XtraDB，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。  3. 事务  事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。
 原子性 ( $atomicity$ )：一个事务必须被视为一个不可分割的最小工作单元； 一致性 ( $consistency$ )：数据库总是从一个一致性的状态转换到另外一个一致性的状态； 隔离性 ( $isolation$ )：一个事务所做的修改在最终提交以前，对其他事务是不可见的； 持久性 ( $durability$ )：一旦事务提交，其所做的修改就会永久保存到数据库中。   一个运行良好的事务处理系统，必须满足ACID特性。但在应用逻辑中，要想实现这一点很困难，甚至可以说是不可能完成的任务。一个兼容ACID的数据库系统，需要做很多复杂但可能用户并没有觉察到的工作。</description>
    </item>
    
    <item>
      <title>Java 8实战：日期和时间API</title>
      <link>https://z217blog.cn/post/java-8%E5%AE%9E%E6%88%98%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api/</link>
      <pubDate>Thu, 18 Feb 2021 18:39:00 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java-8%E5%AE%9E%E6%88%98%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api/</guid>
      <description>在Java 1.0中，对日期和时间的支持只能依赖 $java.util.Date$ 类。这个类无法表示日期，只能以毫秒的精度表示时间。而且由于某些原因未知的设计决策，这个类的易用性也不高。例如一个表示 $2014$ 年 $3$ 月 $18$ 日的 $Date$ 需要用以下方式创建：
Date date = new Date(114, 2, 18);  此外，$Date.toString$ 方法的返回值中虽然包含时区，但 $Date$ 并不支持时区。所以，在Java 1.1中，$Date$ 的许多方法被废弃，取而代之的是 $java.util.Calendar$ 类，但是这个类同样也存在着很多问题。比如月份依旧是从 $0$ 开始，而且没有提供 $DateFormat$ 方法。如果使用 $DateFormat$ 方法，那么又会带来并发问题，因为它不是线程安全的。为了解决上述问题，Java 8中新增的 $java.time$ 包中添加了新的日期和时间API。 $java.time$ 包中提供了一些新类：$LocalDate$ 、$LocalTime$ 、$Instant$ 、$Duration$ 和 $Period$ 。
1. LocalDate/LocalTime/LocalDateTime  $LocalDate$ 的实例是一个不可变对象，它只提供了简单的日期，并不包含当天的时间信息。另外，它也不附带任何与时区相关的信息。可以通过静态工厂方法 $of$ 创建一个 $LocalDate$ 实例，或者通过 $now$ 方法从系统时钟中获取当前日期，并通过 $getYear$ 、$getMonth$ 、$getDayOfMonth$ 等方法读取常用值。
LocalDate date = LocalDate.of(2014, 3, 18); // 2014-03-18 int year = date.</description>
    </item>
    
    <item>
      <title>Java 8实战：流处理</title>
      <link>https://z217blog.cn/post/java-8%E5%AE%9E%E6%88%98%E6%B5%81%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 17 Feb 2021 18:00:13 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java-8%E5%AE%9E%E6%88%98%E6%B5%81%E5%A4%84%E7%90%86/</guid>
      <description>流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流。基于流的思想，Java 8在 $java.util.stream$ 中添加了一个Stream API。 $Stream$&amp;lt;$T$&amp;gt; 就是一系列 $T$ 类型的项目。 和Collection API相比，Stream API处理数据的方式非常不同。用集合的话，需要使用 $for$ 循环迭代并处理元素，我们称之为外部迭代。相反，Stream API的数据处理完全是在库内部进行的，我们称之为内部迭代。虽然都能访问数据项目的序列，但是相比之下，Collection API主要是为了存储和访问数据，而Stream API主要用于描述对数据的计算。这里的关键点在于，Stream API允许并行处理一个 $Stream$ 中的元素。筛选一个 $Collection$ 最快的方式通常是将其转换为 $Stream$ ，进行并行处理，再转换回 $List$ 。粗略地说，流与集合之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，包含数据结构中目前所有的值，集合中的元素只有经过计算后才能添加；相比之下，流是在概念上固定的数据结构，不能通过流添加或删除元素，流中的元素是按需计算的，即只从流中提取出需要的值。与迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。要想重新遍历，可以从原始数据源中重新获取一个新的流。尝试再次遍历一个已经消费的流会抛出 $IllegalStateException$ 异常。流与集合的另一个关键区别在于遍历数据的方式，正如之前所说，使用 $Collection$ 接口需要用户进行外部迭代，而 $Steams$ 库使用的是内部迭代，即库自动完成迭代，并将流值存放在某个地方。相较于显式的外部迭代，内部迭代下项目可以透明地并行处理，或者用更优化的顺序进行处理，例如同时处理多个数据，或者优先处理某些数据等。
1. 流操作    操作 类型 返回类型 操作参数 函数描述符 目的     $filter$ 中间 $Stream$&amp;lt;$T$&amp;gt; $Predicate$&amp;lt;$T$&amp;gt; $T \rightarrow boolean$ 返回一个包含所有符合谓词的元素的流   $distinct$ 中间 $Stream$&amp;lt;$T$&amp;gt;   返回一个元素各异的流   $map$ 中间 $Stream$&amp;lt;$R$&amp;gt; $Function$&amp;lt;$T, R$&amp;gt; $T \rightarrow R$ 将函数应用到每个元素上，并映射成一个新元素   $flatMap$ 中间 $Stream$&amp;lt;$R$&amp;gt; $Function$&amp;lt;$T,R$&amp;gt; $T \rightarrow R$ 将多个生成流扁平化为单个流   $limit$ 中间 $Stream$&amp;lt;$T$&amp;gt;   返回一个不超过给定长度的流   $skip$ 中间 $Stream$&amp;lt;$T$&amp;gt;   返回一个跳过给定数量元素的流   $sorted$ 中间 $Stream$&amp;lt;$T$&amp;gt; $Comparator$&amp;lt;$T$&amp;gt; $(T, T) \rightarrow int$ 返回一个经过排序的流   $forEach$ 终端 $void$ $Consumer$&amp;lt;$T$&amp;gt; $T \rightarrow void$ 消费流中的每一个元素并对其应用Lambda，返回类型为 $void$   $count$ 终端 $long$   返回流中元素的个数，返回类型为 $long$   $collect$ 终端 $R$ $Collector$&amp;lt;$T, A, R$&amp;gt;  把流归约成一个集合并返回   $anyMatch$ 终端 $boolean$ $Predicate$&amp;lt;$T$&amp;gt; $T \rightarrow boolean$ 流中是否含有一个元素能匹配给定的谓词   $allMatch$ 终端 $boolean$ $Predicate$&amp;lt;$T$&amp;gt; $T \rightarrow boolean$ 流中的元素是否都能匹配给定的谓词   $noneMatch$ 终端 $boolean$ $Predicate$&amp;lt;$T$&amp;gt; $T \rightarrow boolean$ 流中是否没有元素与给定的谓词匹配   $findAny$ 终端 $Optional$&amp;lt;$T$&amp;gt;   返回当前流中的任意元素   $findFirst$ 终端 $Optional$&amp;lt;$T$&amp;gt;   返回当前流中第一个元素   $reduce$ 终端 $Optional$&amp;lt;$T$&amp;gt; $BinaryOperator$&amp;lt;$T$&amp;gt; $(T, T) \rightarrow T$ 对流中元素重复应用方法     诸如 $filter$ 或 $Sorted$ 等操作会返回另一个流，这让多个操作可以连接起来形成一个查询，这种操作称为中间操作。除非流水线上触发一个终端操作，否则中间操作不会执行任何处理。终端操作会从流的流水线生成结果，其结果是任何不是流的值，比如 $List$ 、$Integer$ 等。总而言之，流的使用一般包括三件事：一个数据源、一个中间操作链和一个终端操作。 诸如 $map$ 或 $filter$ 等操作会从输入流中获取每一个元素，并在输出流中得到 $0$ 或 $1$ 个结果。这些操作一般都是无状态操作。但诸如 $reduce$ 、$sum$ 、$max$ 等操作需要内部状态来累计结果，这些操作就是有状态操作。但是这些操作的内部状态很小，通常只是一些基本数据类型，不管流中有多少元素需要处理，内部状态都是有界的。而诸如 $sorted$ 或 $distinct$ 等操作，它们的内部状态可能很大，这时就要求无界的存储空间。 $peek$ 是一个特殊的流操作，可以在流的每个元素恢复运行之前，插入执行一个动作。$peek$ 不会恢复流的运行，而是在一个元素上完成操作之后，将操作顺承到流水线中的下一个操作。 Java 8引入了三个原始类型特化流接口 $IntStream$ 、$DoubleStream$ 和 $LongStream$ ，分别将流中的元素特化为 $int$ 、$long$ 和 $double$ ，从而避免了暗含的装箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的 $sum$ ，此外还可以在必要时将它们转换回对象流。将流转换为特化版本的常用方法是 $mapToInt$ 、$mapToDouble$ 和 $mapToLong$ 。这些方法和 $map$ 的工作方式一样，但是会返回特化流。如果想要将特化流转换为对象流，可以使用 $boxed$ 方法。类似的，也可以使用 $mapToObj$ 方法生成对象流。 Java 8还引入了两个可以用于 $IntStream$ 和 $LongStream$ 的静态方法，帮助生成数值范围，分别是 $range$ 和 $rangeClosed$ ，前者为开区间，后者为闭区间。 除了调用集合中的 $stream$ 方法之外，还有一些其他的构造流的方式：</description>
    </item>
    
    <item>
      <title>JVM（10）：线程安全与锁优化</title>
      <link>https://z217blog.cn/post/jvm10%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</link>
      <pubDate>Wed, 13 Jan 2021 21:17:10 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm10%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</guid>
      <description>1. 线程安全  按照线程安全程度由强到弱，可以将Java语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。
1.1 不可变  在Java语言里，不可变 ( $Immutable$ ) 对象一定是线程安全对象，因此不需要进行任何线程安全保障措施。对于基本数据类型，只需要在定义时使用 $final$ 关键字即可保证不可变。而对于对象类型，Java语言目前暂时还没有提供支持，因此只能让对象自行保证行为不会影响状态，其中最简单的一种方式就是把所有带有状态的变量都声明为 $final$ 。
1.2 绝对线程安全  绝对线程安全指的是当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果。而实际上，要想达到绝对线程安全可能需要付出非常高昂的代价。Java API中标注线程安全的类，大多数都不是绝对线程安全的。例如 $java.util.Vector$ 是一个线程安全的容器，因为它的很多方法被 $synchronized$ 修饰，但是在以下情况下还是线程不安全的：
private static Vector&amp;lt;Integer&amp;gt; vector = new Vector&amp;lt;&amp;gt;(); public static void main(String[] args) { while (true) { for (int i = 0; i &amp;lt; 10; i++) vector.add(i); Thread removeThread = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &amp;lt; vector.</description>
    </item>
    
    <item>
      <title>JVM（9）：内存模型与线程</title>
      <link>https://z217blog.cn/post/jvm9%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 12 Jan 2021 21:13:32 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm9%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>1. 内存模型 1.1 主内存与工作内存  Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。在这里主要考虑的问题是多线程对同一块内存区域进行的操作，因此并不需要考虑一些线程私有的变量比如局部变量和方法参数。Java内存模型规定了所有变量都存储在主内存 ( $Main\ \ Memory$ ) 中，每条线程允许拥有自己的工作内存 ( $Working\ \ Memory$ )，保存了主内存中要使用的变量的副本。对于引用对象，工作内存中并不会包含整个对象的副本，而是对象引用以及对象中要使用的字段的副本。通过工作内存，线程的所有的对变量的操作都会在工作内存中进行，即通过工作内存间接访问主内存。
1.1 内存间交互  主内存与工作内存之间的交互协议指的是一个变量如何从主内存拷贝到工作内存，并从工作内存同步至主内存的过程。Java内存模型定义了 $8$ 种原子性操作：
 $lock$ ：作用于主内存变量，将变量标识为线程独占状态； $unlock$ ：作用于主内存变量，把释放一个处于线程独占状态的变量； $read$ ：作用于主内存变量，将一个变量传输到工作内存中； $load$ ：作用于工作内存变量，将一个主内存传输的变量载入工作内存的副本中； $use$ ：作用于工作内存变量，每当虚拟机遇到一个需要使用变量的字节码指令时，将变量传递给执行引擎； $assign$ ：作用于工作内存变量，每当虚拟机遇到一个给变量赋值的字节码指令时，从执行引擎接收值并赋给变量； $store$ ：作用于工作内存变量，将一个变量传送到主内存中； $write$ ：作用于主内存变量，将一个工作内存传送的变量写入主内存的变量中。   如果要把一个变量从主内存拷贝到工作内存中，就需要顺序执行 $read$ 和 $load$ 操作；反过来，如果要把一个变量从工作内存拷贝到主内存中，就需要顺序执行 $store$ 和 $write$ 操作。Java内存模型虽然规定了上述操作要顺序执行，但并没有要求连续执行，也就是说可以读取多个变量后再依次载入，或者存储多个变量后再依次写入。除此之外，还有其他规则：
 不允许 $read$ 和 $load$ 、$store$ 和 $write$ 单独出现； 不允许线程丢弃 $assign$ 操作； 不允许线程在没有进行 $assign$ 操作时同步内存； 不允许在工作内存中直接 $use$ 一个未被初始化的变量； 一个变量在一个时刻只能被一个线程 $lock$ ，一个线程可以多次执行 $lock$ 操作，后续需要执行相应次数的 $unlock$ 才能解锁； 对一个变量执行 $lock$ 操作会清除变量值，需要重新执行 $load$ 或者 $assign$ 进行赋值； 不允许对一个没有被锁定的变量 $unlock$ ，也不允许 $unlock$ 其他线程独占的变量； $unlock$ 变量前需要先对其进行 $store$ 和 $write$ 。  1.</description>
    </item>
    
    <item>
      <title>JVM（8）：后端编译与优化</title>
      <link>https://z217blog.cn/post/jvm8%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 09 Jan 2021 20:58:35 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm8%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
      <description>1. 即时编译器  目前主流的两款商用Java虚拟机里，Java程序最初都是通过解释器执行的。当虚拟机发现某个方法或者代码块运行频繁，就会把代码认为是热点代码 ( $Hot\ \ Spot\ \ Code$ )，并将这些代码编译为本地机器码，同时进行代码优化。完成这个任务的后端编译器就称为即时编译器。
1.1 解释器与编译器  当程序需要迅速启动和执行时，解释器可以省去编译时间立即运行；当程序启动后，越来越多的代码会被编译成本地代码，从而减少解释器带来的中间损耗，获得更快的执行速度。如果程序运行环境中内存限制过大，可以使用解释执行从而节约内存，反之可以使用编译执行提升效率。当编译器采取的优化手段出现罕见陷阱 ( $Uncommon\ \ Trap$ ) 时，可以通过逆优化 ( $Deoptimization$ ) 退回到解释状态执行。 HotSpot虚拟机中内置了两个（或三个）即时编译器，其中两个存在已久的编译器分别称为客户端编译器 ( $Client\ \ Compiler$ ) 和服务端编译器 ( $Server\ \ Compiler$ )，简称为 $C1$ 编译器和 $C2$ 编译器。第三个编译器是JDK 10时出现的，目标是替代 $C2$ 的 $Graal$ 编译器。 在分层编译 ( $Tiered\ \ Compilation$ ) 的工作模式出现前，通常采用解释器与一个编译器直接搭配的方式工作，这时用户也可以通过 $-client$ 和 $-server$ 参数直接运行模式。解释器与编译器搭配使用的方式称为混合模式 ( $Mixed\ \ Mode$ )，也可以通过 $-Xint$ 或者 $-Xcomp$ 强制运行解释模式或者编译模式。 即时编译需要占用程序运行时间，而且编译过程中还需要进行优化。要想达到好的优化效果，解释器需要替编译器收集性能监控信息。当然，这也会影响解释执行的速度。为了寻求启动响应速度与运行效率之间的平衡，HotSpot虚拟机在编译子系统中加入了分层编译，包括：
 第 $0$ 层，程序解释执行，不开启性能监控； 第 $1$ 层，使用客户端编译器，进行简单优化，不开启性能监控； 第 $2$ 层，使用客户端编译器，开启方法和回边次数统计等监控； 第 $3$ 层，使用客户端编译器，开启全部性能监控，除了第 $2$ 层的统计信息外，还会收集分支跳转、虚方法等统计信息； 第 $4$ 层，使用服务端编译器将字节码编译为本地代码，需要更多的优化，还可能采取一些不可靠的激进优化。   实施分层编译后，解释器、客户端编译器、服务端编译器就会同时工作，热点代码可能会被多次编译。使用客户端编译器编译可以获得更高的编译速度，使用服务端编译器可以获得更好的编译质量。</description>
    </item>
    
    <item>
      <title>JVM（7）：前端编译与优化</title>
      <link>https://z217blog.cn/post/jvm7%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
      <pubDate>Fri, 08 Jan 2021 20:09:14 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm7%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
      <description>1. Javac编译器  Javac是一个由Java语言编写的程序，从其代码总体结构来看，可以将编译过程大致分为 $1$ 个准备过程和 $3$ 个处理过程：
 准备过程：初始化插入式注解处理器 解析与填充符号表过程，包括词法分析、语法分析和符号表创建 插入式注解处理器的注解处理过程 分析与字节码生成过程，包括标注检查、数据流及控制流分析、解语法糖和字节码生成   在上述处理过程中，执行插入式注解时可能又会产生新的符号。如果产生新的符号，就必须对它们进行解析，因此又回到了步骤 $2$ 。Javac编译动作的入口是 $com.sun.tools.javac.main.JavaCompiler$ 类，上述 $3$ 个过程的代码逻辑集中在这个类的 $compiler(\ )$ 和 $compiler2(\ )$ 方法。
1.1 解析与填充符号表  解析过程通过 $JavaCompiler.parseFiles(\ )$ 方法发起。
1.1.1 词法、语法分析  词法分析过程由 $com.sun.tools.javac.parser.Scanner$ 类完成。语法分析过程由 $com.sun.tools.javac.parser.Parser$ 类完成，产出的抽象语法树以 $com.sun.tools.javac.tree.JCTree$ 类表示。在完成词法、语法分析之后，编译器后续的操作都建立在抽象语法树的基础上，不会再对源码进行操作了。
1.1.2 填充符号表  填充符号表过程通过 $JavaCompiler.enterTrees(\ )$ 方法发起，由 $com.sun.tools.javac.comp.Enter$ 类完成，产出一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级结点。
1.2 注解处理器  在JDK 5时，注解只会在程序运行期间发挥作用。JDK 6中提供了一组称为“插入式注解处理器”的标准API，使得特定注解的处理可以提前至编译期进行。插入式注解处理器可以读取、修改和添加抽象语法树的元素。如果在这个过程中发生了修改操作，那么编译器需要返回解析与填充符号表过程重新处理。
1.3 语义分析与字节码生成  抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义符合逻辑，因此需要进行语义分析对源程序进行上下文相关性质的检查，譬如类型检查、控制流检查、数据流检查等。
1.3.1 标注检查  标注检查由 $JavaCompiler.attribute(\ )$ 方法发起。标注检查步骤要检查的内容包括变量使用前是否已声明、变量与赋值之间的数据类型是否匹配等。此外还会进行常量折叠 ( $Constant\ \ Folding$ ) 。</description>
    </item>
    
    <item>
      <title>JVM（6）：字节码执行引擎</title>
      <link>https://z217blog.cn/post/jvm6%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</link>
      <pubDate>Wed, 14 Oct 2020 17:02:05 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm6%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</guid>
      <description>1. 运行时栈帧  JVM以方法作为最基本的执行单元，栈帧 ( $Stack\ \ Frame$ ) 是用于支持虚拟机进行方法调用和方法执行背后的数据结构，也是虚拟机运行时数据区中的虚拟机栈 ( $Virtual\ \ Machine\ \ Stack$ ) 的栈元素，存储了方法的局部变量表、操作数栈、动态连接和方法返回地址和一些额外的附加信息，方法表的 $Code$ 属性包含了栈帧所需的局部变量表和操作数栈的大小。对于执行引擎来讲，在每个线程中，只有处于调用堆栈栈顶的方法才是正在运行的方法，称为当前栈帧 ( $Current\ \ Stack\ \ Frame$ )，与这个栈帧关联的方法称为当前方法 ( $Current\ \ Method$ )。
1.1 局部变量表  局部变量表 ( $Local\ \ Variable\ \ Table$ ) 是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量，其最大容量由方法 $Code$ 属性中的 $max_-locals$ 数据项决定。局部变量表以变量槽 ( $Variable\ \ Slot$ ) 为最小单位，每个变量槽都应该能存放一个 $boolean$ 、$byte$ 、$char$ 、$short$ 、$int$ 、$float$ 、$reference$ 或 $returnAddress$ 类型的数据。这些数据长度一般都为 $32$ 位 ( $reference$ 可能为 $64$ 位 )，也意味着变量槽的长度至少为 $32$ 位。而对于 $64$ 位的数据类型，比如 $long$ 和 $double$ ，会通过高位对齐的方式分配两个连续的变量槽。</description>
    </item>
    
    <item>
      <title>JVM（5）：类加载</title>
      <link>https://z217blog.cn/post/jvm5%E7%B1%BB%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Tue, 22 Sep 2020 22:20:52 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm5%E7%B1%BB%E5%8A%A0%E8%BD%BD/</guid>
      <description>1. 类加载的时机  一个类型从被加载到卸载的过程中，会经历加载 ( $Loading$ )、验证 ( $Verification$ )、准备 ( $Preparation$ )、解析 ( $Resolution$ )、初始化 ( $Initialization$ )、使用 ( $Using$ ) 和卸载 ( $Unloading$ ) 七个阶段，其中可以把验证、准备、解析统称为连接 ( $Linking$ )。这些阶段之间可以交叉进行。加载、验证、准备、初始化、卸载的顺序是确定的，解析阶段则不一定，可能开始在初始化之后。
《Java虚拟机规范》中并没有规定什么时候需要进行加载，但是严格规定了有且只有六种情况需要进行初始化：
 执行 $new$ 、$getstatic$ 、$putstatic$ 、$invokestatic$ 四条字节码指令时，如果类型没有初始化，需要先进行初始化阶段。这四条字节码指令分别对应：使用 $new$ 创建对象实例、读取和设置静态字段 ( $final$ 字段除外，因为它在编译器就已被置入常量池 )、调用静态方法； 对类型进行反射调用时，如果类型没有初始化，需要先进行初始化阶段； 初始化类时如果父类没有初始化，需要先初始化父类； 虚拟机启动时，主类需要先进行初始化； JDK 7之后，如果一个 $java.lang.invoke.MethodHandle$ 实例的解析结果为 $REF_-getStatic$ 、$REF_-putStatic$ 、$REF_-newInvokeSpecial$ 四种类型的方法句柄时，如果该方法句柄对应的类没有初始化，需要先进行初始化阶段； JDK 8之后，接口中包含 $default$ 方法时，在其实现类发生初始化前，需要先进行接口的初始化阶段。   这六种情况触发初始化场景的行为称为主动引用，除此之外的引用称为被动引用。例如通过子类访问父类的静态字段并不会触发子类的初始化，只会触发父类的初始化；声明一个引用数组并不会触发引用类型的初始化，而是初始化一个数组类型。
与类相同，接口也具有初始化过程。虽然接口中不能使用静态代码块，但是编译器仍然会生成 &amp;lt;$clinit$&amp;gt;$(\ )$ 类构造器，用于初始化成员变量。在前面的六种主动引用触发场景中，只有在初始化父类时才会对接口进行初始化。但是一个接口在初始化时，并不要求其父接口全部初始化，只有在用到时才需要进行初始化。
2. 类加载的过程 2.1 加载  类加载过程，虚拟机需要完成以下三件事：</description>
    </item>
    
    <item>
      <title>回溯算法：八皇后</title>
      <link>https://z217blog.cn/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%AB%E7%9A%87%E5%90%8E/</link>
      <pubDate>Sat, 19 Sep 2020 16:11:12 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%AB%E7%9A%87%E5%90%8E/</guid>
      <description>原题地址：Problem 51
 将 $N$ 个皇后放在 $N \times N$ 的棋盘上，要求皇后不能处于同行、同列、同对角线上。没有什么取巧的方案，只能尝试所有情况后将可行的情况列出，因此可以使用回溯算法。
此题的难点在于判断皇后之间是否能相互攻击。如果将皇后所处的格子视为 $1$ ，其它格子视为 $0$ ，那么就可以使用位运算来判断。保证皇后不同行的方式很简单，只需要保证每一行只放置一个皇后即可。而如果想要保证皇后不同列，就需要记录之前行的皇后的位置。我们可以通过按位或和按位和进行记录和判断。
 $$ .\ \ Q\ .\ \ .\ \ \\ .\ \ .\ \ .\ \ Q\ \\ Q\ .\ \ .\ \ .\ \ \\ .\ \ .\ \ Q\ .\ \ \\ $$   对于上面的例子，第一行我们可以记为 $0100$ 。到第二行通过按位和进行判断：$0100 \And 0001$ ，如果不为 $0$ ，说明发生冲突。如果没有冲突，那么可以通过按位或获取新值：$0100 | 0001 = 0101$ 。重复上述步骤即可保证皇后处于不同列。
如果要保证皇后不处于同对角线，进行观察可以发现：下一行的皇后不能处于上一行皇后的左一格或者右一格，不能处于上上一行皇后的左二格或者右二格……也就是每过一行，就让之前行的皇后统一左移或者右移一格，然后再使用类似于之前判断皇后是否同列的方法进行判断就行了。我们可以使用两个数字 $left$ 和 $right$，专门用于记录之前行皇后的左移或者右移。再以上面的例子，第二行的 $left$ 为 $1000$ ，第三行为 $0010$ ；第二行的 $right$ 为 $0010$ ，第三行的 $right$ 为 $0001$ 。</description>
    </item>
    
    <item>
      <title>JVM（4）：Class文件结构</title>
      <link>https://z217blog.cn/post/jvm4class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 17 Sep 2020 22:58:37 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm4class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</guid>
      <description>1. 平台无关性  Java在刚刚诞生时就有一句非常著名的口号：一次编写，到处运行。这个想法通过虚拟机实现，这些虚拟机都可以执行同一种与平台无关的字节码，从而达到一次编写，到处运行。可以说，字节码就是平台无关性的基石。Java虚拟机并不与Java语言绑定，在其之上还可以运行许多其他语言，如Kotlin、Groovy和Scala等。Java虚拟机唯一绑定的是类似于Class文件这种特殊的二进制文件，其中包含了Java虚拟机的指令集、符号表以及其他辅助信息。通过Class文件，Java虚拟机并不需要关心来源是什么语言，只要这门语言能够生成可以被读取的Class文件，那么它就可以在Java虚拟机上运行。
Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会转成字节码指令的组合，这就要求字节码指令的表达能力必须比Java语言的表达能力更强。从而，一些Java语言中并不支持的特性，字节码也能够表达出来。
2. Class类文件  Class文件是一组以 $8$ 个字节为单位的二进制流，数据项目按照顺序紧凑地排列在文件之中。对于 $8$ 字节以上空间的数据项，会按照高位在前的大端序分割存储在若干个 $8$ 字节中。
Class文件采取一种类似于C语言结构体的伪结构来存储数据，包含两种数据类型：
 无符号数：即基本数据类型，通过 $u1$ 、$u2$ 、$u3$ 、$u4$ 分别表示 $1$ 个字节、$2$ 个字节、$4$ 个字节和 $8$ 个字节的无符号数，用于表示数字、索引引用、数量值或者UTF-8编码的字符串； 表：由多个无符号数或者其他表构成的复合数据类型，一般以 $_-info$ 结尾，用于表示具有层次关系的数据。可以把整个Class文件都视为表，按照对应类型的数据紧凑排列而成。   当需要描述类型相同但数量不定的数据时，经常会使用一个前置的容器计数器加若干个连续的数据项的形式，称为该类型的集合。
2.1 魔数和版本号  Class文件的头 $4$ 字节称为魔数 ( $Magic\ \ Number$ )，用于确定该文件能否被虚拟机接受。魔数在很多文件格式中都存在，文件格式制定者可以自定义魔数，只要不会引起混淆。Class文件的魔数为 $0xCAFEBABE$ ，象征着一款咖啡。
在魔数之后是Class文件的版本号，前两个字节是次版本号 ( $Minor\ \ Version$ )，后两个字节是主版本号 ( $Major\ \ Version$ )。Java主版本号从 $45$ 开始，JDK 1.1之后每个大版本都会在之前的基础上加 $1$ 。次版本号在JDK 1.1及以前曾经短暂使用过，在JDK 1.2之后废弃，全部使用 $0$ 代替，直到JDK 12，由于一些复杂特性需要进行公测，于是重新启用了次版本号。
2.2 常量池  常量池是Class文件中第一次出现表的数据项目，也是与其他项目关联最多的数据，通常也是最庞大的数据项目之一。常量池入口是一个 $u2$ 类型的数据，是常量池容量计数值 ( $constant_-pool_-count$ )，从 $1$ 开始，$0$ 表示不指向常量池中的数据项目。Class文件中只有常量池的容量计数是从 $1$ 开始的。</description>
    </item>
    
    <item>
      <title>快速乘算法简介</title>
      <link>https://z217blog.cn/post/%E5%BF%AB%E9%80%9F%E4%B9%98%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 15 Sep 2020 15:05:04 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E5%BF%AB%E9%80%9F%E4%B9%98%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</guid>
      <description>快速乘算法的原理是俄罗斯农民乘法，这种乘法规则很简单：
 将要相乘的两个数字写在两列； 将第一列乘以二，第二列除以二并写在下一行； 如果这一行中第二列数字为偶数，删去这一行； 在下一行重复上述二至三步直至第二列数字为 $1$ ； 将第一列未被删除的数字求和即为结果   以 $48 \times 58$ 为例：
 $$ \require{cancel} \bcancel{48}\qquad\bcancel{58}\\ 96\qquad29\\ \bcancel{192}\qquad\bcancel{14}\\ 384\qquad7\\ 768\qquad3\\ 1536\qquad1\\ ————\\ 2784\qquad $$   从而 $48 \times 58 = 2784$ 。
运用这个原理，我们可以对二进制数进行计算，只需要将原来的规则调整下即可。对于二进制数 $A$ 和 $B$ ，如果要计算 $A \times B$ ，那么可以：
 如果 $B$ 末位为 $1$ ，将 $A$ 加到结果上； 将 $A$ 左移一位，$B$ 右移一位； 重复上述两步直至 $B$ 为零。   将上述步骤用代码实现如下：
class QuickMulti { public int quickMulti(int A, int B) { int res = 0; while (B !</description>
    </item>
    
    <item>
      <title>Java注解</title>
      <link>https://z217blog.cn/post/java%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 07 Sep 2020 23:32:11 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java%E6%B3%A8%E8%A7%A3/</guid>
      <description>注解为在代码中添加信息提供了一种形式化的方式。Java SE5内置了三种定义在 $java.lang$ 当中的注解：
 $@Override$ ：表示当前定义的方法将覆盖超类中的方法； $@Deprecated$ ：表示方法被弃用，调用此类方法将引发警告； $@SuppressWarnings$ ：关闭某些编译警告信息。   除此之外还有四种注解，用于创建新注解。
1. 语法 1.1 定义 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { public int id(); public String description() default &amp;#34;no description&amp;#34;; }  注解的定义方式很像接口，也与接口一样会被编译为class文件。定义注解需要一些元注解。$@Target$ 定义注解的作用对象，如方法；$@Retention$ 定义的可用级别，分为源码 ( $SOURCE$ )、类文件 ( $CLASS$ )、运行时 ( $RUNTIME$ )。
在定义注解时也可以设置一些元素表示一些值，不同于接口，你可以为这些值设置默认值。如果没有提供默认值，那么在使用注解的时候就必须进行赋值。没有元素的注解称为标记注解 ( $marker\ \ annotation$ )。可用的注解元素包括以下类型：
 基本类型； $String$ ； $Class$ ； $enum$ ； $Annotation$ ； 以上类型的数组。  1.2 元注解  Java内置了四种元注解：</description>
    </item>
    
    <item>
      <title>Java I/O</title>
      <link>https://z217blog.cn/post/java-i-o/</link>
      <pubDate>Sun, 06 Sep 2020 21:28:06 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java-i-o/</guid>
      <description>1. File类  $File$ 类用于储存文件路径，可以代表一个特定文件或者一组文件的名称，如果是后者，可以通过 $list(\ )$ 获得一个字符数组。在不传入参数时，$list(\ )$ 方法返回全部列表，也可以接受一个 $FilenameFilter$ 类型的参数，实现目录过滤：
class DirFilter implements FilenameFilter { private Pattern pattern; public DirFilter(String regex) { pattern = Pattern.compile(regex); } public boolean accept(File dir, String name) { return pattern.matcher(name).matches(); } } public class DirList { public static void main(String[] args) { System.out.println(Arrays.toString(new File(&amp;#34;.&amp;#34;).list(new DirFilter(args[0])))); } }  除了代表文件和目录之外，$File$ 对象还可以用于创建和删除目录，查看文件信息等：
   方法 作用     $getAbsolutePath$ 返回绝对路径   $canRead$ 可读性   $canWrite$ 可写性   $getName$ 返回名称   $getParent$ 返回父目录   $getPath$ 返回路径   $lastModified$ 最后修改时间   $isFile$ 是否为文件   $isDirectory$ 是否为目录   $exists$ 是否存在   $mkdirs$ 创建   $delete$ 删除   $renameTo$ 重命名或移动文件    2.</description>
    </item>
    
    <item>
      <title>Java泛型</title>
      <link>https://z217blog.cn/post/java%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Wed, 02 Sep 2020 21:23:39 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java%E6%B3%9B%E5%9E%8B/</guid>
      <description>泛型允许一个类应用于多种类型，实现了参数化类型的概念。促使泛型产生的原因之一就是容器类，泛型可以用于指定一个容器具体要持有怎样的类型。当然，也可以通过泛型实现持有多个类型的类，如元组类：
public class TwoTuple&amp;lt;A, B&amp;gt; { public final A first; public final B second; public TwoTuple(A a, B b) { this.first = a; this.second = b; } }  如果需要长度更长的元组如三元组，我们可以在二元组的基础上声明三元组类，并令其继承二元组类。
除了具体类外，泛型还可以应用于抽象类和接口当中。
Java泛型存在着很多局限性，第一个就是不能以基本类型作为其类型参数。当然，通过Java自动包装和自动拆包的功能，基本类型和其包装类型可以很方便地进行转换。
之前提到的泛型都是应用于一个类上的，但是泛型同样可以应用于方法上，而且不仅可以应用于泛型类的方法上，也可以应用于普通类的方法上。如果通过使用泛型方法就可以避免使用泛型类，那么推荐使用泛型方法。此外，由于 $static$ 方法无法获取类型参数，因此如果要让 $static$ 方法使用泛型，那么就必须让其成为泛型方法。与使用泛型类不同，使用泛型方法时可以不用指定具体类型，通过类型参数推断，编译器可以为我们找出具体类型。
1. 擦除  通过泛型，我们可以声明一个 $ArrayList&amp;lt;Integer&amp;gt;$ 对象，然后我们可以获取 $ArraysList.class$ ，但是却不能获取 $ArrayList&amp;lt;Integer&amp;gt;.class$ 对象。这个行为说明了在编译器的眼中，$ArrayList&amp;lt;Integer&amp;gt;$ 和 $ArrayList&amp;lt;String&amp;gt;$ 是同一类型。更加夸张的是，不同于C++，在Java的泛型内，你无法获取任何有关于泛型参数类型的信息。这些行为的原因都是因为Java的泛型是使用擦除实现的。在基于擦除的实现中，泛型被认为是第二类类型，既不能在某些重要的上下文环境中使用的类型。泛型类型只有在静态类型检查期间才会出现，之后泛型类型将被擦除，并替换为非泛型边界如 $List$ , $Object$ 等。
在C++中，我们可以实现以下代码：
template&amp;lt;class T&amp;gt; class Test { T obj; public: Test(T t) { this.obj = t; } void f() { obj.</description>
    </item>
    
    <item>
      <title>Java类型信息</title>
      <link>https://z217blog.cn/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Sun, 30 Aug 2020 16:50:55 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</guid>
      <description>运行时类型信息 ( $RTTI$ ) 可以让我们在程序运行时发现和使用类型信息，主要有两种方式：传统RTTI，假定在编译时就已经知道了所有类型；以及反射，允许在运行时发现和使用类型信息。
1. RTTI  传统的RTTI在Java语句执行过程中也发挥着作用。
 我们定义了一个 $Circle$ 对象，将其存储在一 $List&amp;lt;Shape&amp;gt;$ 容器之中。那么当对象被放入容器时，会向上转型为 $Shape$ ；而在取出时，由于 $List$ 容器会将所有对象当作 $Object$ 类型持有，因此会再次转换为 $Shape$ 对象。
1.1 Class对象  $Class$ 对象负责表示运行时的类型信息，Java通过 $Class$ 对象执行RTTI。每个类都拥有一个 $Class$ 对象，当它被编译时，就会通过类加载器产生一个 $.class$ 文件，存储其 $Class$ 对象。
所有的类都是在被第一次使用时动态地被加载到JVM当中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。也就是说构造器也是静态的，因此使用 $new$ 创建对象就会创建一个对静态构造器的引用，从而使得这个类被加载。当类的 $Class$ 对象被载入后，这个类的所有对象都会使用 $Class$ 对象创建。$Class$ 对象还有一些常用方法：
 $forName(\ )$ ：通过全类名获取对应类的 $Class$ 对象； $getName(\ )$ ：获取全限定的类名； $getSimpleName(\ )$ ：获取不含包名的类名； $getInterfaces(\ )$ ：$Class$ 对象中实现的接口； $getSuperclass(\ )$ ：获取基类的 $Class$ 对象。   $Class.newInstance(\ )$ 方法允许你在不知道确切类型的情况下创建对象。通过该方法你可以得到一个 $Object$ 对象，要想正确地使用该对象，你需要对其进行转型。使用 $newInstance$ 创建对象的要求是该对象拥有一个默认构造器。</description>
    </item>
    
    <item>
      <title>JVM（3）：性能监控和故障处理</title>
      <link>https://z217blog.cn/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 25 Aug 2020 20:11:27 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</guid>
      <description>1. 基础故障处理工具  基础故障处理工具是JDK自带的一些位于 $/bin$ 目录下的小工具。这些工具主要用于监视虚拟机运行状态和进行故障处理，根据软件可用性和授权的不同，可以分为三类：
 商业授权工具：主要是JMC ( $Java\ \ Mission\ \ Control$ ) 及其使用的JFR ( $Java\ \ Flight\ \ Recorder$ )。自JDK 7开始集成，在JDK 11前都无需独立下载，但是商业使用需要收费。 正式支持工具：长期支持的工具，可能在不同平台和版本之间存在差异。 实验性工具：没有技术支持，具有实验性质的工具，但通常很稳定且具有强大功能。  1.1 jps：虚拟机进程状况工具  jps ( $JVM\ \ Process\ \ Status\ \ Tool$ ) 的名字类似于UNIX系统中的 $ps$ 命令，功能也和其类似：列出正在运行的虚拟机进程，并显示主类名称和本地虚拟机唯一ID ( $Local\ \ Virtual\ \ Machine\ \ Identifier$, $LVMID$ )。作为使用频率最高的JDK命令行工具，是其他工具查询进程的方法。对于本地虚拟机进程来说，LVMID与操作系统进程ID ( $Process\ \ Identifier$, $PID$ ) 是一致的，使用Windows任务管理器也可以查询到。但是如果存在多个虚拟机进程，使得无法通过进程定位时，jps命令显示的主类信息就可以帮助我们定位。
jps [options] [hostid]    $options$ 作用     $-q$ 输出LVMID，省略主类信息   $-m$ 输出主类 $main$ 函数参数   $-l$ 输出主类全名，如果为JAR包则输出路径   $-v$ 输出JVM参数     $hostid$ 为RMI注册表中注册的主机名，jps可以通过RMI协议查询开启RMI服务的远程虚拟机进程状态。</description>
    </item>
    
    <item>
      <title>JVM（2）：垃圾收集器</title>
      <link>https://z217blog.cn/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</link>
      <pubDate>Sun, 23 Aug 2020 16:33:41 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</guid>
      <description>相比于程序计数器、虚拟机栈和本地方法栈这种应分配的内存大小在类确定时就已固定下来的内存区域，Java堆和方法区这两个区域有着不确定性：一个接口可能有多个实现类，一个方法可能有多个分支。垃圾收集器所关注的也就是这部分不确定的内存。
1. 对象状态  在进行垃圾收集之前，垃圾收集器需要对对象的状态进行判断，即判断其是否仍在被使用。
1.1 引用计数算法  引用计数 ( $Reference\ \ Counting$ ) 算法，可以简单的解释为在对象中添加一个引用计数器，当对象被引用时计数器便加一，反之减一。如此往复，当对象的引用计数器为零时，可以认为其不再被使用。虽然这种算法简单而且效率很高，但是因为存在着很多例外情况，因此不被主流的JVM所采纳。比较简单的例子就比如存在对象 $A$ 和 $B$ ，它们都存在着一个字段互相引用对方，这样它们的引用计数器就都为 $1$ 。但实际上，除了互相引用之外，它们没有被其他对象引用，可以认为是无用的对象，应该被垃圾收集。另一方面，它们的引用计数又不为 $0$ ，无法触发垃圾收集。因此，引用计数算法需要配合大量额外处理才能保证正常工作。
1.2 可达性分析算法  可达性分析 ( $Reachability\ \ Analysis$ ) 算法，基本思路就是通过一系列的称为GC Roots的根对象出发，不断搜索引用关系，搜索路径称为引用链 ( $Reference\ \ Chain$ )。当一个对象没有被搜索到，或者称不可达时，就认为这个对象不再被使用。在Java技术体系里固定可作为GC Roots的对象包括：
 虚拟机栈中的引用对象 方法区中类静态属性的引用对象 方法区中常量引用对象 本地方法栈中JNI ( 即 $Native$ 方法 ) 的引用对象 JVM内部引用，如基本数据类型对应的 $Class$ 对象，一些常驻的异常对象等，还有系统类加载器 同步锁 ( $synchronized$ 关键字 ) 持有的对象 反应JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等   除此之外，根据用户选择的垃圾收集器以及当前收集的内存区域，还会有临时对象的加入。譬如要针对某个特定区域进行垃圾收集时，不仅要加入该区域的，还要加入关联区域的其他对象。虽然现在查找引用链的过程已经可以做到并发，但迄今为止，所有收集器在根节点枚举这一步骤都要暂停用户线程。
1.3 对象引用  在JDK 1.2之前，Java对应用的定义为：如果 $reference$ 类型的数据中存储的数值代表的是另一块内存的起始地址，就称其代表某块内存或某块对象的引用。而在JDK 1.</description>
    </item>
    
    <item>
      <title>JVM（1）：技术体系与内存区域</title>
      <link>https://z217blog.cn/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Wed, 19 Aug 2020 19:42:28 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid>
      <description>1. Java技术体系  从广义上来讲，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序都属于Java技术体系中的一员。从传统意义上来看，JCP官方所定义的Java技术体系包括以下几个部分：
 Java程序设计语言 各种硬件平台上的Java虚拟机实现 Class文件格式 Java类库API 来自商业机构和开源社区的第三方Java类库   我们可以把Java程序设计语言、Java虚拟机、Java类库这三部分统称为JDK ( $Java\ \ Development\ \ Kit$ ) ，JDK是用于支持Java程序开发的最小环境。可以把Java类库API中的Java SE API子集和Java虚拟机这两部分统称为JRE ( $Java\ \ Runtime\ \ Environment$ )，JRE是支持Java程序运行的标准环境。
以上是按照Java组成部分来进行划分，如果按照技术领域来划分，则可以分为以下四条：
 Java Card Java ME Java SE Java EE  2. 自动内存管理  JVM在执行Java程序的过程中会将内存划分为若干个不同的数据区域。
2.1 程序计数器  程序计数器 ( $Program\ \ Counter\ \ Register$ ) 是一块比较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。程序的分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器。在JVM中，一个处理器只会处理一个线程，多线程通过轮流切换来实现，因此每个线程都会有一个程序计数器。对于每个线程之间独立存储的内存，我们称之为“线程私有”内存。
Java中存在 $native$ 关键字，用于指示本地方法。通过 $native$ 关键字，Java程序可以调用本地应用（或库），也可以被其他程序调用。对于本地方法，在执行过程中，程序计数器的值为空 ( $Undefined$ )。而对于Java方法 ( 也就是字节码 ) ，程序计数器的值为正在执行的虚拟机字节码的指令地址。
2.2 Java虚拟机栈  Java虚拟机栈 ( $Java\ \ Virtual\ \ Machine\ \ Stack$ ) 描述的是Java方法执行的线程内存模型。与程序计数器一样，它也是线程私有的。在每个方法被执行时，JVM都会同步创建一个栈帧 ( $Stack\ \ Frame$ ) 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。在方法被调用时，这个栈帧会被压入Java虚拟机栈。当方法执行完毕时，其对应的栈帧也会被从Java虚拟机栈中弹出。如果将Java的内存区域像C/C++那样简单地划分为堆内存 ( $Heap$ ) 和栈内存 ( $Stack$ )，那么这里的虚拟机栈就可以视为栈内存。</description>
    </item>
    
    <item>
      <title>从零开始的JDK编译</title>
      <link>https://z217blog.cn/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84jdk%E7%BC%96%E8%AF%91/</link>
      <pubDate>Wed, 19 Aug 2020 05:40:45 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84jdk%E7%BC%96%E8%AF%91/</guid>
      <description>首先从获取JDK源码开始。以OpenJDK为例，点击 OpenJDK 进入，选择对应的JDK版本，在此以JDK12为例，选择 $jdk12$ 。进入后在左侧选择 $browse$ ，然后再选择 $zip$ 即可下载。源码下载完毕之后解压，可以在解压后的文件目录下的 $/doc/building.html$ 中阅读编译文档。
源码下载完毕之后开始准备Linux环境，要注意在Linux环境中，文件夹请尽量使用英文名，名称中不要出现空格。我使用的是WSL Ubuntu，在刚开始使用时要记得切换镜像源。
vi /etc/apt/sources.list  使用 $vi$ 打开配置文件，然后替换为镜像源，在此我使用的是阿里云的镜像源，$sources.list$ 文件内容如下：
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.</description>
    </item>
    
    <item>
      <title>Geohash算法简介</title>
      <link>https://z217blog.cn/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 05 Aug 2020 19:58:48 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</guid>
      <description>1. Geohash算法介绍 Geohash-Wikipedia
 Geohash是一种用于公共领域的地理编码系统，其将地理位置编码为字母和数字的短字符串。Geohash允许任意精度的属性，可以通过增长或缩短字符串来改变精度。当两个区域的公共前缀越长，说明他们的联系更加紧密。但是反过来，具有短公共前缀或者没有公共前缀并不一定代表着联系很小。
Geohash算法可以将一个二维的经纬度坐标转换成一个可以比较的字符串，也就是降维。使用三十二进制，全球被划分为 $32$ 个大块，再在每个大块内继续划分出 $32$个小块，因此对于越长的geohash字符串，其精度越大，代表的范围也就越小。通过Base32算法，geohash使用字母和数字表示值，如下所示：
   数字 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31     32进制 0 1 2 3 4 5 6 7 8 9 b c d e f g h j k m n p q r s t u v w x y z     即使用了所有 $10$ 以内的数字，以及除 $a$, $i$, $l$ 和 $o$ 之外的所有小写字母。在计算的时候只需要在十进制和三十二进制之间转换即可，举例：</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://z217blog.cn/about/</link>
      <pubDate>Wed, 05 Aug 2020 11:00:59 +0800</pubDate>
      
      <guid>https://z217blog.cn/about/</guid>
      <description>个人博客，记录自己的学习历程。
有事请发邮箱，虽然不能保证及时回复但是总能看到的。除非被当做垃圾邮件了</description>
    </item>
    
    <item>
      <title>友链</title>
      <link>https://z217blog.cn/friend/</link>
      <pubDate>Wed, 05 Aug 2020 11:00:59 +0800</pubDate>
      
      <guid>https://z217blog.cn/friend/</guid>
      <description> 莓道理的博客  </description>
    </item>
    
    <item>
      <title>Git常用指令汇总</title>
      <link>https://z217blog.cn/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/</link>
      <pubDate>Tue, 04 Aug 2020 19:36:05 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/</guid>
      <description>创建仓库/init git init 创建成功后当前目录下会生成一个.git目录，用于跟踪和管理版本库。
添加文件/add git add . 自动添加本地所有修改。
提交/commit git commit $-m$ 增加提交信息。
$-a$ 自动寻找修改的文件并提交。
状态查看/status git status $-s$ 简短输出。
改动查看/diff&amp;amp;blame git diff $&amp;ndash;cached$ 显示暂存区的改动。
$HEAD$ 查看所有改动。
$&amp;ndash;stat$ 显示摘要。
git blame 文件修改记录。
历史查看/log git log 按时间由近到远排序，列出最近的三次提交。
$-p\ \ [filename]$ 文件最后一次提交信息。
$&amp;ndash;pretty=oneline$ 可以列出简略的信息。
$&amp;ndash;graph$ 拓扑图显示。
$&amp;ndash;reverse$ 逆向显示。
$&amp;ndash;author=$ 查找指定作者。
$&amp;ndash;since$, $&amp;ndash;before$, $&amp;ndash;util$, $&amp;ndash;after$ 指定日期。
$&amp;ndash;decorate$ 显示标签。
提交撤销/revert git revert 回退版本/reset git reset --hard HEAD^ git reset --hard HEAD~2 git reset --hard 56e7 $HEAD$ 表示当前版本。^ 表示回退一个版本，可以输入多个 ^。$\sim$ 之后可以输入任意数字，表示回退对应数量的版本。也可以直接输入版本号，版本号通过 $git\ \ log$ 命令查询，使用版本号不仅可以回退版本，在错误回退版本之后，也可以前进到指定的版本，版本号可以不写全，但一定要写到Git能识别出唯一一个版本为止。</description>
    </item>
    
    <item>
      <title>JWT简介</title>
      <link>https://z217blog.cn/post/jwt%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 04 Aug 2020 16:41:22 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jwt%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34;&gt;JWT-Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;code&gt;JWT&lt;/code&gt;( $JSON\ \ Web\ \ Token$ )是一种基于&lt;code&gt;JSON&lt;/code&gt;的用于创建可选签名或可选加密的数据的互联网标准。&lt;code&gt;Token&lt;/code&gt;使用一个私钥或者公钥进行签名，持有私钥或者公钥的一方可以验证令牌的合法性。&lt;code&gt;Token&lt;/code&gt;被设计为紧凑且安全的，尤其适用于&lt;code&gt;Web&lt;/code&gt;浏览器单点登录 ( &lt;code&gt;Single-sign-on&lt;/code&gt;, $SSO$ ) 场景。&lt;code&gt;JWT&lt;/code&gt;声明一般用于在身份提供者和服务提供者之间传递用户身份信息，或者用于业务流程要求的任何其他类型的声明。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://z217blog.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 10 Jul 2020 16:57:11 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式常用的七大原则：
 单一职责原则——一个类应该只负责一项职责。 接口隔离原则——一个类对应另一个类的依赖应该建立在最小的接口上。 依赖倒转原则  高层模块不应依赖于低层模块 抽象不应该依赖于细节 面向接口编程（中心思想）   里氏替换原则——所有引用基类的地方必须能透明的使用子类。 开闭原则——软件实体对扩展开放，对修改关闭，用抽象构建框架，用实现扩展细节。 迪米特法则——一个类应该将逻辑封装在内部，不对外泄露。 合成复用原则——尽量使用合成/聚合方式   23种设计模式的三种类型：
 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式； 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式； 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）。  1.单例模式  单例模式，即采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（通常为静态方法）。单例模式有八种方式：
 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举  1.1 饿汉式（静态常量）  构造器私有化（即不能通过 $new$ 创建实例） 类内部创建对象 向外暴露一个静态公共方法 代码实现  class Singleton { private final static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; } } 优点：写法简单，在类装载时实例化，避免了线程同步问题。</description>
    </item>
    
    <item>
      <title>数据库系统（9）：事务管理</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 13 Jun 2020 17:55:26 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</guid>
      <description>DBMS应该具备的功能中，有三个密切相关的功能，用以保证数据库的可靠性和一致性，即事务支持、并发控制服务和恢复服务。它们之间是相互依赖的。并发控制和恢复主要用于保护数据库，避免数据库发生数据不一致或者数据丢失。许多DBMS都允许用户对数据库进行并发操作。如果对这些操作不加控制，对数据库的访问将互相干扰，使得数据库出现不一致的情况。为了解决这个问题，DBMS实现了并发控制 ( $concurrency\ \ control$ ) 协议，来阻止数据库访问之间的相互干扰。数据库恢复 ( $Database\ \ recovery$ ) 是指在故障以后将数据库还原到正确状态的过程。
1. 支持事务处理  事务 ( $Transaction$ ) 是由单个用户或者应用程序执行的，完成读取或者更新数据库内容的一个或者一串操作。事务是数据库的逻辑操作单位 ( $logical\ \ unit\ \ of\ \ work$ ) 。它可以是整个程序、部分程序或者一条命令，也可以是涉及数据库的任意多个操作。从数据库的角度来看，应用程序的一次执行就是一个事务或者多个事务，若看成多个事务，在事务与事务之间只会出现非数据库操作。复杂的事务由很多操作构成。若并非所有操作都被执行，那么可能会出现不一致状态 ( $inconsistent\ \ state$ ) 。在事务处理过程中，尽管我们允许数据库的一致性遭到暂时破坏，但是事务应该总是能将数据库从一种一致的状态转移到另一种一致的状态。
事务可能有以下两种结果中的一种。如果执行成功，也就是说事务最终被提交 ( $committed$ )，数据库也将到达一种新的一致状态。另一种情况下，事务没有执行成功，则会被撤销 ( $aborted$ )。如果事务被撤销，则数据库必须要还原到事务开始之前的一致的状态。我们称这样的事务被回滚 ( $rolled\ \ back$ ) /撤销 ( $undone$ )。已经提交的事务无法撤销。如果发现已提交的事务存在错误，必须执行另一个补偿事务 ( $compensating\ \ transaction$ ) 来消除该事务已经产生的影响。
DBMS无法得知哪些更新操作将被组合在一起以构成一个独立的逻辑事务。因此很多数据操作语言中都使用关键字 $BEGIN$, $TRANSACTION$, $COMMIT$, $ROLLBACK$ 来划定界限。如果不使用，通常会将整个程序视为一个事务。
1.1 事务的性质  原子性 ( $Atomicity$ )：事务是一个不可分割的单元，要么全执行，要么全不执行。事务的原子性由DBMS的恢复子系统负责保证。 一致性 ( $Consistency$ )：事务必须将数据库从一种一致的状态转换到另一种一致的状态。事务的一致性是由DBMS和应用程序的开发者共同保证的。DBMS可以通过强制实施所有在数据库模式中定义的约束（如完整性约束和企业自定义约束）来保证一致性。 隔离性 ( $Isolation$ )：事务的执行是相互独立的，即未完成事务的中间结果对其他事务来说应该是不可见的。事务的隔离性由并发控制子系统负责保证。 持久性 ( $Durability$ )：成功完成的事务的结果要永久地记录在数据库中。事务的持久性由恢复子系统负责保证。  1.</description>
    </item>
    
    <item>
      <title>数据库系统（8）：规范化</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/</link>
      <pubDate>Fri, 22 May 2020 16:13:29 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/</guid>
      <description>规范化 ( $Normalization$ ) 是一种数据库设计技术，从分析属性之间的联系入手。规范化使用一系列测试，描述为范式 ( $normal\ \ forms$ ) 帮助我们确定这些属性的最佳组合，最终生成一组适当关系。
1. 目的  规范化的目的是确定一组合适的关系以支持企业的数据需求。该关系具有以下性质：
 属性的个数最少，且是必需的 具有紧密逻辑联系，描述为函数依赖 ( $functional\ \ dependency$ ) 的所有属性均在一个关系中 最少的冗余，即每个属性仅出现一次，除了作为外键的属性，因为连接相关关系必须用到外键   具有一组合适的关系，数据库会易于用户访问，数据易于维护，在计算机上也会占有较小的存储空间。
2. 支持  规范化有两种使用方法。方法 $1$ 将规范化视为一种自下而上 ( $bottom-up$ ) 的独立的数据库设计技术。方法 $2$ 将规范化作为一种确认技术使用，即用规范化检验关系的结构，而这些关系的建立可能采用自上而下的方法，如ER建模等。
3. 数据冗余与更新异常  关系数据库设计的一个目的就是将属性组合成关系时保证最少的数据冗余。当然，关系数据库的运行也依赖于一定的数据冗余的存在，一般是以主键或者候选键的多个副本的形式出现，作为外键表示数据间联系。存在冗余数据的关系可能存在一些问题，如更新异常 ( $update\ \ anomalies$ )。更新异常又可分为插入异常、删除异常和修改异常。
 $Staff$ 和 $Branch$ 是不存在数据冗余的两个表。$StaffBranch$ 是将上两个表合起来的存在数据冗余的表，同一个分公司的信息会重复出现。
3.1 插入异常  插入异常主要有两类：
 在向 $StaffBranch$ 中插入新员工时，若同一家分公司信息不同，则会产生一致性问题； 在向 $StaffBranch$ 中插入新的分公司时，由于没有员工，因此员工信息都应设为 $null$ 。但是主键 $staffNo$ 不能为空，否则会违反实体完整性约束。  3.</description>
    </item>
    
    <item>
      <title>数据库系统（7）：ER模型</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 21 May 2020 15:51:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/</guid>
      <description>ER模型是一种自上而下 ( $top-down$ ) 的数据库设计方法，该方法首先确定那些被称为实体的重要数据和这些数据之间的联系，实体和联系时ER模式中必备的元素。然后添加更多的细节信息，如属性、约束等。
统一建模语言 ( $Unified\ \ Modeling\ \ Language$, $UML$ ) 是软件工程项目的工业标准建模语言，我们使用UML的符号集来绘制ER模型。
1 实体类型  实体类型 ( $Entity\ \ types$ ) 是被企事业单位认可的、能够独立存在的一组具有相同属性的对象，是ER模型的基本概念。实体类型既可以是物理 ( 真实 ) 存在的，也可以是概念 ( 抽象 ) 存在的对象。实体出现 ( $entity\ \ occurrence$ ) 是实体类型中可唯一标识的一个对象。在没有歧义的时候，实体类型和实体出现都可以直接简称为实体。
在UML中，实体类型通过一个标有名字的矩形标识，每个实体名字的首字母是大写的。
2. 联系类型  联系类型 ( $Relationship\ \ types$ ) 是实体类型间一组有意义的关联。每个联系类型都被赋予一个能够描述其功能的名字。联系出现 ( $Relationship\ \ occurrence$ ) 是由参与该联系的各个实体类型的一个出现组成的可被唯一标识的关联。
在UML中，每个联系类型都表现为用线将相关的实体类型联系起来，并在线上标上联系的名字，通常使用一个动词或者动词短语命名。同样的，首字母也应该大写。一个联系还要标识方向，意味着这个联系仅在一个方向上有意义。可以在名字旁边添加一个箭头符号，如 $\blacktriangleleft$ 来标识方向。当我们要表示 $A\ \ Has\ \ B$ ( $A$，$B$ 为实体，$Has$ 为联系类型 ) 时可以用如下方法：</description>
    </item>
    
    <item>
      <title>数据库系统（6）：SQL数据定义</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Wed, 20 May 2020 16:46:30 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</guid>
      <description>1. 数据类型 1.1 标识符  SQL标识符 ( $identifier$ ) 用于表示数据库中的对象，如表名、列名、视图名等。用户定义标识符所用的字符必须是字符集 ( $character\ \ set$ ) 中存在的。默认的字符集包括 $A-Z$, $a-z$ 和 $_$ ，也可以另外指定其他字符集。标识符的限制有：
 不能长于 $128$ 个字符（在一些方言中会更短） 必须以字母开头 不能有空格  1.2 数据类型    数据类型 声明     布尔型 $BOOLEAN$   字符型 $CHAR$, $VARCHAR$   位类型 $BIT$, $BIT\ \ VARYING$   定点数型 $NUMERIC$, $DECIMAL$, $INTEGER$, $SMALLINT$, $BIGINT$   浮点数型 $FLOAT$, $REAL$, $DOUBLE\ \ PRECISION$   日期时间型 $DATE$, $TIME$, $TIMESTAMP$   间隔型 $INTERVAL$   大对象型 $CHARACTER\ \ LARGE\ \ OBJECT$, $BINARY\ \ LARGE\ \ OBJECT$    1.</description>
    </item>
    
    <item>
      <title>数据库系统（5）：SQL数据操作</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 20 May 2020 14:17:14 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</guid>
      <description>1. SQL简介  SQL是关系模型发展过程中出现的一种特殊语言，已经成为了标准的关系数据库语言。SQL是面向转换语言 ( $transform-oriented\ \ language$ ) 的例子，将输入关系转换为所需的输出关系，包括两个主要部分：DML和DDL。
SQL具有许多实现版本，每个实现称为方言 ( $dialect$ ) ，供应商在标准之外提供的特性称为扩展 ( $extensions$ )。
1.1 优点  满足数据库语言的思想 易于学习 结构简洁、轻便 存在SQL标准 可以通过终端或者嵌入式访问 所有人都可以使用  1.2 缺点  混合了编程规范和嵌入式访问 缺乏正交性，有多种表达方式 语言越来越复杂和庞大 聚合函数中对空的处理问题 结果表中可以有重复元组，对表中的行和列都强加了一个顺序  2. SQL命令  SQL语言包括保留字 ( $reserved\ \ words$ ) 和用户自定义字 ( $user-defined\ \ words$ ) 。保留字是SQL语言的固定部分，有固定含义。用户自定义字由用户定义，用于表示表、列、视图和索引等数据库对象的名称。虽然标准并没有要求，但是SQL的许多实现版本要求用句子终结符来表示SQL语句的结束。SQL语句的多数组成部分是不区分大小写的，除了字符数据常量外。
2.1 数据操作  DML语句有以下几种：
 $SELECT$, $INSERT$, $UPDATE$, $DELETE$.   常量 ( $Literals$ ) 是指SQL语句中的不变量 ( $constants$ )。不同的数据具有不同的常量形式，所有的非数值型数据必须使用引号，而所有的非数值型数据不能使用引号。</description>
    </item>
    
    <item>
      <title>数据库系统（4）：关系代数</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</link>
      <pubDate>Sun, 17 May 2020 16:05:13 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</guid>
      <description>关系代数 ( $Relational\ \ Algebra$ ) 可以看成一种过程式语言，可用于构造新关系。关系代数是一种纯理论语言，它定义了一些操作，运用这些操作可以从一个或多个关系中得到另一个关系而不改变原关系。关系代数的一个表达式可以嵌套另一个表达式，这种性质称为闭包 ( $closure$ )，即关系在关系代数下是封闭的。
关系代数是一种每次一关系/集合的语言，即用一条不带循环的语句处理，结果也是由所有元组组成的整个关系。关系代数中包含了许多运算，其中五个基本运算是选择 ( $Selection$ ) 、投影 ( $Projection$ ) 、笛卡尔乘积 ( $Cartesian\ \ product$ ) 、集合并 ( $Union$ ) 、集合差 ( $Set\ \ difference$ ) 。选择和投影都是一元运算，其他的运算则是二元运算。除此之外，还有连接 ( $Join$ ) 、集合交 ( $Intersection$ ) 、除 ( $Division$ ) 等，它们都能通过五个基本运算表示。
1. 一元运算 1.1 选择  $$ \sigma_{predicate}(R) $$   作用于单个关系 $R$ ，得到一个新关系，该关系由满足谓词 $predicate$ 的元组组成。可以理解为从表中选出符合条件的行构成一个新表。
1.2 投影  $$ \prod\nolimits_{a_1,a_2,...,a_n}(R) $$   作用于单个关系 $R$ ，得到一个由 $R$ 的垂直子集构成的新关系，该子集抽取 $R$ 中指定属性上的值并去掉重复元组。可以理解为从表中选出指定的列构成一个新表。</description>
    </item>
    
    <item>
      <title>数据库系统（3）：关系模型</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 15 May 2020 13:08:11 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</guid>
      <description>在目前使用的数据处理软件中，关系数据库管理系统 ( $Relational\ \ Database\ \ Management\ \ System$, $RDBMS$ ) 占据了统治地位。RDBMS基于关系数据模型。在关系模型中，所有数据逻辑上被组织成关系（表）结构。
1. 基本术语  关系模型基于数学中的关系 ( $relation$ )。
1.1 关系数据结构 1.1.1 关系  关系是由行和列组成的表。在关系模型中，用关系保存数据库所描述对象的信息，关系用二维表表示。用户主要接触的就是表，但这只限于逻辑结构，即外部层和概念层。对于物理结构，由于是通过多种存储结构实现的，因此并不适用。
1.1.2 属性  属性 ( $Attribute$ ) 是关系中命名的列。在关系的二维表中，每一行对应一个单独的记录，每一列则对应一个属性。
1.1.3 域  域 ( $Domain$ ) 是一个或多个属性的取值集合，必须给每一个属性定义一个域。不同属性的域可以互不相同，也可以共用。通过使用域，用户可以集中定义属性的取值范围和含义。
1.1.4 元组  元组 ( $Tuple$ ) 是关系中的行。关系的结构、域说明以及所有取值约束统称为关系的内涵 ( $intension$ )。它通常是固定的，除非关系的意义改变，需要加入新的属性。元组的集合称为外延 ( $extension$ ) /状态 ( $state$ )，它经常发生改变。
1.1.5 维数  维数 ( $Degree$ ) 是关系所包含的属性个数。只有一个属性的关系称为一元关系或者一元组，两个属性的关系称为二元关系，以此类推，$n$ 个属性的关系称为 $n$ 元组。维数是内含的性质之一。</description>
    </item>
    
    <item>
      <title>数据库系统（2）：数据库环境</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 14 May 2020 11:09:00 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/</guid>
      <description>1. ANSI-SPARC三层体系结构  三层体系结构 ( $Three\ \ Level\ \ Architecture$ )，包括外部层 ( $External$ )、概念层 ( $Conceptual$ ) 和内部层 ( $Internal$ )。用户从外部层观察数据，DBMS和操作系统从内部层观察数据。在内部层，数据使用定义的数据结构和文件组织方法进行存储。概念层则提供内部层和外部层的映射 ( $Mapping$ ) 以及必要的独立性 ( $Independence$ )。三层体系结构的目的是将用户的数据库视图与数据库的物理描述分离。
1.1 外部层  外部层是数据库的用户视图，这一层描述数据库中与用户相关的部分。对于每一个用户，数据库中都存储着其对用的视图。并且对于同一个数据，在不同的视图中可能有着不同的表达方式。
1.2 概念层  概念层是数据库的整体视图，这一层描述哪些数据存储在数据库中，以及这些数据之间的联系。概念层描述：
 所有的实体、实体的属性和实体间的联系 数据的约束 数据的语义信息 安全性和完整性信息   概念层支持每一个外部视图，凡是用户可访问的数据必定包含在概念层或者由概念层导出。
1.3 内部层  内部层是数据库在计算机上的物理表示，这一层描述数据是如何存储在数据库中的。内部层与如下工作相关：
 数据和索引的存储空间分配 存储记录的描述 存储记录 数据压缩和加密   在内部层之下是物理层 ( $Physical\ \ Level$ ) ，物理层可能在DBMS的指导下受操作系统的控制。
1.4 模式、映射和实例  对数据库的整体描述称为数据库模式 ( $Database\ \ Schema$ ) 。在数据库中存在三种不同类型的，在外部层有若干外部模式 ( $External\ \ Schema$ ) /子模式 ( $Subschema$ )，与不同的数据视图对应。在概念层有概念模式 ( $Conceptual\ \ Schema$ )，描述所有实体、属性和联系及其之间的完整性约束。在内部层，有内部模式 ( $Internal\ \ Schema$ )，是内部模型的完整描述，包括存储记录的定义、表示方法、数据域，必要时还有所使用的索引和散列方案。一个数据库可以有多个外部模式，但只能有一个概念模式和内部模式。</description>
    </item>
    
    <item>
      <title>数据库系统（1）：数据库简介</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 13 May 2020 14:23:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 基于文件的系统  基于文件的系统 ( $Traditional\ \ File-Based\ \ Systems$ ) 是一组为终端用户提供服务的应用程序，每一个程序定义和管理它自己的数据。相较于使用纸质文件进行管理的手工文件系统，基于文件的系统更加高效。但是它未能集中存储组织机构的运行数据，而是采用了分散的方法，即每一个部门在数据处理 ( $DP$ ) 人员的帮助下存储和控制它们的数据。通过编写应用程序来管理和查询数据，具有程序-数据依赖性 ( $Program-data\ \ Dependence$ ) 。
1.1 术语  文件 ( $File$ ) 是一些记录 ( $Records$ ) 的简单集合，这些记录中包含逻辑上相关的数据。每一条记录包含一组逻辑上相关的一个或多个数据项/域 ( $Fields$ ) 。
1.2 局限性  数据被分离和孤立
数据被孤立在分离的文件中，如果要访问处于不同文件之间的数据，需要创建一个临时文件。 数据存在冗余
由于文件间的分离，有时需要重复记录一些数据。 数据存在依赖性
数据文件的物理结构和存储方式是由应用程序定义的，很难做出改变，也即程序-数据依赖性。 文件格式不相容
文件结构嵌入应用程序，因此由应用程序语言决定。难以兼容其他使用不同语言的文件结构。 需要不断更改应用程序
完全依赖于开发人员，要求开发人员以编程方式实现所有查询和表。如果查询需求发生了变化，需要重新编写程序或更改文件。  2. 数据库方法  基于文件的系统存在许多问题，总结原因是：
 数据内嵌应用程序 无法实现程序规定之外的操作   因此我们需要一种更加高效的方法，数据库 ( $Database$ ) 和 数据库管理系统 ( $Database\ \ Management\ \ System,\ \ DBMS$ ) 应运而生。</description>
    </item>
    
    <item>
      <title>Redis笔记</title>
      <link>https://z217blog.cn/post/redis%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 10 May 2020 17:20:42 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/redis%E7%AC%94%E8%AE%B0/</guid>
      <description>1. Redis简介 NoSQL即 $Not-Only\ \ SQL$ ，是RDBMS的补充。
Redis是一种NoSQL数据库，是一个使用C语言开发的开源的高性能键值对数据库，内部使用单线程机制进行工作。
 $set\ \ [key]\ \ [value]$ 添加信息, $get\ \ [key]$ 查询信息，为空返回 $nil$ , $del\ \ [key]$ 删除信息，$1$ 代表删除成功, $clear$ 清屏, $help\ \ [op]$ 帮助, $time$ 获取时间.  2. 数据类型 Redis采用键值对的方式存储，$key$ 为字符串，$value$ 则允许多种类型。
2.1 string 最简单的数据类型，最大存储量 $512MB$ ， 可以作为数字使用，最大值为 $java.lang.Long$ 类型的最大值， 允许以JSON对象的方式存储数据，值中间不能有空白符
 $mset/mget$ 获取多个数据 $strlen$ 获取字符个数 $append$ 追加，返回总长度，也可以用于添加信息 $incr/incrby/incrbyfloat$ 指定数据增加指定值，允许负数，返回数值 $decr/decrby$ 指定数据减少指定的值，允许负数，返回数值 $setex/psetex$ 设定数据周期，秒/毫秒  2.2 hash hash 属于 $value$ ，其中包含多组键值对，键称为 $field$ ，键值对较少时为类数组结构，较多时为 $HashMap$ 结构，$value$ 只能为 string ，且最多只能有 $2^{32} - 1$ 组。</description>
    </item>
    
    <item>
      <title>JavaWeb（4）：Spring简介</title>
      <link>https://z217blog.cn/post/javaweb4spring%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 21 Apr 2020 15:48:49 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb4spring%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
Maven依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.inject&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.inject&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.annotation&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.annotation-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;   Spring Framework是一个Java应用程序容器，它提供了许多有用的特性，如反转控制（IoC）、依赖注入（DI）、抽象数据访问、事务管理等。
IoC是一个软件设计模式，即组装器（Spring Framework)在运行时才会绑定对象，也就是运行时才会实例化依赖的组件。这使得开发者可以针对接口进行编程，无需重新编译代码。DI是IoC的一种实现方式，通过DI，一个类可以通过声明其依赖的接口类型，然后利用组装器在运行时注入其依赖的实例。
Spring Framework提供了一个MVC（模型-视图-控制）模式框架，利用它可以简化创建Web应用程序的过程，不用手动处理复杂的Servlet、HttpServletRequest等。控制器类的每个方法都被映射到了一个不同的请求URL、方法或请求的其他属性上，模型可以通过 $Map$&amp;lt;$String, Object$&amp;gt;的形式从控制器传递到视图，控制器返回的视图或视图名称将把模型转发到合适的JSP视图。通过这些特性，Spring Framework极大地简化了Servlet容器的工作内容。
使用MVC框架时，控制器类中的每个方法都可以拥有一个指向特定URL、请求方法、参数存在性、头的值、内容类型或期望响应类型的唯一映射。
Spring Framework容器以一个或多个应用上下文的形式存在，由 $org.springframework.context.ApplicationContext$ 接口表示。一个应用上下文管理着一组bean、执行业务逻辑的Java对象、执行任务等。由Spring管理的bean可以自动进行DI、消息通知、bean验证等服务。一个Spring程序至少需要一个应用上下文，也可以使用多个应用上下文组成层次结构。在层次结构中应用上下文间有着类似于树的父子兄弟关系，一个子应用上下文的bean可以访问父应用上下文的bean，但无法访问兄弟应用上下文的bean。许多类都继承了 $ApplicationContext$ ，也有许多实现了它：
   类 描述     $ConfigurableApplication$ 可配置的应用上下文   $WebApplicationContext$ 用于Java EE Web应用程序，提供了对 $ServletContext$ 和 $ServletConfig$ 的访问   $ConfigurableWebApplicationContext$ 可配置的 $WebApplicationContext$   $XmlApplicationContext$ 用于在Java EE Web应用程序中从XML文件加载Spring配置   $AnnotationConfigWebApplicationContext$ 用于在Java EE Web应用程序中以编程方式配置Spring     Spring使用 $DispatcherServlet$ 处理Web请求，该Servlet将请求委托给合适的控制器，并按需求对请求和响应实体进行转换。在Web应用程序中，我们可以使用任意数量的 $DispatcherServlet$ 。每个 $DispatcherServlet$ 类都有自己的应用上下文，包含了对Web应用程序的 $ServletContext$ 和自己的 $ServletConfig$ 的引用。</description>
    </item>
    
    <item>
      <title>使用WebSocket实现的一个简单的多人聊天室</title>
      <link>https://z217blog.cn/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Sun, 19 Apr 2020 17:25:57 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>环境：JDK1.8, tomcat-8.5.51
源码可以在GitHub上查阅：ChatRoom
 WebSocket最常用的地方就是聊天室，所以我用Servlet+WebSocket实现了一个简单的多人聊天室。这个多人聊天室改一改就能作为一对一的聊天室使用，毕竟实现方法都是差不多的。
 首先是maven依赖，在此只展示几个要注意的依赖项：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.18.12&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; ...... ...... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.datatype&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-datatype-jsr310&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;  Lombok简化实体的编写（虽然只有一个实体），然后jackson相关的依赖用于Java实例和JSON对象之间的相互转化。为了避免兼容问题，我这里选择依赖基本上都是最新版本。
然后是实体，$ChatMessage$ 用于存储消息相关的信息，使用lombok简化了编写：
import lombok.AllArgsConstructor; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.Setter; import java.time.OffsetDateTime; @Getter @Setter @AllArgsConstructor @NoArgsConstructor public class ChatMessage { private String username; private String message; private OffsetDateTime timestamp; }  有了实体之后再建立仓库，用于存储聊天信息以及用户信息：
import java.util.LinkedList; import java.util.List; import java.util.concurrent.CopyOnWriteArraySet; public class ChatRepository { private static List&amp;lt;ChatMessage&amp;gt; repository = new LinkedList&amp;lt;&amp;gt;(); private static CopyOnWriteArraySet&amp;lt;String&amp;gt; users = new CopyOnWriteArraySet&amp;lt;&amp;gt;(); public static List&amp;lt;ChatMessage&amp;gt; getRepository() { /*.</description>
    </item>
    
    <item>
      <title>JSON序列化传输过程中中文乱码问题的解决方法</title>
      <link>https://z217blog.cn/post/json%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 18 Apr 2020 22:13:49 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/json%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>今天在用WebSocket和Servlet写聊天室的时候发现传输中文会乱码的问题，起初以为是在用jackson的 $ObjectMapper$ 将对象转化为字节流的时候出现的问题，但是经过检查后发现不是。又检查了一遍编码，确认了网页的编码是utf-8，输入的字符串也是utf-8，然后发现问题是出在了JSON对象传输的过程中。最后在 stackoverflow 上找到了解法。
 我的问题出在将经过JSON序列化之后的消息对象字符串转换为 $Uint8Array$ 以及将 $Uint8Array$ 转为消息对象的过程中，对此可以采用 $TextEncoder$ 和 $TextDecoder$ 对象。如下所示：
let encoder = new TextEncoder(&amp;#39;utf-8&amp;#39;); let decoder = new TextDecoder(&amp;#39;utf-8&amp;#39;); let message = { username: &amp;#39;用户&amp;#39;, content: &amp;#39;你好，世界！&amp;#39; }; let array = encoder.encode(JSON.stringify(message)); let newMessage = JSON.parse(decoder.decode(array));  在上例中，我们分别使用 $TextEncoder$ 和 $TextDecoder$ 以utf-8作为编码方式创建了编码器和译码器，之后声明了一个 $message$ 对象存储我们要传递的消息，使用JSON序列化该对象，并使用编码器进行编码，编码后得到的是可以进行传输的 $Uint8Array$ 对象，而对其使用译码器进行译码可以得到另一个 $newMessage$ 对象，该对象内存储的值与之前的 $message$ 相同，并且没有出现中文乱码的现象。</description>
    </item>
    
    <item>
      <title>JavaWeb（3）：WebSocket简介</title>
      <link>https://z217blog.cn/post/javaweb3websocket%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 06 Apr 2020 14:57:01 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb3websocket%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
 WebSocket用于解决浏览器和服务器的通信问题。在现有体系中，如果只是简单的使用Ajax进行通信的话，容易出现的问题是只有浏览器发送请求时才能得到响应。也即当有新数据时，浏览器不能得知新数据的存在，也就不能及时发送请求获取新数据。
WebSocket使用了HTTP/1.1 升级特性。该特性的使用很简单，只需要在请求中包含头名称和值 $Connection: Upgrade$ ，并在额外的 $Upgrade$ 头中指定一个或多个协议的列表。如果服务器接收升级请求，那么将返回 $101\ \ Switching\ \ Protocols$ 。HTTP升级提供的最重要的特性是我们可以使用任意协议，并且在升级完成后就不再使用HTTP连接，我们可以用一个Socket来代替，由此产生了WebSocket协议。WebSocket协议将使用心跳消息（分别称为 $ping$ 和 $pong$ ）保持连接活跃，即周期性地发送小数据包。在连接升级为WebScoket协议之后，文本和二进制消息可以持续在两个方向上发送且不需要关闭和重连了；而且HTTP规范要求对应同一个主机名，只允许有两个并发连接，但由于我们升级为WebScoket连接了，因此该规范也不存在了。
使用WebSocket协议之前需先以HTTP协议向服务器发送特殊请求，访问一个特殊的URL，该URL以ws或者wss开头，分别对应http和https，并且除了 $Connection: Upgrade$ 头之外，还包含一个 $Connection: websocket$ 头，用于指定服务器将连接升级为 WebSocket协议。
 HTML5(JavaScript)客户端API  WebSocket并不是只能用于浏览器和服务器的通信中，理论上可以将其应用于任何支持其的应用程序中。但如果要编写使用WebSocket进行连接的浏览器客户端终端，我们就要用到JavaScript，尽管我们使用JavaScript编写，但实际上WebSocket是HTML5的一部分。使用JavaScript创建WebSocket对象十分简单：
var connection = new WebSocket(&amp;#39;ws://www.example.com/chat&amp;#39;, {&amp;#39;chat.v1&amp;#39;, &amp;#39;chat.v2&amp;#39;});  WebSocket构造函数第一个参数为连接所使用的URL，第二个参数可选，为连接所使用的一个或多个协议，这些协议都是自己创建的，不受WebSocket管理。
WebSocket接口中包含 $readyState$ 属性表示当前状态，值为 $CONNECTING$, $OPEN$, $CLOSING$, $CLOSED$ 中的一个，包含四个事件：$onopen$, $onclose$, $onerror$, $onmessage$ ，前两者分别在 $readyState$ 由 $CLOSING$ 变为 $CLOSED$ 时和 $readyState$ 由 $CONNECTING$ 变为 $OPEN$ 时触发。传入 $onclose$ 方法的事件包含三个属性：$wasClean$, $code$, $reason$ ，传入 $onopen$ 的是普通的事件，传入 $onerror$ 和 $onmessage$ 的事件包含一个 $data$ 属性，在前者中是错误对象，而在后者则根据消息类型转变：消息为字符串，则 $data$ 也为字符串；消息为二进制数据，并且 $WebSocket.</description>
    </item>
    
    <item>
      <title>JavaWeb（2）：Session简介</title>
      <link>https://z217blog.cn/post/javaweb2session%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 26 Mar 2020 15:41:52 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb2session%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
注：演示所用 Java 版本为 Java8 ，所用容器为 Tomcat8.5.51
 会话用于处理维持请求和请求之间的状态。在没有使用会话时，HTTP请求是无状态的，在浏览器打开第一个连接到服务器的套接字时开启，在服务器返回最后一个数据包时结束。而有些时候，我们希望保持状态，如用户登录或者在线编辑时，这时我们就要用到会话。
在Web中，会话是由服务器或Web应用程序管理的某些文件、内存片段、对象或者容器。服务器在第一次接收到请求时，会随机生成一串字符串，称为会话ID，并返回用户浏览器中。之后所有从该用户浏览器中发出的请求都需要包含该会话ID，服务器接收到会话ID后可以将会话与请求关联起来。HTTP cookie用于将会话ID发送到服务器，但是如果用户浏览器禁止了cookie，那么就需要将会话ID内嵌在URL中，很明显，这种方式使得其他人可以轻松地获得会话，因此是不安全的。不过由于如今许多网站都要求用户在访问时启用cookie，因此我们可以不用顾虑这点。
会话也是有漏洞的。但是由于描述起来篇幅过长，因此不做赘述，如果感兴趣的话可以在 Session hijacking -Wikipedia 中查看。
 大部分情况下我们可以直接使用会话，不需要添加显式配置，但是出于安全目的，我们应该进行配置。使用&amp;lt;$session-config$&amp;gt;标签进行配置，同时在&amp;lt;$session-config$&amp;gt;标签内，我们也可以使用&amp;lt;$cookie-config$&amp;gt;标签进行cookie的配置。所有在&amp;lt;$session-config$&amp;gt;标签和&amp;lt;$cookie-config$&amp;gt;标签内的标签都是可选的。下面列出了所有的可选标签：
&amp;lt;session-config&amp;gt; &amp;lt;session-timeout&amp;gt;30&amp;lt;/session-timeout&amp;gt; &amp;lt;cookie-config&amp;gt; &amp;lt;name&amp;gt;JSESSIONID&amp;lt;/name&amp;gt; &amp;lt;domain&amp;gt;example.org&amp;lt;/domain&amp;gt; &amp;lt;path&amp;gt;/path&amp;lt;/path&amp;gt; &amp;lt;comment&amp;gt;&amp;lt;! [CDATA[Keeps you logged in. See our privacy policy for more information.]]&amp;gt;&amp;lt;/comment&amp;gt; &amp;lt;http-only&amp;gt;true&amp;lt;/http-only&amp;gt; &amp;lt;secure&amp;gt;false&amp;lt;/secure&amp;gt; &amp;lt;max-age&amp;gt;180&amp;lt;/max-age&amp;gt; &amp;lt;/cookie-config&amp;gt; &amp;lt;tracking-mode&amp;gt;COOKIE&amp;lt;/tracking-mode&amp;gt; &amp;lt;tracking-mode&amp;gt;URL&amp;lt;/tracking-mode&amp;gt; &amp;lt;tracking-mode&amp;gt;SSL&amp;lt;/tracking-mode&amp;gt; &amp;lt;/session-config&amp;gt;  下面为每个标签的作用：
   标签 作用     &amp;lt;$session-timeout$&amp;gt; 会话在无效前可以保持不活跃状态的时间，以分钟为单位，为 $0$ 表示永远不过期。   &amp;lt;$tracking-mode$&amp;gt; 表示容器使用哪种技术追踪会话ID，可以配置多个值，按照配置顺序使用。URL表示容器将在URL中内嵌会话ID，COOKIE表示使用cookie，SSL表示使用SSL会话，但要求所有请求均是HTTPS请求。   &amp;lt;$name$&amp;gt; 可以自定义会话cookie的名字，通常不用设置。   &amp;lt;$domain$&amp;gt; 设置cookie的Domain特性，通常不用设置。   &amp;lt;$path$&amp;gt; 设置cookie的Path特性，通常不用设置。   &amp;lt;$comment$&amp;gt; 可以添加任意文本，用于解释cookie。   &amp;lt;$http-only$&amp;gt; 设置cookie的HttpOnly特性，为了提高安全性，一般都设置为 $true$ 。   &amp;lt;$secure$&amp;gt; 设置cookie的Secure特性，如果使用的是HTTPS，就应设置为 $true$ 。   &amp;lt;$max-age$&amp;gt; 设置cookie的Max-Age特性，控制cookie何时过期，以秒为单位，通常不用设置。     学习了如何配置会话之后，就该学习如何使用会话了。为了获取会话，我们可以调用 $HttpServletRequest.</description>
    </item>
    
    <item>
      <title>JavaWeb（1）：Servlet入门</title>
      <link>https://z217blog.cn/post/javaweb1servlet%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 14 Mar 2020 19:20:22 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb1servlet%E5%85%A5%E9%97%A8/</guid>
      <description>参考书籍：Pro Java for Web Apps
注：以下内容需要HTTP基础，演示所用Java版本为Java8，所用容器为Tomcat8.5.51
 Servlet是一个运行在Web服务器中的Java小程序，用于接收和响应来自Web客户端的请求，使用HTTP进行通信，是所有Web应用程序的核心类，也是唯一的既可以直接处理和响应用户请求，也可以将处理工作委托给应用中的其他部分的类。
Servlet只是一个简单的接口，包含了相关的方法。大多数情况下Servlet都继承自 $javax.servlet.GenericServlet$ 类，该类只包含一个抽象的 $service$ 方法以及一些辅助方法。$service$ 方法会处理所有请求，然后返回对应的响应。我们可以使用$javax.servlet.http.HttpServlet$ 类用于响应HTTP请求，它继承自 $GenericServlet$ 并实现其 $service$ 方法，而对于响应HTTP请求的方法只是空实现。在 $HttpServlet$ 类中，HTTP请求包括 $GET,HEAD,POST,PUT,DELETE,OPTIONS,TRACE$ 对应的响应方法名称为 $do +$ 首字母大写的请求名称。如 $GET$ 对应 $doGet()$ ，$POST$ 对应 $doPost()$ 等。除了响应方法之外，Servlet类中还包含 $init$ 方法和 $destroy$ 方法，分别在启用和关闭Servlet时调用，不过通常这些方法什么也不做。
 大多数情况下我们的Servlet类都是继承 $HttpServlet$ 类。对于上述提到的所有方法，它们都接收两个参数，一个是 $javax.servlet.http.HttpServletRequest$ 类型的参数，另一个是 $javax.servlet.http.HttpServletResponse$ 类型。顾名思义，$HttpServletRequest$ 指向客户端请求，对其我们有如下常用方法：
   方法 作用     $getParameter$ 返回参数的单个值   $getParameterValues$ 返回参数的值的数组   $getParameterMap$ 返回一个包含所有参数名值对的$java.util.Map&amp;lt;String, String[\ \ ]&amp;gt;$   $getParameterNames$ 返回所有可用参数的名字的枚举   $getContentLength$ 返回请求正文的长度（小于 $2$ GB）   $getContentLengthLong$ 返回请求正文的长度（大于 $2$ GB）   $getCharacterEncoding$ 返回请求内容的字符编码   $getReader$ 返回一个 $java.</description>
    </item>
    
    <item>
      <title>Dijkstra算法原理及其实现</title>
      <link>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 03 Mar 2020 17:27:28 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</guid>
      <description>参考书籍：《算法（第4版）》
 $Dijkstra$ 算法应用于带权有向图中求最短路径问题。通俗来讲就是不断选择权值最小的边加入集合直到所有顶点都在集合中，属于贪心算法。需要注意的是，$Dijkstra$ 算法只能用于解决边权非负的图类问题。
假设对于一个带权有向图 $G(V,E)$ 以邻接矩阵表示，其所有边存储在一个二维整型数组 $matrix[\ \ ][\ \ ]$ 中， $matrix[i][j]$ 表示从顶点 $i$ 到顶点 $j$ 之间的边，值为边的权值，若值为 $∞$ ，说明该边不存在。为了实现 $Dijkstra$ 算法，我们需要一个布尔值数组 $visit[\ \ ]$ ，用于判断顶点是否访问过，或者说是否在集合中；一个整型数组 $distance[\ \ ]$ 用于储存原点到每个点的最短距离。定义了基本的结构，就可以实现算法了，步骤为：
 从 $V$ 中选择一个点 $s$ 作为原点，将邻接矩阵中的 $matrix[s]$ 数组复制到 $distance[s]$ （复制后 $distance[s]$ 应为 $0$ ），建立一个 $visit[\ \ ]$ 数组并清零。 从 $V$ 中选择一个顶点 $u$ 加入集合，其中点 $u$ 满足：  之前未曾访问过点 $u$ （即 $visit[u] = false$ ）。 与 $s$ 距离最短（即 $distance[u]$ 的值最小）。   以 $u$ 为中心点，对于每个与 $u$ 相邻的顶点 $k$ ，令 $distance[k] = Min(distance[k], distance[u] + matrix[u][k])$ ，这一步也称为松弛( $relaxation$ )。 重复2、3直到所有顶点加入集合。   $Dijkstra$ 算法类似于 $Prim$ 算法，实质上都是构造了一颗树。经过以上步骤之后，我们得到了一个 $distance[\ \ ]$ 数组，其中的值为从原点 $s$ 到图中其他所有点的最短距离。在使用代码实现的过程中，有些情况下我们可以使用优先队列来简化寻找最小权值的这一过程。如果我们确认了一幅图是无环图，那么我们也可以不使用 $visit[\ \ ]$ ，而是通过拓扑排序的顺序依次遍历顶点。</description>
    </item>
    
    <item>
      <title>JavaScript中的数组</title>
      <link>https://z217blog.cn/post/javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 01 Mar 2020 15:05:01 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</guid>
      <description>参考书籍：《JavaScript高级程序设计（第3版）》
 作为一种可以说是最常用的类型，EMCAScript当中的数组与其他语言的数组有很大区别，例如数组元素可以是不同类型，数组长度可以动态调整等，因此我总结了一下EMCAScript中的数组类型，即 $Array$ 类型（主要集中于与其他语言不同的地方）。
 数组创建 数组长度 数组方法  判定方法 转换方法 栈方法 队列方法 排序方法 操作方法 位置方法 迭代方法 归并方法    1. 数组创建  EMCAScript中数组是一个特殊的类型，有自己的构造函数，我们可以通过 $new$ 运算符来调用数组的构造函数。
var array = new Array(); //建立一个空数组  当然，你也可以通过传参来调用带参构造函数。
var array1 = new Array(10); //大小为10的数组 var array2 = new Array(1, 2, 3); //包含1,2,3三个元素的数组 var array2 = new Array(&amp;#34;A&amp;#34;); //包含一个&amp;#34;A&amp;#34;的数组  但是在这里要注意的是，如果你只给构造函数传一个数字，则会创建对应大小的数组,其中每一项的值都是 $undefined$ ；如果传的是多个数字，则会创建包含这些数字的数组。
除了调用构造函数之外，我们还可以使用字面量语法。如下所示：
var array1 = []; //空数组 var array2 = [1]; //包含一个1的数组 var array3 = [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;]; //包含三个元素的数组  2.</description>
    </item>
    
    <item>
      <title>Leetcode题解（2）：二分搜索</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A32%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sat, 29 Feb 2020 17:23:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A32%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</guid>
      <description>原题地址: Problem 4
参考题解
 题目不用多解释，如果没有要求时间复杂度的话可以直接用双指针法遍历即可，但既然题目要求对数级的复杂度，再加上是排序数组，那么很容易就可以想到是二分法，接下来的问题就是怎么二分了。回忆下中位数的概念，中位数是一组顺序排序的数据中居于中间位置的数。也就是说，如果我们知道一组数据的中位数，我们就可以顺势以中位数为基准，将这组数据分成相同大小的两部分，其中一部分中的数总是小于（或等于）另一部分。再回到题目来，如果我们知道这两个数组的中位数，那么我们就可以将这两个数组以中位数为基准将每个数组分为两部分，如下所示：
 其中左边两部分中所有的值永远小于或等于右边两部分。这时很明显中位数为
 $$ median = \frac{max(nums1[i - 1], nums2[j - 1])\ +\ min(nums1[i] + nums2[j])}{2} $$   这样我们的目标就从找中位数变成了寻找一个 $i$ 和 $j$ ，满足如下条件（假设 $i$ 和 $j$ 总是存在）：
 $i + j = \Large\frac{nums1.length\ +\ nums2.length}{2}\normalsize;$ $nums1[i - 1] &amp;lt;= nums2[j];$ $nums2[j - 1] &amp;lt;= nums1[i].$   根据上述条件，如果我们要进行二分搜索，第一步必须先将两个数组分别二分，保证条件1为真。
if (nums1.length &amp;gt; nums2.length) return findMedianSortedArrays(nums2, nums1); int len1 = nums1.length, len2 = nums2.length, halfLen = (len1 + len2 + 1) / 2, i = len1 / 2, j = halfLen - i; }  可以发现我们在开始判断了下$nums1[\ \ ]$和$nums2[\ \ ]$的长度，确保 $nums1.</description>
    </item>
    
    <item>
      <title>JavaScript的对象构造</title>
      <link>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/</link>
      <pubDate>Fri, 28 Feb 2020 12:48:51 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/</guid>
      <description>参考书籍：《JavaScript高级程序设计》（第3版）
 JavaScript是一门面向对象的语言，即拥有类的概念。但ECMAScript中没有类的概念，因此它的对象与其他基于类的语言不同，我们可以把ECMAScript中的对象想象成散列表，由一组组键值对构成，值可以是数据或者函数。
 $object$ 构造函数模式 对象字面量 工厂模式 构造函数模式 原型模式  什么是原型对象   寄生构造函数模式 稳妥构造函数模式 属性类型   1.object构造函数模式 var person = new object(); person.name = &amp;#34;A&amp;#34;; person.sayName = function() { alert(this.name); };  上例创建了一个 $person$ 对象，并为其添加了 $name$ 属性和 $sayName(\ )$ 方法，是最简单的构造对象的方法。
 2.对象字面量 var person = { name: &amp;#34;XiaoMing&amp;#34;, sayName: function() { alert(this.name); } };  上例创建了相同的 $person$ 对象，不同之处在于它是使用对象字面量定义的。以花括号表示开始和结束，属性名+冒号+值的格式定义属性，用逗号隔开多个不同的属性。
在使用对象字面量时，属性名也可以使用字符串。需要注意的是，JSON只支持此种语法。
var person = { &amp;#34;name&amp;#34;: &amp;#34;XiaoMing&amp;#34;, &amp;#34;sayName&amp;#34;: function() { alert(this.</description>
    </item>
    
    <item>
      <title>Leetcode周赛：177</title>
      <link>https://z217blog.cn/post/leetcode%E5%91%A8%E8%B5%9B177/</link>
      <pubDate>Thu, 27 Feb 2020 11:18:21 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E5%91%A8%E8%B5%9B177/</guid>
      <description>第 177 场周赛
 Problem 1360: 日期之间间隔几天 Problem 1361: 验证二叉树 Problem 1362: 最接近因数 Problem 1363: 形成三的最大倍数   Problem 1360: 日期之间间隔几天
 直接调用库函数即可。
import java.time.LocalDate; import java.time.temporal.ChronoUnit; class Solution { public int daysBetweenDates(String date1, String date2) { return (int) Math.abs(LocalDate.parse(date1).until(LocalDate.parse(date2), ChronoUnit.DAYS)); } }  使用 $LocalDate$ 类及其 $until(\ )$ 方法，使用 $ChronoUnit.DAYS$ 常量表明以天为单位计算。在此要注意的是Leetcode并没有默认导入 $java.time$ 类，因此要自己导入。
 Problem 1361: 验证二叉树
 利用二叉树的性质可以知道，二叉树根节点外每个节点有且只有一个父节点，并且有且只有一个根节点。通过这个性质，我们可以遍历数组，找到所有的节点的父节点，再验证是否符合上述性质。
class Solution { public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) { int[] parent = new int[n]; //储存每个节点的父节点  Arrays.</description>
    </item>
    
    <item>
      <title>Leetcode题解：一道”难“题</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A3%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98/</link>
      <pubDate>Mon, 17 Feb 2020 17:44:43 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A3%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98/</guid>
      <description>原题地址：Problem 1332
 题目很直(mo)白(hu)，就是从一个字符串中删除回文子列直到字符串为空。但是我——没看示例，盯着题目描述和左上角的“简单”，陷入了长时间的思考，最终怀疑人生。毕竟如果你要找回文串的话就得遍历一遍得到子串，然后删除，再遍历，再循环……如此反复，时间复杂度很高，完全不是简单难度，毫无办法的我最终只能看向题解，然后在惊叹中一分钟提交了答案。
class Solution { public int removePalindromeSub(String s) { if (s.length() == 0) return 0; else if (s.equals(new StringBuilder(s).reverse().toString())) return 1; else return 2; } }  总之这道题很沙雕，沙雕之处就在于它的子序列可以不连续。所以，如果不是空串或者回文串的话，先删掉所有的 $a$ 再删掉所有的 $b$ 就行了。由于让我卡了很久，专门写了一篇博客，特此留念。</description>
    </item>
    
    <item>
      <title>Leetcode题解（1）：动态规划</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A31%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Wed, 12 Feb 2020 20:42:30 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A31%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>原题地址：Problem 62
参考题解
 第一眼看到这道题就联想到了离散数学里的排列的相关知识，从而可以很容易的得出排列数为 $C(m+n-2,m-1)$ 或者 $C(m+n-2,n-1)$，可以直接利用该公式进行计算。但问题是阶乘的增长量级过大，很快就产生了溢出的问题，这时可以通过使用 $BigInteger$ 类型对象解决。
虽然问题解决了，但显然这种偏暴力方式的解法不是我们的目的，因此我们还要寻找另一种解法。通过观察题目，我们可以很明显的发现：由于只能右移或者下移，因此到达每一块方格的路径数（不包括第一行和第一列） = 到达其左边方格的路径数 + 到达其上边方格的路径数。以此规律，我们可以运用动态规划来解决该问题。
 首先先设
int[][] dp = new int[m][n];  dp数组为二维数组，储存到达每个方格的路径数。由于达到第一列和第一行中所有方格的路径数有且仅有一条，因此可以
for (int i = 0; i &amp;lt; m; i++) dp[i][0] = 1; for (int i = 1; i &amp;lt; n; i++) dp[0][i] = 1;  之后仅需双循环进行赋值即可：
for (int i = 1; i &amp;lt; m; i++) for (int j = 1; j &amp;lt; n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  在此，无论是按行还是按列，结果都是一样的。最后 $dp[m - 1][n - 1]$ 即为答案。将上述代码合并起来即为：</description>
    </item>
    
    <item>
      <title>JavaScript的对象继承</title>
      <link>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 06 Dec 2019 22:58:43 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/</guid>
      <description>参考书籍：《JavaScript高级程序设计》（第3版）
 继承是OO语言（面对对象语言）中的概念。许多OO语言都支持两种继承方式：接口继承（继承方法签名）和实现继承（继承实际方法）。但由于JavaScript中没有签名，因此在ECMAScript中只能实现方法继承。
 原型链 借用构造函数 组合继承 原型式继承 寄生式继承 寄生组合式继承   1. 原型链  原型链（ $prototype\ \ chaining$ ）是实现继承的主要方法。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
function SuperType() { this.property = true; } SuperType.property.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; } //继承SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; }  上述代码中定义了两种类型—— $SuperType$ 和 $SubType$ ，其中 $SubType$ 继承了 $SuperType$ 。实现的本质是重写 $SubType$ 的原型对象，即将一个 $SuperType$ 对象赋给 $SubType.property$ ，从而使得 $SuperType$ 中所有的属性和方法均存在于 $SubType$ 中。在实例中，我们也给 $SubType$ 添加了一个新方法。此外，还要注意，以此种方式实现的继承中， $SubType.</description>
    </item>
    
    <item>
      <title>get in touch</title>
      <link>https://z217blog.cn/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://z217blog.cn/contact/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
