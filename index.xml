<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>z217&#39;s blog</title>
    <link>https://z217blog.cn/</link>
    <description>Recent content on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Sat, 09 Jan 2021 20:58:35 +0800</lastBuildDate>
    
	<atom:link href="https://z217blog.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JVM（8）：后端编译与优化</title>
      <link>https://z217blog.cn/post/jvm8%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 09 Jan 2021 20:58:35 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm8%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
      <description>1. 即时编译器  目前主流的两款商用Java虚拟机里，Java程序最初都是通过解释器执行的。当虚拟机发现某个方法或者代码块运行频繁，就会把代码认为是热点代码 ( $Hot\ \ Spot\ \ Code$ )，并将这些代码编译为本地机器码，同时进行代码优化。完成这个任务的后端编译器就称为即时编译器。
1.1 解释器与编译器  当程序需要迅速启动和执行时，解释器可以省去编译时间立即运行；当程序启动后，越来越多的代码会被编译成本地代码，从而减少解释器带来的中间损耗，获得更快的执行速度。如果程序运行环境中内存限制过大，可以使用解释执行从而节约内存，反之可以使用编译执行提升效率。当编译器采取的优化手段出现罕见陷阱 ( $Uncommon\ \ Trap$ ) 时，可以通过逆优化 ( $Deoptimization$ ) 退回到解释状态执行。 HotSpot虚拟机中内置了两个（或三个）即时编译器，其中两个存在已久的编译器分别称为客户端编译器 ( $Client\ \ Compiler$ ) 和服务端编译器 ( $Server\ \ Compiler$ )，简称为 $C1$ 编译器和 $C2$ 编译器。第三个编译器是JDK 10时出现的，目标是替代 $C2$ 的 $Graal$ 编译器。 在分层编译 ( $Tiered\ \ Compilation$ ) 的工作模式出现前，通常采用解释器与一个编译器直接搭配的方式工作，这时用户也可以通过 $-client$ 和 $-server$ 参数直接运行模式。解释器与编译器搭配使用的方式称为混合模式 ( $Mixed\ \ Mode$ )，也可以通过 $-Xint$ 或者 $-Xcomp$ 强制运行解释模式或者编译模式。 即时编译需要占用程序运行时间，而且编译过程中还需要进行优化。要想达到好的优化效果，解释器需要替编译器收集性能监控信息。当然，这也会影响解释执行的速度。为了寻求启动响应速度与运行效率之间的平衡，HotSpot虚拟机在编译子系统中加入了分层编译，包括：
 第 $0$ 层，程序解释执行，不开启性能监控； 第 $1$ 层，使用客户端编译器，进行简单优化，不开启性能监控； 第 $2$ 层，使用客户端编译器，开启方法和回边次数统计等监控； 第 $3$ 层，使用客户端编译器，开启全部性能监控，除了第 $2$ 层的统计信息外，还会收集分支跳转、虚方法等统计信息； 第 $4$ 层，使用服务端编译器将字节码编译为本地代码，需要更多的优化，还可能采取一些不可靠的激进优化。   实施分层编译后，解释器、客户端编译器、服务端编译器就会同时工作，热点代码可能会被多次编译。使用客户端编译器编译可以获得更高的编译速度，使用服务端编译器可以获得更好的编译质量。</description>
    </item>
    
    <item>
      <title>JVM（7）：前端编译与优化</title>
      <link>https://z217blog.cn/post/jvm7%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
      <pubDate>Fri, 08 Jan 2021 20:09:14 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm7%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
      <description>1. Javac编译器  Javac是一个由Java语言编写的程序，从其代码总体结构来看，可以将编译过程大致分为 $1$ 个准备过程和 $3$ 个处理过程：
 准备过程：初始化插入式注解处理器 解析与填充符号表过程，包括词法分析、语法分析和符号表创建 插入式注解处理器的注解处理过程 分析与字节码生成过程，包括标注检查、数据流及控制流分析、解语法糖和字节码生成   在上述处理过程中，执行插入式注解时可能又会产生新的符号。如果产生新的符号，就必须对它们进行解析，因此又回到了步骤 $2$ 。Javac编译动作得入口是 $com.sun.tools.javac.main.JavaCompiler$ 类，上述 $3$ 个过程的代码逻辑集中在这个类的 $compiler(\ )$ 和 $compiler2(\ )$ 方法。
1.1 解析与填充符号表  解析过程通过 $JavaCompiler.parseFiles(\ )$ 方法发起。
1.1.1 词法、语法分析  词法分析过程由 $com.sun.tools.javac.parser.Scanner$ 类完成。语法分析过程由 $com.sun.tools.javac.parser.Parser$ 类完成，产出的抽象语法树以 $com.sun.tools.javac.tree.JCTree$ 类表示。在完成词法、语法分析之后，编译器后续的操作都建立在抽象语法树的基础上，不会再对源码进行操作了。
1.1.2 填充符号表  填充符号表过程通过 $JavaCompiler.enterTrees(\ )$ 方法发起，由 $com.sun.tools.javac.comp.Enter$ 类完成，产出一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级结点。
1.2 注解处理器  在JDK 5时，注解只会在程序运行期间发挥作用。JDK 6中提供了一组称为“插入式注解处理器”的标准API，使得特定注解的处理可以提前至编译期进行。插入式注解处理器可以读取、修改和添加抽象语法树的元素。如果在这个过程中发生了修改操作，那么编译器需要返回解析与填充符号表过程重新处理。
1.3 语义分析与字节码生成  抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义符合逻辑，因此需要进行语义分析对源程序进行上下文相关性质的检查，譬如类型检查、控制流检查、数据流检查等。
1.3.1 标注检查  标注检查由 $JavaCompiler.attribute(\ )$ 方法发起。标注检查步骤要检查的内容包括变量使用前是否已声明、变量与赋值之间的数据类型是否匹配等。此外还会进行常量折叠 ( $Constant\ \ Folding$ ) 。</description>
    </item>
    
    <item>
      <title>JVM（6）：字节码执行引擎</title>
      <link>https://z217blog.cn/post/jvm6%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</link>
      <pubDate>Wed, 14 Oct 2020 17:02:05 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm6%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</guid>
      <description>1. 运行时栈帧  JVM以方法作为最基本的执行单元，栈帧 ( $Stack\ \ Frame$ ) 是用于支持虚拟机进行方法调用和方法执行背后的数据结构，也是虚拟机运行时数据区中的虚拟机栈 ( $Virtual\ \ Machine\ \ Stack$ ) 的栈元素，存储了方法的局部变量表、操作数栈、动态连接和方法返回地址和一些额外的附加信息，方法表的 $Code$ 属性包含了栈帧所需的局部变量表和操作数栈的大小。对于执行引擎来讲，在每个线程中，只有处于调用堆栈栈顶的方法才是正在运行的方法，称为当前栈帧 ( $Current\ \ Stack\ \ Frame$ )，与这个栈帧关联的方法称为当前方法 ( $Current\ \ Method$ )。
1.1 局部变量表  局部变量表 ( $Local\ \ Variable\ \ Table$ ) 是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量，其最大容量由方法 $Code$ 属性中的 $max_-locals$ 数据项决定。局部变量表以变量槽 ( $Variable\ \ Slot$ ) 为最小单位，每个变量槽都应该能存放一个 $boolean$ 、$byte$ 、$char$ 、$short$ 、$int$ 、$float$ 、$reference$ 或 $returnAddress$ 类型的数据。这些数据长度一般都为 $32$ 位 ( $reference$ 可能为 $64$ 位 )，也意味着变量槽的长度至少为 $32$ 位。而对于 $64$ 位的数据类型，比如 $long$ 和 $double$ ，会通过高位对齐的方式分配两个连续的变量槽。</description>
    </item>
    
    <item>
      <title>JVM（5）：类加载</title>
      <link>https://z217blog.cn/post/jvm5%E7%B1%BB%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Tue, 22 Sep 2020 22:20:52 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm5%E7%B1%BB%E5%8A%A0%E8%BD%BD/</guid>
      <description>1. 类加载的时机  一个类型从被加载到卸载的过程中，会经历加载 ( $Loading$ )、验证 ( $Verification$ )、准备 ( $Preparation$ )、解析 ( $Resolution$ )、初始化 ( $Initialization$ )、使用 ( $Using$ ) 和卸载 ( $Unloading$ ) 七个阶段，其中可以把验证、准备、解析统称为连接 ( $Linking$ )。这些阶段之间可以交叉进行。加载、验证、准备、初始化、卸载的顺序是确定的，解析阶段则不一定，可能开始在初始化之后。
《Java虚拟机规范》中并没有规定什么时候需要进行加载，但是严格规定了有且只有六种情况需要进行初始化：
 执行 $new$ 、$getstatic$ 、$putstatic$ 、$invokestatic$ 四条字节码指令时，如果类型没有初始化，需要先进行初始化阶段。这四条字节码指令分别对应：使用 $new$ 创建对象实例、读取和设置静态字段 ( $final$ 字段除外，因为它在编译器就已被置入常量池 )、调用静态方法； 对类型进行反射调用时，如果类型没有初始化，需要先进行初始化阶段； 初始化类时如果父类没有初始化，需要先初始化父类； 虚拟机启动时，主类需要先进行初始化； JDK 7之后，如果一个 $java.lang.invoke.MethodHandle$ 实例的解析结果为 $REF_-getStatic$ 、$REF_-putStatic$ 、$REF_-newInvokeSpecial$ 四种类型的方法句柄时，如果该方法句柄对应的类没有初始化，需要先进行初始化阶段； JDK 8之后，接口中包含 $default$ 方法时，在其实现类发生初始化前，需要先进行接口的初始化阶段。   这六种情况触发初始化场景的行为称为主动引用，除此之外的引用称为被动引用。例如通过子类访问父类的静态字段并不会触发子类的初始化，只会触发父类的初始化；声明一个引用数组并不会触发引用类型的初始化，而是初始化一个数组类型。
与类相同，接口也具有初始化过程。虽然接口中不能使用静态代码块，但是编译器仍然会生成 &amp;lt;$clinit$&amp;gt;$(\ )$ 类构造器，用于初始化成员变量。在前面的六种主动引用触发场景中，只有在初始化父类时才会对接口进行初始化。但是一个接口在初始化时，并不要求其父接口全部初始化，只有在用到时才需要进行初始化。
2. 类加载的过程 2.1 加载  类加载过程，虚拟机需要完成以下三件事：</description>
    </item>
    
    <item>
      <title>回溯算法：八皇后</title>
      <link>https://z217blog.cn/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%AB%E7%9A%87%E5%90%8E/</link>
      <pubDate>Sat, 19 Sep 2020 16:11:12 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%AB%E7%9A%87%E5%90%8E/</guid>
      <description>原题地址：Problem 51
 将 $N$ 个皇后放在 $N \times N$ 的棋盘上，要求皇后不能处于同行、同列、同对角线上。没有什么取巧的方案，只能尝试所有情况后将可行的情况列出，因此可以使用回溯算法。
此题的难点在于判断皇后之间是否能相互攻击。如果将皇后所处的格子视为 $1$ ，其它格子视为 $0$ ，那么就可以使用位运算来判断。保证皇后不同行的方式很简单，只需要保证每一行只放置一个皇后即可。而如果想要保证皇后不同列，就需要记录之前行的皇后的位置。我们可以通过按位或和按位和进行记录和判断。
 $$ .\ \ Q\ .\ \ .\ \ \\ .\ \ .\ \ .\ \ Q\ \\ Q\ .\ \ .\ \ .\ \ \\ .\ \ .\ \ Q\ .\ \ \\ $$   对于上面的例子，第一行我们可以记为 $0100$ 。到第二行通过按位和进行判断：$0100 \And 0001$ ，如果不为 $0$ ，说明发生冲突。如果没有冲突，那么可以通过按位或获取新值：$0100 | 0001 = 0101$ 。重复上述步骤即可保证皇后处于不同列。
如果要保证皇后不处于同对角线，进行观察可以发现：下一行的皇后不能处于上一行皇后的左一格或者右一格，不能处于上上一行皇后的左二格或者右二格……也就是每过一行，就让之前行的皇后统一左移或者右移一格，然后再使用类似于之前判断皇后是否同列的方法进行判断就行了。我们可以使用两个数字 $left$ 和 $right$，专门用于记录之前行皇后的左移或者右移。再以上面的例子，第二行的 $left$ 为 $1000$ ，第三行为 $0010$ ；第二行的 $right$ 为 $0010$ ，第三行的 $right$ 为 $0001$ 。</description>
    </item>
    
    <item>
      <title>JVM（4）：Class文件结构</title>
      <link>https://z217blog.cn/post/jvm4class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 17 Sep 2020 22:58:37 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm4class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</guid>
      <description>1. 平台无关性  Java在刚刚诞生时就有一句非常著名的口号：一次编写，到处运行。这个想法通过虚拟机实现，这些虚拟机都可以执行同一种与平台无关的字节码，从而达到一次编写，到处运行。可以说，字节码就是平台无关性的基石。Java虚拟机并不与Java语言绑定，在其之上还可以运行许多其他语言，如Kotlin、Groovy和Scala等。Java虚拟机唯一绑定的是类似于Class文件这种特殊的二进制文件，其中包含了Java虚拟机的指令集、符号表以及其他辅助信息。通过Class文件，Java虚拟机并不需要关心来源是什么语言，只要这门语言能够生成可以被读取的Class文件，那么它就可以在Java虚拟机上运行。
Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会转成字节码指令的组合，这就要求字节码指令的表达能力必须比Java语言的表达能力更强。从而，一些Java语言中并不支持的特性，字节码也能够表达出来。
2. Class类文件  Class文件是一组以 $8$ 个字节为单位的二进制流，数据项目按照顺序紧凑地排列在文件之中。对于 $8$ 字节以上空间的数据项，会按照高位在前的大端序分割存储在若干个 $8$ 字节中。
Class文件采取一种类似于C语言结构体的伪结构来存储数据，包含两种数据类型：
 无符号数：即基本数据类型，通过 $u1$ 、$u2$ 、$u3$ 、$u4$ 分别表示 $1$ 个字节、$2$ 个字节、$4$ 个字节和 $8$ 个字节的无符号数，用于表示数字、索引引用、数量值或者UTF-8编码的字符串； 表：由多个无符号数或者其他表构成的复合数据类型，一般以 $_-info$ 结尾，用于表示具有层次关系的数据。可以把整个Class文件都视为表，按照对应类型的数据紧凑排列而成。   当需要描述类型相同但数量不定的数据时，经常会使用一个前置的容器计数器加若干个连续的数据项的形式，称为该类型的集合。
2.1 魔数和版本号  Class文件的头 $4$ 字节称为魔数 ( $Magic\ \ Number$ )，用于确定该文件能否被虚拟机接受。魔数在很多文件格式中都存在，文件格式制定者可以自定义魔数，只要不会引起混淆。Class文件的魔数为 $0xCAFEBABE$ ，象征着一款咖啡。
在魔数之后是Class文件的版本号，前两个字节是次版本号 ( $Minor\ \ Version$ )，后两个字节是主版本号 ( $Major\ \ Version$ )。Java主版本号从 $45$ 开始，JDK 1.1之后每个大版本都会在之前的基础上加 $1$ 。次版本号在JDK 1.1及以前曾经短暂使用过，在JDK 1.2之后废弃，全部使用 $0$ 代替，直到JDK 12，由于一些复杂特性需要进行公测，于是重新启用了次版本号。
2.2 常量池  常量池是Class文件中第一次出现表的数据项目，也是与其他项目关联最多的数据，通常也是最庞大的数据项目之一。常量池入口是一个 $u2$ 类型的数据，是常量池容量计数值 ( $constant_-pool_-count$ )，从 $1$ 开始，$0$ 表示不指向常量池中的数据项目。Class文件中只有常量池的容量计数是从 $1$ 开始的。</description>
    </item>
    
    <item>
      <title>快速乘算法简介</title>
      <link>https://z217blog.cn/post/%E5%BF%AB%E9%80%9F%E4%B9%98%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 15 Sep 2020 15:05:04 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E5%BF%AB%E9%80%9F%E4%B9%98%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</guid>
      <description>快速乘算法的原理是俄罗斯农民乘法，这种乘法规则很简单：
 将要相乘的两个数字写在两列； 将第一列乘以二，第二列除以二并写在下一行； 如果这一行中第二列数字为偶数，删去这一行； 在下一行重复上述二至三步直至第二列数字为 $1$ ； 将第一列未被删除的数字求和即为结果   以 $48 \times 58$ 为例：
 $$ \require{cancel} \bcancel{48}\qquad\bcancel{58}\\ 96\qquad29\\ \bcancel{192}\qquad\bcancel{14}\\ 384\qquad7\\ 768\qquad3\\ 1536\qquad1\\ ————\\ 2784\qquad $$   从而 $48 \times 58 = 2784$ 。
运用这个原理，我们可以对二进制数进行计算，只需要将原来的规则调整下即可。对于二进制数 $A$ 和 $B$ ，如果要计算 $A \times B$ ，那么可以：
 如果 $B$ 末位为 $1$ ，将 $A$ 加到结果上； 将 $A$ 左移一位，$B$ 右移一位； 重复上述两步直至 $B$ 为零。   将上述步骤用代码实现如下：
class QuickMulti { public int quickMulti(int A, int B) { int res = 0; while (B !</description>
    </item>
    
    <item>
      <title>Java注解</title>
      <link>https://z217blog.cn/post/java%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 07 Sep 2020 23:32:11 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java%E6%B3%A8%E8%A7%A3/</guid>
      <description>注解为在代码中添加信息提供了一种形式化的方式。Java SE5内置了三种定义在 $java.lang$ 当中的注解：
 $@Override$ ：表示当前定义的方法将覆盖超类中的方法； $@Deprecated$ ：表示方法被弃用，调用此类方法将引发警告； $@SuppressWarnings$ ：关闭某些编译警告信息。   除此之外还有四种注解，用于创建新注解。
1. 语法 1.1 定义 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { public int id(); public String description() default &amp;#34;no description&amp;#34;; }  注解的定义方式很像接口，也与接口一样会被编译为class文件。定义注解需要一些元注解。$@Target$ 定义注解的作用对象，如方法；$@Retention$ 定义的可用级别，分为源码 ( $SOURCE$ )、类文件 ( $CLASS$ )、运行时 ( $RUNTIME$ )。
在定义注解时也可以设置一些元素表示一些值，不同于接口，你可以为这些值设置默认值。如果没有提供默认值，那么在使用注解的时候就必须进行赋值。没有元素的注解称为标记注解 ( $marker\ \ annotation$ )。可用的注解元素包括以下类型：
 基本类型； $String$ ； $Class$ ； $enum$ ； $Annotation$ ； 以上类型的数组。  1.2 元注解  Java内置了四种元注解：</description>
    </item>
    
    <item>
      <title>Java I/O</title>
      <link>https://z217blog.cn/post/java-i-o/</link>
      <pubDate>Sun, 06 Sep 2020 21:28:06 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java-i-o/</guid>
      <description>1. File类  $File$ 类用于储存文件路径，可以代表一个特定文件或者一组文件的名称，如果是后者，可以通过 $list(\ )$ 获得一个字符数组。在不传入参数时，$list(\ )$ 方法返回全部列表，也可以接受一个 $FilenameFilter$ 类型的参数，实现目录过滤：
class DirFilter implements FilenameFilter { private Pattern pattern; public DirFilter(String regex) { pattern = Pattern.compile(regex); } public boolean accept(File dir, String name) { return pattern.matcher(name).matches(); } } public class DirList { public static void main(String[] args) { System.out.println(Arrays.toString(new File(&amp;#34;.&amp;#34;).list(new DirFilter(args[0])))); } }  除了代表文件和目录之外，$File$ 对象还可以用于创建和删除目录，查看文件信息等：
   方法 作用     $getAbsolutePath$ 返回绝对路径   $canRead$ 可读性   $canWrite$ 可写性   $getName$ 返回名称   $getParent$ 返回父目录   $getPath$ 返回路径   $lastModified$ 最后修改时间   $isFile$ 是否为文件   $isDirectory$ 是否为目录   $exists$ 是否存在   $mkdirs$ 创建   $delete$ 删除   $renameTo$ 重命名或移动文件    2.</description>
    </item>
    
    <item>
      <title>Java泛型</title>
      <link>https://z217blog.cn/post/java%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Wed, 02 Sep 2020 21:23:39 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java%E6%B3%9B%E5%9E%8B/</guid>
      <description>泛型允许一个类应用于多种类型，实现了参数化类型的概念。促使泛型产生的原因之一就是容器类，泛型可以用于指定一个容器具体要持有怎样的类型。当然，也可以通过泛型实现持有多个类型的类，如元组类：
public class TwoTuple&amp;lt;A, B&amp;gt; { public final A first; public final B second; public TwoTuple(A a, B b) { this.first = a; this.second = b; } }  如果需要长度更长的元组如三元组，我们可以在二元组的基础上声明三元组类，并令其继承二元组类。
除了具体类外，泛型还可以应用于抽象类和接口当中。
Java泛型存在着很多局限性，第一个就是不能以基本类型作为其类型参数。当然，通过Java自动包装和自动拆包的功能，基本类型和其包装类型可以很方便地进行转换。
之前提到的泛型都是应用于一个类上的，但是泛型同样可以应用于方法上，而且不仅可以应用于泛型类的方法上，也可以应用于普通类的方法上。如果通过使用泛型方法就可以避免使用泛型类，那么推荐使用泛型方法。此外，由于 $static$ 方法无法获取类型参数，因此如果要让 $static$ 方法使用泛型，那么就必须让其成为泛型方法。与使用泛型类不同，使用泛型方法时可以不用指定具体类型，通过类型参数推断，编译器可以为我们找出具体类型。
1. 擦除  通过泛型，我们可以声明一个 $ArrayList&amp;lt;Integer&amp;gt;$ 对象，然后我们可以获取 $ArraysList.class$ ，但是却不能获取 $ArrayList&amp;lt;Integer&amp;gt;.class$ 对象。这个行为说明了在编译器的眼中，$ArrayList&amp;lt;Integer&amp;gt;$ 和 $ArrayList&amp;lt;String&amp;gt;$ 是同一类型。更加夸张的是，不同于C++，在Java的泛型内，你无法获取任何有关于泛型参数类型的信息。这些行为的原因都是因为Java的泛型是使用擦除实现的。在基于擦除的实现中，泛型被认为是第二类类型，既不能在某些重要的上下文环境中使用的类型。泛型类型只有在静态类型检查期间才会出现，之后泛型类型将被擦除，并替换为非泛型边界如 $List$ , $Object$ 等。
在C++中，我们可以实现以下代码：
template&amp;lt;class T&amp;gt; class Test { T obj; public: Test(T t) { this.obj = t; } void f() { obj.</description>
    </item>
    
    <item>
      <title>Java类型信息</title>
      <link>https://z217blog.cn/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Sun, 30 Aug 2020 16:50:55 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</guid>
      <description>运行时类型信息 ( $RTTI$ ) 可以让我们在程序运行时发现和使用类型信息，主要有两种方式：传统RTTI，假定在编译时就已经知道了所有类型；以及反射，允许在运行时发现和使用类型信息。
1. RTTI  传统的RTTI在Java语句执行过程中也发挥着作用。
 我们定义了一个 $Circle$ 对象，将其存储在一 $List&amp;lt;Shape&amp;gt;$ 容器之中。那么当对象被放入容器时，会向上转型为 $Shape$ ；而在取出时，由于 $List$ 容器会将所有对象当作 $Object$ 类型持有，因此会再次转换为 $Shape$ 对象。
1.1 Class对象  $Class$ 对象负责表示运行时的类型信息，Java通过 $Class$ 对象执行RTTI。每个类都拥有一个 $Class$ 对象，当它被编译时，就会通过类加载器产生一个 $.class$ 文件，存储其 $Class$ 对象。
所有的类都是在被第一次使用时动态地被加载到JVM当中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。也就是说构造器也是静态的，因此使用 $new$ 创建对象就会创建一个对静态构造器的引用，从而使得这个类被加载。当类的 $Class$ 对象被载入后，这个类的所有对象都会使用 $Class$ 对象创建。$Class$ 对象还有一些常用方法：
 $forName(\ )$ ：通过全类名获取对应类的 $Class$ 对象； $getName(\ )$ ：获取全限定的类名； $getSimpleName(\ )$ ：获取不含包名的类名； $getInterfaces(\ )$ ：$Class$ 对象中实现的接口； $getSuperclass(\ )$ ：获取基类的 $Class$ 对象。   $Class.newInstance(\ )$ 方法允许你在不知道确切类型的情况下创建对象。通过该方法你可以得到一个 $Object$ 对象，要想正确地使用该对象，你需要对其进行转型。使用 $newInstance$ 创建对象的要求是该对象拥有一个默认构造器。</description>
    </item>
    
    <item>
      <title>JVM（3）：性能监控和故障处理</title>
      <link>https://z217blog.cn/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 25 Aug 2020 20:11:27 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</guid>
      <description>1. 基础故障处理工具  基础故障处理工具是JDK自带的一些位于 $/bin$ 目录下的小工具。这些工具主要用于监视虚拟机运行状态和进行故障处理，根据软件可用性和授权的不同，可以分为三类：
 商业授权工具：主要是JMC ( $Java\ \ Mission\ \ Control$ ) 及其使用的JFR ( $Java\ \ Flight\ \ Recorder$ )。自JDK 7开始集成，在JDK 11前都无需独立下载，但是商业使用需要收费。 正式支持工具：长期支持的工具，可能在不同平台和版本之间存在差异。 实验性工具：没有技术支持，具有实验性质的工具，但通常很稳定且具有强大功能。  1.1 jps：虚拟机进程状况工具  jps ( $JVM\ \ Process\ \ Status\ \ Tool$ ) 的名字类似于UNIX系统中的 $ps$ 命令，功能也和其类似：列出正在运行的虚拟机进程，并显示主类名称和本地虚拟机唯一ID ( $Local\ \ Virtual\ \ Machine\ \ Identifier$, $LVMID$ )。作为使用频率最高的JDK命令行工具，是其他工具查询进程的方法。对于本地虚拟机进程来说，LVMID与操作系统进程ID ( $Process\ \ Identifier$, $PID$ ) 是一致的，使用Windows任务管理器也可以查询到。但是如果存在多个虚拟机进程，使得无法通过进程定位时，jps命令显示的主类信息就可以帮助我们定位。
jps [options] [hostid]    $options$ 作用     $-q$ 输出LVMID，省略主类信息   $-m$ 输出主类 $main$ 函数参数   $-l$ 输出主类全名，如果为JAR包则输出路径   $-v$ 输出JVM参数     $hostid$ 为RMI注册表中注册的主机名，jps可以通过RMI协议查询开启RMI服务的远程虚拟机进程状态。</description>
    </item>
    
    <item>
      <title>JVM（2）：垃圾收集器</title>
      <link>https://z217blog.cn/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</link>
      <pubDate>Sun, 23 Aug 2020 16:33:41 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</guid>
      <description>相比于程序计数器、虚拟机栈和本地方法栈这种应分配的内存大小在类确定时就已固定下来的内存区域，Java堆和方法区这两个区域有着不确定性：一个接口可能有多个实现类，一个方法可能有多个分支。垃圾收集器所关注的也就是这部分不确定的内存。
1. 对象状态  在进行垃圾收集之前，垃圾收集器需要对对象的状态进行判断，即判断其是否仍在被使用。
1.1 引用计数算法  引用计数 ( $Reference\ \ Counting$ ) 算法，可以简单的解释为在对象中添加一个引用计数器，当对象被引用时计数器便加一，反之减一。如此往复，当对象的引用计数器为零时，可以认为其不再被使用。虽然这种算法简单而且效率很高，但是因为存在着很多例外情况，因此不被主流的JVM所采纳。比较简单的例子就比如存在对象 $A$ 和 $B$ ，它们都存在着一个字段互相引用对方，这样它们的引用计数器就都为 $1$ 。但实际上，除了互相引用之外，它们没有被其他对象引用，可以认为是无用的对象，应该被垃圾收集。另一方面，它们的引用计数又不为 $0$ ，无法触发垃圾收集。因此，引用计数算法需要配合大量额外处理才能保证正常工作。
1.2 可达性分析算法  可达性分析 ( $Reachability\ \ Analysis$ ) 算法，基本思路就是通过一系列的称为GC Roots的跟对象出发，不断搜索引用关系，搜索路径称为引用链 ( $Reference\ \ Chain$ )。当一个对象没有被搜索到，或者称不可达时，就认为这个对象不再被使用。在Java技术体系里固定可作为GC Roots的对象包括：
 虚拟机栈中的引用对象 方法区中类静态属性的引用对象 方法区中常量引用对象 本地方法栈中JNI ( 即 $Native$ 方法 ) 的引用对象 JVM内部引用，如基本数据类型对应的 $Class$ 对象，一些常驻的异常对象等，还有系统类加载器 同步锁 ( $synchronized$ 关键字 ) 持有的对象 反应JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等   除此之外，根据用户选择的垃圾收集器以及当前收集的内存区域，还会有临时对象的加入。譬如要针对某个特定区域进行垃圾收集时，不仅要加入该区域的，还要加入关联区域的其他对象。虽然现在查找引用链的过程已经可以做到并发，但迄今为止，所有收集器在根节点枚举这一步骤都要暂停用户线程。
1.3 对象引用  在JDK 1.2之前，Java对应用的定义为：如果 $reference$ 类型的数据中存储的数值代表的是另一块内存的起始地址，就称其代表某块内存或某块对象的引用。而在JDK 1.</description>
    </item>
    
    <item>
      <title>JVM（1）：技术体系与内存区域</title>
      <link>https://z217blog.cn/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Wed, 19 Aug 2020 19:42:28 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid>
      <description>1. Java技术体系  从广义上来讲，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序都属于Java技术体系中的一员。从传统意义上来看，JCP官方所定义的Java技术体系包括以下几个部分：
 Java程序设计语言 各种硬件平台上的Java虚拟机实现 Class文件格式 Java类库API 来自商业机构和开源社区的第三方Java类库   我们可以把Java程序设计语言、Java虚拟机、Java类库这三部分统称为JDK ( $Java\ \ Development\ \ Kit$ ) ，JDK是用于支持Java程序开发的最小环境。可以把Java类库API中的Java SE API子集和Java虚拟机这两部分统称为JRE ( $Java\ \ Runtime\ \ Environment$ )，JRE是支持Java程序运行的标准环境。
以上是按照Java组成部分来进行划分，如果按照技术领域来划分，则可以分为以下四条：
 Java Card Java ME Java SE Java EE  2. 自动内存管理  JVM在执行Java程序的过程中会将内存划分为若干个不同的数据区域。
2.1 程序计数器  程序计数器 ( $Program\ \ Counter\ \ Register$ ) 是一块比较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。程序的分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器。在JVM中，一个处理器只会处理一个线程，多线程通过轮流切换来实现，因此每个线程都会有一个程序计数器。对于每个线程之间独立存储的内存，我们称之为“线程私有”内存。
Java中存在 $native$ 关键字，用于指示本地方法。通过 $native$ 关键字，Java程序可以调用本地应用（或库），也可以被其他程序调用。对于本地方法，在执行过程中，程序计数器的值为空 ( $Undefined$ )。而对于Java方法 ( 也就是字节码 ) ，程序计数器的值为正在执行的虚拟机字节码的指令地址。
2.2 Java虚拟机栈  Java虚拟机栈 ( $Java\ \ Virtual\ \ Machine\ \ Stack$ ) 描述的是Java方法执行的线程内存模型。与程序计数器一样，它也是线程私有的。在每个方法被执行时，JVM都会同步创建一个栈帧 ( $Stack\ \ Frame$ ) 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。在方法被调用时，这个栈帧会被压入Java虚拟机栈。当方法执行完毕时，其对应的栈帧也会被从Java虚拟机栈中弹出。如果将Java的内存区域像C/C++那样简单地划分为堆内存 ( $Heap$ ) 和栈内存 ( $Stack$ )，那么这里的虚拟机栈就可以视为栈内存。</description>
    </item>
    
    <item>
      <title>从零开始的JDK编译</title>
      <link>https://z217blog.cn/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84jdk%E7%BC%96%E8%AF%91/</link>
      <pubDate>Wed, 19 Aug 2020 05:40:45 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84jdk%E7%BC%96%E8%AF%91/</guid>
      <description>首先从获取JDK源码开始。以OpenJDK为例，点击 OpenJDK 进入，选择对应的JDK版本，在此以JDK12为例，选择 $jdk12$ 。进入后在左侧选择 $browse$ ，然后再选择 $zip$ 即可下载。源码下载完毕之后解压，可以在解压后的文件目录下的 $/doc/building.html$ 中阅读编译文档。
源码下载完毕之后开始准备Linux环境，要注意在Linux环境中，文件夹请尽量使用英文名，名称中不要出现空格。我使用的是WSL Ubuntu，在刚开始使用时要记得切换镜像源。
vi /etc/apt/sources.list  使用 $vi$ 打开配置文件，然后替换为镜像源，在此我使用的是阿里云的镜像源，$sources.list$ 文件内容如下：
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.</description>
    </item>
    
    <item>
      <title>Geohash算法简介</title>
      <link>https://z217blog.cn/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 05 Aug 2020 19:58:48 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</guid>
      <description>1. Geohash算法介绍 Geohash-Wikipedia
 Geohash是一种用于公共领域的地理编码系统，其将地理位置编码为字母和数字的短字符串。Geohash允许任意精度的属性，可以通过增长或缩短字符串来改变精度。当两个区域的公共前缀越长，说明他们的联系更加紧密。但是反过来，具有短公共前缀或者没有公共前缀并不一定代表着联系很小。
Geohash算法可以将一个二维的经纬度坐标转换成一个可以比较的字符串，也就是降维。使用三十二进制，全球被划分为 $32$ 个大块，再在每个大块内继续划分出 $32$个小块，因此对于越长的geohash字符串，其精度越大，代表的范围也就越小。通过Base32算法，geohash使用字母和数字表示值，如下所示：
   数字 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31     32进制 0 1 2 3 4 5 6 7 8 9 b c d e f g h j k m n p q r s t u v w x y z     即使用了所有 $10$ 以内的数字，以及除 $a$, $i$, $l$ 和 $o$ 之外的所有小写字母。在计算的时候只需要在十进制和三十二进制之间转换即可，举例：</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://z217blog.cn/about/</link>
      <pubDate>Wed, 05 Aug 2020 11:00:59 +0800</pubDate>
      
      <guid>https://z217blog.cn/about/</guid>
      <description>个人博客，记录自己的学习历程。
有事请发邮箱，虽然不能保证及时回复但是总能看到的。除非被当做垃圾邮件了
这里是第二博客 ，因为hexo生成速度太慢了折腾不起来，所以换成了hugo。而且因为用的是Github Page所以原来用不了的域名也能用上了
会慢慢地把文章都搬过来。不过原来博客的也不会废弃，只是会更多地关注这边而已。除非服务器到期不想续了</description>
    </item>
    
    <item>
      <title>友链</title>
      <link>https://z217blog.cn/friend/</link>
      <pubDate>Wed, 05 Aug 2020 11:00:59 +0800</pubDate>
      
      <guid>https://z217blog.cn/friend/</guid>
      <description> 莓道理的博客  </description>
    </item>
    
    <item>
      <title>Git常用指令汇总</title>
      <link>https://z217blog.cn/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/</link>
      <pubDate>Tue, 04 Aug 2020 19:36:05 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/</guid>
      <description>创建仓库/init git init 创建成功后当前目录下会生成一个.git目录，用于跟踪和管理版本库。
添加文件/add git add . 自动添加本地所有修改。
提交/commit git commit $-m$ 增加提交信息。
$-a$ 自动寻找修改的文件并提交。
状态查看/status git status $-s$ 简短输出。
改动查看/diff&amp;amp;blame git diff $&amp;ndash;cached$ 显示暂存区的改动。
$HEAD$ 查看所有改动。
$&amp;ndash;stat$ 显示摘要。
git blame 文件修改记录。
历史查看/log git log 按时间由近到远排序，列出最近的三次提交。
$-p\ \ [filename]$ 文件最后一次提交信息。
$&amp;ndash;pretty=oneline$ 可以列出简略的信息。
$&amp;ndash;graph$ 拓扑图显示。
$&amp;ndash;reverse$ 逆向显示。
$&amp;ndash;author=$ 查找指定作者。
$&amp;ndash;since$, $&amp;ndash;before$, $&amp;ndash;util$, $&amp;ndash;after$ 指定日期。
$&amp;ndash;decorate$ 显示标签。
提交撤销/revert git revert 回退版本/reset git reset --hard HEAD^ git reset --hard HEAD~2 git reset --hard 56e7 $HEAD$ 表示当前版本。^ 表示回退一个版本，可以输入多个 ^。$\sim$ 之后可以输入任意数字，表示回退对应数量的版本。也可以直接输入版本号，版本号通过 $git\ \ log$ 命令查询，使用版本号不仅可以回退版本，在错误回退版本之后，也可以前进到指定的版本，版本号可以不写全，但一定要写到Git能识别出唯一一个版本为止。</description>
    </item>
    
    <item>
      <title>JWT简介</title>
      <link>https://z217blog.cn/post/jwt%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 04 Aug 2020 16:41:22 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jwt%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34;&gt;JWT-Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        &lt;code&gt;JWT&lt;/code&gt;( $JSON\ \ Web\ \ Token$ )是一种基于&lt;code&gt;JSON&lt;/code&gt;的用于创建可选签名或可选加密的数据的互联网标准。&lt;code&gt;Token&lt;/code&gt;使用一个私钥或者公钥进行签名，持有私钥或者公钥的一方可以验证令牌的合法性。&lt;code&gt;Token&lt;/code&gt;被设计为紧凑且安全的，尤其适用于&lt;code&gt;Web&lt;/code&gt;浏览器单点登录 ( &lt;code&gt;Single-sign-on&lt;/code&gt;, $SSO$ ) 场景。&lt;code&gt;JWT&lt;/code&gt;声明一般用于在身份提供者和服务提供者之间传递用户身份信息，或者用于业务流程要求的任何其他类型的声明。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://z217blog.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 10 Jul 2020 16:57:11 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式常用的七大原则：
 单一职责原则——一个类应该只负责一项职责。 接口隔离原则——一个类对应另一个类的依赖应该建立在最小的接口上。 依赖倒转原则  高层模块不应依赖于低层模块 抽象不应该依赖于细节 面向接口编程（中心思想）   里氏替换原则——所有引用基类的地方必须能透明的使用子类。 开闭原则——软件实体对扩展开放，对修改关闭，用抽象构建框架，用实现扩展细节。 迪米特法则——一个类应该将逻辑封装在内部，不对外泄露。 合成复用原则——尽量使用合成/聚合方式   23种设计模式的三种类型：
 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式； 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式； 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）。  1.单例模式  单例模式，即采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（通常为静态方法）。单例模式有八种方式：
 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举  1.1 饿汉式（静态常量）  构造器私有化（即不能通过 $new$ 创建实例） 类内部创建对象 向外暴露一个静态公共方法 代码实现  class Singleton { private final static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; } } 优点：写法简单，在类装载时实例化，避免了线程同步问题。</description>
    </item>
    
    <item>
      <title>数据库系统（9）：事务管理</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 13 Jun 2020 17:55:26 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</guid>
      <description>DBMS应该具备的功能中，有三个密切相关的功能，用以保证数据库的可靠性和一致性，即事务支持、并发控制服务和恢复服务。它们之间是相互依赖的。并发控制和恢复主要用于保护数据库，避免数据库发生数据不一致或者数据丢失。许多DBMS都允许用户对数据库进行并发操作。如果对这些操作不加控制，对数据库的访问将互相干扰，使得数据库出现不一致的情况。为了解决这个问题，DBMS实现了并发控制 ( $concurrency\ \ control$ ) 协议，来阻止数据库访问之间的相互干扰。数据库恢复 ( $Database\ \ recovery$ ) 是指在故障以后将数据库还原到正确状态的过程。
1. 支持事务处理  事务 ( $Transaction$ ) 是由单个用户或者应用程序执行的，完成读取或者更新数据库内容的一个或者一串操作。事务是数据库的逻辑操作单位 ( $logical\ \ unit\ \ of\ \ work$ ) 。它可以是整个程序、部分程序或者一条命令，也可以是涉及数据库的任意多个操作。从数据库的角度来看，应用程序的一次执行就是一个事务或者多个事务，若看成多个事务，在事务与事务之间只会出现非数据库操作。复杂的事务由很多操作构成。若并非所有操作都被执行，那么可能会出现不一致状态 ( $inconsistent\ \ state$ ) 。在事务处理过程中，尽管我们允许数据库的一致性遭到暂时破坏，但是事务应该总是能将数据库从一种一致的状态转移到另一种一致的状态。
事务可能有以下两种结果中的一种。如果执行成功，也就是说事务最终被提交 ( $committed$ )，数据库也将到达一种新的一致状态。另一种情况下，事务没有执行成功，则会被撤销 ( $aborted$ )。如果事务被撤销，则数据库必须要还原到事务开始之前的一致的状态。我们称这样的事务被回滚 ( $rolled\ \ back$ ) /撤销 ( $undone$ )。已经提交的事务无法撤销。如果发现已提交的事务存在错误，必须执行另一个补偿事务 ( $compensating\ \ transaction$ ) 来消除该事务已经产生的影响。
DBMS无法得知哪些更新操作将被组合在一起以构成一个独立的逻辑事务。因此很多数据操作语言中都使用关键字 $BEGIN$, $TRANSACTION$, $COMMIT$, $ROLLBACK$ 来划定界限。如果不使用，通常会将整个程序视为一个事务。
1.1 事务的性质  原子性 ( $Atomicity$ )：事务是一个不可分割的单元，要么全执行，要么全不执行。事务的原子性由DBMS的恢复子系统负责保证。 一致性 ( $Consistency$ )：事务必须将数据库从一种一致的状态转换到另一种一致的状态。事务的一致性是由DBMS和应用程序的开发者共同保证的。DBMS可以通过强制实施所有在数据库模式中定义的约束（如完整性约束和企业自定义约束）来保证一致性。 隔离性 ( $Isolation$ )：事务的执行是相互独立的，即未完成事务的中间结果对其他事务来说应该是不可见的。事务的隔离性由并发控制子系统负责保证。 持久性 ( $Durability$ )：成功完成的事务的结果要永久地记录在数据库中。事务的持久性由恢复子系统负责保证。  1.</description>
    </item>
    
    <item>
      <title>数据库系统（8）：规范化</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/</link>
      <pubDate>Fri, 22 May 2020 16:13:29 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/</guid>
      <description>规范化 ( $Normalization$ ) 是一种数据库设计技术，从分析属性之间的联系入手。规范化使用一系列测试，描述为范式 ( $normal\ \ forms$ ) 帮助我们确定这些属性的最佳组合，最终生成一组适当关系。
1. 目的  规范化的目的是确定一组合适的关系以支持企业的数据需求。该关系具有以下性质：
 属性的个数最少，且是必需的 具有紧密逻辑联系，描述为函数依赖 ( $functional\ \ dependency$ ) 的所有属性均在一个关系中 最少的冗余，即每个属性仅出现一次，除了作为外键的属性，因为连接相关关系必须用到外键   具有一组合适的关系，数据库会易于用户访问，数据易于维护，在计算机上也会占有较小的存储空间。
2. 支持  规范化有两种使用方法。方法 $1$ 将规范化视为一种自下而上 ( $bottom-up$ ) 的独立的数据库设计技术。方法 $2$ 将规范化作为一种确认技术使用，即用规范化检验关系的结构，而这些关系的建立可能采用自上而下的方法，如ER建模等。
3. 数据冗余与更新异常  关系数据库设计的一个目的就是将属性组合成关系时保证最少的数据冗余。当然，关系数据库的运行也依赖于一定的数据冗余的存在，一般是以主键或者候选键的多个副本的形式出现，作为外键表示数据间联系。存在冗余数据的关系可能存在一些问题，如更新异常 ( $update\ \ anomalies$ )。更新异常又可分为插入异常、删除异常和修改异常。
 $Staff$ 和 $Branch$ 是不存在数据冗余的两个表。$StaffBranch$ 是将上两个表合起来的存在数据冗余的表，同一个分公司的信息会重复出现。
3.1 插入异常  插入异常主要有两类：
 在向 $StaffBranch$ 中插入新员工时，若同一家分公司信息不同，则会产生一致性问题； 在向 $StaffBranch$ 中插入新的分公司时，由于没有员工，因此员工信息都应设为 $null$ 。但是主键 $staffNo$ 不能为空，否则会违反实体完整性约束。  3.</description>
    </item>
    
    <item>
      <title>数据库系统（7）：ER模型</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 21 May 2020 15:51:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/</guid>
      <description>ER模型是一种自上而下 ( $top-down$ ) 的数据库设计方法，该方法首先确定那些被称为实体的重要数据和这些数据之间的联系，实体和联系时ER模式中必备的元素。然后添加更多的细节信息，如属性、约束等。
统一建模语言 ( $Unified\ \ Modeling\ \ Language$, $UML$ ) 是软件工程项目的工业标准建模语言，我们使用UML的符号集来绘制ER模型。
1 实体类型  实体类型 ( $Entity\ \ types$ ) 是被企事业单位认可的、能够独立存在的一组具有相同属性的对象，是ER模型的基本概念。实体类型既可以是物理 ( 真实 ) 存在的，也可以是概念 ( 抽象 ) 存在的对象。实体出现 ( $entity\ \ occurrence$ ) 是实体类型中可唯一标识的一个对象。在没有歧义的时候，实体类型和实体出现都可以直接简称为实体。
在UML中，实体类型通过一个标有名字的矩形标识，每个实体名字的首字母是大写的。
2. 联系类型  联系类型 ( $Relationship\ \ types$ ) 是实体类型间一组有意义的关联。每个联系类型都被赋予一个能够描述其功能的名字。联系出现 ( $Relationship\ \ occurrence$ ) 是由参与该联系的各个实体类型的一个出现组成的可被唯一标识的关联。
在UML中，每个联系类型都表现为用线将相关的实体类型联系起来，并在线上标上联系的名字，通常使用一个动词或者动词短语命名。同样的，首字母也应该大写。一个联系还要标识方向，意味着这个联系仅在一个方向上有意义。可以在名字旁边添加一个箭头符号，如 $\blacktriangleleft$ 来标识方向。当我们要表示 $A\ \ Has\ \ B$ ( $A$，$B$ 为实体，$Has$ 为联系类型 ) 时可以用如下方法：</description>
    </item>
    
    <item>
      <title>数据库系统（6）：SQL数据定义</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Wed, 20 May 2020 16:46:30 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</guid>
      <description>1. 数据类型 1.1 标识符  SQL标识符 ( $identifier$ ) 用于表示数据库中的对象，如表名、列名、视图名等。用户定义标识符所用的字符必须是字符集 ( $character\ \ set$ ) 中存在的。默认的字符集包括 $A-Z$, $a-z$ 和 $_$ ，也可以另外指定其他字符集。标识符的限制有：
 不能长于 $128$ 个字符（在一些方言中会更短） 必须以字母开头 不能有空格  1.2 数据类型    数据类型 声明     布尔型 $BOOLEAN$   字符型 $CHAR$, $VARCHAR$   位类型 $BIT$, $BIT\ \ VARYING$   定点数型 $NUMERIC$, $DECIMAL$, $INTEGER$, $SMALLINT$, $BIGINT$   浮点数型 $FLOAT$, $REAL$, $DOUBLE\ \ PRECISION$   日期时间型 $DATE$, $TIME$, $TIMESTAMP$   间隔型 $INTERVAL$   大对象型 $CHARACTER\ \ LARGE\ \ OBJECT$, $BINARY\ \ LARGE\ \ OBJECT$    1.</description>
    </item>
    
    <item>
      <title>数据库系统（5）：SQL数据操作</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 20 May 2020 14:17:14 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</guid>
      <description>1. SQL简介  SQL是关系模型发展过程中出现的一种特殊语言，已经成为了标准的关系数据库语言。SQL是面向转换语言 ( $transform-oriented\ \ language$ ) 的例子，将输入关系转换为所需的输出关系，包括两个主要部分：DML和DDL。
SQL具有许多实现版本，每个实现称为方言 ( $dialect$ ) ，供应商在标准之外提供的特性称为扩展 ( $extensions$ )。
1.1 优点  满足数据库语言的思想 易于学习 结构简洁、轻便 存在SQL标准 可以通过终端或者嵌入式访问 所有人都可以使用  1.2 缺点  混合了编程规范和嵌入式访问 缺乏正交性，有多种表达方式 语言越来越复杂和庞大 聚合函数中对空的处理问题 结果表中可以有重复元组，对表中的行和列都强加了一个顺序  2. SQL命令  SQL语言包括保留字 ( $reserved\ \ words$ ) 和用户自定义字 ( $user-defined\ \ words$ ) 。保留字是SQL语言的固定部分，有固定含义。用户自定义字由用户定义，用于表示表、列、视图和索引等数据库对象的名称。虽然标准并没有要求，但是SQL的许多实现版本要求用句子终结符来表示SQL语句的结束。SQL语句的多数组成部分是不区分大小写的，除了字符数据常量外。
2.1 数据操作  DML语句有以下几种：
 $SELECT$, $INSERT$, $UPDATE$, $DELETE$.   常量 ( $Literals$ ) 是指SQL语句中的不变量 ( $constants$ )。不同的数据具有不同的常量形式，所有的非数值型数据必须使用引号，而所有的非数值型数据不能使用引号。</description>
    </item>
    
    <item>
      <title>数据库系统（4）：关系代数</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</link>
      <pubDate>Sun, 17 May 2020 16:05:13 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</guid>
      <description>关系代数 ( $Relational\ \ Algebra$ ) 可以看成一种过程式语言，可用于构造新关系。关系代数是一种纯理论语言，它定义了一些操作，运用这些操作可以从一个或多个关系中得到另一个关系而不改变原关系。关系代数的一个表达式可以嵌套另一个表达式，这种性质称为闭包 ( $closure$ )，即关系在关系代数下是封闭的。
关系代数是一种每次一关系/集合的语言，即用一条不带循环的语句处理，结果也是由所有元组组成的整个关系。关系代数中包含了许多运算，其中五个基本运算是选择 ( $Selection$ ) 、投影 ( $Projection$ ) 、笛卡尔乘积 ( $Cartesian\ \ product$ ) 、集合并 ( $Union$ ) 、集合差 ( $Set\ \ difference$ ) 。选择和投影都是一元运算，其他的运算则是二元运算。除此之外，还有连接 ( $Join$ ) 、集合交 ( $Intersection$ ) 、除 ( $Division$ ) 等，它们都能通过五个基本运算表示。
1. 一元运算 1.1 选择  $$ \sigma_{predicate}(R) $$   作用于单个关系 $R$ ，得到一个新关系，该关系由满足谓词 $predicate$ 的元组组成。可以理解为从表中选出符合条件的行构成一个新表。
1.2 投影  $$ \prod\nolimits_{a_1,a_2,...,a_n}(R) $$   作用于单个关系 $R$ ，得到一个由 $R$ 的垂直子集构成的新关系，该子集抽取 $R$ 中指定属性上的值并去掉重复元组。可以理解为从表中选出指定的列构成一个新表。</description>
    </item>
    
    <item>
      <title>数据库系统（3）：关系模型</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 15 May 2020 13:08:11 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</guid>
      <description>在目前使用的数据处理软件中，关系数据库管理系统 ( $Relational\ \ Database\ \ Management\ \ System$, $RDBMS$ ) 占据了统治地位。RDBMS基于关系数据模型。在关系模型中，所有数据逻辑上被组织成关系（表）结构。
1. 基本术语  关系模型基于数学中的关系 ( $relation$ )。
1.1 关系数据结构 1.1.1 关系  关系是由行和列组成的表。在关系模型中，用关系保存数据库所描述对象的信息，关系用二维表表示。用户主要接触的就是表，但这只限于逻辑结构，即外部层和概念层。对于物理结构，由于是通过多种存储结构实现的，因此并不适用。
1.1.2 属性  属性 ( $Attribute$ ) 是关系中命名的列。在关系的二维表中，每一行对应一个单独的记录，每一列则对应一个属性。
1.1.3 域  域 ( $Domain$ ) 是一个或多个属性的取值集合，必须给每一个属性定义一个域。不同属性的域可以互不相同，也可以共用。通过使用域，用户可以集中定义属性的取值范围和含义。
1.1.4 元组  元组 ( $Tuple$ ) 是关系中的行。关系的结构、域说明以及所有取值约束统称为关系的内涵 ( $intension$ )。它通常是固定的，除非关系的意义改变，需要加入新的属性。元组的集合称为外延 ( $extension$ ) /状态 ( $state$ )，它经常发生改变。
1.1.5 维数  维数 ( $Degree$ ) 是关系所包含的属性个数。只有一个属性的关系称为一元关系或者一元组，两个属性的关系称为二元关系，以此类推，$n$ 个属性的关系称为 $n$ 元组。维数是内含的性质之一。</description>
    </item>
    
    <item>
      <title>数据库系统（2）：数据库环境</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 14 May 2020 11:09:00 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/</guid>
      <description>1. ANSI-SPARC三层体系结构  三层体系结构 ( $Three\ \ Level\ \ Architecture$ )，包括外部层 ( $External$ )、概念层 ( $Conceptual$ ) 和内部层 ( $Internal$ )。用户从外部层观察数据，DBMS和操作系统从内部层观察数据。在内部层，数据使用定义的数据结构和文件组织方法进行存储。概念层则提供内部层和外部层的映射 ( $Mapping$ ) 以及必要的独立性 ( $Independence$ )。三层体系结构的目的是将用户的数据库视图与数据库的物理描述分离。
1.1 外部层  外部层是数据库的用户视图，这一层描述数据库中与用户相关的部分。对于每一个用户，数据库中都存储着其对用的视图。并且对于同一个数据，在不同的视图中可能有着不同的表达方式。
1.2 概念层  概念层是数据库的整体视图，这一层描述哪些数据存储在数据库中，以及这些数据之间的联系。概念层描述：
 所有的实体、实体的属性和实体间的联系 数据的约束 数据的语义信息 安全性和完整性信息   概念层支持每一个外部视图，凡是用户可访问的数据必定包含在概念层或者由概念层导出。
1.3 内部层  内部层是数据库在计算机上的物理表示，这一层描述数据是如何存储在数据库中的。内部层与如下工作相关：
 数据和索引的存储空间分配 存储记录的描述 存储记录 数据压缩和加密   在内部层之下是物理层 ( $Physical\ \ Level$ ) ，物理层可能在DBMS的指导下受操作系统的控制。
1.4 模式、映射和实例  对数据库的整体描述称为数据库模式 ( $Database\ \ Schema$ ) 。在数据库中存在三种不同类型的，在外部层有若干外部模式 ( $External\ \ Schema$ ) /子模式 ( $Subschema$ )，与不同的数据视图对应。在概念层有概念模式 ( $Conceptual\ \ Schema$ )，描述所有实体、属性和联系及其之间的完整性约束。在内部层，有内部模式 ( $Internal\ \ Schema$ )，是内部模型的完整描述，包括存储记录的定义、表示方法、数据域，必要时还有所使用的索引和散列方案。一个数据库可以有多个外部模式，但只能有一个概念模式和内部模式。</description>
    </item>
    
    <item>
      <title>数据库系统（1）：数据库简介</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 13 May 2020 14:23:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 基于文件的系统  基于文件的系统 ( $Traditional\ \ File-Based\ \ Systems$ ) 是一组为终端用户提供服务的应用程序，每一个程序定义和管理它自己的数据。相较于使用纸质文件进行管理的手工文件系统，基于文件的系统更加高效。但是它未能集中存储组织机构的运行数据，而是采用了分散的方法，即每一个部门在数据处理 ( $DP$ ) 人员的帮助下存储和控制它们的数据。通过编写应用程序来管理和查询数据，具有程序-数据依赖性 ( $Program-data\ \ Dependence$ ) 。
1.1 术语  文件 ( $File$ ) 是一些记录 ( $Records$ ) 的简单集合，这些记录中包含逻辑上相关的数据。每一条记录包含一组逻辑上相关的一个或多个数据项/域 ( $Fields$ ) 。
1.2 局限性  数据被分离和孤立
数据被孤立在分离的文件中，如果要访问处于不同文件之间的数据，需要创建一个临时文件。 数据存在冗余
由于文件间的分离，有时需要重复记录一些数据。 数据存在依赖性
数据文件的物理结构和存储方式是由应用程序定义的，很难做出改变，也即程序-数据依赖性。 文件格式不相容
文件结构嵌入应用程序，因此由应用程序语言决定。难以兼容其他使用不同语言的文件结构。 需要不断更改应用程序
完全依赖于开发人员，要求开发人员以编程方式实现所有查询和表。如果查询需求发生了变化，需要重新编写程序或更改文件。  2. 数据库方法  基于文件的系统存在许多问题，总结原因是：
 数据内嵌应用程序 无法实现程序规定之外的操作   因此我们需要一种更加高效的方法，数据库 ( $Database$ ) 和 数据库管理系统 ( $Database\ \ Management\ \ System,\ \ DBMS$ ) 应运而生。</description>
    </item>
    
    <item>
      <title>Redis笔记</title>
      <link>https://z217blog.cn/post/redis%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 10 May 2020 17:20:42 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/redis%E7%AC%94%E8%AE%B0/</guid>
      <description>1. Redis简介 NoSQL即 $Not-Only\ \ SQL$ ，是RDBMS的补充。
Redis是一种NoSQL数据库，是一个使用C语言开发的开源的高性能键值对数据库，内部使用单线程机制进行工作。
 $set\ \ [key]\ \ [value]$ 添加信息, $get\ \ [key]$ 查询信息，为空返回 $nil$ , $del\ \ [key]$ 删除信息，$1$ 代表删除成功, $clear$ 清屏, $help\ \ [op]$ 帮助, $time$ 获取时间.  2. 数据类型 Redis采用键值对的方式存储，$key$ 为字符串，$value$ 则允许多种类型。
2.1 string 最简单的数据类型，最大存储量 $512MB$ ， 可以作为数字使用，最大值为 $java.lang.Long$ 类型的最大值， 允许以JSON对象的方式存储数据，值中间不能有空白符
 $mset/mget$ 获取多个数据 $strlen$ 获取字符个数 $append$ 追加，返回总长度，也可以用于添加信息 $incr/incrby/incrbyfloat$ 指定数据增加指定值，允许负数，返回数值 $decr/decrby$ 指定数据减少指定的值，允许负数，返回数值 $setex/psetex$ 设定数据周期，秒/毫秒  2.2 hash hash 属于 $value$ ，其中包含多组键值对，键称为 $field$ ，键值对较少时为类数组结构，较多时为 $HashMap$ 结构，$value$ 只能为 string ，且最多只能有 $2^{32} - 1$ 组。</description>
    </item>
    
    <item>
      <title>JavaWeb（4）：Spring简介</title>
      <link>https://z217blog.cn/post/javaweb4spring%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 21 Apr 2020 15:48:49 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb4spring%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
Maven依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.inject&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.inject&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.annotation&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.annotation-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;   Spring Framework是一个Java应用程序容器，它提供了许多有用的特性，如反转控制（IoC）、依赖注入（DI）、抽象数据访问、事务管理等。
IoC是一个软件设计模式，即组装器（Spring Framework)在运行时才会绑定对象，也就是运行时才会实例化依赖的组件。这使得开发者可以针对接口进行编程，无需重新编译代码。DI是IoC的一种实现方式，通过DI，一个类可以通过声明其依赖的接口类型，然后利用组装器在运行时注入其依赖的实例。
Spring Framework提供了一个MVC（模型-视图-控制）模式框架，利用它可以简化创建Web应用程序的过程，不用手动处理复杂的Servlet、HttpServletRequest等。控制器类的每个方法都被映射到了一个不同的请求URL、方法或请求的其他属性上，模型可以通过 $Map$&amp;lt;$String, Object$&amp;gt;的形式从控制器传递到视图，控制器返回的视图或视图名称将把模型转发到合适的JSP视图。通过这些特性，Spring Framework极大地简化了Servlet容器的工作内容。
使用MVC框架时，控制器类中的每个方法都可以拥有一个指向特定URL、请求方法、参数存在性、头的值、内容类型或期望响应类型的唯一映射。
Spring Framework容器以一个或多个应用上下文的形式存在，由 $org.springframework.context.ApplicationContext$ 接口表示。一个应用上下文管理着一组bean、执行业务逻辑的Java对象、执行任务等。由Spring管理的bean可以自动进行DI、消息通知、bean验证等服务。一个Spring程序至少需要一个应用上下文，也可以使用多个应用上下文组成层次结构。在层次结构中应用上下文间有着类似于树的父子兄弟关系，一个子应用上下文的bean可以访问父应用上下文的bean，但无法访问兄弟应用上下文的bean。许多类都继承了 $ApplicationContext$ ，也有许多实现了它：
   类 描述     $ConfigurableApplication$ 可配置的应用上下文   $WebApplicationContext$ 用于Java EE Web应用程序，提供了对 $ServletContext$ 和 $ServletConfig$ 的访问   $ConfigurableWebApplicationContext$ 可配置的 $WebApplicationContext$   $XmlApplicationContext$ 用于在Java EE Web应用程序中从XML文件加载Spring配置   $AnnotationConfigWebApplicationContext$ 用于在Java EE Web应用程序中以编程方式配置Spring     Spring使用 $DispatcherServlet$ 处理Web请求，该Servlet将请求委托给合适的控制器，并按需求对请求和响应实体进行转换。在Web应用程序中，我们可以使用任意数量的 $DispatcherServlet$ 。每个 $DispatcherServlet$ 类都有自己的应用上下文，包含了对Web应用程序的 $ServletContext$ 和自己的 $ServletConfig$ 的引用。</description>
    </item>
    
    <item>
      <title>使用WebSocket实现的一个简单的多人聊天室</title>
      <link>https://z217blog.cn/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Sun, 19 Apr 2020 17:25:57 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>环境：JDK1.8, tomcat-8.5.51
源码可以在GitHub上查阅：ChatRoom
 WebSocket最常用的地方就是聊天室，所以我用Servlet+WebSocket实现了一个简单的多人聊天室。这个多人聊天室改一改就能作为一对一的聊天室使用，毕竟实现方法都是差不多的。
 首先是maven依赖，在此只展示几个要注意的依赖项：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.18.12&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; ...... ...... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.datatype&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-datatype-jsr310&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;  Lombok简化实体的编写（虽然只有一个实体），然后jackson相关的依赖用于Java实例和JSON对象之间的相互转化。为了避免兼容问题，我这里选择依赖基本上都是最新版本。
然后是实体，$ChatMessage$ 用于存储消息相关的信息，使用lombok简化了编写：
import lombok.AllArgsConstructor; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.Setter; import java.time.OffsetDateTime; @Getter @Setter @AllArgsConstructor @NoArgsConstructor public class ChatMessage { private String username; private String message; private OffsetDateTime timestamp; }  有了实体之后再建立仓库，用于存储聊天信息以及用户信息：
import java.util.LinkedList; import java.util.List; import java.util.concurrent.CopyOnWriteArraySet; public class ChatRepository { private static List&amp;lt;ChatMessage&amp;gt; repository = new LinkedList&amp;lt;&amp;gt;(); private static CopyOnWriteArraySet&amp;lt;String&amp;gt; users = new CopyOnWriteArraySet&amp;lt;&amp;gt;(); public static List&amp;lt;ChatMessage&amp;gt; getRepository() { /*.</description>
    </item>
    
    <item>
      <title>JSON序列化传输过程中中文乱码问题的解决方法</title>
      <link>https://z217blog.cn/post/json%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 18 Apr 2020 22:13:49 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/json%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>今天在用WebSocket和Servlet写聊天室的时候发现传输中文会乱码的问题，起初以为是在用jackson的 $ObjectMapper$ 将对象转化为字节流的时候出现的问题，但是经过检查后发现不是。又检查了一遍编码，确认了网页的编码是utf-8，输入的字符串也是utf-8，然后发现问题是出在了JSON对象传输的过程中。最后在 stackoverflow 上找到了解法。
 我的问题出在将经过JSON序列化之后的消息对象字符串转换为 $Uint8Array$ 以及将 $Uint8Array$ 转为消息对象的过程中，对此可以采用 $TextEncoder$ 和 $TextDecoder$ 对象。如下所示：
let encoder = new TextEncoder(&amp;#39;utf-8&amp;#39;); let decoder = new TextDecoder(&amp;#39;utf-8&amp;#39;); let message = { username: &amp;#39;用户&amp;#39;, content: &amp;#39;你好，世界！&amp;#39; }; let array = encoder.encode(JSON.stringify(message)); let newMessage = JSON.parse(decoder.decode(array));  在上例中，我们分别使用 $TextEncoder$ 和 $TextDecoder$ 以utf-8作为编码方式创建了编码器和译码器，之后声明了一个 $message$ 对象存储我们要传递的消息，使用JSON序列化该对象，并使用编码器进行编码，编码后得到的是可以进行传输的 $Uint8Array$ 对象，而对其使用译码器进行译码可以得到另一个 $newMessage$ 对象，该对象内存储的值与之前的 $message$ 相同，并且没有出现中文乱码的现象。</description>
    </item>
    
    <item>
      <title>JavaWeb（3）：WebSocket简介</title>
      <link>https://z217blog.cn/post/javaweb3websocket%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 06 Apr 2020 14:57:01 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb3websocket%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
 WebSocket用于解决浏览器和服务器的通信问题。在现有体系中，如果只是简单的使用Ajax进行通信的话，容易出现的问题是只有浏览器发送请求时才能得到响应。也即当有新数据时，浏览器不能得知新数据的存在，也就不能及时发送请求获取新数据。
WebSocket使用了HTTP/1.1 升级特性。该特性的使用很简单，只需要在请求中包含头名称和值 $Connection: Upgrade$ ，并在额外的 $Upgrade$ 头中指定一个或多个协议的列表。如果服务器接收升级请求，那么将返回 $101\ \ Switching\ \ Protocols$ 。HTTP升级提供的最重要的特性是我们可以使用任意协议，并且在升级完成后就不再使用HTTP连接，我们可以用一个Socket来代替，由此产生了WebSocket协议。WebSocket协议将使用心跳消息（分别称为 $ping$ 和 $pong$ ）保持连接活跃，即周期性地发送小数据包。在连接升级为WebScoket协议之后，文本和二进制消息可以持续在两个方向上发送且不需要关闭和重连了；而且HTTP规范要求对应同一个主机名，只允许有两个并发连接，但由于我们升级为WebScoket连接了，因此该规范也不存在了。
使用WebSocket协议之前需先以HTTP协议向服务器发送特殊请求，访问一个特殊的URL，该URL以ws或者wss开头，分别对应http和https，并且除了 $Connection: Upgrade$ 头之外，还包含一个 $Connection: websocket$ 头，用于指定服务器将连接升级为 WebSocket协议。
 HTML5(JavaScript)客户端API  WebSocket并不是只能用于浏览器和服务器的通信中，理论上可以将其应用于任何支持其的应用程序中。但如果要编写使用WebSocket进行连接的浏览器客户端终端，我们就要用到JavaScript，尽管我们使用JavaScript编写，但实际上WebSocket是HTML5的一部分。使用JavaScript创建WebSocket对象十分简单：
var connection = new WebSocket(&amp;#39;ws://www.example.com/chat&amp;#39;, {&amp;#39;chat.v1&amp;#39;, &amp;#39;chat.v2&amp;#39;});  WebSocket构造函数第一个参数为连接所使用的URL，第二个参数可选，为连接所使用的一个或多个协议，这些协议都是自己创建的，不受WebSocket管理。
WebSocket接口中包含 $readyState$ 属性表示当前状态，值为 $CONNECTING$, $OPEN$, $CLOSING$, $CLOSED$ 中的一个，包含四个事件：$onopen$, $onclose$, $onerror$, $onmessage$ ，前两者分别在 $readyState$ 由 $CLOSING$ 变为 $CLOSED$ 时和 $readyState$ 由 $CONNECTING$ 变为 $OPEN$ 时触发。传入 $onclose$ 方法的事件包含三个属性：$wasClean$, $code$, $reason$ ，传入 $onopen$ 的是普通的事件，传入 $onerror$ 和 $onmessage$ 的事件包含一个 $data$ 属性，在前者中是错误对象，而在后者则根据消息类型转变：消息为字符串，则 $data$ 也为字符串；消息为二进制数据，并且 $WebSocket.</description>
    </item>
    
    <item>
      <title>JavaWeb（2）：Session简介</title>
      <link>https://z217blog.cn/post/javaweb2session%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 26 Mar 2020 15:41:52 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb2session%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
注：演示所用 Java 版本为 Java8 ，所用容器为 Tomcat8.5.51
 会话用于处理维持请求和请求之间的状态。在没有使用会话时，HTTP请求是无状态的，在浏览器打开第一个连接到服务器的套接字时开启，在服务器返回最后一个数据包时结束。而有些时候，我们希望保持状态，如用户登录或者在线编辑时，这时我们就要用到会话。
在Web中，会话是由服务器或Web应用程序管理的某些文件、内存片段、对象或者容器。服务器在第一次接收到请求时，会随机生成一串字符串，称为会话ID，并返回用户浏览器中。之后所有从该用户浏览器中发出的请求都需要包含该会话ID，服务器接收到会话ID后可以将会话与请求关联起来。HTTP cookie用于将会话ID发送到服务器，但是如果用户浏览器禁止了cookie，那么就需要将会话ID内嵌在URL中，很明显，这种方式使得其他人可以轻松地获得会话，因此是不安全的。不过由于如今许多网站都要求用户在访问时启用cookie，因此我们可以不用顾虑这点。
会话也是有漏洞的。但是由于描述起来篇幅过长，因此不做赘述，如果感兴趣的话可以在 Session hijacking -Wikipedia 中查看。
 大部分情况下我们可以直接使用会话，不需要添加显式配置，但是出于安全目的，我们应该进行配置。使用&amp;lt;$session-config$&amp;gt;标签进行配置，同时在&amp;lt;$session-config$&amp;gt;标签内，我们也可以使用&amp;lt;$cookie-config$&amp;gt;标签进行cookie的配置。所有在&amp;lt;$session-config$&amp;gt;标签和&amp;lt;$cookie-config$&amp;gt;标签内的标签都是可选的。下面列出了所有的可选标签：
&amp;lt;session-config&amp;gt; &amp;lt;session-timeout&amp;gt;30&amp;lt;/session-timeout&amp;gt; &amp;lt;cookie-config&amp;gt; &amp;lt;name&amp;gt;JSESSIONID&amp;lt;/name&amp;gt; &amp;lt;domain&amp;gt;example.org&amp;lt;/domain&amp;gt; &amp;lt;path&amp;gt;/path&amp;lt;/path&amp;gt; &amp;lt;comment&amp;gt;&amp;lt;! [CDATA[Keeps you logged in. See our privacy policy for more information.]]&amp;gt;&amp;lt;/comment&amp;gt; &amp;lt;http-only&amp;gt;true&amp;lt;/http-only&amp;gt; &amp;lt;secure&amp;gt;false&amp;lt;/secure&amp;gt; &amp;lt;max-age&amp;gt;180&amp;lt;/max-age&amp;gt; &amp;lt;/cookie-config&amp;gt; &amp;lt;tracking-mode&amp;gt;COOKIE&amp;lt;/tracking-mode&amp;gt; &amp;lt;tracking-mode&amp;gt;URL&amp;lt;/tracking-mode&amp;gt; &amp;lt;tracking-mode&amp;gt;SSL&amp;lt;/tracking-mode&amp;gt; &amp;lt;/session-config&amp;gt;  下面为每个标签的作用：
   标签 作用     &amp;lt;$session-timeout$&amp;gt; 会话在无效前可以保持不活跃状态的时间，以分钟为单位，为 $0$ 表示永远不过期。   &amp;lt;$tracking-mode$&amp;gt; 表示容器使用哪种技术追踪会话ID，可以配置多个值，按照配置顺序使用。URL表示容器将在URL中内嵌会话ID，COOKIE表示使用cookie，SSL表示使用SSL会话，但要求所有请求均是HTTPS请求。   &amp;lt;$name$&amp;gt; 可以自定义会话cookie的名字，通常不用设置。   &amp;lt;$domain$&amp;gt; 设置cookie的Domain特性，通常不用设置。   &amp;lt;$path$&amp;gt; 设置cookie的Path特性，通常不用设置。   &amp;lt;$comment$&amp;gt; 可以添加任意文本，用于解释cookie。   &amp;lt;$http-only$&amp;gt; 设置cookie的HttpOnly特性，为了提高安全性，一般都设置为 $true$ 。   &amp;lt;$secure$&amp;gt; 设置cookie的Secure特性，如果使用的是HTTPS，就应设置为 $true$ 。   &amp;lt;$max-age$&amp;gt; 设置cookie的Max-Age特性，控制cookie何时过期，以秒为单位，通常不用设置。     学习了如何配置会话之后，就该学习如何使用会话了。为了获取会话，我们可以调用 $HttpServletRequest.</description>
    </item>
    
    <item>
      <title>JavaWeb（1）：Servlet入门</title>
      <link>https://z217blog.cn/post/javaweb1servlet%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 14 Mar 2020 19:20:22 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb1servlet%E5%85%A5%E9%97%A8/</guid>
      <description>参考书籍：Pro Java for Web Apps
注：以下内容需要HTTP基础，演示所用Java版本为Java8，所用容器为Tomcat8.5.51
 Servlet是一个运行在Web服务器中的Java小程序，用于接收和响应来自Web客户端的请求，使用HTTP进行通信，是所有Web应用程序的核心类，也是唯一的既可以直接处理和响应用户请求，也可以将处理工作委托给应用中的其他部分的类。
Servlet只是一个简单的接口，包含了相关的方法。大多数情况下Servlet都继承自 $javax.servlet.GenericServlet$ 类，该类只包含一个抽象的 $service$ 方法以及一些辅助方法。$service$ 方法会处理所有请求，然后返回对应的响应。我们可以使用$javax.servlet.http.HttpServlet$ 类用于响应HTTP请求，它继承自 $GenericServlet$ 并实现其 $service$ 方法，而对于响应HTTP请求的方法只是空实现。在 $HttpServlet$ 类中，HTTP请求包括 $GET,HEAD,POST,PUT,DELETE,OPTIONS,TRACE$ 对应的响应方法名称为 $do +$ 首字母大写的请求名称。如 $GET$ 对应 $doGet()$ ，$POST$ 对应 $doPost()$ 等。除了响应方法之外，Servlet类中还包含 $init$ 方法和 $destroy$ 方法，分别在启用和关闭Servlet时调用，不过通常这些方法什么也不做。
 大多数情况下我们的Servlet类都是继承 $HttpServlet$ 类。对于上述提到的所有方法，它们都接收两个参数，一个是 $javax.servlet.http.HttpServletRequest$ 类型的参数，另一个是 $javax.servlet.http.HttpServletResponse$ 类型。顾名思义，$HttpServletRequest$ 指向客户端请求，对其我们有如下常用方法：
   方法 作用     $getParameter$ 返回参数的单个值   $getParameterValues$ 返回参数的值的数组   $getParameterMap$ 返回一个包含所有参数名值对的$java.util.Map&amp;lt;String, String[\ \ ]&amp;gt;$   $getParameterNames$ 返回所有可用参数的名字的枚举   $getContentLength$ 返回请求正文的长度（小于 $2$ GB）   $getContentLengthLong$ 返回请求正文的长度（大于 $2$ GB）   $getCharacterEncoding$ 返回请求内容的字符编码   $getReader$ 返回一个 $java.</description>
    </item>
    
    <item>
      <title>Dijkstra算法原理及其实现</title>
      <link>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 03 Mar 2020 17:27:28 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</guid>
      <description>参考书籍：《算法（第4版）》
 $Dijkstra$ 算法应用于带权有向图中求最短路径问题。通俗来讲就是不断选择权值最小的边加入集合直到所有顶点都在集合中，属于贪心算法。需要注意的是，$Dijkstra$ 算法只能用于解决边权非负的图类问题。
假设对于一个带权有向图 $G(V,E)$ 以邻接矩阵表示，其所有边存储在一个二维整型数组 $matrix[\ \ ][\ \ ]$ 中， $matrix[i][j]$ 表示从顶点 $i$ 到顶点 $j$ 之间的边，值为边的权值，若值为 $∞$ ，说明该边不存在。为了实现 $Dijkstra$ 算法，我们需要一个布尔值数组 $visit[\ \ ]$ ，用于判断顶点是否访问过，或者说是否在集合中；一个整型数组 $distance[\ \ ]$ 用于储存原点到每个点的最短距离。定义了基本的结构，就可以实现算法了，步骤为：
 从 $V$ 中选择一个点 $s$ 作为原点，将邻接矩阵中的 $matrix[s]$ 数组复制到 $distance[s]$ （复制后 $distance[s]$ 应为 $0$ ），建立一个 $visit[\ \ ]$ 数组并清零。 从 $V$ 中选择一个顶点 $u$ 加入集合，其中点 $u$ 满足：  之前未曾访问过点 $u$ （即 $visit[u] = false$ ）。 与 $s$ 距离最短（即 $distance[u]$ 的值最小）。   以 $u$ 为中心点，对于每个与 $u$ 相邻的顶点 $k$ ，令 $distance[k] = Min(distance[k], distance[u] + matrix[u][k])$ ，这一步也称为松弛( $relaxation$ )。 重复2、3直到所有顶点加入集合。   $Dijkstra$ 算法类似于 $Prim$ 算法，实质上都是构造了一颗树。经过以上步骤之后，我们得到了一个 $distance[\ \ ]$ 数组，其中的值为从原点 $s$ 到图中其他所有点的最短距离。在使用代码实现的过程中，有些情况下我们可以使用优先队列来简化寻找最小权值的这一过程。如果我们确认了一幅图是无环图，那么我们也可以不使用 $visit[\ \ ]$ ，而是通过拓扑排序的顺序依次遍历顶点。</description>
    </item>
    
    <item>
      <title>JavaScript中的数组</title>
      <link>https://z217blog.cn/post/javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 01 Mar 2020 15:05:01 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</guid>
      <description>参考书籍：《JavaScript高级程序设计（第3版）》
 作为一种可以说是最常用的类型，EMCAScript当中的数组与其他语言的数组有很大区别，例如数组元素可以是不同类型，数组长度可以动态调整等，因此我总结了一下EMCAScript中的数组类型，即 $Array$ 类型（主要集中于与其他语言不同的地方）。
 数组创建 数组长度 数组方法  判定方法 转换方法 栈方法 队列方法 排序方法 操作方法 位置方法 迭代方法 归并方法    1. 数组创建  EMCAScript中数组是一个特殊的类型，有自己的构造函数，我们可以通过 $new$ 运算符来调用数组的构造函数。
var array = new Array(); //建立一个空数组  当然，你也可以通过传参来调用带参构造函数。
var array1 = new Array(10); //大小为10的数组 var array2 = new Array(1, 2, 3); //包含1,2,3三个元素的数组 var array2 = new Array(&amp;#34;A&amp;#34;); //包含一个&amp;#34;A&amp;#34;的数组  但是在这里要注意的是，如果你只给构造函数传一个数字，则会创建对应大小的数组,其中每一项的值都是 $undefined$ ；如果传的是多个数字，则会创建包含这些数字的数组。
除了调用构造函数之外，我们还可以使用字面量语法。如下所示：
var array1 = []; //空数组 var array2 = [1]; //包含一个1的数组 var array3 = [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;]; //包含三个元素的数组  2.</description>
    </item>
    
    <item>
      <title>Leetcode题解（2）：二分搜索</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A32%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sat, 29 Feb 2020 17:23:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A32%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</guid>
      <description>原题地址: Problem 4
参考题解
 题目不用多解释，如果没有要求时间复杂度的话可以直接用双指针法遍历即可，但既然题目要求对数级的复杂度，再加上是排序数组，那么很容易就可以想到是二分法，接下来的问题就是怎么二分了。回忆下中位数的概念，中位数是一组顺序排序的数据中居于中间位置的数。也就是说，如果我们知道一组数据的中位数，我们就可以顺势以中位数为基准，将这组数据分成相同大小的两部分，其中一部分中的数总是小于（或等于）另一部分。再回到题目来，如果我们知道这两个数组的中位数，那么我们就可以将这两个数组以中位数为基准将每个数组分为两部分，如下所示：
 其中左边两部分中所有的值永远小于或等于右边两部分。这时很明显中位数为
 $$ median = \frac{max(nums1[i - 1], nums2[j - 1])\ +\ min(nums1[i] + nums2[j])}{2} $$   这样我们的目标就从找中位数变成了寻找一个 $i$ 和 $j$ ，满足如下条件（假设 $i$ 和 $j$ 总是存在）：
 $i + j = \Large\frac{nums1.length\ +\ nums2.length}{2}\normalsize;$ $nums1[i - 1] &amp;lt;= nums2[j];$ $nums2[j - 1] &amp;lt;= nums1[i].$   根据上述条件，如果我们要进行二分搜索，第一步必须先将两个数组分别二分，保证条件1为真。
if (nums1.length &amp;gt; nums2.length) return findMedianSortedArrays(nums2, nums1); int len1 = nums1.length, len2 = nums2.length, halfLen = (len1 + len2 + 1) / 2, i = len1 / 2, j = halfLen - i; }  可以发现我们在开始判断了下$nums1[\ \ ]$和$nums2[\ \ ]$的长度，确保 $nums1.</description>
    </item>
    
    <item>
      <title>JavaScript的对象构造</title>
      <link>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/</link>
      <pubDate>Fri, 28 Feb 2020 12:48:51 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/</guid>
      <description>参考书籍：《JavaScript高级程序设计》（第3版）
 JavaScript是一门面向对象的语言，即拥有类的概念。但ECMAScript中没有类的概念，因此它的对象与其他基于类的语言不同，我们可以把ECMAScript中的对象想象成散列表，由一组组键值对构成，值可以是数据或者函数。
 $object$ 构造函数模式 对象字面量 工厂模式 构造函数模式 原型模式  什么是原型对象   寄生构造函数模式 稳妥构造函数模式 属性类型   1.object构造函数模式 var person = new object(); person.name = &amp;#34;A&amp;#34;; person.sayName = function() { alert(this.name); };  上例创建了一个 $person$ 对象，并为其添加了 $name$ 属性和 $sayName(\ )$ 方法，是最简单的构造对象的方法。
 2.对象字面量 var person = { name: &amp;#34;XiaoMing&amp;#34;, sayName: function() { alert(this.name); } };  上例创建了相同的 $person$ 对象，不同之处在于它是使用对象字面量定义的。以花括号表示开始和结束，属性名+冒号+值的格式定义属性，用逗号隔开多个不同的属性。
在使用对象字面量时，属性名也可以使用字符串。需要注意的是，JSON只支持此种语法。
var person = { &amp;#34;name&amp;#34;: &amp;#34;XiaoMing&amp;#34;, &amp;#34;sayName&amp;#34;: function() { alert(this.</description>
    </item>
    
    <item>
      <title>Leetcode周赛：177</title>
      <link>https://z217blog.cn/post/leetcode%E5%91%A8%E8%B5%9B177/</link>
      <pubDate>Thu, 27 Feb 2020 11:18:21 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E5%91%A8%E8%B5%9B177/</guid>
      <description>第 177 场周赛
 Problem 1360: 日期之间间隔几天 Problem 1361: 验证二叉树 Problem 1362: 最接近因数 Problem 1363: 形成三的最大倍数   **Problem 1360: 日期之间间隔几天**
 直接调用库函数即可。
import java.time.LocalDate; import java.time.temporal.ChronoUnit; class Solution { public int daysBetweenDates(String date1, String date2) { return (int) Math.abs(LocalDate.parse(date1).until(LocalDate.parse(date2), ChronoUnit.DAYS)); } }  使用 $LocalDate$ 类及其 $until(\ )$ 方法，使用 $ChronoUnit.DAYS$ 常量表明以天为单位计算。在此要注意的是Leetcode并没有默认导入 $java.time$ 类，因此要自己导入。
 **Problem 1361: 验证二叉树**
 利用二叉树的性质可以知道，二叉树根节点外每个节点有且只有一个父节点，并且有且只有一个根节点。通过这个性质，我们可以遍历数组，找到所有的节点的父节点，再验证是否符合上述性质。
class Solution { public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) { int[] parent = new int[n]; //储存每个节点的父节点  Arrays.</description>
    </item>
    
    <item>
      <title>Leetcode题解：一道”难“题</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A3%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98/</link>
      <pubDate>Mon, 17 Feb 2020 17:44:43 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A3%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98/</guid>
      <description>原题地址：Problem 1332
 题目很直(mo)白(hu)，就是从一个字符串中删除回文子列直到字符串为空。但是我——没看示例，盯着题目描述和左上角的“简单”，陷入了长时间的思考，最终怀疑人生。毕竟如果你要找回文串的话就得遍历一遍得到子串，然后删除，再遍历，再循环……如此反复，时间复杂度很高，完全不是简单难度，毫无办法的我最终只能看向题解，然后在惊叹中一分钟提交了答案。
class Solution { public int removePalindromeSub(String s) { if (s.length() == 0) return 0; else if (s.equals(new StringBuilder(s).reverse().toString())) return 1; else return 2; } }  总之这道题很沙雕，沙雕之处就在于它的子序列可以不连续。所以，如果不是空串或者回文串的话，先删掉所有的 $a$ 再删掉所有的 $b$ 就行了。由于让我卡了很久，专门写了一篇博客，特此留念。</description>
    </item>
    
    <item>
      <title>Leetcode题解（1）：动态规划</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A31%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Wed, 12 Feb 2020 20:42:30 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A31%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>原题地址：Problem 62
参考题解
 第一眼看到这道题就联想到了离散数学里的排列的相关知识，从而可以很容易的得出排列数为 $C(m+n-2,m-1)$ 或者 $C(m+n-2,n-1)$，可以直接利用该公式进行计算。但问题是阶乘的增长量级过大，很快就产生了溢出的问题，这时可以通过使用 $BigInteger$ 类型对象解决。
虽然问题解决了，但显然这种偏暴力方式的解法不是我们的目的，因此我们还要寻找另一种解法。通过观察题目，我们可以很明显的发现：由于只能右移或者下移，因此到达每一块方格的路径数（不包括第一行和第一列） = 到达其左边方格的路径数 + 到达其上边方格的路径数。以此规律，我们可以运用动态规划来解决该问题。
 首先先设
int[][] dp = new int[m][n];  dp数组为二维数组，储存到达每个方格的路径数。由于达到第一列和第一行中所有方格的路径数有且仅有一条，因此可以
for (int i = 0; i &amp;lt; m; i++) dp[i][0] = 1; for (int i = 1; i &amp;lt; n; i++) dp[0][i] = 1;  之后仅需双循环进行赋值即可：
for (int i = 1; i &amp;lt; m; i++) for (int j = 1; j &amp;lt; n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  在此，无论是按行还是按列，结果都是一样的。最后 $dp[m - 1][n - 1]$ 即为答案。将上述代码合并起来即为：</description>
    </item>
    
    <item>
      <title>JavaScript的对象继承</title>
      <link>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 06 Dec 2019 22:58:43 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/</guid>
      <description>参考书籍：《JavaScript高级程序设计》（第3版）
 继承是OO语言（面对对象语言）中的概念。许多OO语言都支持两种继承方式：接口继承（继承方法签名）和实现继承（继承实际方法）。但由于JavaScript中没有签名，因此在ECMAScript中只能实现方法继承。
 原型链 借用构造函数 组合继承 原型式继承 寄生式继承 寄生组合式继承   1. 原型链  原型链（ $prototype\ \ chaining$ ）是实现继承的主要方法。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
function SuperType() { this.property = true; } SuperType.property.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; } //继承SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; }  上述代码中定义了两种类型—— $SuperType$ 和 $SubType$ ，其中 $SubType$ 继承了 $SuperType$ 。实现的本质是重写 $SubType$ 的原型对象，即将一个 $SuperType$ 对象赋给 $SubType.property$ ，从而使得 $SuperType$ 中所有的属性和方法均存在于 $SubType$ 中。在实例中，我们也给 $SubType$ 添加了一个新方法。此外，还要注意，以此种方式实现的继承中， $SubType.</description>
    </item>
    
    <item>
      <title>get in touch</title>
      <link>https://z217blog.cn/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://z217blog.cn/contact/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>