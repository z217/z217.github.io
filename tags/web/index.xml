<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Web on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/web/</link>
    <description>Recent content in Web on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2022, z217 and the hugo authors, all rights reserved.</copyright>
    <lastBuildDate>Fri, 18 Feb 2022 18:28:56 +0800</lastBuildDate><atom:link href="https://z217blog.cn/tags/web/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unix网络编程补充：套接字选项</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/</link>
      <pubDate>Fri, 18 Feb 2022 18:28:56 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/</guid>
      <description>1. getsockopt和setsockop函数 #include &amp;lt;sys/socket.h&amp;gt; // 成功返回0，出错返回-1 int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen); // 成功返回0，出错返回-1 int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);  这两个函数仅适用于套接字。$sockfd$ 指向一个打开的套接字描述符，$level$ 指定系统中解释选项的代码或为通用套接字代码，或为某个特定于协议的代码。$optval$ 是一个指向某个变量的指针，$setsockopt$ 从 $optval$ 中获取设置，$getoptval$ 向 $optval$ 中写入设置。$optval$ 的大小由 $optlen$ 指定。套接字选项粗分为两大基本类型：一是启用或禁用某个特性的二元选项 ( 标志选项 )，二是取得并返回我们可以设置或检查的特定值的选项 ( 值选项 )。对于标志选项，$optval$ 是一个整数，$1$ 标识启用，$0$ 表示禁用。
   $level$ $optname$ $get$ $set$ 说明 标志选项 数据类型     $SOL_-SOCKET$ $SO_-BROADCAST$ $\checkmark$ $\checkmark$ 允许发送广播数据报 $\checkmark$ $int$   $SO_-DEBUG$ $\checkmark$ $\checkmark$ 开启调试跟踪 $\checkmark$ $int$   $SO_-DONTROUTE$ $\checkmark$ $\checkmark$ 绕过外出路由表查询 $\checkmark$ $int$   $SO_-ERROR$ $\checkmark$  获取待处理错误并清除  $int$   $SO_-KEEPALIVE$ $\checkmark$ $\checkmark$ 周期性测试连接是否仍存活 $\checkmark$ $int$   $SO_-LINGER$ $\checkmark$ $\checkmark$ 若有数据待发送则延迟关闭  $linger\{\}$   $SO_-OOBINLINE$ $\checkmark$ $\checkmark$ 让接收到的带外数据在线存留 $\checkmark$ $int$   $SO_-RCVBUF$ $\checkmark$ $\checkmark$ 接收缓冲区大小  $int$   $SO_-SNDBUF$ $\checkmark$ $\checkmark$ 发送缓冲区大小  $int$   $SO_-RCVLOWAT$ $\checkmark$ $\checkmark$ 接收缓冲区低水位标记  $int$   $SO_-SNDLOWAT$ $\checkmark$ $\checkmark$ 发送缓冲区低水位标记  $int$   $SO_-RCVTIMEO$ $\checkmark$ $\checkmark$ 接收超时  $timeval\{\}$   $SO_-SNDTIMEO$ $\checkmark$ $\checkmark$ 发送超时  $timeval\{\}$   $SO_-REUSEADDR$ $\checkmark$ $\checkmark$ 允许重用本地地址 $\checkmark$ $int$   $SO_-REUSEPORT$ $\checkmark$ $\checkmark$ 允许重用本地端口 $\checkmark$ $int$   $SO_-TYPE$ $\checkmark$  取得套接字类型  $int$   $SO_-USELOOPBACK$ $\checkmark$ $\checkmark$ 路由套接字取得所发送数据的副本 $\checkmark$ $int$   $IPPROTO_-IP$ $IP_-HDRINCL$ $\checkmark$ $\checkmark$ 随数据包含的IP首部 $\checkmark$ $int$   $IP_-OPTIONS$ $\checkmark$ $\checkmark$ IP首部选项  见后续   $IP_-RECVDSTADDR$ $\checkmark$ $\checkmark$ 返回目的IP地址 $\checkmark$ $int$   $IP_-RCVIF$ $\checkmark$ $\checkmark$ 返回接收接口索引 $\checkmark$ $int$   $IP_-TOS$ $\checkmark$ $\checkmark$ 服务类型和优先权  $int$   $IP_-TTL$ $\checkmark$ $\checkmark$ 存活时间  $int$   $IP_-MULTICAST_-IF$ $\checkmark$ $\checkmark$ 指定外出接口  $in_-addr\{\}$   $IP_-MULTICAST_-TTL$ $\checkmark$ $\checkmark$ 指定外出 $TTL$  $u_-char$   $IP_-MULTICAST_-LOOP$ $\checkmark$ $\checkmark$ 指定是否环回  $u_-char$   $IP_-ADD_-MEMBERSHIP$  $\checkmark$ 加入多播组  $ip_-mreq\{\}$   $IP_-DROP_-MEMBERSHIP$  $\checkmark$ 离开多播组  $ip_-mreq\{\}$   $IP_-BLOCK_-SOURCE$  $\checkmark$ 阻塞多播源  $ip_-mreq_-source\{\}$   $IP_-UNBLOCK_-SOURCE$  $\checkmark$ 开通多播源  $ip_-mreq_-source\{\}$   $IP_-ADD_-SOURCE_-MEMBERSHIP$  $\checkmark$ 加入源特定多播组  $ip_-mreq_-source\{\}$   $IP_-DROP_-SOURCE_-MEMBERSHIP$  $\checkmark$ 离开源特定多播组  $ip_-mreq_-source\{\}$   $IPPROTO_-ICMPV6$ $ICMP6_-FILTER$ $\checkmark$ $\checkmark$ 指定待传递的ICMPv6消息类型  $icmp6_-filter\{\}$   $IPPROTO_-IPV6$ $IPV6_-CHECKSUM$ $\checkmark$ $\checkmark$ 用于原始套接字的校验和字段偏移  $int$   $IPV6_-CHECKSUM$ $\checkmark$ $\checkmark$ 用于原始套接字的校验和字段偏移  $int$   $IPV6_-DONTFRAG$ $\checkmark$ $\checkmark$ 丢弃大的分组而将其分片 $\checkmark$ $int$   $IPV6_-NEXTHOP$ $\checkmark$ $\checkmark$ 指定下一跳地址  $sockaddr_-in6\{\}$   $IPV6_-PATHMTU$ $\checkmark$  获取当前路径 $MTU$  $ip6_-mtuinfo\{\}$   $IPV6_-RECVDSTOPTS$ $\checkmark$ $\checkmark$ 接收目的地选项 $\checkmark$ $int$   $IPV6_-RECVHOPLIMIT$ $\checkmark$ $\checkmark$ 接收单播跳限 $\checkmark$ $int$   $IPV6_-RECVHOPOPTS$ $\checkmark$ $\checkmark$ 接收步跳选项 $\checkmark$ $int$   $IPV6_-RECVPATHMTU$ $\checkmark$ $\checkmark$ 接收路径 $MTU$ $\checkmark$ $int$   $IPV6_-RECVPKTINFO$ $\checkmark$ $\checkmark$ 接收分组信息 $\checkmark$ $int$   $IPV6_-RECVRTHDR$ $\checkmark$ $\checkmark$ 接收源路径 $\checkmark$ $int$   $IPV6_-RECVTCLASS$ $\checkmark$ $\checkmark$ 接收流通类型 $\checkmark$ $int$   $IPV6_-UNICAST_-HOPS$ $\checkmark$ $\checkmark$ 默认单播跳限  $int$   $IPV6_-USE_-MIN_-MTU$ $\checkmark$ $\checkmark$ 使用最小 $MTU$ $\checkmark$ $int$   $IPV6_-V6ONLY$ $\checkmark$ $\checkmark$ 禁止v4兼容 $\checkmark$ $int$   $IPV6_-XXX$ $\checkmark$ $\checkmark$ 黏附性辅助数据  见后续   $IPV6_-MULTICAST_-IF$ $\checkmark$ $\checkmark$ 指定外出接口  $u_-int$   $IPV6_-MULTICAST_-HOPS$ $\checkmark$ $\checkmark$ 指定外出跳限  $int$   $IPV6_-MULTICAST_-LOOP$ $\checkmark$ $\checkmark$ 指定是否环回 $\checkmark$ $u_-int$   $IPV6_-JOIN_-GROUP$  $\checkmark$ 加入多播组  $ipv6_-mreq\{\}$   $IPV6_-LEAVE_-GROUP$  $\checkmark$ 离开多播组  $ipv6_-mreq\{\}$   $IPPROTO_-IP$ 或 $IPPROTO_-IPV6$ $MCAST_-JOIN_-GROUP$  $\checkmark$ 加入多播组  $group_-req\{\}$   $MCAST_-LEAVE_-GROUP$  $\checkmark$ 离开多播组  $group_-source_-req\{\}$   $MCAST_-BLOCK_-SOURCE$  $\checkmark$ 阻塞多播源  $group_-source_-req\{\}$   $MCAST_-UNBLOCK_-SOURCE$  $\checkmark$ 开通多播源  $group_-source_-req\{\}$   $MCAST_-JOIN_-SOURCE_-GROUP$  $\checkmark$ 加入源特定多播组  $group_-source_-req\{\}$   $MCAST_-LEAVE_-SOURCE_-GROUP$  $\checkmark$ 离开源特定多播组  $group_-source_-req\{\}$   $IPPROTO_-TCP$ $TCP_-MAXSEG$ $\checkmark$ $\checkmark$ TCP最大分节大小  $int$   $TCP_-NODELAY$ $\checkmark$ $\checkmark$ 禁止 $Nagle$ 算法 $\checkmark$ $int$    2.</description>
    </item>
    
    <item>
      <title>Unix网络编程（15）：程序设计范式</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B15/</link>
      <pubDate>Fri, 18 Feb 2022 14:37:07 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B15/</guid>
      <description>开发一个Unix服务器程序时，我们有如下类型的进程控制可选：
 迭代服务器 ( $iterative$ $server$ ) 程序，在一个主循环内处理所有客户服务。这种类型的适用情形极为有限，因为这样的服务器在完成当前客户的服务之前无法处理后续等待的客户； 并发服务器 ( $concurrent$ $server$ ) 程序，它为每个客户调用 $fork$ 派生一个子进程。传统上大多数Unix服务器程序属于这种类型； 通过 $select$ 处理任意多个客户的服务器； 预先派生子进程 ( $preforking$ ) 程序，它让服务器在启动阶段调用 $fork$ 创建一个子进程池，每个客户请求由当前可用子进程池中的某个闲置子进程处理； 预先创建线程 ( $prethreading$ ) 程序，它让服务器在启动阶段创建一个线程池，每个客户由当前可用线程池中的某个闲置线程处理。   TCP客户程序则有以下范式：
 以停-等方式运作的客户程序，进程在被阻塞以等待用户输入期间，看不到诸如对端关闭连接等网络事件，而且批处理效率极低； 调用 $select$ 监听的客户程序，可以得到网络事件通知； 非阻塞式I/O客户程序； 多进程客户程序； 多线程客户程序。  1. TCP预先派生子进程服务器程序，accept无上锁保护  这种技术的优点在于无须引入父进程执行 $fork$ 的开销就能处理新客户，缺点是父进程必须在服务器启动阶段配置预先派生子进程数量。可选的改进方案是增加一些代码，让父进程监听可用子进程数，一旦降低到某个阈值就派生额外的子进程；同样的，一旦可用子进程数增加到某个阈值就终止一些过剩的子进程。
#include &amp;#34;unp.h&amp;#34; #define MAXN 16384 // max # bytes client can request  static int nchildren; static pid_t *pids; int main(int argc, char **argv) { int listenfd, i; socklen_t addrlen; void sig_int(int); pid_t child_make(int, int, int); if (argc == 3) listenfd = Tcp_listen(NULL.</description>
    </item>
    
    <item>
      <title>Unix网络编程（14）：线程</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B14/</link>
      <pubDate>Thu, 17 Feb 2022 14:28:16 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B14/</guid>
      <description>在传统的Unix模型中，当一个进程需要另一个实体来完成某事时，它就 $fork$ 一个子进程并让子进程去处理。尽管这种范式多年来一直应用得挺好，但是 $fork$ 调用却存在一些问题：
 $fork$ 是重量级调用。$fork$ 调用要把父进程的内存映射到子进程，并在子进程中复制所有描述符等。当今的实现使用写时复制 ( $copy-on-write$ ) 技术，只有子进程需要时才会复制数据。然而，即使存在这样的优化，$fork$ 依然是重量级调用； $fork$ 返回之后父子进程之间的信息传递需要进程间通信机制。   线程有助于解决这两个问题，它的创建可能比进程快 $10 \sim 100$ 倍，而且同一进程内的线程共享相同的全局内存。然而，线程的引入也会带来同步 ( $synchronization$ ) 问题。同一进程内的所有线程除了共享全局变量之外还共享：
 进程指令； 大多数数据； 打开的文件 ( 描述符 )； 信号处理函数和信号处置； 当前工作目录； 用户ID和组ID。   每个线程也有各自的：
 线程ID ( TID )； 寄存器集合，包括程序计数器和栈指针； 栈 ( 存放局部变量和返回地址 )； $errno$ ； 信号掩码； 优先级。  1. 创建和终止 1.1 pthread_create函数 #include &amp;lt;pthread.h&amp;gt; // 成功返回0，出错返回非负错误码 int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*func)(void *), void *arg);  当一个程序由 $exec$ 启动时，称为初始线程 ( $initial$ $thread$ ) 或主线程 ( $main$ $thread$ ) 的单个线程就创建了，其余线程则由 $pthread_-create$ 函数创建。一个进程内每个线程都由线程ID标识，数据类型为 $pthread_-t$ 。如果新线程成功创建，ID会通过 $tid$ 返回。每个线程都有属性：优先级、初始栈大小、是否应该成为守护线程等，可以通过 $attr$ 参数指定。通常情况下我们采取默认配置，这时会把 $attr$ 设置为 $NULL$ 。最后两个参数是线程执行的函数以及参数，线程通过调用这个函数开始执行，然后显式终止 ( $pthread_-exit$ ) 或者隐式终止 ( 函数返回 ) 。如果我们需要传递多个参数，需要把它们打包成一个结构，通过结构指针传递。</description>
    </item>
    
    <item>
      <title>Unix网络编程（13）：信号驱动式I/O</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B13/</link>
      <pubDate>Wed, 16 Feb 2022 16:55:21 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B13/</guid>
      <description>信号驱动式I/O是指进程预先告知内核，使得当某个描述符上发生某事时，内核使用信号通知相关进程。
1. 套接字的信号驱动式I/O  针对一个套接字使用信号驱动式I/O ( $SIGIO$ ) 要求进程执行以下 $3$ 个步骤：
 创建 $SIGIO$ 信号的信号处理函数； 设置该套接字的属主； 开启该套接字的信号驱动式I/O，通常通过使用 $fcntl$ 的 $F_-SETFL$ 命令打开 $O_-ASYNC$ 标志。  1.1 对于UDP套接字的SIGIO信号  在UDP上使用信号驱动式I/O是简单的。$SIGIO$ 信号在发生以下事件时产生：
 数据报到达套接字； 套接字上发生异步错误。   因此当捕获对于某个UDP套接字的 $SIGIO$ 信号时，我们调用 $recvfrom$ 或者读入到达的数据报，或者获取发生的异步错误。
1.2 对于TCP套接字的SIGIO信号  信号驱动式I/O对于TCP套接字近乎无用，因为该信号产生得过于频繁，并且信号出现并没有告诉我们发生了什么事。下列条件均导致TCP套接字产生 $SIGIO$ 信号：
 监听套接字上某个连接请求已经完成； 某个断连的请求已经发起； 某个断连的请求已经完成； 某个连接已经半关闭； 数据到达套接字； 数据已经从套接字发送走 ( 即输出缓冲区有空闲空间 )； 发生异步错误。   我们应该只考虑对监听套接字使用 $SIGIO$ ，因为监听套接字产生 $SIGIO$ 的唯一条件是某个新连接的完成。
2. 使用SIGIO的UDP回射服务器程序  使用 $SIGIO$ 的UDP回射程序可以设计为这种形式：当一个数据报到达时，$SIGIO$ 处理函数读入数据报，同时记录到达时刻，然后将它置于进程内的另一个队列中，主服务器循环从队列中取出数据并处理。相比起不使用 $SIGIO$ 而是简单使用一个服务器循环处理的程序，这种形式可以精确的获知数据报到达时间戳。</description>
    </item>
    
    <item>
      <title>Unix网络编程（12）：带外数据</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B12/</link>
      <pubDate>Tue, 15 Feb 2022 17:50:04 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B12/</guid>
      <description>许多传输层有带外数据 ( $out-of-band$ $data$ ) 的概念，有时也被称为经加速数据 ( $expedited$ $data$ )。当一个连接的某端发生了重要的事情，而且该端希望迅速告知对端，这意味着这些数据应该在已经排队等待发送的任何普通数据之前发送。带外数据并不要求在客户和服务器之间再创建一个连接，而是使用现有的连接。不幸的是，几乎每个传输层都有各自不同的带外数据的实现。UDP是一个极端的例子，没有带外数据。
1. TCP带外数据  TCP并没有真正的带外数据，不过提供了紧急模式 ( $urgent$ $mode$ )。以下为TCP发送缓冲区。
 进程以 $MSG_-OOB$ 标志发送一个带外数据：
send(fd, &amp;#34;a&amp;#34;, 1, MSG_OOB);  TCP将这个数据放置在发送缓冲区的下一个可用位置，并把该连接的TCP紧急指针设置为下一个可用位置。
 TCP紧急指针对应一个TCP序列号，它是使用 $MSG_-OOB$ 标志写出的最后一个数据字节 ( 即带外数据字节 ) 对应的序列号加 $1$ 。发送端TCP将为待发送的下一个分节在TCP首部设置URG标志，并把TCP紧急偏移 ( $urgent$ $offset$ ) 字段设置为紧急指针指向的字节，这个分节可能包含也可能不含之前发送的带外数据。$16$ 位的TCP序列号加上 $16$ 位的紧急偏移字段即可得到 $32$ 位的紧急指针。TCP紧急模式的一个重要特点是TCP首部指出发送端已经进入紧急模式 ( 设置URG标志 )，但是紧急指针指向的实际数据字节却不一定发送。
从接收端的角度来看，发生了以下事件：
 收到URG分节，接收端检查紧急指针，确定它是否指向带外数据，也就是判断本分节是不是首个到达的紧急模式分节。发送端TCP往往发送多个URG分节并且其紧急指针都会指向同一个数据字节的分节，只有第一个到达的分节会通知接收进程有新的带外数据到达； 当有新的紧急指针到达时，不论由紧急指针指向的实际数据字节是否已经到达，接收进程会收到通知。内核给接收套接字的进程发送 $SIGURG$ 信号，前提是接收进程 ( 或其他进程 ) 曾调用 $fcntl$ 或 $ioctl$ 为这个套接字建立了属主，而且该属主今后层已经为 $SIGURG$ 信号建立了信号处理函数。其次，如果接收进程阻塞在 $select$ 调用中，$select$ 调用就立即返回； 当由紧急指针指向的实际数据字节到达接收端TCP时，该数据字节可能被拉出带外，也可能留在带内。$SO_-OOBINLINE$ 套接字选项默认是禁止的，对于这样的套接字，该数据字节并不立即放入接收缓冲区，而是放入该连接的一个独立的单字节带外缓冲区。接收进程从这个单字节缓冲区中读入数据的唯一方法是指定 $MSG_-OOB$ 标志调用 $recv$ 、$recvfrom$ 或 $recvmsg$ 。如果新的带外字节在就旧的带外字节被读取之前到达，旧的带外字节会被丢弃。如果开启了 $SO_-OOBINLINE$ ，接收进程不能通过 $MSG_-OOB$ 标志读入带外数据，而是通过检查连接的带外标记获悉何时访问到这个字节。   这个过程可能会发送以下错误：</description>
    </item>
    
    <item>
      <title>Unix网络编程（11）：路由套接字</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B11/</link>
      <pubDate>Mon, 14 Feb 2022 19:31:39 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B11/</guid>
      <description>注：以下内容可能不适用于Linux系统
 内核中的Unix路由表传统上一直使用 $ioctl$ 访问，但是 $ioctl$ 不能输出整个路由表，而诸如 $netstat$ 等程序通过读取内核的内存获取路由表内容。诸如 $gated$ 等路由守护进程需要监视由内核收取的ICMP重定向消息，它们通常创建一个原始ICMP套接字，再在这个套接字上监听所有收到的ICMP消息。在路由域中支持的唯一一种套接字是原始套接字。路由套接字上支持 $3$ 种类型的操作：
 进程可以通过写出到路由套接字而往内核发送消息。路径的增加和删除采用这种操作实现； 进程可以通过从路由套接字读入而从内核接收消息。内核采用这种操作通知进程已收到并处理一个ICMP重定向消息，或者请求外部路由进程解析一个路径； 进程可以使用 $sysctl$ 函数输出路由表或者列出所有已配置的接口。   前两种操作可以复合使用，需要超级用户权限，最后一种任何进程都可以执行。
1. 数据链路套接字地址结构 #include &amp;lt;net/if_dl.h&amp;gt; struct sockaddr_dl { uint8_t sdl_len; sa_family_t sdl_family; // AF_LINK  uint16_t sdl_index; // 大于0的系统分配的索引  uint8_t sdl_type; // IFT_ETHER等在&amp;lt;net/if_types.h&amp;gt;中定义的常值  uint8_t sdl_nlen; // 名字长度，从sdl_data[0]开始  uint8_t sdl_alen; // 链路层地址长度  uint8_t sdl_slen; // 链路层选择器长度  char sdl_data[12]; // 最小工作区域，可以扩大，包含i/f名称和链路层地址 }; #define LLADDR(s) ((caddr_t) ((s)-&amp;gt;sdl_data + (s)-&amp;gt;sdl_nlen))  每个接口都有一个唯一的索引。$sdl_-data$ 成员含有名字和链路层地址，名字从 $sdl_-data[0]$ 开始，并且不以空字符结尾。链路层地址从 $sdl_-data[sdl_-nlen]$ 开始，$LLADDR$ 宏返回指向链路层地址的指针。</description>
    </item>
    
    <item>
      <title>Unix网络编程（10）：ioctl</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B10/</link>
      <pubDate>Mon, 14 Feb 2022 15:10:53 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B10/</guid>
      <description>$ioctl$ 函数传统上一直作为那些不适合归入其他精细定义类别的特性的系统接口。POSIX致力于摆脱处于标准化过程的特定功能的 $ioctl$ 接口，办法是为它们创造一些特殊的函数以取代 $ioctl$ 请求，办法是为它们创造一些特殊的函数以取代 $ioctl$ 请求。网络层程序经常在程序启动执行后使用 $ioctl$ 获取所在主机全部网络接口的信息，包括：接口地址、是否支持广播、是否支持多播等。
1. ioctl函数 #include &amp;lt;unistd.h&amp;gt; // 成功返回 $0$ ，出错返回-1 int ioctl(int fd, int request, ... /* void *arg */);  第三个参数是一个指针，类型依赖于 $request$ 参数。我们可以把和网络相关的请求分为 $6$ 类：
   类别 $request$ 说明 数据类型     套接字 $SIOCATMARK$ 是否位于带外标记 $int$   $SIOCSPGRP$ 设置套接字的进程ID或进程组ID $int$   $SIOCGPGRP$ 获取套接字的进程ID或进程组ID $int$   文件 $FIONBIO$ 设置/清除非阻塞式I/O标志 $int$   $FIOASYNC$ 设置/清除信号驱动异步I/O标志 $int$   $FIONREAD$ 获取接收缓冲区的字节数 $int$   $FIOSETOWN$ 设置文件的进程ID或进程组ID $int$   $FIOGETOWN$ 获取文件的进程ID或进程组ID $int$   接口 $SIOCGIFCONF$ 获取所有接口的列表 $struct$ $ifconf$   $SIOCSIFADDR$ 设置接口地址 $struct$ $ifreq$   $SIOCGIFADDR$ 获取接口地址 $struct$ $ifreq$   $SIOCGIFADDR$ 获取接口地址 $struct$ $ifreq$   $SIOCSIFFLAGS$ 设置接口标志 $struct$ $ifreq$   $SIOCGIFFLAGS$ 获取接口标志 $struct$ $ifreq$   $SIOCSIFDSTADDR$ 设置点到点地址 $struct$ $ifreq$   $SIOCGIFDSTADDR$ 获取点到点标志 $struct$ $ifreq$   $SIOCGIFBRDADDR$ 获取广播地址 $struct$ $ifreq$   $SIOCSIFBRDADDR$ 设置广播地址 $struct$ $ifreq$   $SIOCGIFNETMASK$ 获取子网掩码 $struct$ $ifreq$   $SIOCSIFNETMASK$ 设置子网掩码 $struct$ $ifreq$   $SIOCGIFMETRIC$ 获取接口的测度 $struct$ $ifreq$   $SIOCSIFMETRIC$ 设置接口的测度 $struct$ $ifreq$   $SIOCGIFMTU$ 获取接口 $MTU$  $struct$ $ifreq$   ARP $SIOCSARP$ 创建/修改ARP表项 $struct$ $arpreq$   $SIOCGARP$ 获取ARP表项 $struct$ $arpreq$   $SIOCDARP$ 删除ARP表项 $struct$ $arpreq$   路由 $SIOCADDRT$ 增加路径 $struct$ $rtentry$   $SIOCDELRT$ 删除路径 $struct$ $rtentry$   流 $I_-xxx$ 以后说明    2.</description>
    </item>
    
    <item>
      <title>Unix网络编程（9）：非阻塞式I/O</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B9/</link>
      <pubDate>Sat, 12 Feb 2022 17:12:54 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B9/</guid>
      <description>套接字的默认状态是阻塞的，这就意味着当发出一个不能立即完成的套接字调用时，其进程将被置于休眠状态，直到相应操作完成。可能阻塞套接字的调用分为以下四类：
 输入：$read$ 、$readv$ 、$recv$ 、$recvfrom$ 和 $recvmsg$ 共 $5$ 个函数。如果对阻塞式套接字调用，而且套接字接收缓冲区中没有数据可读，进程将休眠。而对于非阻塞式套接字，如果输入操作不能被满足，调用将返回 $EWOULDBLOCK$ 错误； 输出：$write$ 、$writev$ 、$send$ 、$sendto$ 和 $sendmsg$ 共 $5$ 个函数。如果对阻塞式套接字调用，而且套接字发送缓冲区中没有空间，进程将休眠。对于非阻塞的TCP套接字，如果发送缓冲区中没有空间，输出函数调用将立即返回 $EWOULDBLOCK$ 错误； 接受外来连接，即 $accept$ 函数。如果对一个非阻塞套接字调用 $accept$ 函数，而且无新连接到达，将会立即返回 $EWOULDBLOCK$ 错误； 发起外出连接，即用于TCP的 $connect$ 函数。如果对一个非阻塞套接字调用 $connect$ ，而且连接不能立即建立，那么会立即返回 $EINPROGRESS$ 错误。  1. 非阻塞读和写 #include &amp;#34;unp.h&amp;#34;#include &amp;lt;time.h&amp;gt; char *gf_time(void); void str_cli(FILE *fp, int sockfd) { int maxfdp1, val, stdineof; ssize_t n , nwritten; fd_set rset, wset; char to[MAXLINE], fr[MAXLINE]; char *toiptr, *tooptr, *friptr, *froptr; val = Fcntl(sockfd, F_GETFL, 0); Fcntl(sockfd, F_SETFL, val | O_NONBLOCK); val = Fcntl(STDIN_FILENO, F_GETFL, 0); Fcntl(STDIN_FILENO, F_SETFL, val | O_NONBLOCK); val = Fcntl(STDOUT_FILENO, F_GETFL, 0); Fcntl(STDOUT_FILENO, F_SETFL, val | O_NONBLOCK); toiptr = tooptr = to; friptr = froptr = fr; stdineof = 0; maxfdp1 = max(max(STDIN_FILENO, STDOUT_FILENO), sockfd) + 1; for (;;) { FD_ZERO(&amp;amp;rset); FD_ZERO(&amp;amp;wset); if (stdineof == 0 &amp;amp;&amp;amp; toiptr &amp;lt; &amp;amp;to[MAXLINE]) FD_SET(STDIN_FILENO, &amp;amp;rset); // read from stdin  if (friptr &amp;lt; &amp;amp;fr[MAXLINE]) FD_SET(sockfd, &amp;amp;rset); // read from socket  if (tooptr !</description>
    </item>
    
    <item>
      <title>Unix网络编程（8）：Unix域协议</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B8/</link>
      <pubDate>Sat, 12 Feb 2022 14:58:42 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B8/</guid>
      <description>Unix域协议并不是一个实际的协议族，而是在单个主机上执行客户/服务器通信的一种方法，所用API就是在不同主机上执行客户/服务器通信所用的API，因此，Unix域协议可视为IPC方法之一。Unix域提供两类套接字：字节流套接字 ( 类似TCP ) 和数据报套接字 ( 类似UDP )。
1. 套接字地址结构 #include &amp;lt;sys/un.h&amp;gt; struct sockaddr_un { sa_family_t sun_family; // AF_LOCAL  char sun_path[104]; // null-terminated pathname };  存放在 $sun_-path$ 数组中的路径名必须以空字符结尾。实现提供一个 $SUN_-LEN$ 宏以一个指向 $sockaddr_-un$ 结构的指针为参数并返回该结构的长度，包括路径名中的非空字节数。未指定地址通过空字符串作为路径名指示，等价于IPv4的 $INADDR_-ANY$ 常值或IPv6的 $IN6ADDR_-ANY_-INIT$ 常值。
#include &amp;#34;unp.h&amp;#34; int main(int argc, char **argv) { int sockfd; socklen_t len; struct sockaddr_un addr1, addr2; if (argc != 2) err_quit(&amp;#34;usage: unixbind &amp;lt;pathname&amp;gt;&amp;#34;); sockfd = Socket(AF_LOCAL, SOCK_STREAM, 0); unlink(argv[1]); bzero(&amp;amp;addr1, sizeof(addr1)); addr1.</description>
    </item>
    
    <item>
      <title>Unix网络编程（7）：高级I/O函数</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B7/</link>
      <pubDate>Fri, 11 Feb 2022 16:00:04 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B7/</guid>
      <description>1. 套接字超时  在涉及套接字的I/O操作上设置超时的办法有以下三种：
 调用 $alarm$ ，它在指定超时期满时产生 $SIGALRM$ 信号。这个办法涉及信号处理，而信号处理在不同的实现上存储差异，而且可能干扰进程中现有的 $alarm$ 调用； 在 $select$ 中阻塞等待I/O，以此代替直接阻塞在 $read$ 或 $write$ 调用上； 使用较新的 $SO_-RCVTIMEO$ 和 $SO_-SNDTIMEO$ 套接字选项。这个办法的问题在于并非所有实现都支持这两个套接字选项。   以上三种技术都适用于输入和输出操作，不过我们依然期待可用于 $connect$ 技术，因为TCP内置的 $connect$ 超时时间相当长 ( 典型为 $75$ 秒 )。$select$ 可用来在 $connect$ 上设置超时的先决条件是相应套接字处于非阻塞模式，而那两个套接字选项对 $connect$ 并不适用。还要注意，前两个技术适用于任何描述符，而最后一个只适用于套接字描述符。
#include &amp;#34;unp.h&amp;#34; static void connect_alarm(int); int connect_timeo(int sockfd, const struct sockaddr *saptr, socklen_t salen, int nsec) { Sigfunc *sigfunc; int n; sigfunc = Signal(SIGALRM, connect_alarm); if (alarm(nsec) != 0) err_msg(&amp;#34;connect_timeo: alarm was already set&amp;#34;); if ((n = connect(sockfd, saptr, salen)) &amp;lt; 0) { close(sockfd); if (errno == EINTR) errno = ETIMEDOUT; } alarm(0); // turn off the alarm  Signal(SIGALRM, sigfunc) // restore previous signal handler  return n; } static void connect_alarm(int signo) { return; // just interrupt the connect() }  上述代码使用第一种方法，通过 $alarm$ 设置秒数，再通过信号处理函数中断 $connect$ 调用，同时关闭套接字。自定义的 $Signal$ 函数也会阻塞 $SA_-RESTART$ 信号。要注意，如果指定 $nsec$ 为一个大于 $75$ 的值，那么函数仍然会在 $75$ 秒时超时并返回。还要注意，虽然通过这种方式实现简单，但是在多线程程序中，正确使用信号是很困难的，所以建议只在未线程化或单线程程序中适用该技术。</description>
    </item>
    
    <item>
      <title>Unix网络编程（6）：守护进程</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B6/</link>
      <pubDate>Wed, 09 Feb 2022 16:20:07 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B6/</guid>
      <description>守护进程 ( $daemon$ ) 是在后台运行且不与任何控制终端关联的进程。Unix系统通常有很多守护进程在后台运行，执行不同的管理任务。守护进程没有控制终端通常源于它们由系统初始化脚本启动，然而守护进程也可能从某个终端由用户在shell提示符下输入命令行启动，这样的守护进程必须亲自脱离与控制终端的关联。
1. syslogd守护进程  Unix系统中的 $syslogd$ 守护进程通常由某个系统初始化脚本启动，而且在系统工作期间一直运行。Linux系统的不同发行版会使用各自的实现，比如Ubuntu会使用 $rsyslog$ ，Arch使用 $journal$ 。源自 $Berkeley$ 的 $syslogd$ 实现在启动时执行以下步骤：
 读取配置文件。通常为 $/etc/syslog.conf$ 的配置文件指定本守护进程可能收取的各种日志消息应该如何处理。这些消息可能被添加到一个文件，或被写到指定用户的登录窗口，或被转发给另一个主机上的 $syslog$ 进程； 创建一个Unix域数据报套接字，给它捆绑路径名 $/var/run/log$ ； 创建一个UDP套接字，给他捆绑端口 $514$ ( $syslog$ 服务使用的端口 )； 打开路径名 $/dev/klog$ ，来自内核中的任何出错消息看着像是这个设备的输入。   此后 $syslog$ 一直在一个无限循环中运行：调用 $select$ 等待 $3$ 个描述符 ( 上述第 $2$ 、$3$ 和 $4$ 步 )，读入日志消息，按照配置文件进行处理。如果接收到 $SIGHUP$ 信号，则重新读取配置文件。
通过创建一个Unix域数据报套接字，我们就可以从自己的守护进程中通过往 $syslogd$ 绑定的路径名发送我们的消息，从而达到发送日志消息的目的。另外，我们也可以创建一个UDP套接字 ( 较新的实现为防止遭受攻击，会禁止套接字的创建 )，通过往环回地址和端口 $514$ 发送我们的消息达到发送日志消息的目的。
2. syslog函数 #include &amp;lt;syslog.h&amp;gt; void syslog(int priority, const char *message, .</description>
    </item>
    
    <item>
      <title>Unix网络编程（5）：DNS</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B5/</link>
      <pubDate>Mon, 07 Feb 2022 15:57:58 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B5/</guid>
      <description>1. 域名系统  DNS中的条目称为资源记录 ( $resource$ $record$ , $RR$ )。
 $A$ ：$A$ 记录把一个主机名映射成一个 $32$ 位的IPv4地址； $AAAA$ ：四 $A$ ( $quad$ $A$ ) 记录把一个主机名映射成一个 $128$ 位的IPv6地址； $PTR$ ：指针记录 ( $pointer$ $record$ ) 把IP地址映射成主机名。对于IPv4地址，$32$ 地址的 $4$ 字节先反转顺序，每字节都转换成各自的十进制ASCII值后，再添加 $in-addr.arpa$ ；对于IPv6地址，$128$ 位地址中的 $32$ 个四位组先反转顺序，每个四位组都被转换成相应的十六进制ASCII值后，再添加 $ip6.arpa$ ； $MX$　：$MX$ 记录把一个主机指定作为给定主机的邮件交换器 ( $mail$ $exchanger$ )； $CNAME$ ：$CNAME$ 代表规范名字 ( $canonical$ $name$ )，常见用法是为常用的服务指派 ( 例如 $ftp$ 和 $www$ ) CNAME记录。如果人们使用这些服务名而不是真实的主机名，那么相应的服务挪到另一个主机时他们也不必知道。   每个组织往往运行一个或多个名字服务器 ( $name$ $server$ )，它们通常就是所谓的 $BIND$ ( $Berkeley$ $Internet$ $Name$ $Domain$ ) 程序。诸如我们编写的客户和服务器等应用程序通过调用称为解析器 ( $resolver$ ) 的函数库中的函数接触DNS服务器。解析器代码通常包含在一个系统函数库中，在构造应用程序时被链编 ( $link-editing$ ) 到应用程序中。解析器使用UDP向本地名字服务器发出查询，如果本地名字服务器不知道答案，通常就会使用UDP在整个因特网上查询其他名字服务器。如果答案太常，超出了UDP消息的承载能力，本地名字服务器和解析器会自动切换到TCP。</description>
    </item>
    
    <item>
      <title>Unix网络编程（4）：基本UDP/SCTP套接字编程</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B4/</link>
      <pubDate>Thu, 03 Feb 2022 16:08:32 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B4/</guid>
      <description>1. 基本UDP套接字编程 1.1 recvfrom和sendto函数  $recvfrom$ 和 $sendto$ 类似于标准 $read$ 和 $write$ 函数，不过需要三个额外的参数。
#include &amp;lt;sys/socket.h&amp;gt; ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen); ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t addrlen); // 成功则返回读或写的字节数，出错返回-1  $sendto$ 的 $to$ 参数指向一个含有数据报接收者的协议地址的套接字地址结构，其大小由 $addrlen$ 指定。$recvfrom$ 的 $from$ 参数指向一个将由该参数在返回时填写数据报发送者的协议地址的套接字地址结构，其大小由 $addrlen$ 返回给调用者。写一个长度为 $0$ 的数据报是可行的。在UDP情况下，这回形成一个只包含一个IP首部和一个 $8$ 字节UDP首部而没有数据的IP数据报。这也意味着对于数据报协议，$recvfrom$ 返回 $0$ 值是可以接受的，并不像TCP一样代表对端连接关闭。如果 $recvfrom$ 的 $from$ 参数是一个空指针，那么相应的长度参数 $addrlen$ 也必须是一个空指针。</description>
    </item>
    
    <item>
      <title>Unix网络编程（3）：I/O复用</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</link>
      <pubDate>Wed, 02 Feb 2022 15:04:28 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</guid>
      <description>1. I/O模型  Unix下有 $5$ 种可用的I/O模型：阻塞式I/O、非阻塞式I/O、I/O复用、信号驱动式I/O和异步I/O。
1.1 阻塞式I/O  最流行的I/O模型是阻塞式I/O ( $blocking$ $I/O$ ) 模型。默认情形下，所有的套接字都是阻塞的。
1.2 非阻塞式I/O  进程把一个套接字设置成非阻塞式是在通知内核：当所请求的I/O操作非得把本进程置于休眠状态才能完成时，不要把本进程置于休眠状态，而是返回一个错误。
 当一个应用进程像这样对一个非阻塞描述符循环调用 $recvfrom$ 时，我们称之为轮询 ( $polling$ )。应用进程持续轮询内核，以查看某个操作是否就绪，这么做往往耗费大量CPU时间。不过这种模型偶尔也会遇到，通常是在专门提供某一种功能的系统中才有。
1.3 I/O复用  通过I/O复用，我们可以调用 $select$ 或 $poll$ ，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。
1.4 信号驱动式I/O  我们也可以使用信号，让内核在描述符就绪时发送 $SIGIO$ 信号通知我们。
 我们首先开启套接字的信号驱动I/O功能，并通过 $sigaction$ 系统调用安装一个信号处理函数。该系统调用立即返回，我们的进程继续工作。当数据报准备好被读取时，内核就为该进程产生一个 $SIGIO$ 信号。我们随后既可以在信号处理函数中调用 $recvfrom$ 读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。
1.5 异步I/O  异步I/O ( $asynchronous$ $I/O$ ) 由POSIX规范定义。一般地说，这些函数的工作机制是：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。这种模型与前一节介绍的信号驱动模型的主要区别在于：信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作，异步I/O是由内核通知我们I/O操作何时完成。
 我们调用 $aio_-read$ 函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。该系统调用会立即返回，而且在等待I/O完成期间，我们的进程不被阻塞。
2. select函数  $select$ 函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定时间后才唤醒。
#include &amp;lt;sys/select.h&amp;gt;#include &amp;lt;sys/time.h&amp;gt; // 存在就绪描述符则返回其数目，超时返回0，出错返回-1 int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); strcut timeval { long tv_sec; // seconds  long tv_usec; // microseconds  $timeval$ 参数有以下三种可能：</description>
    </item>
    
    <item>
      <title>Unix网络编程（2）：基本TCP套接字编程</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</link>
      <pubDate>Sat, 29 Jan 2022 18:38:32 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</guid>
      <description>1. 基本TCP套接字编程 1.1 socket函数  为了执行网络I/O，进程必须做的第一件事就是调用 $socket$ 函数。
#include &amp;lt;sys/socket.h&amp;gt; // 成功返回套接字描述符，失败返回-1 int socket(int family, int type. int protocol);  $family$ 为协议族，由于历史问题，一些实现中还存在以 $PF$ 开头的协议族，但基本等价；$type$ 指明套接字类型；$protocol$ 为某个协议类型常值。
   $family$ 说明     $AF_-INET$ IPv4协议   $AF_-INET6$ IPv6协议   $AF_-LOCAL$ Unix域协议   $AF_-ROUTE$ 路由套接字   $AF_-KEY$ 密钥套接字        $type$ 说明     $SOCK_-STREAM$ 字节流套接字   $SOCK_-DGRAM$ 数据报套接字   $SOCK_-SEQPACKET$ 有序分组套接字   $SOCK_-RAW$ 原始套接字        $protocol$ 说明     $IPPROTO_-TCP$ TCP传输协议   $IPPROTO_-UDP$ UDP传输协议   $IPPROTO_-SCTP$ SCTP传输协议        组合 $AF_-INET$ $AF_-INET6$ $AF_-LOCAL$ $AF_-ROUTE$ $AF_-KEY$     $SOCK_-STREAM$ TCP｜SCTP TCP｜SCTP 有效     $SOCK_-DGRAM$ UDP UDP 有效     $SOCK_-SEQPACKET$ SCTP SCTP 有效     $SOCK_-RAW$ IPv4 IPv6  有效 有效    1.</description>
    </item>
    
    <item>
      <title>Unix网络编程（1）：套接字编程简介</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</link>
      <pubDate>Wed, 26 Jan 2022 17:10:43 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</guid>
      <description>1. 传输层  TCP建立一个连接需要三次握手：
 服务器准备接受外部连接，通常通过调用 $socket$ 、$bind$ 、$listen$ 这 $3$ 个函数完成，称为被动打开 ( $passive$ $open$ )； 客户端通过调用 $connect$ 发起主动打开 ( $active$ $open$ )，即发送一个SYN报文； 服务器确认 ( ACK ) 客户端的SYN，同时也发送一个SYN； 客户端确认服务器的SYN。   TCP终止一个连接需要四次挥手：
 某个进程调用 $close$ ，称为主动关闭 ( $active$ $close$ )，该端发送一个FIN报文； 对端接受FIN，执行被动关闭 ( $passive$ $close$ )。这个FIN由TCP确认，接收也作为一个文件结束符 ( $end-of-file$ , $EOF$ ) 传递给接收端应用程序 ( 放在已排队等候该应用进程接收的任何其他数据之后 )； 一段时间后，接收到EOF的进程调用 $close$ 关闭套接字，并发送一个FIN报文； 接收到FIN的原端TCP确认。   TCP状态转换图可参考TCP、UDP和DNS简介。
SCTP建立一个连接的过程为：
 服务器准备接受外部连接，通常通过调用 $socket$ 、$bind$ 、$listen$ 这 $3$ 个函数完成，称为被动打开； 客户端通过调用 $connect$ 或者发送一个隐式打开该关联的消息进行主动打开，从而发送一个INIT消息，告知服务器客户端的IP地址清单、初始序列号、分组起始标记、客户端请求的外出流数目以及客户端能支持的外出流的数目； 服务器以一个INIT ACK消息确认，其中含有服务器的IP地址清单、初始序列号、起始标记、请求的外出流数目、支持的外出流数目和一个状态cookie，包含服务器用于确认本次连接有效所需的所有状态； 客户端以一个COOKIE ECHO消息回射状态cookie； 服务器以一个COOKIE ACK消息确认cookie正确，于是连接建立。   SCTP不像TCP那样允许”半关闭“的连接，而是当某一端关闭时，另一端必须停止发送新数据，在发送完所有队列中的数据后关闭。</description>
    </item>
    
    <item>
      <title>TCP、UDP和DNS简介</title>
      <link>https://z217blog.cn/post/tcpudp%E5%92%8Cdns%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 06 Mar 2021 15:36:09 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/tcpudp%E5%92%8Cdns%E7%AE%80%E4%BB%8B/</guid>
      <description>1. TCP  TCP是一种面向连接的 ( $connection-oriented$ ) 协议，在一个应用进程向另一个应用进程发送数据之前，这两个进程必须先相互握手。TCP建立的连接是一条逻辑链接，其共同状态仅保留在两个通信端系统的TCP程序中。由于TCP协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持TCP连接状态。事实上，中间路由器看到的是数据报，而非TCP连接。 一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。TCP接收到数据后，会将数据引导到连接的发送缓存 ( $send\ \ buffer$ ) 里，发送缓存是发起三次握手期间设置的缓存之一。接下来TCP就会时不时从发送缓存里取出一块数据，并将数据传递到网络层。TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度 ( $Maximum\ \ Segment\ \ Size$ ，$MSS$ )。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度( 即所谓的最大传输单元 ( $Maximum\ \ Transmission\ \ Unit$ ，$MTU$ )) 来设置。以太网和PPP链路层协议都具有 $1500$ 字节的MTU，再加上TCP/IP首部长度 ( 通常为 $40$ 字节 ) ，因此MSS的典型值为 $1460$ 字节。 TCP为每块客户端数据配上一个TCP首部，从而形成多个TCP报文段 ( $TCP\ \ segment$ )。这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段之后，该报文段的数据就被放入该TCP连接的接收缓存中。
1.1 序号和确认号  TCP报文段首部中两个最重要的字段是序号字段和确认号字段。TCP把数据看成一个无结构的、有序的字节流。序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个报文段的序号 ( $sequence\ \ number\ \ for\ \ a\ \ segment$ ) 是该报文段首字节的字节流编号。 TCP是全双工协议，因此主机 $A$ 在向主机 $B$ 发送数据的同时，也许也接收来自主机 $B$ 的数据。从主机 $B$ 到达的每个报文段中都有一个序号用于从 $B$ 流向 $A$ 的数据。主机 $A$ 填充进报文段的确认号是主机 $A$ 期望从主机 $B$ 收到的下一字节的序号。假设主机 $A$ 已收到一个来自主机 $B$ 的包含字节 $0 \sim 535$ 的报文段，以及另一个包含字节 $900 \sim 1000$ 的报文段。由于某种原因，主机 $A$ 还没有收到字节 $536 \sim 899$ 的报文段。在这个例子中，主机 $A$ 为了重新构建主机 $B$ 的数据流，仍在等待字节 $536$ 。因此 $A$ 到 $B$ 的下一个报文段将在确认号字段中包含 $536$ 。因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供累计确认 ( $cumulative\ \ acknowledge$ )。当主机 $A$ 在收到第二个报文段 ( $536 \sim 899$ ) 之前收到第三个报文段 ( $900 \sim 1000$ )，这时候的处理方式TCP RFC并没有明确规定任何规则，编程人员有两种处理方式：丢弃或者缓存。显然，后一种选择对网络带宽而言更为有效，也是实践中采用的方法。 主机 $A$ 和主机 $B$ 之间数据的确认可以承载在数据的报文段中，而不需要重新发一个独立的确认报文段，这种确认称为捎带 ( $piggybacked$ )。主机之间也可以发送空报文段，通常用于确认已经收到数据。对于空报文段，虽然没有数据，但仍然需要分配一个序号，因为TCP中存在序号字段，报文段需要填入序号。</description>
    </item>
    
    <item>
      <title>HTTP协议介绍</title>
      <link>https://z217blog.cn/post/http%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 05 Mar 2021 22:19:56 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/http%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</guid>
      <description>1. HTTP  HTTP协议用于客户端和服务端之间的通信，通过请求和响应的交换达成通信。HTTP本身是一种不保存状态的协议，即无状态协议，每当有新请求发送，就会对应着有响应的产生。 请求报文和响应报文的首部内容由以下数据组成：
 请求行：包含请求方法、请求URI和HTTP版本； 状态行：包含表明响应结果的状态码、原因短语和HTTP版本； 首部字段：包含表示请求和响应的各种条件和属性的各类首部，一般有四类首部：通用首部、请求首部、响应首部和实体首部； 其他：可能包含HTTP的RFC里未定义的首部 ( 如Cookie等 )。   HTTP在传输数据时可以那招数据原貌直接传输，也可以在传输的过程中通过编码提升传输速率。报文 ( $message$ ) 是HTTP通信中的基本单位，由字节流组成；实体 ( $entity$ ) 是请求或响应的有效载荷数据，由实体首部和实体主体组成。通常报文主体等于实体主体，只有当传输中进行编码操作时，实体主体的内容才会发生变化。 在传输大容量数据时，HTTP允许将数据分割，这种功能称为分块传输编码 ( $Chunked\ \ Transfer\ \ Coding$ )，允许将实体主体分块，每块使用十六进制标记大小，最后一块会使用 $0(CR+LF)$ 标记。为了发送多种类型实体，HTTP还采用了多部份对象集合，包含如下对象：$multipart/form-data$ 、$multipart/byteranges$ 。在使用时，需要在首部字段里加上 $Content-type$ 。 HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。
 代理：代理扮演了位于服务器和客户端的中间人的角色，接收请求和响应并进行转发。使用代理的理由有：利用缓存技术减少网络带宽流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等； 网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，就像自己拥有资源的服务器一样处理。使用网关能提高通信的安全性； 隧道是在相隔甚远的客户端和服务器之间进行中转，并保持双方通信连接的应用程序。隧道的目的是确保客户端能与服务器进行安全的通信。  1.1 请求 GET /index.htm HTTP/1.1 Host: xxxx.com  起始行开头的 $GET$ 表示请求访问服务器的类型，称为方法。$/index.htm$ 是请求访问的资源对象，也叫做请求URI ( $Request\ \ URI$ ) 。最后的 $HTTP/1.1$ 即HTTP版本号，指明客户端使用的HTTP协议版本。 HTTP使用URI定位互联网上的资源，可以指定完整路径，也可以通过与 $Host$ 字段结合指定相对路径。如果不是访问特定资源而是对服务器本身发起请求，可以使用 $*$ 代替请求URI，如下：
OPTIONS * HTTP/1.</description>
    </item>
    
    <item>
      <title>JavaWeb（4）：Spring简介</title>
      <link>https://z217blog.cn/post/javaweb4spring%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 21 Apr 2020 15:48:49 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb4spring%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
Maven依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.inject&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.inject&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.annotation&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.annotation-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;   Spring Framework是一个Java应用程序容器，它提供了许多有用的特性，如反转控制（IoC）、依赖注入（DI）、抽象数据访问、事务管理等。
IoC是一个软件设计模式，即组装器（Spring Framework)在运行时才会绑定对象，也就是运行时才会实例化依赖的组件。这使得开发者可以针对接口进行编程，无需重新编译代码。DI是IoC的一种实现方式，通过DI，一个类可以通过声明其依赖的接口类型，然后利用组装器在运行时注入其依赖的实例。
Spring Framework提供了一个MVC（模型-视图-控制）模式框架，利用它可以简化创建Web应用程序的过程，不用手动处理复杂的Servlet、HttpServletRequest等。控制器类的每个方法都被映射到了一个不同的请求URL、方法或请求的其他属性上，模型可以通过 $Map$&amp;lt;$String, Object$&amp;gt;的形式从控制器传递到视图，控制器返回的视图或视图名称将把模型转发到合适的JSP视图。通过这些特性，Spring Framework极大地简化了Servlet容器的工作内容。
使用MVC框架时，控制器类中的每个方法都可以拥有一个指向特定URL、请求方法、参数存在性、头的值、内容类型或期望响应类型的唯一映射。
Spring Framework容器以一个或多个应用上下文的形式存在，由 $org.springframework.context.ApplicationContext$ 接口表示。一个应用上下文管理着一组bean、执行业务逻辑的Java对象、执行任务等。由Spring管理的bean可以自动进行DI、消息通知、bean验证等服务。一个Spring程序至少需要一个应用上下文，也可以使用多个应用上下文组成层次结构。在层次结构中应用上下文间有着类似于树的父子兄弟关系，一个子应用上下文的bean可以访问父应用上下文的bean，但无法访问兄弟应用上下文的bean。许多类都继承了 $ApplicationContext$ ，也有许多实现了它：
   类 描述     $ConfigurableApplication$ 可配置的应用上下文   $WebApplicationContext$ 用于Java EE Web应用程序，提供了对 $ServletContext$ 和 $ServletConfig$ 的访问   $ConfigurableWebApplicationContext$ 可配置的 $WebApplicationContext$   $XmlApplicationContext$ 用于在Java EE Web应用程序中从XML文件加载Spring配置   $AnnotationConfigWebApplicationContext$ 用于在Java EE Web应用程序中以编程方式配置Spring     Spring使用 $DispatcherServlet$ 处理Web请求，该Servlet将请求委托给合适的控制器，并按需求对请求和响应实体进行转换。在Web应用程序中，我们可以使用任意数量的 $DispatcherServlet$ 。每个 $DispatcherServlet$ 类都有自己的应用上下文，包含了对Web应用程序的 $ServletContext$ 和自己的 $ServletConfig$ 的引用。</description>
    </item>
    
    <item>
      <title>使用WebSocket实现的一个简单的多人聊天室</title>
      <link>https://z217blog.cn/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Sun, 19 Apr 2020 17:25:57 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>环境：JDK1.8, tomcat-8.5.51
源码可以在GitHub上查阅：ChatRoom
 WebSocket最常用的地方就是聊天室，所以我用Servlet+WebSocket实现了一个简单的多人聊天室。这个多人聊天室改一改就能作为一对一的聊天室使用，毕竟实现方法都是差不多的。
 首先是maven依赖，在此只展示几个要注意的依赖项：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.18.12&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; ...... ...... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.datatype&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-datatype-jsr310&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;  Lombok简化实体的编写（虽然只有一个实体），然后jackson相关的依赖用于Java实例和JSON对象之间的相互转化。为了避免兼容问题，我这里选择依赖基本上都是最新版本。
然后是实体，$ChatMessage$ 用于存储消息相关的信息，使用lombok简化了编写：
import lombok.AllArgsConstructor; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.Setter; import java.time.OffsetDateTime; @Getter @Setter @AllArgsConstructor @NoArgsConstructor public class ChatMessage { private String username; private String message; private OffsetDateTime timestamp; }  有了实体之后再建立仓库，用于存储聊天信息以及用户信息：
import java.util.LinkedList; import java.util.List; import java.util.concurrent.CopyOnWriteArraySet; public class ChatRepository { private static List&amp;lt;ChatMessage&amp;gt; repository = new LinkedList&amp;lt;&amp;gt;(); private static CopyOnWriteArraySet&amp;lt;String&amp;gt; users = new CopyOnWriteArraySet&amp;lt;&amp;gt;(); public static List&amp;lt;ChatMessage&amp;gt; getRepository() { /*.</description>
    </item>
    
    <item>
      <title>JavaWeb（3）：WebSocket简介</title>
      <link>https://z217blog.cn/post/javaweb3websocket%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 06 Apr 2020 14:57:01 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb3websocket%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
 WebSocket用于解决浏览器和服务器的通信问题。在现有体系中，如果只是简单的使用Ajax进行通信的话，容易出现的问题是只有浏览器发送请求时才能得到响应。也即当有新数据时，浏览器不能得知新数据的存在，也就不能及时发送请求获取新数据。
WebSocket使用了HTTP/1.1 升级特性。该特性的使用很简单，只需要在请求中包含头名称和值 $Connection: Upgrade$ ，并在额外的 $Upgrade$ 头中指定一个或多个协议的列表。如果服务器接收升级请求，那么将返回 $101\ \ Switching\ \ Protocols$ 。HTTP升级提供的最重要的特性是我们可以使用任意协议，并且在升级完成后就不再使用HTTP连接，我们可以用一个Socket来代替，由此产生了WebSocket协议。WebSocket协议将使用心跳消息（分别称为 $ping$ 和 $pong$ ）保持连接活跃，即周期性地发送小数据包。在连接升级为WebScoket协议之后，文本和二进制消息可以持续在两个方向上发送且不需要关闭和重连了；而且HTTP规范要求对应同一个主机名，只允许有两个并发连接，但由于我们升级为WebScoket连接了，因此该规范也不存在了。
使用WebSocket协议之前需先以HTTP协议向服务器发送特殊请求，访问一个特殊的URL，该URL以ws或者wss开头，分别对应http和https，并且除了 $Connection: Upgrade$ 头之外，还包含一个 $Connection: websocket$ 头，用于指定服务器将连接升级为 WebSocket协议。
 HTML5(JavaScript)客户端API  WebSocket并不是只能用于浏览器和服务器的通信中，理论上可以将其应用于任何支持其的应用程序中。但如果要编写使用WebSocket进行连接的浏览器客户端终端，我们就要用到JavaScript，尽管我们使用JavaScript编写，但实际上WebSocket是HTML5的一部分。使用JavaScript创建WebSocket对象十分简单：
var connection = new WebSocket(&amp;#39;ws://www.example.com/chat&amp;#39;, {&amp;#39;chat.v1&amp;#39;, &amp;#39;chat.v2&amp;#39;});  WebSocket构造函数第一个参数为连接所使用的URL，第二个参数可选，为连接所使用的一个或多个协议，这些协议都是自己创建的，不受WebSocket管理。
WebSocket接口中包含 $readyState$ 属性表示当前状态，值为 $CONNECTING$, $OPEN$, $CLOSING$, $CLOSED$ 中的一个，包含四个事件：$onopen$, $onclose$, $onerror$, $onmessage$ ，前两者分别在 $readyState$ 由 $CLOSING$ 变为 $CLOSED$ 时和 $readyState$ 由 $CONNECTING$ 变为 $OPEN$ 时触发。传入 $onclose$ 方法的事件包含三个属性：$wasClean$, $code$, $reason$ ，传入 $onopen$ 的是普通的事件，传入 $onerror$ 和 $onmessage$ 的事件包含一个 $data$ 属性，在前者中是错误对象，而在后者则根据消息类型转变：消息为字符串，则 $data$ 也为字符串；消息为二进制数据，并且 $WebSocket.</description>
    </item>
    
    <item>
      <title>JavaWeb（2）：Session简介</title>
      <link>https://z217blog.cn/post/javaweb2session%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 26 Mar 2020 15:41:52 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb2session%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
注：演示所用 Java 版本为 Java8 ，所用容器为 Tomcat8.5.51
 会话用于处理维持请求和请求之间的状态。在没有使用会话时，HTTP请求是无状态的，在浏览器打开第一个连接到服务器的套接字时开启，在服务器返回最后一个数据包时结束。而有些时候，我们希望保持状态，如用户登录或者在线编辑时，这时我们就要用到会话。
在Web中，会话是由服务器或Web应用程序管理的某些文件、内存片段、对象或者容器。服务器在第一次接收到请求时，会随机生成一串字符串，称为会话ID，并返回用户浏览器中。之后所有从该用户浏览器中发出的请求都需要包含该会话ID，服务器接收到会话ID后可以将会话与请求关联起来。HTTP cookie用于将会话ID发送到服务器，但是如果用户浏览器禁止了cookie，那么就需要将会话ID内嵌在URL中，很明显，这种方式使得其他人可以轻松地获得会话，因此是不安全的。不过由于如今许多网站都要求用户在访问时启用cookie，因此我们可以不用顾虑这点。
会话也是有漏洞的。但是由于描述起来篇幅过长，因此不做赘述，如果感兴趣的话可以在 Session hijacking -Wikipedia 中查看。
 大部分情况下我们可以直接使用会话，不需要添加显式配置，但是出于安全目的，我们应该进行配置。使用&amp;lt;$session-config$&amp;gt;标签进行配置，同时在&amp;lt;$session-config$&amp;gt;标签内，我们也可以使用&amp;lt;$cookie-config$&amp;gt;标签进行cookie的配置。所有在&amp;lt;$session-config$&amp;gt;标签和&amp;lt;$cookie-config$&amp;gt;标签内的标签都是可选的。下面列出了所有的可选标签：
&amp;lt;session-config&amp;gt; &amp;lt;session-timeout&amp;gt;30&amp;lt;/session-timeout&amp;gt; &amp;lt;cookie-config&amp;gt; &amp;lt;name&amp;gt;JSESSIONID&amp;lt;/name&amp;gt; &amp;lt;domain&amp;gt;example.org&amp;lt;/domain&amp;gt; &amp;lt;path&amp;gt;/path&amp;lt;/path&amp;gt; &amp;lt;comment&amp;gt;&amp;lt;! [CDATA[Keeps you logged in. See our privacy policy for more information.]]&amp;gt;&amp;lt;/comment&amp;gt; &amp;lt;http-only&amp;gt;true&amp;lt;/http-only&amp;gt; &amp;lt;secure&amp;gt;false&amp;lt;/secure&amp;gt; &amp;lt;max-age&amp;gt;180&amp;lt;/max-age&amp;gt; &amp;lt;/cookie-config&amp;gt; &amp;lt;tracking-mode&amp;gt;COOKIE&amp;lt;/tracking-mode&amp;gt; &amp;lt;tracking-mode&amp;gt;URL&amp;lt;/tracking-mode&amp;gt; &amp;lt;tracking-mode&amp;gt;SSL&amp;lt;/tracking-mode&amp;gt; &amp;lt;/session-config&amp;gt;  下面为每个标签的作用：
   标签 作用     &amp;lt;$session-timeout$&amp;gt; 会话在无效前可以保持不活跃状态的时间，以分钟为单位，为 $0$ 表示永远不过期。   &amp;lt;$tracking-mode$&amp;gt; 表示容器使用哪种技术追踪会话ID，可以配置多个值，按照配置顺序使用。URL表示容器将在URL中内嵌会话ID，COOKIE表示使用cookie，SSL表示使用SSL会话，但要求所有请求均是HTTPS请求。   &amp;lt;$name$&amp;gt; 可以自定义会话cookie的名字，通常不用设置。   &amp;lt;$domain$&amp;gt; 设置cookie的Domain特性，通常不用设置。   &amp;lt;$path$&amp;gt; 设置cookie的Path特性，通常不用设置。   &amp;lt;$comment$&amp;gt; 可以添加任意文本，用于解释cookie。   &amp;lt;$http-only$&amp;gt; 设置cookie的HttpOnly特性，为了提高安全性，一般都设置为 $true$ 。   &amp;lt;$secure$&amp;gt; 设置cookie的Secure特性，如果使用的是HTTPS，就应设置为 $true$ 。   &amp;lt;$max-age$&amp;gt; 设置cookie的Max-Age特性，控制cookie何时过期，以秒为单位，通常不用设置。     学习了如何配置会话之后，就该学习如何使用会话了。为了获取会话，我们可以调用 $HttpServletRequest.</description>
    </item>
    
    <item>
      <title>JavaWeb（1）：Servlet入门</title>
      <link>https://z217blog.cn/post/javaweb1servlet%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 14 Mar 2020 19:20:22 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb1servlet%E5%85%A5%E9%97%A8/</guid>
      <description>参考书籍：Pro Java for Web Apps
注：以下内容需要HTTP基础，演示所用Java版本为Java8，所用容器为Tomcat8.5.51
 Servlet是一个运行在Web服务器中的Java小程序，用于接收和响应来自Web客户端的请求，使用HTTP进行通信，是所有Web应用程序的核心类，也是唯一的既可以直接处理和响应用户请求，也可以将处理工作委托给应用中的其他部分的类。
Servlet只是一个简单的接口，包含了相关的方法。大多数情况下Servlet都继承自 $javax.servlet.GenericServlet$ 类，该类只包含一个抽象的 $service$ 方法以及一些辅助方法。$service$ 方法会处理所有请求，然后返回对应的响应。我们可以使用$javax.servlet.http.HttpServlet$ 类用于响应HTTP请求，它继承自 $GenericServlet$ 并实现其 $service$ 方法，而对于响应HTTP请求的方法只是空实现。在 $HttpServlet$ 类中，HTTP请求包括 $GET,HEAD,POST,PUT,DELETE,OPTIONS,TRACE$ 对应的响应方法名称为 $do +$ 首字母大写的请求名称。如 $GET$ 对应 $doGet()$ ，$POST$ 对应 $doPost()$ 等。除了响应方法之外，Servlet类中还包含 $init$ 方法和 $destroy$ 方法，分别在启用和关闭Servlet时调用，不过通常这些方法什么也不做。
 大多数情况下我们的Servlet类都是继承 $HttpServlet$ 类。对于上述提到的所有方法，它们都接收两个参数，一个是 $javax.servlet.http.HttpServletRequest$ 类型的参数，另一个是 $javax.servlet.http.HttpServletResponse$ 类型。顾名思义，$HttpServletRequest$ 指向客户端请求，对其我们有如下常用方法：
   方法 作用     $getParameter$ 返回参数的单个值   $getParameterValues$ 返回参数的值的数组   $getParameterMap$ 返回一个包含所有参数名值对的$java.util.Map&amp;lt;String, String[\ \ ]&amp;gt;$   $getParameterNames$ 返回所有可用参数的名字的枚举   $getContentLength$ 返回请求正文的长度（小于 $2$ GB）   $getContentLengthLong$ 返回请求正文的长度（大于 $2$ GB）   $getCharacterEncoding$ 返回请求内容的字符编码   $getReader$ 返回一个 $java.</description>
    </item>
    
  </channel>
</rss>
