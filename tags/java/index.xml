<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/java/</link>
    <description>Recent content in Java on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Tue, 03 Mar 2020 17:27:28 +0000</lastBuildDate>
    
	<atom:link href="https://z217blog.cn/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dijkstra算法原理及其实现</title>
      <link>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 03 Mar 2020 17:27:28 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</guid>
      <description>参考书籍：《算法（第4版）》
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\(Dijkstra\) 算法应用于带权有向图中求最短路径问题。通俗来讲就是不断选择权值最小的边加入集合直到所有顶点都在集合中，属于贪心算法。需要注意的是，\(Dijkstra\) 算法只能用于解决边权非负的图类问题。
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;假设对于一个带权有向图 \(G(V,E)\) 以邻接矩阵表示，其所有边存储在一个二维整型数组 \(matrix[\ \ ][\ \ ]\) 中， \(matrix[i][j]\) 表示从顶点 \(i\) 到顶点 \(j\) 之间的边，值为边的权值，若值为 \(∞\) ，说明该边不存在。为了实现 \(Dijkstra\) 算法，我们需要一个布尔值数组 \(visit[\ \ ]\) ，用于判断顶点是否访问过，或者说是否在集合中；一个整型数组 \(distance[\ \ ]\) 用于储存原点到每个点的最短距离。定义了基本的结构，就可以实现算法了，步骤为：
 从 \(V\) 中选择一个点 \(s\) 作为原点，将邻接矩阵中的 \(matrix[s]\) 数组复制到 \(distance[s]\) （复制后 \(distance[s]\) 应为 \(0\) ），建立一个 \(visit[\ \ ]\) 数组并清零。 从 \(V\) 中选择一个顶点 \(u\) 加入集合，其中点 \(u\) 满足：
 之前未曾访问过点 \(u\) （即 \(visit[u] = false\) ）。 与 \(s\) 距离最短（即 \(distance[u]\) 的值最小）。  以 \(u\) 为中心点，对于每个与 \(u\) 相邻的顶点 \(k\) ，令 \(distance[k] = Min(distance[k], distance[u] + matrix[u][k])\) ，这一步也称为松弛( \(relaxation\) )。 重复2、3直到所有顶点加入集合。  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\(Dijkstra\) 算法类似于 \(Prim\) 算法，实质上都是构造了一颗树。经过以上步骤之后，我们得到了一个 \(distance[\ \ ]\) 数组，其中的值为从原点 \(s\) 到图中其他所有点的最短距离。在使用代码实现的过程中，有些情况下我们可以使用优先队列来简化寻找最小权值的这一过程。如果我们确认了一幅图是无环图，那么我们也可以不使用 \(visit[\ \ ]\) ，而是通过拓扑排序的顺序依次遍历顶点。</description>
    </item>
    
  </channel>
</rss>