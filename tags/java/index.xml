<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/java/</link>
    <description>Recent content in Java on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2021, z217 and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Mon, 23 Aug 2021 15:01:55 +0800</lastBuildDate><atom:link href="https://z217blog.cn/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HashMap源码解读</title>
      <link>https://z217blog.cn/post/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Mon, 23 Aug 2021 15:01:55 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>1. 字段  字段设置为 $transient$ ，因为 $HashMap$ 通过 $Object.hashCode(\ )$ 获取哈希值，并通过哈希值与桶个数取模确定对象。$Object.hashCode(\ )$ 是一个本地方法，依赖于JVM实现，存在跨平台问题，所有 $HashMap$ 在序列化时会先保存所有 $Key$ ，再在反序列化时重新插入。
// 最大容量 static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; // 默认负载因子，大小/容量超过这个比例就会扩容 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶中节点数不小于该值时树化 // 树节点大小是常规节点两倍，应该在有足够的节点后树化 static final int TREEIFY_THRESHOLD = 8; // 当桶中节点数小于该值时链表化 // 不设为TREEIFY_THRESHOLD，避免抖动 static final int UNTREEIFY_THRESHOLD = 6; // 当容量不小于该值时才会树化，否则会优先扩容 // 应当至少为 4 * TREEIFY_THRESHOLD static final int MIN_TREEIFY_CAPACITY = 64; // 初次使用时初始化，长度为 2 的幂次 transient Node&amp;lt;K,V&amp;gt;[] table; // entrySet() 缓存 transient Set&amp;lt;Map.</description>
    </item>
    
    <item>
      <title>StampedLock源码解读</title>
      <link>https://z217blog.cn/post/stampedlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Tue, 30 Mar 2021 14:05:51 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/stampedlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>1. 字段 // 处理器数量 private static final int NCPU = Runtime.getRuntime().availableProcessors(); // 入队前的最大重试次数 private static final int SPINS = (NCPU &amp;gt; 1) ? 1 &amp;lt;&amp;lt; 6 : 0; // 作为首节点阻塞前的最大重试次数 private static final int HEAD_SPINS = (NCPU &amp;gt; 1) ? 1 &amp;lt;&amp;lt; 10 : 0; // 再次阻塞前的最大重试次数 private static final int MAX_HEAD_SPINS = (NCPU &amp;gt; 1) ? 1 &amp;lt;&amp;lt; 16 : 0; // 等待自旋上溢的闲置时期，必须为2的幂次-1 private static final int OVERFLOW_YIELD_RATE = 7; // 在上溢前记录读锁的位数，占据低位 private static final int LG_READERS = 7; // 每次读增加的单位 private static final long RUNIT = 1L; // 写锁所在位数 // 1000 0000 private static final long WBIT = 1L &amp;lt;&amp;lt; LG_READERS; // 读锁所在位数 // 0111 1111 private static final long RBITS = WBIT - 1L; // 读锁上限 // 0111 1110 private static final long RFULL = RBITS - 1L; // 掩码 // 1111 1111 private static final long ABTIS = RBITS | WBITS; // 读锁反数 // 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1000 0000 private static final long SBITS = ~RBITS; // 锁状态初始值 // 0001 0000 0000 private static final long ORIGIN = WBIT &amp;lt;&amp;lt; 1; // 取消获取锁时的特殊状态，表示中断 private static final long INTERRUPTED = 1L; // 等待状态 private static final int WAITING = -1; // 取消状态 private static final int CANCELLED = 1; // 节点读模式 private static final int RMODE = 0; // 节点写模式 private static final int WMODE = 1; // CLH队列首节点 private transient volatile WNode whead; // CLH队列尾节点 private transient volatile WNode wtail; // 视图 transient ReadLockView readLockView; transient WriteLockView writeLockView; transient ReadWriteLockView readWriteLockView; // 锁队列状态 // 高24位为版本号，每次获取和释放写锁都会+1，25位为写锁标志，剩余7位为读锁计数，记录当前读锁数量 private transient volatile long state; // 额外的读锁计数 private transient int readerOverflow; 2.</description>
    </item>
    
    <item>
      <title>ReentranLock源码解读</title>
      <link>https://z217blog.cn/post/reentranlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 20 Mar 2021 22:27:10 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/reentranlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>$ReentrantLock$ 是一个可重入的独占锁，与 $synchronized$ 行为类似，但提供了额外的功能。
1. 构造函数 // 默认为非公平锁 public ReentrantLock() { sync = new NonfairSync(); } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 2. 内部类 abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; abstract void lock(); // 非公平上锁, tryAcquire方法在子类中实现  final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { // 锁未被占有  if (compareAndSetState(0, acquires)) { // 尝试获取锁  setExclusiveOwnerThread(current); // 设置独占线程  return true; } } else if (current == getExclusiveOwnerThread()) { // 当前线程已经占有锁  int nextc = c + acquires; if (nextc &amp;lt; 0) throw new Error(&amp;#34;Maximum lock count exceeded&amp;#34;); setState(nextc); // 添加上锁次数  return true; } return false; } protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.</description>
    </item>
    
    <item>
      <title>AQS源码解读</title>
      <link>https://z217blog.cn/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Fri, 19 Mar 2021 20:14:24 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>AQS提供了一个实现阻塞锁和相关的基于FIFO队列的同步器的框架。该类作为大部分依赖于一个状态字段的同步器的基础。子类必须定义 $protected$ 方法来改变状态，其他方法用于管理队列和实现阻塞机制。子类也可以包含其他状态字段，但必须通过原子性操作维护状态。
1. 成员变量 // 等待队列的头节点，懒加载，只能通过setHead方法修改 private transient volatile Node head; // 等待队列的尾部，懒加载，只能通过enq方法添加新节点 private transient volatile Node tail; // 同步状态 private volatile int state; // 如果超时时间大于该值，中断，单位为纳秒 static final long spinForTimeoutThreshold = 1000L; 2. 内部类Node static final class Node { // 节点在共享模式等待的标志  static final Node SHARED = new Node(); // 节点在独占模式等待的标志  static final Node EXCLUSIVE = null; // 表示线程被取消  static final int CANCELLED = 1; // 表示线程在释放资源后需要唤醒后继节点  static final int SIGNAL = -1; // 表示线程在等待condition  static final int CONDITION = -2; // 共享模式下表示无条件传播  static final int PROPAGATE = -3; // 等待状态  volatile int waitStatus; // 前驱节点  volatile Node prev; // 后继节点  volatile Node next; // 节点对应的线程  volatile Thread thread; // 下一个在condition上等待的节点，或者表示共享模式  Node nextWaiter; final boolean isShared() { return nextWaiter == SHARED; } final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } Node() {} // 用于创建头节点或者共享标记  Node(Thread thread, Node mode) { this.</description>
    </item>
    
    <item>
      <title>Leetcode题解（5）：LRU与LinkedHashMap</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A35lru%E4%B8%8Elinkedhashmap/</link>
      <pubDate>Tue, 16 Mar 2021 18:05:19 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A35lru%E4%B8%8Elinkedhashmap/</guid>
      <description>LeetCode146
 为了记录访问顺序，我们可以使用一个双向链表，首节点为最近最少访问的数据，尾节点为最近访问的数据。为了快速获取值，我们可以额外使用一个 $Map$ 存储键值映射。
public class LRUCache { private int capacity; private int size; private Map&amp;lt;Integer, Node&amp;gt; map; private Node head; private Node tail; public LRUCache(int capacity) { this.capacity = capacity; size = 0; map = new HashMap&amp;lt;&amp;gt;(); } public int get(int key) { Node node = getNode(key); return node == null ? -1 : node.val; } public void put(int key, int value) { Node node = getNode(key); if (node !</description>
    </item>
    
    <item>
      <title>String.indexOf方法和KMP算法简介</title>
      <link>https://z217blog.cn/post/string.indexof%E6%96%B9%E6%B3%95%E5%92%8Ckmp%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 13 Mar 2021 21:14:45 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/string.indexof%E6%96%B9%E6%B3%95%E5%92%8Ckmp%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</guid>
      <description>1. String.indexOf  子字符串查找是字符串的一种基本操作：给定一段长度为 $N$ 的文本和一个长度为 $M$ 的模式 ( $pattern$ ) 字符串，在文本中找到一个和该模式相符的子字符串。对于一般的暴力式方法，在最坏的情况下运行时间与 $MN$ 成正比，但是在处理许多应用程序中的字符串时 ( 除了一些极端情况外 )，它的实际运行时间一般与 $M + N$ 成正比。另外，它很好地利用了大多数计算机系统中标准的结构特性，因此即使是更加巧妙的算法也很难超越它经过优化后的版本的性能。
public static int search(String pat, String txt) { int M = pat.length(); int N = txt.length(); for (int i = 0; i &amp;lt;= N; i++) { int j; for (j = 0; j &amp;lt; M; j++) if (txt.charAt(i + j) != pat.charAt(j)) break; if (j == M) return i; } return N; }  $String.</description>
    </item>
    
    <item>
      <title>Java 8实战：日期和时间API</title>
      <link>https://z217blog.cn/post/java-8%E5%AE%9E%E6%88%98%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api/</link>
      <pubDate>Thu, 18 Feb 2021 18:39:00 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java-8%E5%AE%9E%E6%88%98%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api/</guid>
      <description>在Java 1.0中，对日期和时间的支持只能依赖 $java.util.Date$ 类。这个类无法表示日期，只能以毫秒的精度表示时间。而且由于某些原因未知的设计决策，这个类的易用性也不高。例如一个表示 $2014$ 年 $3$ 月 $18$ 日的 $Date$ 需要用以下方式创建：
Date date = new Date(114, 2, 18);  此外，$Date.toString$ 方法的返回值中虽然包含时区，但 $Date$ 并不支持时区。所以，在Java 1.1中，$Date$ 的许多方法被废弃，取而代之的是 $java.util.Calendar$ 类，但是这个类同样也存在着很多问题。比如月份依旧是从 $0$ 开始，而且没有提供 $DateFormat$ 方法。如果使用 $DateFormat$ 方法，那么又会带来并发问题，因为它不是线程安全的。为了解决上述问题，Java 8中新增的 $java.time$ 包中添加了新的日期和时间API。 $java.time$ 包中提供了一些新类：$LocalDate$ 、$LocalTime$ 、$Instant$ 、$Duration$ 和 $Period$ 。
1. LocalDate/LocalTime/LocalDateTime  $LocalDate$ 的实例是一个不可变对象，它只提供了简单的日期，并不包含当天的时间信息。另外，它也不附带任何与时区相关的信息。可以通过静态工厂方法 $of$ 创建一个 $LocalDate$ 实例，或者通过 $now$ 方法从系统时钟中获取当前日期，并通过 $getYear$ 、$getMonth$ 、$getDayOfMonth$ 等方法读取常用值。
LocalDate date = LocalDate.of(2014, 3, 18); // 2014-03-18 int year = date.</description>
    </item>
    
    <item>
      <title>Java 8实战：流处理</title>
      <link>https://z217blog.cn/post/java-8%E5%AE%9E%E6%88%98%E6%B5%81%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 17 Feb 2021 18:00:13 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java-8%E5%AE%9E%E6%88%98%E6%B5%81%E5%A4%84%E7%90%86/</guid>
      <description>流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流。基于流的思想，Java 8在 $java.util.stream$ 中添加了一个Stream API。 $Stream$&amp;lt;$T$&amp;gt; 就是一系列 $T$ 类型的项目。 和Collection API相比，Stream API处理数据的方式非常不同。用集合的话，需要使用 $for$ 循环迭代并处理元素，我们称之为外部迭代。相反，Stream API的数据处理完全是在库内部进行的，我们称之为内部迭代。虽然都能访问数据项目的序列，但是相比之下，Collection API主要是为了存储和访问数据，而Stream API主要用于描述对数据的计算。这里的关键点在于，Stream API允许并行处理一个 $Stream$ 中的元素。筛选一个 $Collection$ 最快的方式通常是将其转换为 $Stream$ ，进行并行处理，再转换回 $List$ 。粗略地说，流与集合之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，包含数据结构中目前所有的值，集合中的元素只有经过计算后才能添加；相比之下，流是在概念上固定的数据结构，不能通过流添加或删除元素，流中的元素是按需计算的，即只从流中提取出需要的值。与迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。要想重新遍历，可以从原始数据源中重新获取一个新的流。尝试再次遍历一个已经消费的流会抛出 $IllegalStateException$ 异常。流与集合的另一个关键区别在于遍历数据的方式，正如之前所说，使用 $Collection$ 接口需要用户进行外部迭代，而 $Steams$ 库使用的是内部迭代，即库自动完成迭代，并将流值存放在某个地方。相较于显式的外部迭代，内部迭代下项目可以透明地并行处理，或者用更优化的顺序进行处理，例如同时处理多个数据，或者优先处理某些数据等。
1. 流操作    操作 类型 返回类型 操作参数 函数描述符 目的     $filter$ 中间 $Stream$&amp;lt;$T$&amp;gt; $Predicate$&amp;lt;$T$&amp;gt; $T \rightarrow boolean$ 返回一个包含所有符合谓词的元素的流   $distinct$ 中间 $Stream$&amp;lt;$T$&amp;gt;   返回一个元素各异的流   $map$ 中间 $Stream$&amp;lt;$R$&amp;gt; $Function$&amp;lt;$T, R$&amp;gt; $T \rightarrow R$ 将函数应用到每个元素上，并映射成一个新元素   $flatMap$ 中间 $Stream$&amp;lt;$R$&amp;gt; $Function$&amp;lt;$T,R$&amp;gt; $T \rightarrow R$ 将多个生成流扁平化为单个流   $limit$ 中间 $Stream$&amp;lt;$T$&amp;gt;   返回一个不超过给定长度的流   $skip$ 中间 $Stream$&amp;lt;$T$&amp;gt;   返回一个跳过给定数量元素的流   $sorted$ 中间 $Stream$&amp;lt;$T$&amp;gt; $Comparator$&amp;lt;$T$&amp;gt; $(T, T) \rightarrow int$ 返回一个经过排序的流   $forEach$ 终端 $void$ $Consumer$&amp;lt;$T$&amp;gt; $T \rightarrow void$ 消费流中的每一个元素并对其应用Lambda，返回类型为 $void$   $count$ 终端 $long$   返回流中元素的个数，返回类型为 $long$   $collect$ 终端 $R$ $Collector$&amp;lt;$T, A, R$&amp;gt;  把流归约成一个集合并返回   $anyMatch$ 终端 $boolean$ $Predicate$&amp;lt;$T$&amp;gt; $T \rightarrow boolean$ 流中是否含有一个元素能匹配给定的谓词   $allMatch$ 终端 $boolean$ $Predicate$&amp;lt;$T$&amp;gt; $T \rightarrow boolean$ 流中的元素是否都能匹配给定的谓词   $noneMatch$ 终端 $boolean$ $Predicate$&amp;lt;$T$&amp;gt; $T \rightarrow boolean$ 流中是否没有元素与给定的谓词匹配   $findAny$ 终端 $Optional$&amp;lt;$T$&amp;gt;   返回当前流中的任意元素   $findFirst$ 终端 $Optional$&amp;lt;$T$&amp;gt;   返回当前流中第一个元素   $reduce$ 终端 $Optional$&amp;lt;$T$&amp;gt; $BinaryOperator$&amp;lt;$T$&amp;gt; $(T, T) \rightarrow T$ 对流中元素重复应用方法     诸如 $filter$ 或 $Sorted$ 等操作会返回另一个流，这让多个操作可以连接起来形成一个查询，这种操作称为中间操作。除非流水线上触发一个终端操作，否则中间操作不会执行任何处理。终端操作会从流的流水线生成结果，其结果是任何不是流的值，比如 $List$ 、$Integer$ 等。总而言之，流的使用一般包括三件事：一个数据源、一个中间操作链和一个终端操作。 诸如 $map$ 或 $filter$ 等操作会从输入流中获取每一个元素，并在输出流中得到 $0$ 或 $1$ 个结果。这些操作一般都是无状态操作。但诸如 $reduce$ 、$sum$ 、$max$ 等操作需要内部状态来累计结果，这些操作就是有状态操作。但是这些操作的内部状态很小，通常只是一些基本数据类型，不管流中有多少元素需要处理，内部状态都是有界的。而诸如 $sorted$ 或 $distinct$ 等操作，它们的内部状态可能很大，这时就要求无界的存储空间。 $peek$ 是一个特殊的流操作，可以在流的每个元素恢复运行之前，插入执行一个动作。$peek$ 不会恢复流的运行，而是在一个元素上完成操作之后，将操作顺承到流水线中的下一个操作。 Java 8引入了三个原始类型特化流接口 $IntStream$ 、$DoubleStream$ 和 $LongStream$ ，分别将流中的元素特化为 $int$ 、$long$ 和 $double$ ，从而避免了暗含的装箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的 $sum$ ，此外还可以在必要时将它们转换回对象流。将流转换为特化版本的常用方法是 $mapToInt$ 、$mapToDouble$ 和 $mapToLong$ 。这些方法和 $map$ 的工作方式一样，但是会返回特化流。如果想要将特化流转换为对象流，可以使用 $boxed$ 方法。类似的，也可以使用 $mapToObj$ 方法生成对象流。 Java 8还引入了两个可以用于 $IntStream$ 和 $LongStream$ 的静态方法，帮助生成数值范围，分别是 $range$ 和 $rangeClosed$ ，前者为开区间，后者为闭区间。 除了调用集合中的 $stream$ 方法之外，还有一些其他的构造流的方式：</description>
    </item>
    
    <item>
      <title>Java注解</title>
      <link>https://z217blog.cn/post/java%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 07 Sep 2020 23:32:11 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java%E6%B3%A8%E8%A7%A3/</guid>
      <description>注解为在代码中添加信息提供了一种形式化的方式。Java SE5内置了三种定义在 $java.lang$ 当中的注解：
 $@Override$ ：表示当前定义的方法将覆盖超类中的方法； $@Deprecated$ ：表示方法被弃用，调用此类方法将引发警告； $@SuppressWarnings$ ：关闭某些编译警告信息。   除此之外还有四种注解，用于创建新注解。
1. 语法 1.1 定义 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { public int id(); public String description() default &amp;#34;no description&amp;#34;; }  注解的定义方式很像接口，也与接口一样会被编译为class文件。定义注解需要一些元注解。$@Target$ 定义注解的作用对象，如方法；$@Retention$ 定义的可用级别，分为源码 ( $SOURCE$ )、类文件 ( $CLASS$ )、运行时 ( $RUNTIME$ )。
在定义注解时也可以设置一些元素表示一些值，不同于接口，你可以为这些值设置默认值。如果没有提供默认值，那么在使用注解的时候就必须进行赋值。没有元素的注解称为标记注解 ( $marker\ \ annotation$ )。可用的注解元素包括以下类型：
 基本类型； $String$ ； $Class$ ； $enum$ ； $Annotation$ ； 以上类型的数组。  1.2 元注解  Java内置了四种元注解：</description>
    </item>
    
    <item>
      <title>Java I/O</title>
      <link>https://z217blog.cn/post/java-i-o/</link>
      <pubDate>Sun, 06 Sep 2020 21:28:06 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java-i-o/</guid>
      <description>1. File类  $File$ 类用于储存文件路径，可以代表一个特定文件或者一组文件的名称，如果是后者，可以通过 $list(\ )$ 获得一个字符数组。在不传入参数时，$list(\ )$ 方法返回全部列表，也可以接受一个 $FilenameFilter$ 类型的参数，实现目录过滤：
class DirFilter implements FilenameFilter { private Pattern pattern; public DirFilter(String regex) { pattern = Pattern.compile(regex); } public boolean accept(File dir, String name) { return pattern.matcher(name).matches(); } } public class DirList { public static void main(String[] args) { System.out.println(Arrays.toString(new File(&amp;#34;.&amp;#34;).list(new DirFilter(args[0])))); } }  除了代表文件和目录之外，$File$ 对象还可以用于创建和删除目录，查看文件信息等：
   方法 作用     $getAbsolutePath$ 返回绝对路径   $canRead$ 可读性   $canWrite$ 可写性   $getName$ 返回名称   $getParent$ 返回父目录   $getPath$ 返回路径   $lastModified$ 最后修改时间   $isFile$ 是否为文件   $isDirectory$ 是否为目录   $exists$ 是否存在   $mkdirs$ 创建   $delete$ 删除   $renameTo$ 重命名或移动文件    2.</description>
    </item>
    
    <item>
      <title>Java泛型</title>
      <link>https://z217blog.cn/post/java%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Wed, 02 Sep 2020 21:23:39 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java%E6%B3%9B%E5%9E%8B/</guid>
      <description>泛型允许一个类应用于多种类型，实现了参数化类型的概念。促使泛型产生的原因之一就是容器类，泛型可以用于指定一个容器具体要持有怎样的类型。当然，也可以通过泛型实现持有多个类型的类，如元组类：
public class TwoTuple&amp;lt;A, B&amp;gt; { public final A first; public final B second; public TwoTuple(A a, B b) { this.first = a; this.second = b; } }  如果需要长度更长的元组如三元组，我们可以在二元组的基础上声明三元组类，并令其继承二元组类。
除了具体类外，泛型还可以应用于抽象类和接口当中。
Java泛型存在着很多局限性，第一个就是不能以基本类型作为其类型参数。当然，通过Java自动包装和自动拆包的功能，基本类型和其包装类型可以很方便地进行转换。
之前提到的泛型都是应用于一个类上的，但是泛型同样可以应用于方法上，而且不仅可以应用于泛型类的方法上，也可以应用于普通类的方法上。如果通过使用泛型方法就可以避免使用泛型类，那么推荐使用泛型方法。此外，由于 $static$ 方法无法获取类型参数，因此如果要让 $static$ 方法使用泛型，那么就必须让其成为泛型方法。与使用泛型类不同，使用泛型方法时可以不用指定具体类型，通过类型参数推断，编译器可以为我们找出具体类型。
1. 擦除  通过泛型，我们可以声明一个 $ArrayList&amp;lt;Integer&amp;gt;$ 对象，然后我们可以获取 $ArraysList.class$ ，但是却不能获取 $ArrayList&amp;lt;Integer&amp;gt;.class$ 对象。这个行为说明了在编译器的眼中，$ArrayList&amp;lt;Integer&amp;gt;$ 和 $ArrayList&amp;lt;String&amp;gt;$ 是同一类型。更加夸张的是，不同于C++，在Java的泛型内，你无法获取任何有关于泛型参数类型的信息。这些行为的原因都是因为Java的泛型是使用擦除实现的。在基于擦除的实现中，泛型被认为是第二类类型，既不能在某些重要的上下文环境中使用的类型。泛型类型只有在静态类型检查期间才会出现，之后泛型类型将被擦除，并替换为非泛型边界如 $List$ , $Object$ 等。
在C++中，我们可以实现以下代码：
template&amp;lt;class T&amp;gt; class Test { T obj; public: Test(T t) { this.obj = t; } void f() { obj.</description>
    </item>
    
    <item>
      <title>Java类型信息</title>
      <link>https://z217blog.cn/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Sun, 30 Aug 2020 16:50:55 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</guid>
      <description>运行时类型信息 ( $RTTI$ ) 可以让我们在程序运行时发现和使用类型信息，主要有两种方式：传统RTTI，假定在编译时就已经知道了所有类型；以及反射，允许在运行时发现和使用类型信息。
1. RTTI  传统的RTTI在Java语句执行过程中也发挥着作用。
 我们定义了一个 $Circle$ 对象，将其存储在一 $List&amp;lt;Shape&amp;gt;$ 容器之中。那么当对象被放入容器时，会向上转型为 $Shape$ ；而在取出时，由于 $List$ 容器会将所有对象当作 $Object$ 类型持有，因此会再次转换为 $Shape$ 对象。
1.1 Class对象  $Class$ 对象负责表示运行时的类型信息，Java通过 $Class$ 对象执行RTTI。每个类都拥有一个 $Class$ 对象，当它被编译时，就会通过类加载器产生一个 $.class$ 文件，存储其 $Class$ 对象。
所有的类都是在被第一次使用时动态地被加载到JVM当中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。也就是说构造器也是静态的，因此使用 $new$ 创建对象就会创建一个对静态构造器的引用，从而使得这个类被加载。当类的 $Class$ 对象被载入后，这个类的所有对象都会使用 $Class$ 对象创建。$Class$ 对象还有一些常用方法：
 $forName(\ )$ ：通过全类名获取对应类的 $Class$ 对象； $getName(\ )$ ：获取全限定的类名； $getSimpleName(\ )$ ：获取不含包名的类名； $getInterfaces(\ )$ ：$Class$ 对象中实现的接口； $getSuperclass(\ )$ ：获取基类的 $Class$ 对象。   $Class.newInstance(\ )$ 方法允许你在不知道确切类型的情况下创建对象。通过该方法你可以得到一个 $Object$ 对象，要想正确地使用该对象，你需要对其进行转型。使用 $newInstance$ 创建对象的要求是该对象拥有一个默认构造器。</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://z217blog.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 10 Jul 2020 16:57:11 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式常用的七大原则：
 单一职责原则——一个类应该只负责一项职责。 接口隔离原则——一个类对应另一个类的依赖应该建立在最小的接口上。 依赖倒转原则  高层模块不应依赖于低层模块 抽象不应该依赖于细节 面向接口编程（中心思想）   里氏替换原则——所有引用基类的地方必须能透明的使用子类。 开闭原则——软件实体对扩展开放，对修改关闭，用抽象构建框架，用实现扩展细节。 迪米特法则——一个类应该将逻辑封装在内部，不对外泄露。 合成复用原则——尽量使用合成/聚合方式   23种设计模式的三种类型：
 创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式； 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式； 行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）。  1.单例模式  单例模式，即采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（通常为静态方法）。单例模式有八种方式：
 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举  1.1 饿汉式（静态常量）  构造器私有化（即不能通过 $new$ 创建实例） 类内部创建对象 向外暴露一个静态公共方法 代码实现  class Singleton { private final static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; } } 优点：写法简单，在类装载时实例化，避免了线程同步问题。</description>
    </item>
    
    <item>
      <title>Redis笔记</title>
      <link>https://z217blog.cn/post/redis%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 10 May 2020 17:20:42 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/redis%E7%AC%94%E8%AE%B0/</guid>
      <description>1. Redis简介 NoSQL即 $Not-Only\ \ SQL$ ，是RDBMS的补充。
Redis是一种NoSQL数据库，是一个使用C语言开发的开源的高性能键值对数据库，内部使用单线程机制进行工作。
 $set\ \ [key]\ \ [value]$ 添加信息, $get\ \ [key]$ 查询信息，为空返回 $nil$ , $del\ \ [key]$ 删除信息，$1$ 代表删除成功, $clear$ 清屏, $help\ \ [op]$ 帮助, $time$ 获取时间.  2. 数据类型 Redis采用键值对的方式存储，$key$ 为字符串，$value$ 则允许多种类型。
2.1 string 最简单的数据类型，最大存储量 $512MB$ ， 可以作为数字使用，最大值为 $java.lang.Long$ 类型的最大值， 允许以JSON对象的方式存储数据，值中间不能有空白符
 $mset/mget$ 获取多个数据 $strlen$ 获取字符个数 $append$ 追加，返回总长度，也可以用于添加信息 $incr/incrby/incrbyfloat$ 指定数据增加指定值，允许负数，返回数值 $decr/decrby$ 指定数据减少指定的值，允许负数，返回数值 $setex/psetex$ 设定数据周期，秒/毫秒  2.2 hash hash 属于 $value$ ，其中包含多组键值对，键称为 $field$ ，键值对较少时为类数组结构，较多时为 $HashMap$ 结构，$value$ 只能为 string ，且最多只能有 $2^{32} - 1$ 组。</description>
    </item>
    
    <item>
      <title>JavaWeb（4）：Spring简介</title>
      <link>https://z217blog.cn/post/javaweb4spring%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 21 Apr 2020 15:48:49 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb4spring%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
Maven依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.inject&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.inject&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.annotation&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.annotation-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;   Spring Framework是一个Java应用程序容器，它提供了许多有用的特性，如反转控制（IoC）、依赖注入（DI）、抽象数据访问、事务管理等。
IoC是一个软件设计模式，即组装器（Spring Framework)在运行时才会绑定对象，也就是运行时才会实例化依赖的组件。这使得开发者可以针对接口进行编程，无需重新编译代码。DI是IoC的一种实现方式，通过DI，一个类可以通过声明其依赖的接口类型，然后利用组装器在运行时注入其依赖的实例。
Spring Framework提供了一个MVC（模型-视图-控制）模式框架，利用它可以简化创建Web应用程序的过程，不用手动处理复杂的Servlet、HttpServletRequest等。控制器类的每个方法都被映射到了一个不同的请求URL、方法或请求的其他属性上，模型可以通过 $Map$&amp;lt;$String, Object$&amp;gt;的形式从控制器传递到视图，控制器返回的视图或视图名称将把模型转发到合适的JSP视图。通过这些特性，Spring Framework极大地简化了Servlet容器的工作内容。
使用MVC框架时，控制器类中的每个方法都可以拥有一个指向特定URL、请求方法、参数存在性、头的值、内容类型或期望响应类型的唯一映射。
Spring Framework容器以一个或多个应用上下文的形式存在，由 $org.springframework.context.ApplicationContext$ 接口表示。一个应用上下文管理着一组bean、执行业务逻辑的Java对象、执行任务等。由Spring管理的bean可以自动进行DI、消息通知、bean验证等服务。一个Spring程序至少需要一个应用上下文，也可以使用多个应用上下文组成层次结构。在层次结构中应用上下文间有着类似于树的父子兄弟关系，一个子应用上下文的bean可以访问父应用上下文的bean，但无法访问兄弟应用上下文的bean。许多类都继承了 $ApplicationContext$ ，也有许多实现了它：
   类 描述     $ConfigurableApplication$ 可配置的应用上下文   $WebApplicationContext$ 用于Java EE Web应用程序，提供了对 $ServletContext$ 和 $ServletConfig$ 的访问   $ConfigurableWebApplicationContext$ 可配置的 $WebApplicationContext$   $XmlApplicationContext$ 用于在Java EE Web应用程序中从XML文件加载Spring配置   $AnnotationConfigWebApplicationContext$ 用于在Java EE Web应用程序中以编程方式配置Spring     Spring使用 $DispatcherServlet$ 处理Web请求，该Servlet将请求委托给合适的控制器，并按需求对请求和响应实体进行转换。在Web应用程序中，我们可以使用任意数量的 $DispatcherServlet$ 。每个 $DispatcherServlet$ 类都有自己的应用上下文，包含了对Web应用程序的 $ServletContext$ 和自己的 $ServletConfig$ 的引用。</description>
    </item>
    
    <item>
      <title>使用WebSocket实现的一个简单的多人聊天室</title>
      <link>https://z217blog.cn/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Sun, 19 Apr 2020 17:25:57 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>环境：JDK1.8, tomcat-8.5.51
源码可以在GitHub上查阅：ChatRoom
 WebSocket最常用的地方就是聊天室，所以我用Servlet+WebSocket实现了一个简单的多人聊天室。这个多人聊天室改一改就能作为一对一的聊天室使用，毕竟实现方法都是差不多的。
 首先是maven依赖，在此只展示几个要注意的依赖项：
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.18.12&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; ...... ...... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.datatype&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-datatype-jsr310&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;  Lombok简化实体的编写（虽然只有一个实体），然后jackson相关的依赖用于Java实例和JSON对象之间的相互转化。为了避免兼容问题，我这里选择依赖基本上都是最新版本。
然后是实体，$ChatMessage$ 用于存储消息相关的信息，使用lombok简化了编写：
import lombok.AllArgsConstructor; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.Setter; import java.time.OffsetDateTime; @Getter @Setter @AllArgsConstructor @NoArgsConstructor public class ChatMessage { private String username; private String message; private OffsetDateTime timestamp; }  有了实体之后再建立仓库，用于存储聊天信息以及用户信息：
import java.util.LinkedList; import java.util.List; import java.util.concurrent.CopyOnWriteArraySet; public class ChatRepository { private static List&amp;lt;ChatMessage&amp;gt; repository = new LinkedList&amp;lt;&amp;gt;(); private static CopyOnWriteArraySet&amp;lt;String&amp;gt; users = new CopyOnWriteArraySet&amp;lt;&amp;gt;(); public static List&amp;lt;ChatMessage&amp;gt; getRepository() { /*.</description>
    </item>
    
    <item>
      <title>JavaWeb（3）：WebSocket简介</title>
      <link>https://z217blog.cn/post/javaweb3websocket%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 06 Apr 2020 14:57:01 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb3websocket%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
 WebSocket用于解决浏览器和服务器的通信问题。在现有体系中，如果只是简单的使用Ajax进行通信的话，容易出现的问题是只有浏览器发送请求时才能得到响应。也即当有新数据时，浏览器不能得知新数据的存在，也就不能及时发送请求获取新数据。
WebSocket使用了HTTP/1.1 升级特性。该特性的使用很简单，只需要在请求中包含头名称和值 $Connection: Upgrade$ ，并在额外的 $Upgrade$ 头中指定一个或多个协议的列表。如果服务器接收升级请求，那么将返回 $101\ \ Switching\ \ Protocols$ 。HTTP升级提供的最重要的特性是我们可以使用任意协议，并且在升级完成后就不再使用HTTP连接，我们可以用一个Socket来代替，由此产生了WebSocket协议。WebSocket协议将使用心跳消息（分别称为 $ping$ 和 $pong$ ）保持连接活跃，即周期性地发送小数据包。在连接升级为WebScoket协议之后，文本和二进制消息可以持续在两个方向上发送且不需要关闭和重连了；而且HTTP规范要求对应同一个主机名，只允许有两个并发连接，但由于我们升级为WebScoket连接了，因此该规范也不存在了。
使用WebSocket协议之前需先以HTTP协议向服务器发送特殊请求，访问一个特殊的URL，该URL以ws或者wss开头，分别对应http和https，并且除了 $Connection: Upgrade$ 头之外，还包含一个 $Connection: websocket$ 头，用于指定服务器将连接升级为 WebSocket协议。
 HTML5(JavaScript)客户端API  WebSocket并不是只能用于浏览器和服务器的通信中，理论上可以将其应用于任何支持其的应用程序中。但如果要编写使用WebSocket进行连接的浏览器客户端终端，我们就要用到JavaScript，尽管我们使用JavaScript编写，但实际上WebSocket是HTML5的一部分。使用JavaScript创建WebSocket对象十分简单：
var connection = new WebSocket(&amp;#39;ws://www.example.com/chat&amp;#39;, {&amp;#39;chat.v1&amp;#39;, &amp;#39;chat.v2&amp;#39;});  WebSocket构造函数第一个参数为连接所使用的URL，第二个参数可选，为连接所使用的一个或多个协议，这些协议都是自己创建的，不受WebSocket管理。
WebSocket接口中包含 $readyState$ 属性表示当前状态，值为 $CONNECTING$, $OPEN$, $CLOSING$, $CLOSED$ 中的一个，包含四个事件：$onopen$, $onclose$, $onerror$, $onmessage$ ，前两者分别在 $readyState$ 由 $CLOSING$ 变为 $CLOSED$ 时和 $readyState$ 由 $CONNECTING$ 变为 $OPEN$ 时触发。传入 $onclose$ 方法的事件包含三个属性：$wasClean$, $code$, $reason$ ，传入 $onopen$ 的是普通的事件，传入 $onerror$ 和 $onmessage$ 的事件包含一个 $data$ 属性，在前者中是错误对象，而在后者则根据消息类型转变：消息为字符串，则 $data$ 也为字符串；消息为二进制数据，并且 $WebSocket.</description>
    </item>
    
    <item>
      <title>JavaWeb（2）：Session简介</title>
      <link>https://z217blog.cn/post/javaweb2session%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 26 Mar 2020 15:41:52 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb2session%E7%AE%80%E4%BB%8B/</guid>
      <description>参考书籍：《Pro Java for Web Apps》
注：演示所用 Java 版本为 Java8 ，所用容器为 Tomcat8.5.51
 会话用于处理维持请求和请求之间的状态。在没有使用会话时，HTTP请求是无状态的，在浏览器打开第一个连接到服务器的套接字时开启，在服务器返回最后一个数据包时结束。而有些时候，我们希望保持状态，如用户登录或者在线编辑时，这时我们就要用到会话。
在Web中，会话是由服务器或Web应用程序管理的某些文件、内存片段、对象或者容器。服务器在第一次接收到请求时，会随机生成一串字符串，称为会话ID，并返回用户浏览器中。之后所有从该用户浏览器中发出的请求都需要包含该会话ID，服务器接收到会话ID后可以将会话与请求关联起来。HTTP cookie用于将会话ID发送到服务器，但是如果用户浏览器禁止了cookie，那么就需要将会话ID内嵌在URL中，很明显，这种方式使得其他人可以轻松地获得会话，因此是不安全的。不过由于如今许多网站都要求用户在访问时启用cookie，因此我们可以不用顾虑这点。
会话也是有漏洞的。但是由于描述起来篇幅过长，因此不做赘述，如果感兴趣的话可以在 Session hijacking -Wikipedia 中查看。
 大部分情况下我们可以直接使用会话，不需要添加显式配置，但是出于安全目的，我们应该进行配置。使用&amp;lt;$session-config$&amp;gt;标签进行配置，同时在&amp;lt;$session-config$&amp;gt;标签内，我们也可以使用&amp;lt;$cookie-config$&amp;gt;标签进行cookie的配置。所有在&amp;lt;$session-config$&amp;gt;标签和&amp;lt;$cookie-config$&amp;gt;标签内的标签都是可选的。下面列出了所有的可选标签：
&amp;lt;session-config&amp;gt; &amp;lt;session-timeout&amp;gt;30&amp;lt;/session-timeout&amp;gt; &amp;lt;cookie-config&amp;gt; &amp;lt;name&amp;gt;JSESSIONID&amp;lt;/name&amp;gt; &amp;lt;domain&amp;gt;example.org&amp;lt;/domain&amp;gt; &amp;lt;path&amp;gt;/path&amp;lt;/path&amp;gt; &amp;lt;comment&amp;gt;&amp;lt;! [CDATA[Keeps you logged in. See our privacy policy for more information.]]&amp;gt;&amp;lt;/comment&amp;gt; &amp;lt;http-only&amp;gt;true&amp;lt;/http-only&amp;gt; &amp;lt;secure&amp;gt;false&amp;lt;/secure&amp;gt; &amp;lt;max-age&amp;gt;180&amp;lt;/max-age&amp;gt; &amp;lt;/cookie-config&amp;gt; &amp;lt;tracking-mode&amp;gt;COOKIE&amp;lt;/tracking-mode&amp;gt; &amp;lt;tracking-mode&amp;gt;URL&amp;lt;/tracking-mode&amp;gt; &amp;lt;tracking-mode&amp;gt;SSL&amp;lt;/tracking-mode&amp;gt; &amp;lt;/session-config&amp;gt;  下面为每个标签的作用：
   标签 作用     &amp;lt;$session-timeout$&amp;gt; 会话在无效前可以保持不活跃状态的时间，以分钟为单位，为 $0$ 表示永远不过期。   &amp;lt;$tracking-mode$&amp;gt; 表示容器使用哪种技术追踪会话ID，可以配置多个值，按照配置顺序使用。URL表示容器将在URL中内嵌会话ID，COOKIE表示使用cookie，SSL表示使用SSL会话，但要求所有请求均是HTTPS请求。   &amp;lt;$name$&amp;gt; 可以自定义会话cookie的名字，通常不用设置。   &amp;lt;$domain$&amp;gt; 设置cookie的Domain特性，通常不用设置。   &amp;lt;$path$&amp;gt; 设置cookie的Path特性，通常不用设置。   &amp;lt;$comment$&amp;gt; 可以添加任意文本，用于解释cookie。   &amp;lt;$http-only$&amp;gt; 设置cookie的HttpOnly特性，为了提高安全性，一般都设置为 $true$ 。   &amp;lt;$secure$&amp;gt; 设置cookie的Secure特性，如果使用的是HTTPS，就应设置为 $true$ 。   &amp;lt;$max-age$&amp;gt; 设置cookie的Max-Age特性，控制cookie何时过期，以秒为单位，通常不用设置。     学习了如何配置会话之后，就该学习如何使用会话了。为了获取会话，我们可以调用 $HttpServletRequest.</description>
    </item>
    
    <item>
      <title>JavaWeb（1）：Servlet入门</title>
      <link>https://z217blog.cn/post/javaweb1servlet%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 14 Mar 2020 19:20:22 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/javaweb1servlet%E5%85%A5%E9%97%A8/</guid>
      <description>参考书籍：Pro Java for Web Apps
注：以下内容需要HTTP基础，演示所用Java版本为Java8，所用容器为Tomcat8.5.51
 Servlet是一个运行在Web服务器中的Java小程序，用于接收和响应来自Web客户端的请求，使用HTTP进行通信，是所有Web应用程序的核心类，也是唯一的既可以直接处理和响应用户请求，也可以将处理工作委托给应用中的其他部分的类。
Servlet只是一个简单的接口，包含了相关的方法。大多数情况下Servlet都继承自 $javax.servlet.GenericServlet$ 类，该类只包含一个抽象的 $service$ 方法以及一些辅助方法。$service$ 方法会处理所有请求，然后返回对应的响应。我们可以使用$javax.servlet.http.HttpServlet$ 类用于响应HTTP请求，它继承自 $GenericServlet$ 并实现其 $service$ 方法，而对于响应HTTP请求的方法只是空实现。在 $HttpServlet$ 类中，HTTP请求包括 $GET,HEAD,POST,PUT,DELETE,OPTIONS,TRACE$ 对应的响应方法名称为 $do +$ 首字母大写的请求名称。如 $GET$ 对应 $doGet()$ ，$POST$ 对应 $doPost()$ 等。除了响应方法之外，Servlet类中还包含 $init$ 方法和 $destroy$ 方法，分别在启用和关闭Servlet时调用，不过通常这些方法什么也不做。
 大多数情况下我们的Servlet类都是继承 $HttpServlet$ 类。对于上述提到的所有方法，它们都接收两个参数，一个是 $javax.servlet.http.HttpServletRequest$ 类型的参数，另一个是 $javax.servlet.http.HttpServletResponse$ 类型。顾名思义，$HttpServletRequest$ 指向客户端请求，对其我们有如下常用方法：
   方法 作用     $getParameter$ 返回参数的单个值   $getParameterValues$ 返回参数的值的数组   $getParameterMap$ 返回一个包含所有参数名值对的$java.util.Map&amp;lt;String, String[\ \ ]&amp;gt;$   $getParameterNames$ 返回所有可用参数的名字的枚举   $getContentLength$ 返回请求正文的长度（小于 $2$ GB）   $getContentLengthLong$ 返回请求正文的长度（大于 $2$ GB）   $getCharacterEncoding$ 返回请求内容的字符编码   $getReader$ 返回一个 $java.</description>
    </item>
    
    <item>
      <title>Dijkstra算法原理及其实现</title>
      <link>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 03 Mar 2020 17:27:28 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</guid>
      <description>参考书籍：《算法（第4版）》
 $Dijkstra$ 算法应用于带权有向图中求最短路径问题。通俗来讲就是不断选择权值最小的边加入集合直到所有顶点都在集合中，属于贪心算法。需要注意的是，$Dijkstra$ 算法只能用于解决边权非负的图类问题。
假设对于一个带权有向图 $G(V,E)$ 以邻接矩阵表示，其所有边存储在一个二维整型数组 $matrix[\ \ ][\ \ ]$ 中， $matrix[i][j]$ 表示从顶点 $i$ 到顶点 $j$ 之间的边，值为边的权值，若值为 $∞$ ，说明该边不存在。为了实现 $Dijkstra$ 算法，我们需要一个布尔值数组 $visit[\ \ ]$ ，用于判断顶点是否访问过，或者说是否在集合中；一个整型数组 $distance[\ \ ]$ 用于储存原点到每个点的最短距离。定义了基本的结构，就可以实现算法了，步骤为：
 从 $V$ 中选择一个点 $s$ 作为原点，将邻接矩阵中的 $matrix[s]$ 数组复制到 $distance[s]$ （复制后 $distance[s]$ 应为 $0$ ），建立一个 $visit[\ \ ]$ 数组并清零。 从 $V$ 中选择一个顶点 $u$ 加入集合，其中点 $u$ 满足：  之前未曾访问过点 $u$ （即 $visit[u] = false$ ）。 与 $s$ 距离最短（即 $distance[u]$ 的值最小）。   以 $u$ 为中心点，对于每个与 $u$ 相邻的顶点 $k$ ，令 $distance[k] = Min(distance[k], distance[u] + matrix[u][k])$ ，这一步也称为松弛( $relaxation$ )。 重复2、3直到所有顶点加入集合。   $Dijkstra$ 算法类似于 $Prim$ 算法，实质上都是构造了一颗树。经过以上步骤之后，我们得到了一个 $distance[\ \ ]$ 数组，其中的值为从原点 $s$ 到图中其他所有点的最短距离。在使用代码实现的过程中，有些情况下我们可以使用优先队列来简化寻找最小权值的这一过程。如果我们确认了一幅图是无环图，那么我们也可以不使用 $visit[\ \ ]$ ，而是通过拓扑排序的顺序依次遍历顶点。</description>
    </item>
    
    <item>
      <title>Leetcode题解（2）：二分搜索</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A32%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sat, 29 Feb 2020 17:23:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A32%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</guid>
      <description>原题地址: Problem 4
参考题解
 题目不用多解释，如果没有要求时间复杂度的话可以直接用双指针法遍历即可，但既然题目要求对数级的复杂度，再加上是排序数组，那么很容易就可以想到是二分法，接下来的问题就是怎么二分了。回忆下中位数的概念，中位数是一组顺序排序的数据中居于中间位置的数。也就是说，如果我们知道一组数据的中位数，我们就可以顺势以中位数为基准，将这组数据分成相同大小的两部分，其中一部分中的数总是小于（或等于）另一部分。再回到题目来，如果我们知道这两个数组的中位数，那么我们就可以将这两个数组以中位数为基准将每个数组分为两部分，如下所示：
 其中左边两部分中所有的值永远小于或等于右边两部分。这时很明显中位数为
 $$ median = \frac{max(nums1[i - 1], nums2[j - 1])\ +\ min(nums1[i] + nums2[j])}{2} $$   这样我们的目标就从找中位数变成了寻找一个 $i$ 和 $j$ ，满足如下条件（假设 $i$ 和 $j$ 总是存在）：
 $i + j = \Large\frac{nums1.length\ +\ nums2.length}{2}\normalsize;$ $nums1[i - 1] &amp;lt;= nums2[j];$ $nums2[j - 1] &amp;lt;= nums1[i].$   根据上述条件，如果我们要进行二分搜索，第一步必须先将两个数组分别二分，保证条件1为真。
if (nums1.length &amp;gt; nums2.length) return findMedianSortedArrays(nums2, nums1); int len1 = nums1.length, len2 = nums2.length, halfLen = (len1 + len2 + 1) / 2, i = len1 / 2, j = halfLen - i; }  可以发现我们在开始判断了下$nums1[\ \ ]$和$nums2[\ \ ]$的长度，确保 $nums1.</description>
    </item>
    
    <item>
      <title>Leetcode周赛：177</title>
      <link>https://z217blog.cn/post/leetcode%E5%91%A8%E8%B5%9B177/</link>
      <pubDate>Thu, 27 Feb 2020 11:18:21 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E5%91%A8%E8%B5%9B177/</guid>
      <description>第 177 场周赛
 Problem 1360: 日期之间间隔几天 Problem 1361: 验证二叉树 Problem 1362: 最接近因数 Problem 1363: 形成三的最大倍数   Problem 1360: 日期之间间隔几天
 直接调用库函数即可。
import java.time.LocalDate; import java.time.temporal.ChronoUnit; class Solution { public int daysBetweenDates(String date1, String date2) { return (int) Math.abs(LocalDate.parse(date1).until(LocalDate.parse(date2), ChronoUnit.DAYS)); } }  使用 $LocalDate$ 类及其 $until(\ )$ 方法，使用 $ChronoUnit.DAYS$ 常量表明以天为单位计算。在此要注意的是Leetcode并没有默认导入 $java.time$ 类，因此要自己导入。
 Problem 1361: 验证二叉树
 利用二叉树的性质可以知道，二叉树根节点外每个节点有且只有一个父节点，并且有且只有一个根节点。通过这个性质，我们可以遍历数组，找到所有的节点的父节点，再验证是否符合上述性质。
class Solution { public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) { int[] parent = new int[n]; //储存每个节点的父节点  Arrays.</description>
    </item>
    
    <item>
      <title>Leetcode题解：一道”难“题</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A3%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98/</link>
      <pubDate>Mon, 17 Feb 2020 17:44:43 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A3%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98/</guid>
      <description>原题地址：Problem 1332
 题目很直(mo)白(hu)，就是从一个字符串中删除回文子列直到字符串为空。但是我——没看示例，盯着题目描述和左上角的“简单”，陷入了长时间的思考，最终怀疑人生。毕竟如果你要找回文串的话就得遍历一遍得到子串，然后删除，再遍历，再循环……如此反复，时间复杂度很高，完全不是简单难度，毫无办法的我最终只能看向题解，然后在惊叹中一分钟提交了答案。
class Solution { public int removePalindromeSub(String s) { if (s.length() == 0) return 0; else if (s.equals(new StringBuilder(s).reverse().toString())) return 1; else return 2; } }  总之这道题很沙雕，沙雕之处就在于它的子序列可以不连续。所以，如果不是空串或者回文串的话，先删掉所有的 $a$ 再删掉所有的 $b$ 就行了。由于让我卡了很久，专门写了一篇博客，特此留念。</description>
    </item>
    
    <item>
      <title>Leetcode题解（1）：动态规划</title>
      <link>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A31%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Wed, 12 Feb 2020 20:42:30 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/leetcode%E9%A2%98%E8%A7%A31%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>原题地址：Problem 62
参考题解
 第一眼看到这道题就联想到了离散数学里的排列的相关知识，从而可以很容易的得出排列数为 $C(m+n-2,m-1)$ 或者 $C(m+n-2,n-1)$，可以直接利用该公式进行计算。但问题是阶乘的增长量级过大，很快就产生了溢出的问题，这时可以通过使用 $BigInteger$ 类型对象解决。
虽然问题解决了，但显然这种偏暴力方式的解法不是我们的目的，因此我们还要寻找另一种解法。通过观察题目，我们可以很明显的发现：由于只能右移或者下移，因此到达每一块方格的路径数（不包括第一行和第一列） = 到达其左边方格的路径数 + 到达其上边方格的路径数。以此规律，我们可以运用动态规划来解决该问题。
 首先先设
int[][] dp = new int[m][n];  dp数组为二维数组，储存到达每个方格的路径数。由于达到第一列和第一行中所有方格的路径数有且仅有一条，因此可以
for (int i = 0; i &amp;lt; m; i++) dp[i][0] = 1; for (int i = 1; i &amp;lt; n; i++) dp[0][i] = 1;  之后仅需双循环进行赋值即可：
for (int i = 1; i &amp;lt; m; i++) for (int j = 1; j &amp;lt; n; j++) dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  在此，无论是按行还是按列，结果都是一样的。最后 $dp[m - 1][n - 1]$ 即为答案。将上述代码合并起来即为：</description>
    </item>
    
  </channel>
</rss>
