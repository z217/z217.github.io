<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JVM on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/jvm/</link>
    <description>Recent content in JVM on z217&#39;s blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2024, z217 and the hugo authors, all rights reserved.</copyright>
    <lastBuildDate>Wed, 13 Jan 2021 21:17:10 +0800</lastBuildDate>
    <atom:link href="https://z217blog.cn/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JVM（10）：线程安全与锁优化</title>
      <link>https://z217blog.cn/post/jvm10%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</link>
      <pubDate>Wed, 13 Jan 2021 21:17:10 +0800</pubDate>
      <guid>https://z217blog.cn/post/jvm10%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;h2 id=&#34;1-线程安全&#34;&gt;1. 线程安全&lt;/h2&gt;&#xA;&lt;p&gt;        按照线程安全程度由强到弱，可以将&lt;code&gt;Java&lt;/code&gt;语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-不可变&#34;&gt;1.1 不可变&lt;/h3&gt;&#xA;&lt;p&gt;        在&lt;code&gt;Java&lt;/code&gt;语言里，不可变 ( $Immutable$ ) 对象一定是线程安全对象，因此不需要进行任何线程安全保障措施。对于基本数据类型，只需要在定义时使用 $final$ 关键字即可保证不可变。而对于对象类型，&lt;code&gt;Java&lt;/code&gt;语言目前暂时还没有提供支持，因此只能让对象自行保证行为不会影响状态，其中最简单的一种方式就是把所有带有状态的变量都声明为 $final$ 。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-绝对线程安全&#34;&gt;1.2 绝对线程安全&lt;/h3&gt;&#xA;&lt;p&gt;        绝对线程安全指的是当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果。而实际上，要想达到绝对线程安全可能需要付出非常高昂的代价。&lt;code&gt;Java API&lt;/code&gt;中标注线程安全的类，大多数都不是绝对线程安全的。例如 $java.util.Vector$ 是一个线程安全的容器，因为它的很多方法被 $synchronized$ 修饰，但是在以下情况下还是线程不安全的：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Vector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;removeThread&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Runnable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;printThread&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Runnable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;removeThread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;printThread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;        而要想做到线程安全，需要将上述代码改为如下形式：&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM（9）：内存模型与线程</title>
      <link>https://z217blog.cn/post/jvm9%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 12 Jan 2021 21:13:32 +0800</pubDate>
      <guid>https://z217blog.cn/post/jvm9%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;1-内存模型&#34;&gt;1. 内存模型&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-主内存与工作内存&#34;&gt;1.1 主内存与工作内存&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;code&gt;Java&lt;/code&gt;内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。在这里主要考虑的问题是多线程对同一块内存区域进行的操作，因此并不需要考虑一些线程私有的变量比如局部变量和方法参数。&lt;code&gt;Java&lt;/code&gt;内存模型规定了所有变量都存储在主内存 ( $Main\ \ Memory$ ) 中，每条线程允许拥有自己的工作内存 ( $Working\ \ Memory$ )，保存了主内存中要使用的变量的副本。对于引用对象，工作内存中并不会包含整个对象的副本，而是对象引用以及对象中要使用的字段的副本。通过工作内存，线程的所有的对变量的操作都会在工作内存中进行，即通过工作内存间接访问主内存。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-内存间交互&#34;&gt;1.1 内存间交互&lt;/h3&gt;&#xA;&lt;p&gt;        主内存与工作内存之间的交互协议指的是一个变量如何从主内存拷贝到工作内存，并从工作内存同步至主内存的过程。&lt;code&gt;Java&lt;/code&gt;内存模型定义了 $8$ 种原子性操作：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;$lock$ ：作用于主内存变量，将变量标识为线程独占状态；&lt;/li&gt;&#xA;&lt;li&gt;$unlock$ ：作用于主内存变量，把释放一个处于线程独占状态的变量；&lt;/li&gt;&#xA;&lt;li&gt;$read$ ：作用于主内存变量，将一个变量传输到工作内存中；&lt;/li&gt;&#xA;&lt;li&gt;$load$ ：作用于工作内存变量，将一个主内存传输的变量载入工作内存的副本中；&lt;/li&gt;&#xA;&lt;li&gt;$use$ ：作用于工作内存变量，每当虚拟机遇到一个需要使用变量的字节码指令时，将变量传递给执行引擎；&lt;/li&gt;&#xA;&lt;li&gt;$assign$ ：作用于工作内存变量，每当虚拟机遇到一个给变量赋值的字节码指令时，从执行引擎接收值并赋给变量；&lt;/li&gt;&#xA;&lt;li&gt;$store$ ：作用于工作内存变量，将一个变量传送到主内存中；&lt;/li&gt;&#xA;&lt;li&gt;$write$ ：作用于主内存变量，将一个工作内存传送的变量写入主内存的变量中。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;        如果要把一个变量从主内存拷贝到工作内存中，就需要顺序执行 $read$ 和 $load$ 操作；反过来，如果要把一个变量从工作内存拷贝到主内存中，就需要顺序执行 $store$ 和 $write$ 操作。&lt;code&gt;Java&lt;/code&gt;内存模型虽然规定了上述操作要顺序执行，但并没有要求连续执行，也就是说可以读取多个变量后再依次载入，或者存储多个变量后再依次写入。除此之外，还有其他规则：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不允许 $read$ 和 $load$ 、$store$ 和 $write$ 单独出现；&lt;/li&gt;&#xA;&lt;li&gt;不允许线程丢弃 $assign$ 操作；&lt;/li&gt;&#xA;&lt;li&gt;不允许线程在没有进行 $assign$ 操作时同步内存；&lt;/li&gt;&#xA;&lt;li&gt;不允许在工作内存中直接 $use$ 一个未被初始化的变量；&lt;/li&gt;&#xA;&lt;li&gt;一个变量在一个时刻只能被一个线程 $lock$ ，一个线程可以多次执行 $lock$ 操作，后续需要执行相应次数的 $unlock$ 才能解锁；&lt;/li&gt;&#xA;&lt;li&gt;对一个变量执行 $lock$ 操作会清除变量值，需要重新执行 $load$ 或者 $assign$ 进行赋值；&lt;/li&gt;&#xA;&lt;li&gt;不允许对一个没有被锁定的变量 $unlock$ ，也不允许 $unlock$ 其他线程独占的变量；&lt;/li&gt;&#xA;&lt;li&gt;$unlock$ 变量前需要先对其进行 $store$ 和 $write$ 。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;12-volatile&#34;&gt;1.2 &lt;code&gt;volatile&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;        $volatile$ 具有一些特殊的访问规则。当一个变量被定义为 $volatile$ 之后，它将具有两条性质：一是保证变量是所有线程可见的，即一个线程的修改可以在之后被另一个线程所发现；二是指令重排序优化会被禁止，以保证语句之间的相对执行顺序。虽然可见性使得线程间变量值的传递不再需要经过对主内存的读取和写入，但这并不意味读取到的变量值是正确的。因为 $volatile$ 允许多线程同时对变量进行写操作，这就意味着对于一些非原子性的操作，譬如&lt;code&gt;Java&lt;/code&gt;中的运算操作符（需要先将值读取到操作栈之后才能进行运算），$volatile$ 只能保证值被读取的时候是正确的，并不能保证在之后进行运算的过程中值不会发生改变。因此对于第一条性质，要保证运算结果并不依赖变量的当前值，或者只有一个线程会修改变量值。&lt;br/&gt;&#xA;        保证 $volatile$ 可见性的关键在于 $lock$ 操作，它会清空变量值，并在之后对变量进行 $store$ 和 $write$ 操作，从而保证了对变量的修改可以被其他线程发现。同时，$lock$ 操作也充当着内存屏障的功能，即执行 $lock$ 操作代表之前的操作已经执行完毕，从而可以利用 $lock$ 操作保证指令之间的相对执行顺序。也因此，$volatile$ 相比于 $synchronized$ 或者 $java.util.concurrent$ ，读操作速度没有什么差别，但是写操作会慢上一些，因为需要插入许多内存屏障以保证执行顺序，当然总体上来讲还是要快于后两者的。&lt;br/&gt;&#xA;        &lt;code&gt;Java&lt;/code&gt;内存模型也对 $volatile$ 变量定义了特殊规则，设 $V$ 和 $W$ 代表两个 $volatile$ 变量，则有：&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM（8）：后端编译与优化</title>
      <link>https://z217blog.cn/post/jvm8%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sat, 09 Jan 2021 20:58:35 +0800</pubDate>
      <guid>https://z217blog.cn/post/jvm8%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;h2 id=&#34;1-即时编译器&#34;&gt;1. 即时编译器&lt;/h2&gt;&#xA;&lt;p&gt;        目前主流的两款商用&lt;code&gt;Java&lt;/code&gt;虚拟机里，&lt;code&gt;Java&lt;/code&gt;程序最初都是通过解释器执行的。当虚拟机发现某个方法或者代码块运行频繁，就会把代码认为是热点代码 ( $Hot\ \ Spot\ \ Code$ )，并将这些代码编译为本地机器码，同时进行代码优化。完成这个任务的后端编译器就称为即时编译器。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-解释器与编译器&#34;&gt;1.1 解释器与编译器&lt;/h3&gt;&#xA;&lt;p&gt;        当程序需要迅速启动和执行时，解释器可以省去编译时间立即运行；当程序启动后，越来越多的代码会被编译成本地代码，从而减少解释器带来的中间损耗，获得更快的执行速度。如果程序运行环境中内存限制过大，可以使用解释执行从而节约内存，反之可以使用编译执行提升效率。当编译器采取的优化手段出现罕见陷阱 ( $Uncommon\ \ Trap$ ) 时，可以通过逆优化 ( $Deoptimization$ ) 退回到解释状态执行。&lt;br/&gt;&#xA;        &lt;code&gt;HotSpot&lt;/code&gt;虚拟机中内置了两个（或三个）即时编译器，其中两个存在已久的编译器分别称为客户端编译器 ( $Client\ \ Compiler$ ) 和服务端编译器 ( $Server\ \ Compiler$ )，简称为 $C1$ 编译器和 $C2$ 编译器。第三个编译器是&lt;code&gt;JDK 10&lt;/code&gt;时出现的，目标是替代 $C2$ 的 $Graal$ 编译器。&lt;br/&gt;&#xA;        在分层编译 ( $Tiered\ \ Compilation$ ) 的工作模式出现前，通常采用解释器与一个编译器直接搭配的方式工作，这时用户也可以通过 $-client$ 和 $-server$ 参数直接运行模式。解释器与编译器搭配使用的方式称为混合模式 ( $Mixed\ \ Mode$ )，也可以通过 $-Xint$ 或者 $-Xcomp$ 强制运行解释模式或者编译模式。&lt;br/&gt;&#xA;        即时编译需要占用程序运行时间，而且编译过程中还需要进行优化。要想达到好的优化效果，解释器需要替编译器收集性能监控信息。当然，这也会影响解释执行的速度。为了寻求启动响应速度与运行效率之间的平衡，&lt;code&gt;HotSpot&lt;/code&gt;虚拟机在编译子系统中加入了分层编译，包括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第 $0$ 层，程序解释执行，不开启性能监控；&lt;/li&gt;&#xA;&lt;li&gt;第 $1$ 层，使用客户端编译器，进行简单优化，不开启性能监控；&lt;/li&gt;&#xA;&lt;li&gt;第 $2$ 层，使用客户端编译器，开启方法和回边次数统计等监控；&lt;/li&gt;&#xA;&lt;li&gt;第 $3$ 层，使用客户端编译器，开启全部性能监控，除了第 $2$ 层的统计信息外，还会收集分支跳转、虚方法等统计信息；&lt;/li&gt;&#xA;&lt;li&gt;第 $4$ 层，使用服务端编译器将字节码编译为本地代码，需要更多的优化，还可能采取一些不可靠的激进优化。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;        实施分层编译后，解释器、客户端编译器、服务端编译器就会同时工作，热点代码可能会被多次编译。使用客户端编译器编译可以获得更高的编译速度，使用服务端编译器可以获得更好的编译质量。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM（7）：前端编译与优化</title>
      <link>https://z217blog.cn/post/jvm7%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
      <pubDate>Fri, 08 Jan 2021 20:09:14 +0800</pubDate>
      <guid>https://z217blog.cn/post/jvm7%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;h2 id=&#34;1-javac编译器&#34;&gt;1. &lt;code&gt;Javac&lt;/code&gt;编译器&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;code&gt;Javac&lt;/code&gt;是一个由&lt;code&gt;Java&lt;/code&gt;语言编写的程序，从其代码总体结构来看，可以将编译过程大致分为 $1$ 个准备过程和 $3$ 个处理过程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;准备过程：初始化插入式注解处理器&lt;/li&gt;&#xA;&lt;li&gt;解析与填充符号表过程，包括词法分析、语法分析和符号表创建&lt;/li&gt;&#xA;&lt;li&gt;插入式注解处理器的注解处理过程&lt;/li&gt;&#xA;&lt;li&gt;分析与字节码生成过程，包括标注检查、数据流及控制流分析、解语法糖和字节码生成&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;        在上述处理过程中，执行插入式注解时可能又会产生新的符号。如果产生新的符号，就必须对它们进行解析，因此又回到了步骤 $2$ 。&lt;code&gt;Javac&lt;/code&gt;编译动作的入口是 $com.sun.tools.javac.main.JavaCompiler$ 类，上述 $3$ 个过程的代码逻辑集中在这个类的 $compiler(\ )$ 和 $compiler2(\ )$ 方法。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-解析与填充符号表&#34;&gt;1.1 解析与填充符号表&lt;/h3&gt;&#xA;&lt;p&gt;        解析过程通过 $JavaCompiler.parseFiles(\ )$ 方法发起。&lt;/p&gt;&#xA;&lt;h4 id=&#34;111-词法语法分析&#34;&gt;1.1.1 词法、语法分析&lt;/h4&gt;&#xA;&lt;p&gt;        词法分析过程由 $com.sun.tools.javac.parser.Scanner$ 类完成。语法分析过程由 $com.sun.tools.javac.parser.Parser$ 类完成，产出的抽象语法树以 $com.sun.tools.javac.tree.JCTree$ 类表示。在完成词法、语法分析之后，编译器后续的操作都建立在抽象语法树的基础上，不会再对源码进行操作了。&lt;/p&gt;&#xA;&lt;h4 id=&#34;112-填充符号表&#34;&gt;1.1.2 填充符号表&lt;/h4&gt;&#xA;&lt;p&gt;        填充符号表过程通过 $JavaCompiler.enterTrees(\ )$ 方法发起，由 $com.sun.tools.javac.comp.Enter$ 类完成，产出一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级结点。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-注解处理器&#34;&gt;1.2 注解处理器&lt;/h3&gt;&#xA;&lt;p&gt;        在&lt;code&gt;JDK 5&lt;/code&gt;时，注解只会在程序运行期间发挥作用。&lt;code&gt;JDK 6&lt;/code&gt;中提供了一组称为“插入式注解处理器”的标准&lt;code&gt;API&lt;/code&gt;，使得特定注解的处理可以提前至编译期进行。插入式注解处理器可以读取、修改和添加抽象语法树的元素。如果在这个过程中发生了修改操作，那么编译器需要返回解析与填充符号表过程重新处理。&lt;/p&gt;&#xA;&lt;h3 id=&#34;13-语义分析与字节码生成&#34;&gt;1.3 语义分析与字节码生成&lt;/h3&gt;&#xA;&lt;p&gt;        抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义符合逻辑，因此需要进行语义分析对源程序进行上下文相关性质的检查，譬如类型检查、控制流检查、数据流检查等。&lt;/p&gt;&#xA;&lt;h4 id=&#34;131-标注检查&#34;&gt;1.3.1 标注检查&lt;/h4&gt;&#xA;&lt;p&gt;        标注检查由 $JavaCompiler.attribute(\ )$ 方法发起。标注检查步骤要检查的内容包括变量使用前是否已声明、变量与赋值之间的数据类型是否匹配等。此外还会进行常量折叠 ( $Constant\ \ Folding$ ) 。&lt;/p&gt;&#xA;&lt;h4 id=&#34;132-数据及控制流分析&#34;&gt;1.3.2 数据及控制流分析&lt;/h4&gt;&#xA;&lt;p&gt;        数据及控制流分析是对程序上下文逻辑的更进一步验证，可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有受查异常都被正确处理等。编译期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上可以看作是一致的，但有一些校验项只有在编译期或者运行期才能进行。数据及控制流分析由 $JavaCompiler.flow(\ )$ 方法发起，由 $com.sun.tools.javac.comp.Flow$ 类完成。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM（6）：字节码执行引擎</title>
      <link>https://z217blog.cn/post/jvm6%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</link>
      <pubDate>Wed, 14 Oct 2020 17:02:05 +0800</pubDate>
      <guid>https://z217blog.cn/post/jvm6%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</guid>
      <description>&lt;h2 id=&#34;1-运行时栈帧&#34;&gt;1. 运行时栈帧&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;code&gt;JVM&lt;/code&gt;以方法作为最基本的执行单元，&lt;strong&gt;栈帧&lt;/strong&gt; ( $Stack\ \ Frame$ ) 是用于支持虚拟机进行方法调用和方法执行背后的数据结构，也是虚拟机运行时数据区中的&lt;strong&gt;虚拟机栈&lt;/strong&gt; ( $Virtual\ \ Machine\ \ Stack$ ) 的栈元素，存储了方法的局部变量表、操作数栈、动态连接和方法返回地址和一些额外的附加信息，方法表的 $Code$ 属性包含了栈帧所需的局部变量表和操作数栈的大小。对于执行引擎来讲，在每个线程中，只有处于调用堆栈栈顶的方法才是正在运行的方法，称为&lt;em&gt;&lt;strong&gt;当前栈帧&lt;/strong&gt;&lt;/em&gt; ( $Current\ \ Stack\ \ Frame$ )，与这个栈帧关联的方法称为&lt;em&gt;&lt;strong&gt;当前方法&lt;/strong&gt;&lt;/em&gt; ( $Current\ \ Method$ )。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-局部变量表&#34;&gt;1.1 局部变量表&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;strong&gt;局部变量表&lt;/strong&gt; ( $Local\ \ Variable\ \ Table$ ) 是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量，其最大容量由方法 $Code$ 属性中的 $max_-locals$ 数据项决定。局部变量表以&lt;b&gt;变量槽&lt;/b&gt; ( $Variable\ \ Slot$ ) 为最小单位，每个变量槽都应该能存放一个 $boolean$ 、$byte$ 、$char$ 、$short$ 、$int$ 、$float$ 、$reference$ 或 $returnAddress$ 类型的数据。这些数据长度一般都为 $32$ 位 ( $reference$ 可能为 $64$ 位 )，也意味着变量槽的长度至少为 $32$ 位。而对于 $64$ 位的数据类型，比如 $long$ 和 $double$ ，会通过高位对齐的方式分配两个连续的变量槽。&lt;br&gt;&#xA;        &lt;code&gt;JVM&lt;/code&gt;通过索引定位的方式使用局部变量表。对于 $32$ 位数据类型的变量，使用一个索引值；对于 $64$ 位数据类型的变量，使用相邻的两个索引值。当方法被调用时，&lt;code&gt;JVM&lt;/code&gt;使用局部变量表将参数值传递到参数变量列表，即从实参到形参。如果方法为实例方法，那么局部变量表第 $0$ 位索引的变量槽默认为传递方法所属对象实例的引用。在参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。因为方法中定义的变量的作用域不一定会覆盖整个方法体，因此变量槽是可以重用的。&lt;br&gt;&#xA;        局部变量槽会影响系统的垃圾收集行为，可以观察以下三种情况：&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM（5）：类加载</title>
      <link>https://z217blog.cn/post/jvm5%E7%B1%BB%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Tue, 22 Sep 2020 22:20:52 +0800</pubDate>
      <guid>https://z217blog.cn/post/jvm5%E7%B1%BB%E5%8A%A0%E8%BD%BD/</guid>
      <description>&lt;h2 id=&#34;1-类加载的时机&#34;&gt;1. 类加载的时机&lt;/h2&gt;&#xA;&lt;p&gt;        一个类型从被加载到卸载的过程中，会经历&lt;strong&gt;加载&lt;/strong&gt; ( $Loading$ )、&lt;strong&gt;验证&lt;/strong&gt; ( $Verification$ )、&lt;strong&gt;准备&lt;/strong&gt; ( $Preparation$ )、&lt;strong&gt;解析&lt;/strong&gt; ( $Resolution$ )、&lt;strong&gt;初始化&lt;/strong&gt; ( $Initialization$ )、&lt;strong&gt;使用&lt;/strong&gt; ( $Using$ ) 和&lt;strong&gt;卸载&lt;/strong&gt; ( $Unloading$ ) 七个阶段，其中可以把验证、准备、解析统称为&lt;strong&gt;连接&lt;/strong&gt; ( $Linking$ )。这些阶段之间可以交叉进行。加载、验证、准备、初始化、卸载的顺序是确定的，解析阶段则不一定，可能开始在初始化之后。&lt;br&gt;&#xA;        《&lt;code&gt;Java&lt;/code&gt;虚拟机规范》中并没有规定什么时候需要进行加载，但是严格规定了有且只有六种情况需要进行初始化：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;执行 $new$ 、$getstatic$ 、$putstatic$ 、$invokestatic$ 四条字节码指令时，如果类型没有初始化，需要先进行初始化阶段。这四条字节码指令分别对应：使用 $new$ 创建对象实例、读取和设置静态字段 ( $final$ 字段除外，因为它在编译器就已被置入常量池 )、调用静态方法；&lt;/li&gt;&#xA;&lt;li&gt;对类型进行反射调用时，如果类型没有初始化，需要先进行初始化阶段；&lt;/li&gt;&#xA;&lt;li&gt;初始化类时如果父类没有初始化，需要先初始化父类；&lt;/li&gt;&#xA;&lt;li&gt;虚拟机启动时，主类需要先进行初始化；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;JDK 7&lt;/code&gt;之后，如果一个 $java.lang.invoke.MethodHandle$ 实例的解析结果为 $REF_-getStatic$ 、$REF_-putStatic$ 、$REF_-newInvokeSpecial$ 四种类型的方法句柄时，如果该方法句柄对应的类没有初始化，需要先进行初始化阶段；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;JDK 8&lt;/code&gt;之后，接口中包含 $default$ 方法时，在其实现类发生初始化前，需要先进行接口的初始化阶段。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        这六种情况触发初始化场景的行为称为主动引用，除此之外的引用称为被动引用。例如通过子类访问父类的静态字段并不会触发子类的初始化，只会触发父类的初始化；声明一个引用数组并不会触发引用类型的初始化，而是初始化一个数组类型。&lt;br&gt;&#xA;        与类相同，接口也具有初始化过程。虽然接口中不能使用静态代码块，但是编译器仍然会生成 &amp;lt;$clinit$&amp;gt;$(\ )$ 类构造器，用于初始化成员变量。在前面的六种主动引用触发场景中，只有在初始化父类时才会对接口进行初始化。但是一个接口在初始化时，并不要求其父接口全部初始化，只有在用到时才需要进行初始化。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-类加载的过程&#34;&gt;2. 类加载的过程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-加载&#34;&gt;2.1 加载&lt;/h3&gt;&#xA;&lt;p&gt;        类加载过程，虚拟机需要完成以下三件事：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过类的全限定名获取二进制字节流；&lt;/li&gt;&#xA;&lt;li&gt;将字节流所代表的静态存储结构转为方法区的运行时数据结构；&lt;/li&gt;&#xA;&lt;li&gt;在内存中生成一个代表这个类的 $java.lang.Class$ 对象，作为方法区中该类各种数据的访问入口。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        由于没有限制获取字节流的位置，因此可以从许多地方以许多方式获取，例如从&lt;code&gt;Jar&lt;/code&gt;包、&lt;code&gt;War&lt;/code&gt;包获取，从&lt;code&gt;JSP&lt;/code&gt;文件获取、从数据库中读取等。相较于其他阶段，非数组类型的类加载的可控性很强，可以通过自定义的类加载器完成。数组类的加载十分特殊，它并不依赖类加载器，而是由&lt;code&gt;JVM&lt;/code&gt;在内存中直接构造。但是数组类仍然与类加载器有着密切关系，因为其元素类型仍然需要依赖类加载完成加载。一个数组类的创建规则如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM（4）：Class文件结构</title>
      <link>https://z217blog.cn/post/jvm4class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 17 Sep 2020 22:58:37 +0800</pubDate>
      <guid>https://z217blog.cn/post/jvm4class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;h2 id=&#34;1-平台无关性&#34;&gt;1. 平台无关性&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;code&gt;Java&lt;/code&gt;在刚刚诞生时就有一句非常著名的口号：一次编写，到处运行。这个想法通过虚拟机实现，这些虚拟机都可以执行同一种与平台无关的字节码，从而达到一次编写，到处运行。可以说，字节码就是平台无关性的基石。&lt;code&gt;Java&lt;/code&gt;虚拟机并不与&lt;code&gt;Java&lt;/code&gt;语言绑定，在其之上还可以运行许多其他语言，如&lt;code&gt;Kotlin&lt;/code&gt;、&lt;code&gt;Groovy&lt;/code&gt;和&lt;code&gt;Scala&lt;/code&gt;等。&lt;code&gt;Java&lt;/code&gt;虚拟机唯一绑定的是类似于&lt;code&gt;Class&lt;/code&gt;文件这种特殊的二进制文件，其中包含了&lt;code&gt;Java&lt;/code&gt;虚拟机的指令集、符号表以及其他辅助信息。通过&lt;code&gt;Class&lt;/code&gt;文件，&lt;code&gt;Java&lt;/code&gt;虚拟机并不需要关心来源是什么语言，只要这门语言能够生成可以被读取的&lt;code&gt;Class&lt;/code&gt;文件，那么它就可以在&lt;code&gt;Java&lt;/code&gt;虚拟机上运行。&lt;br&gt;&#xA;        &lt;code&gt;Java&lt;/code&gt;语言中的各种语法、关键字、常量变量和运算符号的语义最终都会转成字节码指令的组合，这就要求字节码指令的表达能力必须比&lt;code&gt;Java&lt;/code&gt;语言的表达能力更强。从而，一些&lt;code&gt;Java&lt;/code&gt;语言中并不支持的特性，字节码也能够表达出来。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-class类文件&#34;&gt;2. &lt;code&gt;Class&lt;/code&gt;类文件&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;code&gt;Class&lt;/code&gt;文件是一组以 $8$ 个字节为单位的二进制流，数据项目按照顺序紧凑地排列在文件之中。对于 $8$ 字节以上空间的数据项，会按照高位在前的大端序分割存储在若干个 $8$ 字节中。&lt;br&gt;&#xA;        &lt;code&gt;Class&lt;/code&gt;文件采取一种类似于&lt;code&gt;C&lt;/code&gt;语言结构体的伪结构来存储数据，包含两种数据类型：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无符号数：即基本数据类型，通过 $u1$ 、$u2$ 、$u3$ 、$u4$ 分别表示 $1$ 个字节、$2$ 个字节、$4$ 个字节和 $8$ 个字节的无符号数，用于表示数字、索引引用、数量值或者&lt;code&gt;UTF-8&lt;/code&gt;编码的字符串；&lt;/li&gt;&#xA;&lt;li&gt;表：由多个无符号数或者其他表构成的复合数据类型，一般以 $_-info$ 结尾，用于表示具有层次关系的数据。可以把整个&lt;code&gt;Class&lt;/code&gt;文件都视为表，按照对应类型的数据紧凑排列而成。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        当需要描述类型相同但数量不定的数据时，经常会使用一个前置的容器计数器加若干个连续的数据项的形式，称为该类型的集合。&lt;/p&gt;&#xA;&lt;h3 id=&#34;21-魔数和版本号&#34;&gt;2.1 魔数和版本号&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;code&gt;Class&lt;/code&gt;文件的头 $4$ 字节称为&lt;strong&gt;魔数&lt;/strong&gt; ( $Magic\ \ Number$ )，用于确定该文件能否被虚拟机接受。魔数在很多文件格式中都存在，文件格式制定者可以自定义魔数，只要不会引起混淆。&lt;code&gt;Class&lt;/code&gt;文件的魔数为 $0xCAFEBABE$ ，象征着一款咖啡。&lt;br&gt;&#xA;        在魔数之后是&lt;code&gt;Class&lt;/code&gt;文件的版本号，前两个字节是&lt;strong&gt;次版本号&lt;/strong&gt; ( $Minor\ \ Version$ )，后两个字节是&lt;strong&gt;主版本号&lt;/strong&gt; ( $Major\ \ Version$ )。&lt;code&gt;Java&lt;/code&gt;主版本号从 $45$ 开始，&lt;code&gt;JDK 1.1&lt;/code&gt;之后每个大版本都会在之前的基础上加 $1$ 。次版本号在&lt;code&gt;JDK 1.1&lt;/code&gt;及以前曾经短暂使用过，在&lt;code&gt;JDK 1.2&lt;/code&gt;之后废弃，全部使用 $0$ 代替，直到&lt;code&gt;JDK 12&lt;/code&gt;，由于一些复杂特性需要进行公测，于是重新启用了次版本号。&lt;/p&gt;&#xA;&lt;h3 id=&#34;22-常量池&#34;&gt;2.2 常量池&lt;/h3&gt;&#xA;&lt;p&gt;        常量池是&lt;code&gt;Class&lt;/code&gt;文件中第一次出现表的数据项目，也是与其他项目关联最多的数据，通常也是最庞大的数据项目之一。常量池入口是一个 $u2$ 类型的数据，是&lt;em&gt;&lt;strong&gt;常量池容量计数值&lt;/strong&gt;&lt;/em&gt; ( $constant_-pool_-count$ )，从 $1$ 开始，$0$ 表示不指向常量池中的数据项目。&lt;code&gt;Class&lt;/code&gt;文件中只有常量池的容量计数是从 $1$ 开始的。&lt;br&gt;&#xA;        常量池中主要存放字面量 ( $Literal$ ) 和符号引用 ( $Symbolic\ \ References$ )。字面量类似于&lt;code&gt;Java&lt;/code&gt;中的常量，存放字符串、$final$ 常量等。符号引用则属于编译原理方面的概念，包括：&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM（3）：性能监控和故障处理</title>
      <link>https://z217blog.cn/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 25 Aug 2020 20:11:27 +0800</pubDate>
      <guid>https://z217blog.cn/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/</guid>
      <description>&lt;h2 id=&#34;1-基础故障处理工具&#34;&gt;1. 基础故障处理工具&lt;/h2&gt;&#xA;&lt;p&gt;        基础故障处理工具是&lt;code&gt;JDK&lt;/code&gt;自带的一些位于 $/bin$ 目录下的小工具。这些工具主要用于监视虚拟机运行状态和进行故障处理，根据软件可用性和授权的不同，可以分为三类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;商业授权工具&lt;/strong&gt;：主要是&lt;code&gt;JMC&lt;/code&gt; ( $Java\ \ Mission\ \ Control$ ) 及其使用的&lt;code&gt;JFR&lt;/code&gt; ( $Java\ \ Flight\ \ Recorder$ )。自&lt;code&gt;JDK 7&lt;/code&gt;开始集成，在&lt;code&gt;JDK 11&lt;/code&gt;前都无需独立下载，但是商业使用需要收费。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;正式支持工具&lt;/strong&gt;：长期支持的工具，可能在不同平台和版本之间存在差异。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;实验性工具&lt;/strong&gt;：没有技术支持，具有实验性质的工具，但通常很稳定且具有强大功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;11-jps虚拟机进程状况工具&#34;&gt;1.1 &lt;code&gt;jps&lt;/code&gt;：虚拟机进程状况工具&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;code&gt;jps&lt;/code&gt; ( $JVM\ \ Process\ \ Status\ \ Tool$ ) 的名字类似于&lt;code&gt;UNIX&lt;/code&gt;系统中的 $ps$ 命令，功能也和其类似：列出正在运行的虚拟机进程，并显示主类名称和&lt;em&gt;&lt;strong&gt;本地虚拟机唯一&lt;/strong&gt;&lt;/em&gt;&lt;code&gt;ID&lt;/code&gt; ( $Local\ \ Virtual\ \ Machine\ \ Identifier$, $LVMID$ )。作为使用频率最高的&lt;code&gt;JDK&lt;/code&gt;命令行工具，是其他工具查询进程的方法。对于本地虚拟机进程来说，&lt;code&gt;LVMID&lt;/code&gt;与操作系统进程&lt;code&gt;ID&lt;/code&gt; ( $Process\ \ Identifier$, $PID$ ) 是一致的，使用&lt;code&gt;Windows&lt;/code&gt;任务管理器也可以查询到。但是如果存在多个虚拟机进程，使得无法通过进程定位时，&lt;code&gt;jps&lt;/code&gt;命令显示的主类信息就可以帮助我们定位。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;jps [options] [hostid]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;$options$&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;作用&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$-q$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;输出&lt;code&gt;LVMID&lt;/code&gt;，省略主类信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$-m$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;输出主类 $main$ 函数参数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$-l$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;输出主类全名，如果为&lt;code&gt;JAR&lt;/code&gt;包则输出路径&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$-v$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;输出&lt;code&gt;JVM&lt;/code&gt;参数&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;        $hostid$ 为&lt;code&gt;RMI&lt;/code&gt;注册表中注册的主机名，&lt;code&gt;jps&lt;/code&gt;可以通过&lt;code&gt;RMI&lt;/code&gt;协议查询开启&lt;code&gt;RMI&lt;/code&gt;服务的远程虚拟机进程状态。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM（2）：垃圾收集器</title>
      <link>https://z217blog.cn/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</link>
      <pubDate>Sun, 23 Aug 2020 16:33:41 +0800</pubDate>
      <guid>https://z217blog.cn/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</guid>
      <description>&lt;p&gt;        相比于程序计数器、虚拟机栈和本地方法栈这种应分配的内存大小在类确定时就已固定下来的内存区域，&lt;code&gt;Java&lt;/code&gt;堆和方法区这两个区域有着不确定性：一个接口可能有多个实现类，一个方法可能有多个分支。垃圾收集器所关注的也就是这部分不确定的内存。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-对象状态&#34;&gt;1. 对象状态&lt;/h2&gt;&#xA;&lt;p&gt;        在进行垃圾收集之前，垃圾收集器需要对对象的状态进行判断，即判断其是否仍在被使用。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-引用计数算法&#34;&gt;1.1 引用计数算法&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;strong&gt;引用计数&lt;/strong&gt; ( $Reference\ \ Counting$ ) 算法，可以简单的解释为在对象中添加一个引用计数器，当对象被引用时计数器便加一，反之减一。如此往复，当对象的引用计数器为零时，可以认为其不再被使用。虽然这种算法简单而且效率很高，但是因为存在着很多例外情况，因此不被主流的&lt;code&gt;JVM&lt;/code&gt;所采纳。比较简单的例子就比如存在对象 $A$ 和 $B$ ，它们都存在着一个字段互相引用对方，这样它们的引用计数器就都为 $1$ 。但实际上，除了互相引用之外，它们没有被其他对象引用，可以认为是无用的对象，应该被垃圾收集。另一方面，它们的引用计数又不为 $0$ ，无法触发垃圾收集。因此，引用计数算法需要配合大量额外处理才能保证正常工作。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-可达性分析算法&#34;&gt;1.2 可达性分析算法&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;strong&gt;可达性分析&lt;/strong&gt; ( $Reachability\ \ Analysis$ ) 算法，基本思路就是通过一系列的称为&lt;code&gt;GC Roots&lt;/code&gt;的根对象出发，不断搜索引用关系，搜索路径称为&lt;em&gt;&lt;strong&gt;引用链&lt;/strong&gt;&lt;/em&gt; ( $Reference\ \ Chain$ )。当一个对象没有被搜索到，或者称不可达时，就认为这个对象不再被使用。在&lt;code&gt;Java&lt;/code&gt;技术体系里固定可作为&lt;code&gt;GC Roots&lt;/code&gt;的对象包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;虚拟机栈中的引用对象&lt;/li&gt;&#xA;&lt;li&gt;方法区中类静态属性的引用对象&lt;/li&gt;&#xA;&lt;li&gt;方法区中常量引用对象&lt;/li&gt;&#xA;&lt;li&gt;本地方法栈中&lt;code&gt;JNI&lt;/code&gt; ( 即 $Native$ 方法 ) 的引用对象&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt;内部引用，如基本数据类型对应的 $Class$ 对象，一些常驻的异常对象等，还有系统类加载器&lt;/li&gt;&#xA;&lt;li&gt;同步锁 ( $synchronized$ 关键字 ) 持有的对象&lt;/li&gt;&#xA;&lt;li&gt;反应&lt;code&gt;JVM&lt;/code&gt;内部情况的&lt;code&gt;JMXBean&lt;/code&gt;、&lt;code&gt;JVMTI&lt;/code&gt;中注册的回调、本地代码缓存等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        除此之外，根据用户选择的垃圾收集器以及当前收集的内存区域，还会有临时对象的加入。譬如要针对某个特定区域进行垃圾收集时，不仅要加入该区域的，还要加入关联区域的其他对象。虽然现在查找引用链的过程已经可以做到并发，但迄今为止，所有收集器在根节点枚举这一步骤都要暂停用户线程。&lt;/p&gt;&#xA;&lt;h3 id=&#34;13-对象引用&#34;&gt;1.3 对象引用&lt;/h3&gt;&#xA;&lt;p&gt;        在&lt;code&gt;JDK 1.2&lt;/code&gt;之前，&lt;code&gt;Java&lt;/code&gt;对应用的定义为：如果 $reference$ 类型的数据中存储的数值代表的是另一块内存的起始地址，就称其代表某块内存或某块对象的引用。而在&lt;code&gt;JDK 1.2&lt;/code&gt;之后，&lt;code&gt;Java&lt;/code&gt;扩充了引用的概念，分为 $4$ 种引用强度：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;强引用&lt;/strong&gt; ( $Strong\ \ Reference$ )：强引用是最传统的引用方式，即指引用赋值。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;软引用&lt;/strong&gt; ( $Soft\ \ Reference$ )：软引用指一些有用但非必须的对象。当系统将发生内存溢出时，软引用对象会被回收。&lt;code&gt;JDK 1.2&lt;/code&gt;之后提供了 $SoftReference$ 类实现软引用。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;弱引用&lt;/strong&gt; ( $Weak\ \ Reference$ )：弱引用指非必须对象，但强度比软引用更弱。无论内存是否足够，都会被回收。&lt;code&gt;JDK 1.2&lt;/code&gt;之后提供了 $WeakReference$ 类实现弱引用。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;虚引用&lt;/strong&gt; ( $Phantom\ \ Reference$ )：虚引用是最弱的引用关系，不会对对象生命周期造成影响，也不能通过虚引用取得对象实例。关联虚引用只是为了在对象被回收之前获得系统通知。&lt;code&gt;JDK 1.2&lt;/code&gt;之后提供了 $PhantomReference$ 类实现虚引用。虚引用需要与 $ReferenceQueue$ 联合使用，当垃圾收集器发现对象存在虚引用时，就会在回收前将虚引用加到与之关联的引用队列中。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;14-对象死亡&#34;&gt;1.4 对象死亡&lt;/h3&gt;&#xA;&lt;p&gt;        一个对象的死亡至少需要经历两次标记过程：第一次为可达性分析，第二次为筛选，筛选覆盖了 $finalize(\ )$ 方法或者执行过 $finalize(\ )$ 方法的对象。如果 $finalize(\ )$ 方法未被覆盖或者未被执行，那么对象会进入 $F-Queue$ 队列，并在之后由一条自动建立的低优先级的 $Finalizer$ 线程执行其 $finalize(\ )$ 方法。稍后收集器会检查队列中的对象，如果对象在 $finalize(\ )$ 方法中建立了与其他对象的关联，那么它就会被移出队列。需要注意的是，为了避免长时间等待或者进入死循环，收集器并不会等待对象的 $finalize(\ )$ 方法执行完毕，而且一个对象的 $finalize(\ )$ 方法只能调用一次，因此有可能在下次对象回收时该对象不能再次自救。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JVM（1）：技术体系与内存区域</title>
      <link>https://z217blog.cn/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Wed, 19 Aug 2020 19:42:28 +0800</pubDate>
      <guid>https://z217blog.cn/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid>
      <description>&lt;h2 id=&#34;1-java技术体系&#34;&gt;1. &lt;code&gt;Java&lt;/code&gt;技术体系&lt;/h2&gt;&#xA;&lt;p&gt;        从广义上来讲，&lt;code&gt;Kotlin&lt;/code&gt;、&lt;code&gt;Clojure&lt;/code&gt;、&lt;code&gt;JRuby&lt;/code&gt;、&lt;code&gt;Groovy&lt;/code&gt;等运行于&lt;code&gt;Java&lt;/code&gt;虚拟机上的编程语言及其相关的程序都属于&lt;code&gt;Java&lt;/code&gt;技术体系中的一员。从传统意义上来看，&lt;code&gt;JCP&lt;/code&gt;官方所定义的&lt;code&gt;Java&lt;/code&gt;技术体系包括以下几个部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Java&lt;/code&gt;程序设计语言&lt;/li&gt;&#xA;&lt;li&gt;各种硬件平台上的&lt;code&gt;Java&lt;/code&gt;虚拟机实现&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Class&lt;/code&gt;文件格式&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Java&lt;/code&gt;类库&lt;code&gt;API&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;来自商业机构和开源社区的第三方&lt;code&gt;Java&lt;/code&gt;类库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        我们可以把&lt;code&gt;Java&lt;/code&gt;程序设计语言、&lt;code&gt;Java&lt;/code&gt;虚拟机、&lt;code&gt;Java&lt;/code&gt;类库这三部分统称为&lt;code&gt;JDK&lt;/code&gt; ( $Java\ \ Development\ \ Kit$ ) ，&lt;code&gt;JDK&lt;/code&gt;是用于支持&lt;code&gt;Java&lt;/code&gt;程序开发的最小环境。可以把&lt;code&gt;Java&lt;/code&gt;类库&lt;code&gt;API&lt;/code&gt;中的&lt;code&gt;Java SE API&lt;/code&gt;子集和&lt;code&gt;Java&lt;/code&gt;虚拟机这两部分统称为&lt;code&gt;JRE&lt;/code&gt; ( $Java\ \ Runtime\ \ Environment$ )，&lt;code&gt;JRE&lt;/code&gt;是支持&lt;code&gt;Java&lt;/code&gt;程序运行的标准环境。&lt;br&gt;&#xA;        以上是按照&lt;code&gt;Java&lt;/code&gt;组成部分来进行划分，如果按照技术领域来划分，则可以分为以下四条：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Java Card&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Java ME&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Java SE&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Java EE&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-自动内存管理&#34;&gt;2. 自动内存管理&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;code&gt;JVM&lt;/code&gt;在执行&lt;code&gt;Java&lt;/code&gt;程序的过程中会将内存划分为若干个不同的数据区域。&lt;/p&gt;&#xA;&lt;h3 id=&#34;21-程序计数器&#34;&gt;2.1 程序计数器&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;strong&gt;程序计数器&lt;/strong&gt; ( $Program\ \ Counter\ \ Register$ ) 是一块比较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。程序的分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器。在&lt;code&gt;JVM&lt;/code&gt;中，一个处理器只会处理一个线程，多线程通过轮流切换来实现，因此每个线程都会有一个程序计数器。对于每个线程之间独立存储的内存，我们称之为“线程私有”内存。&lt;br&gt;&#xA;        &lt;code&gt;Java&lt;/code&gt;中存在 $native$ 关键字，用于指示本地方法。通过 $native$ 关键字，&lt;code&gt;Java&lt;/code&gt;程序可以调用本地应用（或库），也可以被其他程序调用。对于本地方法，在执行过程中，程序计数器的值为空 ( $Undefined$ )。而对于&lt;code&gt;Java&lt;/code&gt;方法 ( 也就是字节码 ) ，程序计数器的值为正在执行的虚拟机字节码的指令地址。&lt;/p&gt;&#xA;&lt;h3 id=&#34;22-java虚拟机栈&#34;&gt;2.2 &lt;code&gt;Java&lt;/code&gt;虚拟机栈&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;code&gt;Java&lt;/code&gt;&lt;strong&gt;虚拟机栈&lt;/strong&gt; ( $Java\ \ Virtual\ \ Machine\ \ Stack$ ) 描述的是&lt;code&gt;Java&lt;/code&gt;方法执行的线程内存模型。与程序计数器一样，它也是线程私有的。在每个方法被执行时，&lt;code&gt;JVM&lt;/code&gt;都会同步创建一个&lt;strong&gt;栈帧&lt;/strong&gt; ( $Stack\ \ Frame$ ) 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。在方法被调用时，这个栈帧会被压入&lt;code&gt;Java&lt;/code&gt;虚拟机栈。当方法执行完毕时，其对应的栈帧也会被从&lt;code&gt;Java&lt;/code&gt;虚拟机栈中弹出。如果将&lt;code&gt;Java&lt;/code&gt;的内存区域像&lt;code&gt;C&lt;/code&gt;/&lt;code&gt;C++&lt;/code&gt;那样简单地划分为&lt;em&gt;&lt;strong&gt;堆内存&lt;/strong&gt;&lt;/em&gt; ( $Heap$ ) 和&lt;em&gt;&lt;strong&gt;栈内存&lt;/strong&gt;&lt;/em&gt; ( $Stack$ )，那么这里的虚拟机栈就可以视为栈内存。&lt;br&gt;&#xA;        局部变量表中存储基本数据类型、对象引用以及 $returnAddress$ 类型 ( 指向一条字节码指令的地址 )。这些数据类型在局部变量表中以局部变量槽 ( $Slot$ ) 表示。对于 $64$ 位长度的 $long$ 和 $double$ 类型，它们将会占用两个槽。其余数据类型只占用一个。局部变量表的大小是在进入方法时就已确定的，不会随着运行而改变。&lt;br&gt;&#xA;        当线程请求的栈深度大于虚拟机允许的深度时就会抛出 $StackOverflowError$ 异常。&lt;code&gt;Java&lt;/code&gt;虚拟机栈的容量允许动态扩展。如果在扩展时无法申请到足够内存，那么就会抛出 $OutOfMemoryError$ 异常。&lt;/p&gt;</description>
    </item>
    <item>
      <title>从零开始的JDK编译</title>
      <link>https://z217blog.cn/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84jdk%E7%BC%96%E8%AF%91/</link>
      <pubDate>Wed, 19 Aug 2020 05:40:45 +0800</pubDate>
      <guid>https://z217blog.cn/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84jdk%E7%BC%96%E8%AF%91/</guid>
      <description>&lt;p&gt;        首先从获取&lt;code&gt;JDK&lt;/code&gt;源码开始。以&lt;code&gt;OpenJDK&lt;/code&gt;为例，点击 &lt;a href=&#34;https://hg.openjdk.java.net/jdk/&#34;&gt;OpenJDK&lt;/a&gt; 进入，选择对应的&lt;code&gt;JDK&lt;/code&gt;版本，在此以&lt;code&gt;JDK12&lt;/code&gt;为例，选择 $jdk12$ 。进入后在左侧选择 $browse$ ，然后再选择 $zip$ 即可下载。源码下载完毕之后解压，可以在解压后的文件目录下的 $/doc/building.html$ 中阅读编译文档。&lt;br&gt;&#xA;        源码下载完毕之后开始准备&lt;code&gt;Linux&lt;/code&gt;环境，要注意在&lt;code&gt;Linux&lt;/code&gt;环境中，文件夹请尽量使用英文名，名称中不要出现空格。我使用的是&lt;code&gt;WSL Ubuntu&lt;/code&gt;，在刚开始使用时要记得切换镜像源。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;vi /etc/apt/sources.list&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;        使用 $vi$ 打开配置文件，然后替换为镜像源，在此我使用的是阿里云的镜像源，$sources.list$ 文件内容如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;        替换完毕后执行更新命令：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
