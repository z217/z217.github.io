<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JVM on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/jvm/</link>
    <description>Recent content in JVM on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Sun, 23 Aug 2020 16:33:41 +0800</lastBuildDate>
    
	<atom:link href="https://z217blog.cn/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JVM（2）：垃圾收集器</title>
      <link>https://z217blog.cn/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</link>
      <pubDate>Sun, 23 Aug 2020 16:33:41 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</guid>
      <description>相比于程序计数器、虚拟机栈和本地方法栈这种应分配的内存大小在类确定时就已固定下来的内存区域，Java堆和方法区这两个区域有着不确定性：一个接口可能有多个实现类，一个方法可能有多个分支。垃圾收集器所关注的也就是这部分不确定的内存。
1. 对象状态  在进行垃圾收集之前，垃圾收集器需要对对象的状态进行判断，即判断其是否仍在被使用。
1.1 引用计数算法  引用计数 ( $Reference\ \ Counting$ ) 算法，可以简单的解释为在对象中添加一个引用计数器，当对象被引用时计数器便加一，反之减一。如此往复，当对象的引用计数器为零时，可以认为其不再被使用。虽然这种算法简单而且效率很高，但是因为存在着很多例外情况，因此不被主流的JVM所采纳。比较简单的例子就比如存在对象 $A$ 和 $B$ ，它们都存在着一个字段互相引用对方，这样它们的引用计数器就都为 $1$ 。但实际上，除了互相引用之外，它们没有被其他对象引用，可以认为是无用的对象，应该被垃圾收集。另一方面，它们的引用计数又不为 $0$ ，无法触发垃圾收集。因此，引用计数算法需要配合大量额外处理才能保证正常工作。
1.2 可达性分析算法  可达性分析 ( $Reachability\ \ Analysis$ ) 算法，基本思路就是通过一系列的称为GC Roots的跟对象出发，不断搜索引用关系，搜索路径称为引用链 ( $Reference\ \ Chain$ )。当一个对象没有被搜索到，或者称不可达时，就认为这个对象不再被使用。在Java技术体系里固定可作为GC Roots的对象包括：
 虚拟机栈中的引用对象 方法区中类静态属性的引用对象 方法区中常量引用对象 本地方法栈中JNI ( 即 $Native$ 方法 ) 的引用对象 JVM内部引用，如基本数据类型对应的 $Class$ 对象，一些常驻的异常对象等，还有系统类加载器 同步锁 ( $synchronized$ 关键字 ) 持有的对象 反应JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等   除此之外，根据用户选择的垃圾收集器以及当前收集的内存区域，还会有临时对象的加入。譬如要针对某个特定区域进行垃圾收集时，不仅要加入该区域的，还要加入关联区域的其他对象。虽然现在查找引用链的过程已经可以做到并发，但迄今为止，所有收集器在根节点枚举这一步骤都要暂停用户线程。
1.3 对象引用  在JDK 1.2之前，Java对应用的定义为：如果 $reference$ 类型的数据中存储的数值代表的是另一块内存的起始地址，就称其代表某块内存或某块对象的引用。而在JDK 1.</description>
    </item>
    
    <item>
      <title>JVM（1）：技术体系与内存区域</title>
      <link>https://z217blog.cn/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Wed, 19 Aug 2020 19:42:28 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid>
      <description>1. Java技术体系  从广义上来讲，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序都属于Java技术体系中的一员。从传统意义上来看，JCP官方所定义的Java技术体系包括以下几个部分：
 Java程序设计语言 各种硬件平台上的Java虚拟机实现 Class文件格式 Java类库API 来自商业机构和开源社区的第三方Java类库   我们可以把Java程序设计语言、Java虚拟机、Java类库这三部分统称为JDK ( $Java\ \ Development\ \ Kit$ ) ，JDK是用于支持Java程序开发的最小环境。可以把Java类库API中的Java SE API子集和Java虚拟机这两部分统称为JRE ( $Java\ \ Runtime\ \ Environment$ )，JRE是支持Java程序运行的标准环境。
以上是按照Java组成部分来进行划分，如果按照技术领域来划分，则可以分为以下四条：
 Java Card Java ME Java SE Java EE  2. 自动内存管理  JVM在执行Java程序的过程中会将内存划分为若干个不同的数据区域。
2.1 程序计数器  程序计数器 ( $Program\ \ Counter\ \ Register$ ) 是一块比较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。程序的分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器。在JVM中，一个处理器只会处理一个线程，多线程通过轮流切换来实现，因此每个线程都会有一个程序计数器。对于每个线程之间独立存储的内存，我们称之为“线程私有”内存。
Java中存在 $native$ 关键字，用于指示本地方法。通过 $native$ 关键字，Java程序可以调用本地应用（或库），也可以被其他程序调用。对于本地方法，在执行过程中，程序计数器的值为空 ( $Undefined$ )。而对于Java方法 ( 也就是字节码 ) ，程序计数器的值为正在执行的虚拟机字节码的指令地址。
2.2 Java虚拟机栈  Java虚拟机栈 ( $Java\ \ Virtual\ \ Machine\ \ Stack$ ) 描述的是Java方法执行的线程内存模型。与程序计数器一样，它也是线程私有的。在每个方法被执行时，JVM都会同步创建一个栈帧 ( $Stack\ \ Frame$ ) 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。在方法被调用时，这个栈帧会被压入Java虚拟机栈。当方法执行完毕时，其对应的栈帧也会被从Java虚拟机栈中弹出。如果将Java的内存区域像C/C++那样简单地划分为堆内存 ( $Heap$ ) 和栈内存 ( $Stack$ )，那么这里的虚拟机栈就可以视为栈内存。</description>
    </item>
    
    <item>
      <title>从零开始的JDK编译</title>
      <link>https://z217blog.cn/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84jdk%E7%BC%96%E8%AF%91/</link>
      <pubDate>Wed, 19 Aug 2020 05:40:45 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84jdk%E7%BC%96%E8%AF%91/</guid>
      <description>首先从获取JDK源码开始。以OpenJDK为例，点击 OpenJDK 进入，选择对应的JDK版本，在此以JDK12为例，选择 $jdk12$ 。进入后在左侧选择 $browse$ ，然后再选择 $zip$ 即可下载。源码下载完毕之后解压，可以在解压后的文件目录下的 $/doc/building.html$ 中阅读编译文档。
源码下载完毕之后开始准备Linux环境，要注意在Linux环境中，文件夹请尽量使用英文名，名称中不要出现空格。我使用的是WSL Ubuntu，在刚开始使用时要记得切换镜像源。
vi /etc/apt/sources.list  使用 $vi$ 打开配置文件，然后替换为镜像源，在此我使用的是阿里云的镜像源，$sources.list$ 文件内容如下：
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.</description>
    </item>
    
  </channel>
</rss>