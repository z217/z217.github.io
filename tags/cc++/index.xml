<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&amp;C&#43;&#43; on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/cc&#43;&#43;/</link>
    <description>Recent content in C&amp;C&#43;&#43; on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2022, z217 and the hugo authors, all rights reserved.</copyright>
    <lastBuildDate>Fri, 11 Feb 2022 16:00:04 +0800</lastBuildDate><atom:link href="https://z217blog.cn/tags/cc++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unix网络编程（7）：高级I/O函数</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B7/</link>
      <pubDate>Fri, 11 Feb 2022 16:00:04 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B7/</guid>
      <description>1. 套接字超时  在涉及套接字的I/O操作上设置超时的办法有以下三种：
 调用 $alarm$ ，它在指定超时期满时产生 $SIGALRM$ 信号。这个办法涉及信号处理，而信号处理在不同的实现上存储差异，而且可能干扰进程中现有的 $alarm$ 调用； 在 $select$ 中阻塞等待I/O，以此代替直接阻塞在 $read$ 或 $write$ 调用上； 使用较新的 $SO_-RCVTIMEO$ 和 $SO_-SNDTIMEO$ 套接字选项。这个办法的问题在于并非所有实现都支持这两个套接字选项。   以上三种技术都适用于输入和输出操作，不过我们依然期待可用于 $connect$ 技术，因为TCP内置的 $connect$ 超时时间相当长 ( 典型为 $75$ 秒 )。$select$ 可用来在 $connect$ 上设置超时的先决条件是相应套接字处于非阻塞模式，而那两个套接字选项对 $connect$ 并不适用。还要注意，前两个技术适用于任何描述符，而最后一个只适用于套接字描述符。
#include &amp;#34;unp.h&amp;#34; static void connect_alarm(int); int connect_timeo(int sockfd, const struct sockaddr *saptr, socklen_t salen, int nsec) { Sigfunc *sigfunc; int n; sigfunc = Signal(SIGALRM, connect_alarm); if (alarm(nsec) != 0) err_msg(&amp;#34;connect_timeo: alarm was already set&amp;#34;); if ((n = connect(sockfd, saptr, salen)) &amp;lt; 0) { close(sockfd); if (errno == EINTR) errno = ETIMEDOUT; } alarm(0); // turn off the alarm  Signal(SIGALRM, sigfunc) // restore previous signal handler  return n; } static void connect_alarm(int signo) { return; // just interrupt the connect() }  上述代码使用第一种方法，通过 $alarm$ 设置秒数，再通过信号处理函数中断 $connect$ 调用，同时关闭套接字。自定义的 $Signal$ 函数也会阻塞 $SA_-RESTART$ 信号。要注意，如果指定 $nsec$ 为一个大于 $75$ 的值，那么函数仍然会在 $75$ 秒时超时并返回。还要注意，虽然通过这种方式实现简单，但是在多线程程序中，正确使用信号是很困难的，所以建议只在未线程化或单线程程序中适用该技术。</description>
    </item>
    
    <item>
      <title>Unix网络编程（6）：守护进程</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B6/</link>
      <pubDate>Wed, 09 Feb 2022 16:20:07 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B6/</guid>
      <description>守护进程 ( $daemon$ ) 是在后台运行且不与任何控制终端关联的进程。Unix系统通常有很多守护进程在后台运行，执行不同的管理任务。守护进程没有控制终端通常源于它们由系统初始化脚本启动，然而守护进程也可能从某个终端由用户在shell提示符下输入命令行启动，这样的守护进程必须亲自脱离与控制终端的关联。
1. syslogd守护进程  Unix系统中的 $syslogd$ 守护进程通常由某个系统初始化脚本启动，而且在系统工作期间一直运行。Linux系统的不同发行版会使用各自的实现，比如Ubuntu会使用 $rsyslog$ ，Arch使用 $journal$ 。源自 $Berkeley$ 的 $syslogd$ 实现在启动时执行以下步骤：
 读取配置文件。通常为 $/etc/syslog.conf$ 的配置文件指定本守护进程可能收取的各种日志消息应该如何处理。这些消息可能被添加到一个文件，或被写到指定用户的登录窗口，或被转发给另一个主机上的 $syslog$ 进程； 创建一个Unix域数据报套接字，给它捆绑路径名 $/var/run/log$ ； 创建一个UDP套接字，给他捆绑端口 $514$ ( $syslog$ 服务使用的端口 )； 打开路径名 $/dev/klog$ ，来自内核中的任何出错消息看着像是这个设备的输入。   此后 $syslog$ 一直在一个无限循环中运行：调用 $select$ 等待 $3$ 个描述符 ( 上述第 $2$ 、$3$ 和 $4$ 步 )，读入日志消息，按照配置文件进行处理。如果接收到 $SIGHUP$ 信号，则重新读取配置文件。
通过创建一个Unix域数据报套接字，我们就可以从自己的守护进程中通过往 $syslogd$ 绑定的路径名发送我们的消息，从而达到发送日志消息的目的。另外，我们也可以创建一个UDP套接字 ( 较新的实现为防止遭受攻击，会禁止套接字的创建 )，通过往环回地址和端口 $514$ 发送我们的消息达到发送日志消息的目的。
2. syslog函数 #include &amp;lt;syslog.h&amp;gt; void syslog(int priority, const char *message, .</description>
    </item>
    
    <item>
      <title>Unix网络编程（5）：DNS</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B5/</link>
      <pubDate>Mon, 07 Feb 2022 15:57:58 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B5/</guid>
      <description>1. 域名系统  DNS中的条目称为资源记录 ( $resource$ $record$ , $RR$ )。
 $A$ ：$A$ 记录把一个主机名映射成一个 $32$ 位的IPv4地址； $AAAA$ ：四 $A$ ( $quad$ $A$ ) 记录把一个主机名映射成一个 $128$ 位的IPv6地址； $PTR$ ：指针记录 ( $pointer$ $record$ ) 把IP地址映射成主机名。对于IPv4地址，$32$ 地址的 $4$ 字节先反转顺序，每字节都转换成各自的十进制ASCII值后，再添加 $in-addr.arpa$ ；对于IPv6地址，$128$ 位地址中的 $32$ 个四位组先反转顺序，每个四位组都被转换成相应的十六进制ASCII值后，再添加 $ip6.arpa$ ； $MX$　：$MX$ 记录把一个主机指定作为给定主机的邮件交换器 ( $mail$ $exchanger$ )； $CNAME$ ：$CNAME$ 代表规范名字 ( $canonical$ $name$ )，常见用法是为常用的服务指派 ( 例如 $ftp$ 和 $www$ ) CNAME记录。如果人们使用这些服务名而不是真实的主机名，那么相应的服务挪到另一个主机时他们也不必知道。   每个组织往往运行一个或多个名字服务器 ( $name$ $server$ )，它们通常就是所谓的 $BIND$ ( $Berkeley$ $Internet$ $Name$ $Domain$ ) 程序。诸如我们编写的客户和服务器等应用程序通过调用称为解析器 ( $resolver$ ) 的函数库中的函数接触DNS服务器。解析器代码通常包含在一个系统函数库中，在构造应用程序时被链编 ( $link-editing$ ) 到应用程序中。解析器使用UDP向本地名字服务器发出查询，如果本地名字服务器不知道答案，通常就会使用UDP在整个因特网上查询其他名字服务器。如果答案太常，超出了UDP消息的承载能力，本地名字服务器和解析器会自动切换到TCP。</description>
    </item>
    
    <item>
      <title>Unix网络编程（4）：基本UDP/SCTP套接字编程</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B4/</link>
      <pubDate>Thu, 03 Feb 2022 16:08:32 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B4/</guid>
      <description>1. 基本UDP套接字编程 1.1 recvfrom和sendto函数  $recvfrom$ 和 $sendto$ 类似于标准 $read$ 和 $write$ 函数，不过需要三个额外的参数。
#include &amp;lt;sys/socket.h&amp;gt; ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen); ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t addrlen); // 成功则返回读或写的字节数，出错返回-1  $sendto$ 的 $to$ 参数指向一个含有数据报接收者的协议地址的套接字地址结构，其大小由 $addrlen$ 指定。$recvfrom$ 的 $from$ 参数指向一个将由该参数在返回时填写数据报发送者的协议地址的套接字地址结构，其大小由 $addrlen$ 返回给调用者。写一个长度为 $0$ 的数据报是可行的。在UDP情况下，这回形成一个只包含一个IP首部和一个 $8$ 字节UDP首部而没有数据的IP数据报。这也意味着对于数据报协议，$recvfrom$ 返回 $0$ 值是可以接受的，并不像TCP一样代表对端连接关闭。如果 $recvfrom$ 的 $from$ 参数是一个空指针，那么相应的长度参数 $addrlen$ 也必须是一个空指针。</description>
    </item>
    
    <item>
      <title>Unix网络编程（3）：I/O复用</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</link>
      <pubDate>Wed, 02 Feb 2022 15:04:28 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</guid>
      <description>1. I/O模型  Unix下有 $5$ 种可用的I/O模型：阻塞式I/O、非阻塞式I/O、I/O复用、信号驱动式I/O和异步I/O。
1.1 阻塞式I/O  最流行的I/O模型是阻塞式I/O ( $blocking$ $I/O$ ) 模型。默认情形下，所有的套接字都是阻塞的。
1.2 非阻塞式I/O  进程把一个套接字设置成非阻塞式是在通知内核：当所请求的I/O操作非得把本进程置于休眠状态才能完成时，不要把本进程置于休眠状态，而是返回一个错误。
 当一个应用进程像这样对一个非阻塞描述符循环调用 $recvfrom$ 时，我们称之为轮询 ( $polling$ )。应用进程持续轮询内核，以查看某个操作是否就绪，这么做往往耗费大量CPU时间。不过这种模型偶尔也会遇到，通常是在专门提供某一种功能的系统中才有。
1.3 I/O复用  通过I/O复用，我们可以调用 $select$ 或 $poll$ ，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。
1.4 信号驱动式I/O  我们也可以使用信号，让内核在描述符就绪时发送 $SIGIO$ 信号通知我们。
 我们首先开启套接字的信号驱动I/O功能，并通过 $sigaction$ 系统调用安装一个信号处理函数。该系统调用立即返回，我们的进程继续工作。当数据报准备好被读取时，内核就为该进程产生一个 $SIGIO$ 信号。我们随后既可以在信号处理函数中调用 $recvfrom$ 读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。
1.5 异步I/O  异步I/O ( $asynchronous$ $I/O$ ) 由POSIX规范定义。一般地说，这些函数的工作机制是：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。这种模型与前一节介绍的信号驱动模型的主要区别在于：信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作，异步I/O是由内核通知我们I/O操作何时完成。
 我们调用 $aio_-read$ 函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。该系统调用会立即返回，而且在等待I/O完成期间，我们的进程不被阻塞。
2. select函数  $select$ 函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定时间后才唤醒。
#include &amp;lt;sys/select.h&amp;gt;#include &amp;lt;sys/time.h&amp;gt; // 存在就绪描述符则返回其数目，超时返回0，出错返回-1 int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); strcut timeval { long tv_sec; // seconds  long tv_usec; // microseconds  $timeval$ 参数有以下三种可能：</description>
    </item>
    
    <item>
      <title>Unix网络编程（2）：基本TCP套接字编程</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</link>
      <pubDate>Sat, 29 Jan 2022 18:38:32 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</guid>
      <description>1. 基本TCP套接字编程 1.1 socket函数  为了执行网络I/O，进程必须做的第一件事就是调用 $socket$ 函数。
#include &amp;lt;sys/socket.h&amp;gt; // 成功返回套接字描述符，失败返回-1 int socket(int family, int type. int protocol);  $family$ 为协议族，由于历史问题，一些实现中还存在以 $PF$ 开头的协议族，但基本等价；$type$ 指明套接字类型；$protocol$ 为某个协议类型常值。
   $family$ 说明     $AF_-INET$ IPv4协议   $AF_-INET6$ IPv6协议   $AF_-LOCAL$ Unix域协议   $AF_-ROUTE$ 路由套接字   $AF_-KEY$ 密钥套接字        $type$ 说明     $SOCK_-STREAM$ 字节流套接字   $SOCK_-DGRAM$ 数据报套接字   $SOCK_-SEQPACKET$ 有序分组套接字   $SOCK_-RAW$ 原始套接字        $protocol$ 说明     $IPPROTO_-TCP$ TCP传输协议   $IPPROTO_-UDP$ UDP传输协议   $IPPROTO_-SCTP$ SCTP传输协议        组合 $AF_-INET$ $AF_-INET6$ $AF_-LOCAL$ $AF_-ROUTE$ $AF_-KEY$     $SOCK_-STREAM$ TCP｜SCTP TCP｜SCTP 有效     $SOCK_-DGRAM$ UDP UDP 有效     $SOCK_-SEQPACKET$ SCTP SCTP 有效     $SOCK_-RAW$ IPv4 IPv6  有效 有效    1.</description>
    </item>
    
    <item>
      <title>Unix网络编程（1）：套接字编程简介</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</link>
      <pubDate>Wed, 26 Jan 2022 17:10:43 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</guid>
      <description>1. 传输层  TCP建立一个连接需要三次握手：
 服务器准备接受外部连接，通常通过调用 $socket$ 、$bind$ 、$listen$ 这 $3$ 个函数完成，称为被动打开 ( $passive$ $open$ )； 客户端通过调用 $connect$ 发起主动打开 ( $active$ $open$ )，即发送一个SYN报文； 服务器确认 ( ACK ) 客户端的SYN，同时也发送一个SYN； 客户端确认服务器的SYN。   TCP终止一个连接需要四次挥手：
 某个进程调用 $close$ ，称为主动关闭 ( $active$ $close$ )，该端发送一个FIN报文； 对端接受FIN，执行被动关闭 ( $passive$ $close$ )。这个FIN由TCP确认，接收也作为一个文件结束符 ( $end-of-file$ , $EOF$ ) 传递给接收端应用程序 ( 放在已排队等候该应用进程接收的任何其他数据之后 )； 一段时间后，接收到EOF的进程调用 $close$ 关闭套接字，并发送一个FIN报文； 接收到FIN的原端TCP确认。   TCP状态转换图可参考TCP、UDP和DNS简介。
SCTP建立一个连接的过程为：
 服务器准备接受外部连接，通常通过调用 $socket$ 、$bind$ 、$listen$ 这 $3$ 个函数完成，称为被动打开； 客户端通过调用 $connect$ 或者发送一个隐式打开该关联的消息进行主动打开，从而发送一个INIT消息，告知服务器客户端的IP地址清单、初始序列号、分组起始标记、客户端请求的外出流数目以及客户端能支持的外出流的数目； 服务器以一个INIT ACK消息确认，其中含有服务器的IP地址清单、初始序列号、起始标记、请求的外出流数目、支持的外出流数目和一个状态cookie，包含服务器用于确认本次连接有效所需的所有状态； 客户端以一个COOKIE ECHO消息回射状态cookie； 服务器以一个COOKIE ACK消息确认cookie正确，于是连接建立。   SCTP不像TCP那样允许”半关闭“的连接，而是当某一端关闭时，另一端必须停止发送新数据，在发送完所有队列中的数据后关闭。</description>
    </item>
    
  </channel>
</rss>
