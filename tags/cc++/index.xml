<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&amp;C&#43;&#43; on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/cc&#43;&#43;/</link>
    <description>Recent content in C&amp;C&#43;&#43; on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2022, z217 and the hugo authors, all rights reserved.</copyright>
    <lastBuildDate>Tue, 15 Feb 2022 17:50:04 +0800</lastBuildDate><atom:link href="https://z217blog.cn/tags/cc++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unix网络编程（12）：带外数据</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B12/</link>
      <pubDate>Tue, 15 Feb 2022 17:50:04 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B12/</guid>
      <description>许多传输层有带外数据 ( $out-of-band$ $data$ ) 的概念，有时也被称为经加速数据 ( $expedited$ $data$ )。当一个连接的某端发生了重要的事情，而且该端希望迅速告知对端，这意味着这些数据应该在已经排队等待发送的任何普通数据之前发送。带外数据并不要求在客户和服务器之间再创建一个连接，而是使用现有的连接。不幸的是，几乎每个传输层都有各自不同的带外数据的实现。UDP是一个极端的例子，没有带外数据。
1. TCP带外数据  TCP并没有真正的带外数据，不过提供了紧急模式 ( $urgent$ $mode$ )。以下为TCP发送缓冲区。
 进程以 $MSG_-OOB$ 标志发送一个带外数据：
send(fd, &amp;#34;a&amp;#34;, 1, MSG_OOB);  TCP将这个数据放置在发送缓冲区的下一个可用位置，并把该连接的TCP紧急指针设置为下一个可用位置。
 TCP紧急指针对应一个TCP序列号，它是使用 $MSG_-OOB$ 标志写出的最后一个数据字节 ( 即带外数据字节 ) 对应的序列号加 $1$ 。发送端TCP将为待发送的下一个分节在TCP首部设置URG标志，并把TCP紧急偏移 ( $urgent$ $offset$ ) 字段设置为紧急指针指向的字节，这个分节可能包含也可能不含之前发送的带外数据。$16$ 位的TCP序列号加上 $16$ 位的紧急偏移字段即可得到 $32$ 位的紧急指针。TCP紧急模式的一个重要特点是TCP首部指出发送端已经进入紧急模式 ( 设置URG标志 )，但是紧急指针指向的实际数据字节却不一定发送。
从接收端的角度来看，发生了以下事件：
 收到URG分节，接收端检查紧急指针，确定它是否指向带外数据，也就是判断本分节是不是首个到达的紧急模式分节。发送端TCP往往发送多个URG分节并且其紧急指针都会指向同一个数据字节的分节，只有第一个到达的分节会通知接收进程有新的带外数据到达； 当有新的紧急指针到达时，不论由紧急指针指向的实际数据字节是否已经到达，接收进程会收到通知。内核给接收套接字的进程发送 $SIGURG$ 信号，前提是接收进程 ( 或其他进程 ) 曾调用 $fcntl$ 或 $ioctl$ 为这个套接字建立了属主，而且该属主今后层已经为 $SIGURG$ 信号建立了信号处理函数。其次，如果接收进程阻塞在 $select$ 调用中，$select$ 调用就立即返回； 当由紧急指针指向的实际数据字节到达接收端TCP时，该数据字节可能被拉出带外，也可能留在带内。$SO_-OOBINLINE$ 套接字选项默认是禁止的，对于这样的套接字，该数据字节并不立即放入接收缓冲区，而是放入该连接的一个独立的单字节带外缓冲区。接收进程从这个单字节缓冲区中读入数据的唯一方法是指定 $MSG_-OOB$ 标志调用 $recv$ 、$recvfrom$ 或 $recvmsg$ 。如果新的带外字节在就旧的带外字节被读取之前到达，旧的带外字节会被丢弃。如果开启了 $SO_-OOBINLINE$ ，接收进程不能通过 $MSG_-OOB$ 标志读入带外数据，而是通过检查连接的带外标记获悉何时访问到这个字节。   这个过程可能会发送以下错误：</description>
    </item>
    
    <item>
      <title>Unix网络编程（11）：路由套接字</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B11/</link>
      <pubDate>Mon, 14 Feb 2022 19:31:39 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B11/</guid>
      <description>注：以下内容可能不适用于Linux系统
 内核中的Unix路由表传统上一直使用 $ioctl$ 访问，但是 $ioctl$ 不能输出整个路由表，而诸如 $netstat$ 等程序通过读取内核的内存获取路由表内容。诸如 $gated$ 等路由守护进程需要监视由内核收取的ICMP重定向消息，它们通常创建一个原始ICMP套接字，再在这个套接字上监听所有收到的ICMP消息。在路由域中支持的唯一一种套接字是原始套接字。路由套接字上支持 $3$ 种类型的操作：
 进程可以通过写出到路由套接字而往内核发送消息。路径的增加和删除采用这种操作实现； 进程可以通过从路由套接字读入而从内核接收消息。内核采用这种操作通知进程已收到并处理一个ICMP重定向消息，或者请求外部路由进程解析一个路径； 进程可以使用 $sysctl$ 函数输出路由表或者列出所有已配置的接口。   前两种操作可以复合使用，需要超级用户权限，最后一种任何进程都可以执行。
1. 数据链路套接字地址结构 #include &amp;lt;net/if_dl.h&amp;gt; struct sockaddr_dl { uint8_t sdl_len; sa_family_t sdl_family; // AF_LINK  uint16_t sdl_index; // 大于0的系统分配的索引  uint8_t sdl_type; // IFT_ETHER等在&amp;lt;net/if_types.h&amp;gt;中定义的常值  uint8_t sdl_nlen; // 名字长度，从sdl_data[0]开始  uint8_t sdl_alen; // 链路层地址长度  uint8_t sdl_slen; // 链路层选择器长度  char sdl_data[12]; // 最小工作区域，可以扩大，包含i/f名称和链路层地址 }; #define LLADDR(s) ((caddr_t) ((s)-&amp;gt;sdl_data + (s)-&amp;gt;sdl_nlen))  每个接口都有一个唯一的索引。$sdl_-data$ 成员含有名字和链路层地址，名字从 $sdl_-data[0]$ 开始，并且不以空字符结尾。链路层地址从 $sdl_-data[sdl_-nlen]$ 开始，$LLADDR$ 宏返回指向链路层地址的指针。</description>
    </item>
    
    <item>
      <title>Unix网络编程（10）：ioctl</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B10/</link>
      <pubDate>Mon, 14 Feb 2022 15:10:53 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B10/</guid>
      <description>$ioctl$ 函数传统上一直作为那些不适合归入其他精细定义类别的特性的系统接口。POSIX致力于摆脱处于标准化过程的特定功能的 $ioctl$ 接口，办法是为它们创造一些特殊的函数以取代 $ioctl$ 请求，办法是为它们创造一些特殊的函数以取代 $ioctl$ 请求。网络层程序经常在程序启动执行后使用 $ioctl$ 获取所在主机全部网络接口的信息，包括：接口地址、是否支持广播、是否支持多播等。
1. ioctl函数 #include &amp;lt;unistd.h&amp;gt; // 成功返回 $0$ ，出错返回-1 int ioctl(int fd, int request, ... /* void *arg */);  第三个参数是一个指针，类型依赖于 $request$ 参数。我们可以把和网络相关的请求分为 $6$ 类：
   类别 $request$ 说明 数据类型     套接字 $SIOCATMARK$ 是否位于带外标记 $int$   $SIOCSPGRP$ 设置套接字的进程ID或进程组ID $int$   $SIOCGPGRP$ 获取套接字的进程ID或进程组ID $int$   文件 $FIONBIO$ 设置/清除非阻塞式I/O标志 $int$   $FIOASYNC$ 设置/清除信号驱动异步I/O标志 $int$   $FIONREAD$ 获取接收缓冲区的字节数 $int$   $FIOSETOWN$ 设置文件的进程ID或进程组ID $int$   $FIOGETOWN$ 获取文件的进程ID或进程组ID $int$   接口 $SIOCGIFCONF$ 获取所有接口的列表 $struct$ $ifconf$   $SIOCSIFADDR$ 设置接口地址 $struct$ $ifreq$   $SIOCGIFADDR$ 获取接口地址 $struct$ $ifreq$   $SIOCGIFADDR$ 获取接口地址 $struct$ $ifreq$   $SIOCSIFFLAGS$ 设置接口标志 $struct$ $ifreq$   $SIOCGIFFLAGS$ 获取接口标志 $struct$ $ifreq$   $SIOCSIFDSTADDR$ 设置点到点地址 $struct$ $ifreq$   $SIOCGIFDSTADDR$ 获取点到点标志 $struct$ $ifreq$   $SIOCGIFBRDADDR$ 获取广播地址 $struct$ $ifreq$   $SIOCSIFBRDADDR$ 设置广播地址 $struct$ $ifreq$   $SIOCGIFNETMASK$ 获取子网掩码 $struct$ $ifreq$   $SIOCSIFNETMASK$ 设置子网掩码 $struct$ $ifreq$   $SIOCGIFMETRIC$ 获取接口的测度 $struct$ $ifreq$   $SIOCSIFMETRIC$ 设置接口的测度 $struct$ $ifreq$   $SIOCGIFMTU$ 获取接口 $MTU$  $struct$ $ifreq$   ARP $SIOCSARP$ 创建/修改ARP表项 $struct$ $arpreq$   $SIOCGARP$ 获取ARP表项 $struct$ $arpreq$   $SIOCDARP$ 删除ARP表项 $struct$ $arpreq$   路由 $SIOCADDRT$ 增加路径 $struct$ $rtentry$   $SIOCDELRT$ 删除路径 $struct$ $rtentry$   流 $I_-xxx$ 以后说明    2.</description>
    </item>
    
    <item>
      <title>Unix网络编程（9）：非阻塞式I/O</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B9/</link>
      <pubDate>Sat, 12 Feb 2022 17:12:54 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B9/</guid>
      <description>套接字的默认状态是阻塞的，这就意味着当发出一个不能立即完成的套接字调用时，其进程将被置于休眠状态，直到相应操作完成。可能阻塞套接字的调用分为以下四类：
 输入：$read$ 、$readv$ 、$recv$ 、$recvfrom$ 和 $recvmsg$ 共 $5$ 个函数。如果对阻塞式套接字调用，而且套接字接收缓冲区中没有数据可读，进程将休眠。而对于非阻塞式套接字，如果输入操作不能被满足，调用将返回 $EWOULDBLOCK$ 错误； 输出：$write$ 、$writev$ 、$send$ 、$sendto$ 和 $sendmsg$ 共 $5$ 个函数。如果对阻塞式套接字调用，而且套接字发送缓冲区中没有空间，进程将休眠。对于非阻塞的TCP套接字，如果发送缓冲区中没有空间，输出函数调用将立即返回 $EWOULDBLOCK$ 错误； 接受外来连接，即 $accept$ 函数。如果对一个非阻塞套接字调用 $accept$ 函数，而且无新连接到达，将会立即返回 $EWOULDBLOCK$ 错误； 发起外出连接，即用于TCP的 $connect$ 函数。如果对一个非阻塞套接字调用 $connect$ ，而且连接不能立即建立，那么会立即返回 $EINPROGRESS$ 错误。  1. 非阻塞读和写 #include &amp;#34;unp.h&amp;#34;#include &amp;lt;time.h&amp;gt; char *gf_time(void); void str_cli(FILE *fp, int sockfd) { int maxfdp1, val, stdineof; ssize_t n , nwritten; fd_set rset, wset; char to[MAXLINE], fr[MAXLINE]; char *toiptr, *tooptr, *friptr, *froptr; val = Fcntl(sockfd, F_GETFL, 0); Fcntl(sockfd, F_SETFL, val | O_NONBLOCK); val = Fcntl(STDIN_FILENO, F_GETFL, 0); Fcntl(STDIN_FILENO, F_SETFL, val | O_NONBLOCK); val = Fcntl(STDOUT_FILENO, F_GETFL, 0); Fcntl(STDOUT_FILENO, F_SETFL, val | O_NONBLOCK); toiptr = tooptr = to; friptr = froptr = fr; stdineof = 0; maxfdp1 = max(max(STDIN_FILENO, STDOUT_FILENO), sockfd) + 1; for (;;) { FD_ZERO(&amp;amp;rset); FD_ZERO(&amp;amp;wset); if (stdineof == 0 &amp;amp;&amp;amp; toiptr &amp;lt; &amp;amp;to[MAXLINE]) FD_SET(STDIN_FILENO, &amp;amp;rset); // read from stdin  if (friptr &amp;lt; &amp;amp;fr[MAXLINE]) FD_SET(sockfd, &amp;amp;rset); // read from socket  if (tooptr !</description>
    </item>
    
    <item>
      <title>Unix网络编程（8）：Unix域协议</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B8/</link>
      <pubDate>Sat, 12 Feb 2022 14:58:42 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B8/</guid>
      <description>Unix域协议并不是一个实际的协议族，而是在单个主机上执行客户/服务器通信的一种方法，所用API就是在不同主机上执行客户/服务器通信所用的API，因此，Unix域协议可视为IPC方法之一。Unix域提供两类套接字：字节流套接字 ( 类似TCP ) 和数据报套接字 ( 类似UDP )。
1. 套接字地址结构 #include &amp;lt;sys/un.h&amp;gt; struct sockaddr_un { sa_family_t sun_family; // AF_LOCAL  char sun_path[104]; // null-terminated pathname };  存放在 $sun_-path$ 数组中的路径名必须以空字符结尾。实现提供一个 $SUN_-LEN$ 宏以一个指向 $sockaddr_-un$ 结构的指针为参数并返回该结构的长度，包括路径名中的非空字节数。未指定地址通过空字符串作为路径名指示，等价于IPv4的 $INADDR_-ANY$ 常值或IPv6的 $IN6ADDR_-ANY_-INIT$ 常值。
#include &amp;#34;unp.h&amp;#34; int main(int argc, char **argv) { int sockfd; socklen_t len; struct sockaddr_un addr1, addr2; if (argc != 2) err_quit(&amp;#34;usage: unixbind &amp;lt;pathname&amp;gt;&amp;#34;); sockfd = Socket(AF_LOCAL, SOCK_STREAM, 0); unlink(argv[1]); bzero(&amp;amp;addr1, sizeof(addr1)); addr1.</description>
    </item>
    
    <item>
      <title>Unix网络编程（7）：高级I/O函数</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B7/</link>
      <pubDate>Fri, 11 Feb 2022 16:00:04 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B7/</guid>
      <description>1. 套接字超时  在涉及套接字的I/O操作上设置超时的办法有以下三种：
 调用 $alarm$ ，它在指定超时期满时产生 $SIGALRM$ 信号。这个办法涉及信号处理，而信号处理在不同的实现上存储差异，而且可能干扰进程中现有的 $alarm$ 调用； 在 $select$ 中阻塞等待I/O，以此代替直接阻塞在 $read$ 或 $write$ 调用上； 使用较新的 $SO_-RCVTIMEO$ 和 $SO_-SNDTIMEO$ 套接字选项。这个办法的问题在于并非所有实现都支持这两个套接字选项。   以上三种技术都适用于输入和输出操作，不过我们依然期待可用于 $connect$ 技术，因为TCP内置的 $connect$ 超时时间相当长 ( 典型为 $75$ 秒 )。$select$ 可用来在 $connect$ 上设置超时的先决条件是相应套接字处于非阻塞模式，而那两个套接字选项对 $connect$ 并不适用。还要注意，前两个技术适用于任何描述符，而最后一个只适用于套接字描述符。
#include &amp;#34;unp.h&amp;#34; static void connect_alarm(int); int connect_timeo(int sockfd, const struct sockaddr *saptr, socklen_t salen, int nsec) { Sigfunc *sigfunc; int n; sigfunc = Signal(SIGALRM, connect_alarm); if (alarm(nsec) != 0) err_msg(&amp;#34;connect_timeo: alarm was already set&amp;#34;); if ((n = connect(sockfd, saptr, salen)) &amp;lt; 0) { close(sockfd); if (errno == EINTR) errno = ETIMEDOUT; } alarm(0); // turn off the alarm  Signal(SIGALRM, sigfunc) // restore previous signal handler  return n; } static void connect_alarm(int signo) { return; // just interrupt the connect() }  上述代码使用第一种方法，通过 $alarm$ 设置秒数，再通过信号处理函数中断 $connect$ 调用，同时关闭套接字。自定义的 $Signal$ 函数也会阻塞 $SA_-RESTART$ 信号。要注意，如果指定 $nsec$ 为一个大于 $75$ 的值，那么函数仍然会在 $75$ 秒时超时并返回。还要注意，虽然通过这种方式实现简单，但是在多线程程序中，正确使用信号是很困难的，所以建议只在未线程化或单线程程序中适用该技术。</description>
    </item>
    
    <item>
      <title>Unix网络编程（6）：守护进程</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B6/</link>
      <pubDate>Wed, 09 Feb 2022 16:20:07 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B6/</guid>
      <description>守护进程 ( $daemon$ ) 是在后台运行且不与任何控制终端关联的进程。Unix系统通常有很多守护进程在后台运行，执行不同的管理任务。守护进程没有控制终端通常源于它们由系统初始化脚本启动，然而守护进程也可能从某个终端由用户在shell提示符下输入命令行启动，这样的守护进程必须亲自脱离与控制终端的关联。
1. syslogd守护进程  Unix系统中的 $syslogd$ 守护进程通常由某个系统初始化脚本启动，而且在系统工作期间一直运行。Linux系统的不同发行版会使用各自的实现，比如Ubuntu会使用 $rsyslog$ ，Arch使用 $journal$ 。源自 $Berkeley$ 的 $syslogd$ 实现在启动时执行以下步骤：
 读取配置文件。通常为 $/etc/syslog.conf$ 的配置文件指定本守护进程可能收取的各种日志消息应该如何处理。这些消息可能被添加到一个文件，或被写到指定用户的登录窗口，或被转发给另一个主机上的 $syslog$ 进程； 创建一个Unix域数据报套接字，给它捆绑路径名 $/var/run/log$ ； 创建一个UDP套接字，给他捆绑端口 $514$ ( $syslog$ 服务使用的端口 )； 打开路径名 $/dev/klog$ ，来自内核中的任何出错消息看着像是这个设备的输入。   此后 $syslog$ 一直在一个无限循环中运行：调用 $select$ 等待 $3$ 个描述符 ( 上述第 $2$ 、$3$ 和 $4$ 步 )，读入日志消息，按照配置文件进行处理。如果接收到 $SIGHUP$ 信号，则重新读取配置文件。
通过创建一个Unix域数据报套接字，我们就可以从自己的守护进程中通过往 $syslogd$ 绑定的路径名发送我们的消息，从而达到发送日志消息的目的。另外，我们也可以创建一个UDP套接字 ( 较新的实现为防止遭受攻击，会禁止套接字的创建 )，通过往环回地址和端口 $514$ 发送我们的消息达到发送日志消息的目的。
2. syslog函数 #include &amp;lt;syslog.h&amp;gt; void syslog(int priority, const char *message, .</description>
    </item>
    
    <item>
      <title>Unix网络编程（5）：DNS</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B5/</link>
      <pubDate>Mon, 07 Feb 2022 15:57:58 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B5/</guid>
      <description>1. 域名系统  DNS中的条目称为资源记录 ( $resource$ $record$ , $RR$ )。
 $A$ ：$A$ 记录把一个主机名映射成一个 $32$ 位的IPv4地址； $AAAA$ ：四 $A$ ( $quad$ $A$ ) 记录把一个主机名映射成一个 $128$ 位的IPv6地址； $PTR$ ：指针记录 ( $pointer$ $record$ ) 把IP地址映射成主机名。对于IPv4地址，$32$ 地址的 $4$ 字节先反转顺序，每字节都转换成各自的十进制ASCII值后，再添加 $in-addr.arpa$ ；对于IPv6地址，$128$ 位地址中的 $32$ 个四位组先反转顺序，每个四位组都被转换成相应的十六进制ASCII值后，再添加 $ip6.arpa$ ； $MX$　：$MX$ 记录把一个主机指定作为给定主机的邮件交换器 ( $mail$ $exchanger$ )； $CNAME$ ：$CNAME$ 代表规范名字 ( $canonical$ $name$ )，常见用法是为常用的服务指派 ( 例如 $ftp$ 和 $www$ ) CNAME记录。如果人们使用这些服务名而不是真实的主机名，那么相应的服务挪到另一个主机时他们也不必知道。   每个组织往往运行一个或多个名字服务器 ( $name$ $server$ )，它们通常就是所谓的 $BIND$ ( $Berkeley$ $Internet$ $Name$ $Domain$ ) 程序。诸如我们编写的客户和服务器等应用程序通过调用称为解析器 ( $resolver$ ) 的函数库中的函数接触DNS服务器。解析器代码通常包含在一个系统函数库中，在构造应用程序时被链编 ( $link-editing$ ) 到应用程序中。解析器使用UDP向本地名字服务器发出查询，如果本地名字服务器不知道答案，通常就会使用UDP在整个因特网上查询其他名字服务器。如果答案太常，超出了UDP消息的承载能力，本地名字服务器和解析器会自动切换到TCP。</description>
    </item>
    
    <item>
      <title>Unix网络编程（4）：基本UDP/SCTP套接字编程</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B4/</link>
      <pubDate>Thu, 03 Feb 2022 16:08:32 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B4/</guid>
      <description>1. 基本UDP套接字编程 1.1 recvfrom和sendto函数  $recvfrom$ 和 $sendto$ 类似于标准 $read$ 和 $write$ 函数，不过需要三个额外的参数。
#include &amp;lt;sys/socket.h&amp;gt; ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen); ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t addrlen); // 成功则返回读或写的字节数，出错返回-1  $sendto$ 的 $to$ 参数指向一个含有数据报接收者的协议地址的套接字地址结构，其大小由 $addrlen$ 指定。$recvfrom$ 的 $from$ 参数指向一个将由该参数在返回时填写数据报发送者的协议地址的套接字地址结构，其大小由 $addrlen$ 返回给调用者。写一个长度为 $0$ 的数据报是可行的。在UDP情况下，这回形成一个只包含一个IP首部和一个 $8$ 字节UDP首部而没有数据的IP数据报。这也意味着对于数据报协议，$recvfrom$ 返回 $0$ 值是可以接受的，并不像TCP一样代表对端连接关闭。如果 $recvfrom$ 的 $from$ 参数是一个空指针，那么相应的长度参数 $addrlen$ 也必须是一个空指针。</description>
    </item>
    
    <item>
      <title>Unix网络编程（3）：I/O复用</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</link>
      <pubDate>Wed, 02 Feb 2022 15:04:28 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B3/</guid>
      <description>1. I/O模型  Unix下有 $5$ 种可用的I/O模型：阻塞式I/O、非阻塞式I/O、I/O复用、信号驱动式I/O和异步I/O。
1.1 阻塞式I/O  最流行的I/O模型是阻塞式I/O ( $blocking$ $I/O$ ) 模型。默认情形下，所有的套接字都是阻塞的。
1.2 非阻塞式I/O  进程把一个套接字设置成非阻塞式是在通知内核：当所请求的I/O操作非得把本进程置于休眠状态才能完成时，不要把本进程置于休眠状态，而是返回一个错误。
 当一个应用进程像这样对一个非阻塞描述符循环调用 $recvfrom$ 时，我们称之为轮询 ( $polling$ )。应用进程持续轮询内核，以查看某个操作是否就绪，这么做往往耗费大量CPU时间。不过这种模型偶尔也会遇到，通常是在专门提供某一种功能的系统中才有。
1.3 I/O复用  通过I/O复用，我们可以调用 $select$ 或 $poll$ ，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。
1.4 信号驱动式I/O  我们也可以使用信号，让内核在描述符就绪时发送 $SIGIO$ 信号通知我们。
 我们首先开启套接字的信号驱动I/O功能，并通过 $sigaction$ 系统调用安装一个信号处理函数。该系统调用立即返回，我们的进程继续工作。当数据报准备好被读取时，内核就为该进程产生一个 $SIGIO$ 信号。我们随后既可以在信号处理函数中调用 $recvfrom$ 读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。
1.5 异步I/O  异步I/O ( $asynchronous$ $I/O$ ) 由POSIX规范定义。一般地说，这些函数的工作机制是：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。这种模型与前一节介绍的信号驱动模型的主要区别在于：信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作，异步I/O是由内核通知我们I/O操作何时完成。
 我们调用 $aio_-read$ 函数，给内核传递描述符、缓冲区指针、缓冲区大小和文件偏移，并告诉内核当整个操作完成时如何通知我们。该系统调用会立即返回，而且在等待I/O完成期间，我们的进程不被阻塞。
2. select函数  $select$ 函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定时间后才唤醒。
#include &amp;lt;sys/select.h&amp;gt;#include &amp;lt;sys/time.h&amp;gt; // 存在就绪描述符则返回其数目，超时返回0，出错返回-1 int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); strcut timeval { long tv_sec; // seconds  long tv_usec; // microseconds  $timeval$ 参数有以下三种可能：</description>
    </item>
    
    <item>
      <title>Unix网络编程（2）：基本TCP套接字编程</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</link>
      <pubDate>Sat, 29 Jan 2022 18:38:32 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</guid>
      <description>1. 基本TCP套接字编程 1.1 socket函数  为了执行网络I/O，进程必须做的第一件事就是调用 $socket$ 函数。
#include &amp;lt;sys/socket.h&amp;gt; // 成功返回套接字描述符，失败返回-1 int socket(int family, int type. int protocol);  $family$ 为协议族，由于历史问题，一些实现中还存在以 $PF$ 开头的协议族，但基本等价；$type$ 指明套接字类型；$protocol$ 为某个协议类型常值。
   $family$ 说明     $AF_-INET$ IPv4协议   $AF_-INET6$ IPv6协议   $AF_-LOCAL$ Unix域协议   $AF_-ROUTE$ 路由套接字   $AF_-KEY$ 密钥套接字        $type$ 说明     $SOCK_-STREAM$ 字节流套接字   $SOCK_-DGRAM$ 数据报套接字   $SOCK_-SEQPACKET$ 有序分组套接字   $SOCK_-RAW$ 原始套接字        $protocol$ 说明     $IPPROTO_-TCP$ TCP传输协议   $IPPROTO_-UDP$ UDP传输协议   $IPPROTO_-SCTP$ SCTP传输协议        组合 $AF_-INET$ $AF_-INET6$ $AF_-LOCAL$ $AF_-ROUTE$ $AF_-KEY$     $SOCK_-STREAM$ TCP｜SCTP TCP｜SCTP 有效     $SOCK_-DGRAM$ UDP UDP 有效     $SOCK_-SEQPACKET$ SCTP SCTP 有效     $SOCK_-RAW$ IPv4 IPv6  有效 有效    1.</description>
    </item>
    
    <item>
      <title>Unix网络编程（1）：套接字编程简介</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</link>
      <pubDate>Wed, 26 Jan 2022 17:10:43 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</guid>
      <description>1. 传输层  TCP建立一个连接需要三次握手：
 服务器准备接受外部连接，通常通过调用 $socket$ 、$bind$ 、$listen$ 这 $3$ 个函数完成，称为被动打开 ( $passive$ $open$ )； 客户端通过调用 $connect$ 发起主动打开 ( $active$ $open$ )，即发送一个SYN报文； 服务器确认 ( ACK ) 客户端的SYN，同时也发送一个SYN； 客户端确认服务器的SYN。   TCP终止一个连接需要四次挥手：
 某个进程调用 $close$ ，称为主动关闭 ( $active$ $close$ )，该端发送一个FIN报文； 对端接受FIN，执行被动关闭 ( $passive$ $close$ )。这个FIN由TCP确认，接收也作为一个文件结束符 ( $end-of-file$ , $EOF$ ) 传递给接收端应用程序 ( 放在已排队等候该应用进程接收的任何其他数据之后 )； 一段时间后，接收到EOF的进程调用 $close$ 关闭套接字，并发送一个FIN报文； 接收到FIN的原端TCP确认。   TCP状态转换图可参考TCP、UDP和DNS简介。
SCTP建立一个连接的过程为：
 服务器准备接受外部连接，通常通过调用 $socket$ 、$bind$ 、$listen$ 这 $3$ 个函数完成，称为被动打开； 客户端通过调用 $connect$ 或者发送一个隐式打开该关联的消息进行主动打开，从而发送一个INIT消息，告知服务器客户端的IP地址清单、初始序列号、分组起始标记、客户端请求的外出流数目以及客户端能支持的外出流的数目； 服务器以一个INIT ACK消息确认，其中含有服务器的IP地址清单、初始序列号、起始标记、请求的外出流数目、支持的外出流数目和一个状态cookie，包含服务器用于确认本次连接有效所需的所有状态； 客户端以一个COOKIE ECHO消息回射状态cookie； 服务器以一个COOKIE ACK消息确认cookie正确，于是连接建立。   SCTP不像TCP那样允许”半关闭“的连接，而是当某一端关闭时，另一端必须停止发送新数据，在发送完所有队列中的数据后关闭。</description>
    </item>
    
  </channel>
</rss>
