<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DBS on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/dbs/</link>
    <description>Recent content in DBS on z217&#39;s blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2025, z217 and the hugo authors, all rights reserved.</copyright>
    <lastBuildDate>Mon, 21 Jun 2021 20:33:31 +0800</lastBuildDate>
    <atom:link href="https://z217blog.cn/tags/dbs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL笔记</title>
      <link>https://z217blog.cn/post/mysql%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 21 Jun 2021 20:33:31 +0800</pubDate>
      <guid>https://z217blog.cn/post/mysql%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;1-架构&#34;&gt;1. 架构&lt;/h2&gt;&#xA;&lt;p&gt;        大体来说，&lt;code&gt;MySQL&lt;/code&gt;可以分为&lt;code&gt;Server&lt;/code&gt;层和存储引擎层两部分。&lt;code&gt;Server&lt;/code&gt;层包括连接器、查询缓存、分析器、优化器、执行器等，以及所有的内置函数，所有跨存储引擎功能都在这一层实现。而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持&lt;code&gt;InnoDB&lt;/code&gt;、&lt;code&gt;MyISAM&lt;/code&gt;、&lt;code&gt;Memory&lt;/code&gt;等多个引擎。不同的存储引擎共用一个&lt;code&gt;Server&lt;/code&gt;层，也就是从连接器到执行器的部分。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;连接器：连接器负责跟客户端建立连接、获取权限、维持和管理连接。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接。建立连接的过程通常比较复杂，所以应尽量使用长连接。但是全部使用长连接后，有时候&lt;code&gt;MySQL&lt;/code&gt;内存占用会很高，因为&lt;code&gt;MySQL&lt;/code&gt;在执行过程中临时使用的内存是在连接对象里的，只有在断开连接时才释放。&lt;/li&gt;&#xA;&lt;li&gt;查询缓存：&lt;code&gt;MySQL&lt;/code&gt;会在执行语句之前先在查询缓存中查询。但是查询缓存的失效很频繁，只要有一个表更新，表上所有缓存都会失效。对于更新压力大的数据库来讲，命中率会很低。&lt;code&gt;MySQL&lt;/code&gt;在 $8.0$ 版本移除了查询缓存功能。&lt;/li&gt;&#xA;&lt;li&gt;分析器：分析器会对语句做语法分析，判断语句是否存在错误，同时理解语句要执行的操作。&lt;/li&gt;&#xA;&lt;li&gt;优化器：优化器是在表中存在多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联时，决定表的连接顺序。&lt;/li&gt;&#xA;&lt;li&gt;执行器：在开始执行之前，会检查是否对表具有查询权限。如果有权限，就打开表执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        一个&lt;code&gt;InnoDB&lt;/code&gt;表包含两个部分，即表结构定义和数据。表结构定义的占用空间很小，在&lt;code&gt;MySQL 8.0&lt;/code&gt;版本以前，表结构是存在以 $.frm$ 为后缀的文件里，而&lt;code&gt;MySQL 8.0&lt;/code&gt;版本已经允许把表结构定义放在系统数据表中了。表数据既可放在共享表空间里，也可以是单独的文件，从&lt;code&gt;MySQL 5.6.6&lt;/code&gt;开始，默认是存储在一个以 $.ibd$ 为后缀的文件中的。对于放在共享表空间中的表，即使通过 $DROP$ 命令删除后，空间也不会回收。在删除的过程中，&lt;code&gt;InnoDB&lt;/code&gt;会查找聚簇索引，将对应的记录标记为删除，而不是真正删除，目的是为以后插入新数据时的复用。记录的复用与数据页的复用不同，记录的复用只允许对应范围的新记录复用，而如果删除整个数据页后，数据页的复用可以允许复用到任何位置。如果相邻的两个数据页的利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另一个数据页就被标记为可复用。&lt;br&gt;&#xA;        重建表即将原来表的记录读取出来，一行一行地插入到新表中。原来的表在删除和插入时会产生很多空洞，数据利用率不高，而重建表就可以解决这个问题。&lt;code&gt;MySQL 5.6&lt;/code&gt;引入了 $Online\ \ DDL$ ，会先建立一个临时文件，保存原来表中的聚簇索引。在建立临时文件的过程中，在之后对原表的操作会被记录到日志文件中，并在临时文件建立完成后重新应用到临时文件中，从而允许重建表过程中的读写。&lt;br&gt;&#xA;        在不同的引擎中，$COUNT(*)$ 有不同的实现方式，&lt;code&gt;MyISAM&lt;/code&gt;把表的行数存在了磁盘上，可以直接返回；&lt;code&gt;InnoDB&lt;/code&gt;会把数据一行一行地读出来然后计数。由于&lt;code&gt;MVCC&lt;/code&gt;的存在，在某个时间段表有多少行是不确定的，因此&lt;code&gt;InnoDB&lt;/code&gt;并不能简单地将行数存起来。&lt;code&gt;MySQL&lt;/code&gt;对此的优化策略是，如果表存在多个索引，那么会选择较小的一颗索引树进行扫描。&lt;br&gt;&#xA;        &lt;code&gt;MySQL&lt;/code&gt;会给每个线程分配一块内存用于排序，称为 $sort_-buffer$。在 $sort_-buffer$ 里面的字段，会每次从数据库中取出数据并存到里面。当取出所有数据后再进行快速排序，如果内存空间不足，会使用外部排序。如果单行长度超过排序的最大长度，那么会将要排序的字段与&lt;code&gt;ID&lt;/code&gt;关联，在排序完成后再通过&lt;code&gt;ID&lt;/code&gt;回查。如果现有索引覆盖了需要排序的字段，那么会直接使用索引。对于使用聚集函数的排序，&lt;code&gt;MySQL&lt;/code&gt;可能会使用临时表。临时表默认是在内存中的，如果超过了内存临时表的大小，就会转成磁盘临时表。&lt;br&gt;&#xA;        内存表指的是使用&lt;code&gt;Memory&lt;/code&gt;引擎的表，这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。临时表可以使用各种引擎类型，如果是使用&lt;code&gt;InnoDB&lt;/code&gt;或者&lt;code&gt;MyISAM&lt;/code&gt;引擎的临时表，写数据的时候是写到磁盘上的。一个临时表只能被创建它的 $session$ 访问，可以与普通表同名。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-日志&#34;&gt;2. 日志&lt;/h2&gt;&#xA;&lt;p&gt;        更新语句的执行过程其实与查询语句一样，但是会涉及日志模块。&lt;br&gt;&#xA;        &lt;code&gt;redo log&lt;/code&gt;记录将要修改的记录，使用了&lt;code&gt;WAL&lt;/code&gt; ( $Write-Ahead\ \ Logging$ ) 技术，即先写日志，再写磁盘。当有一条记录需要更新时，&lt;code&gt;InnoDB&lt;/code&gt;会先把记录写到&lt;code&gt;redo log&lt;/code&gt;中，并更新内存，之后在适当的时候，将这个操作记录更新到磁盘中，往往是在磁盘比较空闲的时候。&lt;br&gt;&#xA;        &lt;code&gt;InnoDB&lt;/code&gt;的&lt;code&gt;redo log&lt;/code&gt;是固定大小的，写到末尾时就循环回到开头重新写。$write\ \ pos$ 是当前记录的位置，随着数据写入后移。$check\ \ point$ 是当前要擦除的位置，在擦除之前要把记录更新到数据文件。$write\ \ pos$ 和 $check\ \ point$ 之间的部分可以记录新的操作。如果之间没有空白部分，需要等待执行记录。&lt;br&gt;&#xA;        &lt;code&gt;InnoDB&lt;/code&gt;通过&lt;code&gt;redo log&lt;/code&gt;，可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，称为 $crash-safe$ 。&lt;br&gt;&#xA;        &lt;code&gt;binlog&lt;/code&gt;与&lt;code&gt;redo log&lt;/code&gt;的区别有：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;redo log&lt;/code&gt;是&lt;code&gt;InnoDB&lt;/code&gt;特有的，&lt;code&gt;binlog&lt;/code&gt;是&lt;code&gt;MySQL&lt;/code&gt;的&lt;code&gt;Server&lt;/code&gt;层实现的；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;redo log&lt;/code&gt;是物理日志，记录对某个数据页的修改；&lt;code&gt;binlog&lt;/code&gt;是逻辑日志，记录语句的原始逻辑；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;redo log&lt;/code&gt;是循环写入的，&lt;code&gt;binlog&lt;/code&gt;是可以追加写入的，即当文件达到一定空间后切换到下一个文件；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;binlog&lt;/code&gt;的应用场景是主从复制和数据恢复；&lt;code&gt;redo log&lt;/code&gt;记录对数据页的修改，&lt;code&gt;InnoDB&lt;/code&gt;使用&lt;code&gt;LSN&lt;/code&gt; ( $Log\ \ Sequence\ \ Number$ ) 进行标记，如果数据页中的&lt;code&gt;LSN&lt;/code&gt;落后于&lt;code&gt;redo log&lt;/code&gt;的&lt;code&gt;LSN&lt;/code&gt;，就通过&lt;code&gt;redo log&lt;/code&gt;恢复数据。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;        每当引擎将新数据更新到内存中时，就会把更新操作记录到&lt;code&gt;redo log&lt;/code&gt;中，此时&lt;code&gt;redo log&lt;/code&gt;处于 $prepare$ 状态。当执行器执行完成后，会生成操作的&lt;code&gt;binlog&lt;/code&gt;。当事务提交之后，引擎会把刚写入的&lt;code&gt;redo log&lt;/code&gt;改成 $commit$ 状态，完成更新。&lt;br&gt;&#xA;        写&lt;code&gt;redo log&lt;/code&gt;的时候，可以通过 $innodb_-flush_-log_-at_-trx_-commit$ 参数设置：&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL索引介绍</title>
      <link>https://z217blog.cn/post/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 04 Mar 2021 22:16:20 +0800</pubDate>
      <guid>https://z217blog.cn/post/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</guid>
      <description>&lt;p&gt;        索引 ( 在&lt;code&gt;MySQL&lt;/code&gt;中也叫做&lt;strong&gt;键&lt;/strong&gt; ( $key$ )) 是存储引擎用于快速找到记录的一种数据结构。索引优化是查询性能优化最有效的手段。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-基础&#34;&gt;1. 基础&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;code&gt;MySQL&lt;/code&gt;中，索引引擎首先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为&lt;code&gt;MySQL&lt;/code&gt;只能高效地使用索引的最左前缀列。&lt;br/&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-类型&#34;&gt;1.1 类型&lt;/h3&gt;&#xA;&lt;p&gt;        索引有很多类型。在&lt;code&gt;MySQL&lt;/code&gt;中，索引是在存储引擎层而不是服务层实现的，所以并没有统一的索引标准。&lt;/p&gt;&#xA;&lt;h4 id=&#34;111-b-tree&#34;&gt;1.1.1 &lt;code&gt;B-Tree&lt;/code&gt;&lt;/h4&gt;&#xA;&lt;p&gt;        如果没有特别指明类型，那么通常所说的索引都是&lt;code&gt;B-Tree&lt;/code&gt;索引，顾名思义，即使用&lt;code&gt;B-Tree&lt;/code&gt;数据结构来存储数据。大多数&lt;code&gt;MySQL&lt;/code&gt;引擎都支持这种索引。不过，底层的存储引擎也可能使用不同的存储结构，例如&lt;code&gt;InnoDB&lt;/code&gt;使用的是&lt;code&gt;B+Tree&lt;/code&gt;。存储引擎以不同的方式使用&lt;code&gt;B-Tree&lt;/code&gt;索引，性能也各有不同，各有优劣。例如，&lt;code&gt;MyISAM&lt;/code&gt;使用前缀压缩技术使得索引更小，但&lt;code&gt;InnoDB&lt;/code&gt;则按照原数据格式进行存储。再如&lt;code&gt;MyISAM&lt;/code&gt;索引通过数据的物理位置引用被索引的行，而&lt;code&gt;InnoDB&lt;/code&gt;则根据主键引用被索引的行。&lt;br/&gt;&#xA;        &lt;code&gt;B-Tree&lt;/code&gt;通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。&lt;code&gt;B-Tree&lt;/code&gt;索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。&lt;br/&gt;&#xA;        &lt;code&gt;B-Tree&lt;/code&gt;索引适用于全键值、键值范围或键值前缀查找。其中键值前缀查找只适用于根据最左前缀的查找。上述的索引对如下类型的查询有效：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全值匹配&lt;/li&gt;&#xA;&lt;li&gt;匹配最左前缀&lt;/li&gt;&#xA;&lt;li&gt;匹配列前缀&lt;/li&gt;&#xA;&lt;li&gt;匹配范围值&lt;/li&gt;&#xA;&lt;li&gt;精确匹配某一列并范围匹配另外一列&lt;/li&gt;&#xA;&lt;li&gt;只访问索引的查询&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        因为索引树的节点是有序的，所以除了按值查找外，索引还可以用于查询中的 $ORDER\ \ BY$ 操作。一般来说，如果&lt;code&gt;B-Tree&lt;/code&gt;可以按照某种方式查找到值，那么也可以按照这种方式用于排序。&lt;/p&gt;&#xA;&lt;h4 id=&#34;12-哈希索引&#34;&gt;1.2 哈希索引&lt;/h4&gt;&#xA;&lt;p&gt;        &lt;strong&gt;哈希索引&lt;/strong&gt; ( $hash\ \ index$ ) 基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，并存储在索引中，同时在哈希表中保存指向每个数据行的指针。在&lt;code&gt;MySQL&lt;/code&gt;中，只有&lt;code&gt;Memory&lt;/code&gt;引擎显式支持哈希索引，同时也是默认索引类型。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。&lt;br/&gt;&#xA;        &lt;code&gt;InnoDB&lt;/code&gt;引擎有一个特殊的功能叫做&lt;strong&gt;自适应哈希索引&lt;/strong&gt; ( $adaptive\ \ hash\ \ index$ )。当&lt;code&gt;InnoDB&lt;/code&gt;注意到某些索引值被使用得非常频繁时，它会在内存中基于&lt;code&gt;B-Tree&lt;/code&gt;索引之上再创建一个哈希索引。&lt;br/&gt;&#xA;        如果存储引擎不支持哈希索引，可以模拟创建哈希索引，即增加一列，存储哈希值。&lt;code&gt;MySQL&lt;/code&gt;提供了 $CRC32$ 函数用于计算哈希值，通过设置触发器，可以在每次插入时自动插入索引。不要使用 $SHA1$ 和 $MD5$ 作为哈希函数，因为这两个函数计算出来的哈希值是非常长的字符串。如果数据表非常大，$CRC32$ 会出现大量哈希冲突，这时也可以考虑自己实现哈希函数。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-优点&#34;&gt;2. 优点&lt;/h2&gt;&#xA;&lt;p&gt;        索引可以让服务器快速地定位到表的指定位置，但并非唯一作用。最常见的&lt;code&gt;B-Tree&lt;/code&gt;索引，按照顺序存储数据，可以用于 $ORDER\ \ BY$ 和 $GROUP\ \ BY$ 操作。利用数据有序的特点，索引有如下三个优点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;减少了服务器需要扫描的数据量；&lt;/li&gt;&#xA;&lt;li&gt;帮助服务器避免排序和临时表；&lt;/li&gt;&#xA;&lt;li&gt;将随机&lt;code&gt;I/O&lt;/code&gt;变为顺序&lt;code&gt;I/O&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        但是索引并不总是最好的工具。对于非常小的表，大部分情况下简单的全表扫描更加高效。而对于中大型表，索引就非常有效。但对于特大型表，建立和使用索引的代价将随之增长，这时候就需要一种可以直接区分出查询需要的数据的技术，例如分区技术。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-索引策略&#34;&gt;3. 索引策略&lt;/h2&gt;&#xA;&lt;h3 id=&#34;31-独立的列&#34;&gt;3.1 独立的列&lt;/h3&gt;&#xA;&lt;p&gt;        如果查询中的列不是独立的，&lt;code&gt;MySQL&lt;/code&gt;就不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。例如：&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL架构介绍</title>
      <link>https://z217blog.cn/post/mysql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 04 Mar 2021 22:16:10 +0800</pubDate>
      <guid>https://z217blog.cn/post/mysql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</guid>
      <description>&lt;h2 id=&#34;1-mysql逻辑架构&#34;&gt;1. &lt;code&gt;MySQL&lt;/code&gt;逻辑架构&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://z217blog.cn/image/2021-03-04-01.png&#34; alt=&#34;MySQL服务器逻辑架构图&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最上层服务并不是&lt;code&gt;MySQL&lt;/code&gt;独有，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构，比如连接处理、授权认证、安全等；&lt;/li&gt;&#xA;&lt;li&gt;第二层架构是&lt;code&gt;MySQL&lt;/code&gt;比较有意思的部分。大多数&lt;code&gt;MySQL&lt;/code&gt;的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等；&lt;/li&gt;&#xA;&lt;li&gt;第三层包含了存储引擎。存储引擎负责&lt;code&gt;MySQL&lt;/code&gt;中数据的存储和提取。存储引擎多种多样，服务器通过&lt;code&gt;API&lt;/code&gt;与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎&lt;code&gt;API&lt;/code&gt;包含了几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析&lt;code&gt;SQL&lt;/code&gt; ( &lt;code&gt;InnoDB&lt;/code&gt;会解析外键定义 ) ，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;11-连接管理与安全性&#34;&gt;1.1 连接管理与安全性&lt;/h3&gt;&#xA;&lt;p&gt;        每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个&lt;code&gt;CPU&lt;/code&gt;核心或者&lt;code&gt;CPU&lt;/code&gt;中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。在连接建立后，服务器会验证客户端是否具有执行某个特定查询的权限。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-优化与执行&#34;&gt;1.2 优化与执行&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;code&gt;MySQL&lt;/code&gt;会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准。&lt;br/&gt;&#xA;        对于 $SELECT$ 语句，在解析查询之前，服务器会先检查查询缓存 ( $Query\ \ Cache$ )，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-并发控制&#34;&gt;2. 并发控制&lt;/h2&gt;&#xA;&lt;p&gt;        在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，&lt;code&gt;MySQL&lt;/code&gt;会通过锁定防止其他用户读取统一数据。大多数时候，&lt;code&gt;MySQL&lt;/code&gt;的内部管理都是透明的。&lt;br/&gt;&#xA;        所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。大多数商业数据库系统没有提供更多的选择，一般都是在表上施加&lt;strong&gt;行级锁&lt;/strong&gt; ( $row-level\ \ lock$ )，并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能地提供更好的性能。而&lt;code&gt;MySQL&lt;/code&gt;则提供了多种选择。每种&lt;code&gt;MySQL&lt;/code&gt;存储引擎都可以实现自己的锁策略和锁粒度。在存储引擎的设计中，锁管理是个非常重要的决定。将锁粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能，但同时却会失去对另外一些应用场景的良好支持。好在&lt;code&gt;MySQL&lt;/code&gt;支持多个存储引擎的架构，所以不需要单一的通用解决方案。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;表锁&lt;/strong&gt; ( $table\ \ lock$ )：表锁是&lt;code&gt;MySQL&lt;/code&gt;中最基本的锁策略，并且是开销最小的策略，它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他的读取的用户才能获得读锁，读锁之间是不相互阻塞的。尽管存储引擎可以管理自己的锁，但&lt;code&gt;MySQL&lt;/code&gt;本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如 $ALTER\ \ TABLE$ 之类的语句使用表锁，而忽略存储引擎锁机制；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;行级锁&lt;/strong&gt; ( $row\ \ lock$ )：行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。众所周知，在&lt;code&gt;InnoDB&lt;/code&gt;和&lt;code&gt;XtraDB&lt;/code&gt;，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而&lt;code&gt;MySQL&lt;/code&gt;服务器层没有实现。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;3-事务&#34;&gt;3. 事务&lt;/h2&gt;&#xA;&lt;p&gt;        事务就是一组原子性的&lt;code&gt;SQL&lt;/code&gt;查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt; ( $atomicity$ )：一个事务必须被视为一个不可分割的最小工作单元；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt; ( $consistency$ )：数据库总是从一个一致性的状态转换到另外一个一致性的状态；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;隔离性&lt;/strong&gt; ( $isolation$ )：一个事务所做的修改在最终提交以前，对其他事务是不可见的；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;持久性&lt;/strong&gt; ( $durability$ )：一旦事务提交，其所做的修改就会永久保存到数据库中。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        一个运行良好的事务处理系统，必须满足&lt;code&gt;ACID&lt;/code&gt;特性。但在应用逻辑中，要想实现这一点很困难，甚至可以说是不可能完成的任务。一个兼容&lt;code&gt;ACID&lt;/code&gt;的数据库系统，需要做很多复杂但可能用户并没有觉察到的工作。&lt;/p&gt;&#xA;&lt;h3 id=&#34;31-隔离级别&#34;&gt;3.1 隔离级别&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;READ UNCOMMITTED&lt;/code&gt; ( &lt;strong&gt;未提交读&lt;/strong&gt; )：事务中的修改，即使没有提交，对其他事务也都是可见的。事务读取未提交的数据称为&lt;strong&gt;脏读&lt;/strong&gt; ( $Dirty\ \ Read$ )；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;READ COMMITTED&lt;/code&gt; ( &lt;strong&gt;提交读&lt;/strong&gt; )：大多数数据库系统的默认隔离级别都是提交读，但&lt;code&gt;MySQL&lt;/code&gt;不是。一个事务开始时，只能看到已经提交的事务所做的修改。这个级别有时候也叫做&lt;em&gt;&lt;strong&gt;不可重复读&lt;/strong&gt;&lt;/em&gt; ( $nonrepeatable\ \ read$ )，因为两次执行同样的查询，可能会得到不一样的结果；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;REPEATABLE READ&lt;/code&gt; ( &lt;strong&gt;可重复读&lt;/strong&gt; )：该级别解决了脏读问题，保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，还是无法解决&lt;strong&gt;幻读&lt;/strong&gt; ( $Phantom\ \ Read$ ) 问题。幻读指的是当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录。可重复读是&lt;code&gt;MySQL&lt;/code&gt;的默认事务隔离级别；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SERIALIZABLE&lt;/code&gt; ( &lt;strong&gt;可串行化&lt;/strong&gt; )：通过强制事务串行执行，可以避免幻读问题。但是由于会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁竞争问题。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;32-死锁&#34;&gt;3.2 死锁&lt;/h3&gt;&#xA;&lt;p&gt;        为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如&lt;code&gt;InnoDB&lt;/code&gt;存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。还有一种解决方式，就是当查询的时间达到等待超时的设定后放弃锁请求，这种方式通常来说不太好。&lt;code&gt;InnoDB&lt;/code&gt;目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。&lt;br/&gt;&#xA;        锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，但有些完全是由于存储引擎的实现方式导致的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库系统（9）：事务管理</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 13 Jun 2020 17:55:26 +0000</pubDate>
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;p&gt;        &lt;code&gt;DBMS&lt;/code&gt;应该具备的功能中，有三个密切相关的功能，用以保证数据库的可靠性和一致性，即事务支持、并发控制服务和恢复服务。它们之间是相互依赖的。并发控制和恢复主要用于保护数据库，避免数据库发生数据不一致或者数据丢失。许多&lt;code&gt;DBMS&lt;/code&gt;都允许用户对数据库进行并发操作。如果对这些操作不加控制，对数据库的访问将互相干扰，使得数据库出现不一致的情况。为了解决这个问题，&lt;code&gt;DBMS&lt;/code&gt;实现了&lt;strong&gt;并发控制&lt;/strong&gt; ( $concurrency\ \ control$ ) 协议，来阻止数据库访问之间的相互干扰。&lt;strong&gt;数据库恢复&lt;/strong&gt; ( $Database\ \ recovery$ ) 是指在故障以后将数据库还原到正确状态的过程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-支持事务处理&#34;&gt;1. 支持事务处理&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;strong&gt;事务&lt;/strong&gt; ( $Transaction$ ) 是由单个用户或者应用程序执行的，完成读取或者更新数据库内容的一个或者一串操作。事务是数据库的&lt;strong&gt;逻辑操作单位&lt;/strong&gt; ( $logical\ \ unit\ \ of\ \ work$ ) 。它可以是整个程序、部分程序或者一条命令，也可以是涉及数据库的任意多个操作。从数据库的角度来看，应用程序的一次执行就是一个事务或者多个事务，若看成多个事务，在事务与事务之间只会出现非数据库操作。复杂的事务由很多操作构成。若并非所有操作都被执行，那么可能会出现&lt;strong&gt;不一致状态&lt;/strong&gt; ( $inconsistent\ \ state$ ) 。在事务处理过程中，尽管我们允许数据库的一致性遭到暂时破坏，但是事务应该总是能将数据库从一种一致的状态转移到另一种一致的状态。&lt;br&gt;&#xA;        事务可能有以下两种结果中的一种。如果执行成功，也就是说事务最终被&lt;strong&gt;提交&lt;/strong&gt; ( $committed$ )，数据库也将到达一种新的一致状态。另一种情况下，事务没有执行成功，则会被&lt;strong&gt;撤销&lt;/strong&gt; ( $aborted$ )。如果事务被撤销，则数据库必须要还原到事务开始之前的一致的状态。我们称这样的事务被&lt;strong&gt;回滚&lt;/strong&gt; ( $rolled\ \ back$ ) /&lt;strong&gt;撤销&lt;/strong&gt; ( $undone$ )。已经提交的事务无法撤销。如果发现已提交的事务存在错误，必须执行另一个&lt;strong&gt;补偿事务&lt;/strong&gt; ( $compensating\ \ transaction$ ) 来消除该事务已经产生的影响。&lt;br&gt;&#xA;        &lt;code&gt;DBMS&lt;/code&gt;无法得知哪些更新操作将被组合在一起以构成一个独立的逻辑事务。因此很多数据操作语言中都使用关键字 $BEGIN$, $TRANSACTION$, $COMMIT$, $ROLLBACK$ 来划定界限。如果不使用，通常会将整个程序视为一个事务。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://z217blog.cn/image/2020-06-13-1.png&#34; alt=&#34;事务的状态转移图&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-事务的性质&#34;&gt;1.1 事务的性质&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt; ( $Atomicity$ )：事务是一个不可分割的单元，要么全执行，要么全不执行。事务的原子性由&lt;code&gt;DBMS&lt;/code&gt;的恢复子系统负责保证。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt; ( $Consistency$ )：事务必须将数据库从一种一致的状态转换到另一种一致的状态。事务的一致性是由&lt;code&gt;DBMS&lt;/code&gt;和应用程序的开发者共同保证的。&lt;code&gt;DBMS&lt;/code&gt;可以通过强制实施所有在数据库模式中定义的约束（如完整性约束和企业自定义约束）来保证一致性。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;隔离性&lt;/strong&gt; ( $Isolation$ )：事务的执行是相互独立的，即未完成事务的中间结果对其他事务来说应该是不可见的。事务的隔离性由并发控制子系统负责保证。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;持久性&lt;/strong&gt; ( $Durability$ )：成功完成的事务的结果要永久地记录在数据库中。事务的持久性由恢复子系统负责保证。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;12-数据库体系结构&#34;&gt;1.2 数据库体系结构&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://z217blog.cn/image/2020-06-13-2.png&#34; alt=&#34;DBMS事务子系统&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库系统（8）：规范化</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/</link>
      <pubDate>Fri, 22 May 2020 16:13:29 +0000</pubDate>
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/</guid>
      <description>&lt;p&gt;        &lt;strong&gt;规范化&lt;/strong&gt; ( $Normalization$ ) 是一种数据库设计技术，从分析属性之间的联系入手。规范化使用一系列测试，描述为&lt;strong&gt;范式&lt;/strong&gt; ( $normal\ \ forms$ ) 帮助我们确定这些属性的最佳组合，最终生成一组适当关系。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-目的&#34;&gt;1. 目的&lt;/h2&gt;&#xA;&lt;p&gt;        规范化的目的是确定一组合适的关系以支持企业的数据需求。该关系具有以下性质：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;属性的个数最少，且是必需的&lt;/li&gt;&#xA;&lt;li&gt;具有紧密逻辑联系，描述为&lt;strong&gt;函数依赖&lt;/strong&gt; ( $functional\ \ dependency$ ) 的所有属性均在一个关系中&lt;/li&gt;&#xA;&lt;li&gt;最少的冗余，即每个属性仅出现一次，除了作为外键的属性，因为连接相关关系必须用到外键&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        具有一组合适的关系，数据库会易于用户访问，数据易于维护，在计算机上也会占有较小的存储空间。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-支持&#34;&gt;2. 支持&lt;/h2&gt;&#xA;&lt;p&gt;        规范化有两种使用方法。方法 $1$ 将规范化视为一种&lt;strong&gt;自下而上&lt;/strong&gt; ( $bottom-up$ ) 的独立的数据库设计技术。方法 $2$ 将规范化作为一种确认技术使用，即用规范化检验关系的结构，而这些关系的建立可能采用自上而下的方法，如&lt;code&gt;ER&lt;/code&gt;建模等。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-数据冗余与更新异常&#34;&gt;3. 数据冗余与更新异常&lt;/h2&gt;&#xA;&lt;p&gt;        关系数据库设计的一个目的就是将属性组合成关系时保证最少的数据冗余。当然，关系数据库的运行也依赖于一定的数据冗余的存在，一般是以主键或者候选键的多个副本的形式出现，作为外键表示数据间联系。存在冗余数据的关系可能存在一些问题，如&lt;strong&gt;更新异常&lt;/strong&gt; ( $update\ \ anomalies$ )。更新异常又可分为插入异常、删除异常和修改异常。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://z217blog.cn/image/2020-05-22-1.png&#34; alt=&#34;存在数据冗余的表&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;        $Staff$ 和 $Branch$ 是不存在数据冗余的两个表。$StaffBranch$ 是将上两个表合起来的存在数据冗余的表，同一个分公司的信息会重复出现。&lt;/p&gt;&#xA;&lt;h3 id=&#34;31-插入异常&#34;&gt;3.1 插入异常&lt;/h3&gt;&#xA;&lt;p&gt;        插入异常主要有两类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在向 $StaffBranch$ 中插入新员工时，若同一家分公司信息不同，则会产生一致性问题；&lt;/li&gt;&#xA;&lt;li&gt;在向 $StaffBranch$ 中插入新的分公司时，由于没有员工，因此员工信息都应设为 $null$ 。但是主键 $staffNo$ 不能为空，否则会违反实体完整性约束。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;32-删除异常&#34;&gt;3.2 删除异常&lt;/h3&gt;&#xA;&lt;p&gt;        从 $StaffBranch$ 中删除元组时，若该元组中的员工信息是某个分公司的最后的员工，则该分公司的信息也会被删除。&lt;/p&gt;&#xA;&lt;h3 id=&#34;33-修改异常&#34;&gt;3.3 修改异常&lt;/h3&gt;&#xA;&lt;p&gt;        当要修改 $StaffBranch$ 中某个分公司的属性值时，必须依次修改所有包含该分公司信息的元组。&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库系统（7）：ER模型</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 21 May 2020 15:51:36 +0000</pubDate>
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;p&gt;        &lt;code&gt;ER&lt;/code&gt;模型是一种&lt;strong&gt;自上而下&lt;/strong&gt; ( $top-down$ ) 的数据库设计方法，该方法首先确定那些被称为实体的重要数据和这些数据之间的联系，实体和联系时&lt;code&gt;ER&lt;/code&gt;模式中必备的元素。然后添加更多的细节信息，如属性、约束等。&lt;br&gt;&#xA;        &lt;strong&gt;统一建模语言&lt;/strong&gt; ( $Unified\ \ Modeling\ \ Language$, $UML$ ) 是软件工程项目的工业标准建模语言，我们使用&lt;code&gt;UML&lt;/code&gt;的符号集来绘制&lt;code&gt;ER&lt;/code&gt;模型。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-实体类型&#34;&gt;1 实体类型&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;strong&gt;实体类型&lt;/strong&gt; ( $Entity\ \ types$ ) 是被企事业单位认可的、能够独立存在的一组具有相同属性的对象，是&lt;code&gt;ER&lt;/code&gt;模型的基本概念。实体类型既可以是物理 ( 真实 ) 存在的，也可以是概念 ( 抽象 ) 存在的对象。&lt;strong&gt;实体出现&lt;/strong&gt; ( $entity\ \ occurrence$ ) 是实体类型中可唯一标识的一个对象。在没有歧义的时候，实体类型和实体出现都可以直接简称为实体。&lt;br&gt;&#xA;        在&lt;code&gt;UML&lt;/code&gt;中，实体类型通过一个标有名字的矩形标识，每个实体名字的首字母是大写的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://z217blog.cn/image/2020-05-21-1.png&#34; alt=&#34;实体&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-联系类型&#34;&gt;2. 联系类型&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;strong&gt;联系类型&lt;/strong&gt; ( $Relationship\ \ types$ ) 是实体类型间一组有意义的关联。每个联系类型都被赋予一个能够描述其功能的名字。&lt;strong&gt;联系出现&lt;/strong&gt; ( $Relationship\ \ occurrence$ ) 是由参与该联系的各个实体类型的一个出现组成的可被唯一标识的关联。&lt;br&gt;&#xA;        在&lt;code&gt;UML&lt;/code&gt;中，每个联系类型都表现为用线将相关的实体类型联系起来，并在线上标上联系的名字，通常使用一个动词或者动词短语命名。同样的，首字母也应该大写。一个联系还要标识方向，意味着这个联系仅在一个方向上有意义。可以在名字旁边添加一个箭头符号，如 $\blacktriangleleft$ 来标识方向。当我们要表示 $A\ \ Has\ \ B$ ( $A$，$B$ 为实体，$Has$ 为联系类型 ) 时可以用如下方法：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://z217blog.cn/image/2020-05-21-2.png&#34; alt=&#34;联系&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库系统（6）：SQL数据定义</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Wed, 20 May 2020 16:46:30 +0000</pubDate>
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</guid>
      <description>&lt;h2 id=&#34;1-数据类型&#34;&gt;1. 数据类型&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-标识符&#34;&gt;1.1 标识符&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;code&gt;SQL&lt;/code&gt;&lt;strong&gt;标识符&lt;/strong&gt; ( $identifier$ ) 用于表示数据库中的对象，如表名、列名、视图名等。用户定义标识符所用的字符必须是&lt;strong&gt;字符集&lt;/strong&gt; ( $character\ \ set$ ) 中存在的。默认的字符集包括 $A-Z$, $a-z$ 和 $_$ ，也可以另外指定其他字符集。标识符的限制有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不能长于 $128$ 个字符（在一些方言中会更短）&lt;/li&gt;&#xA;&lt;li&gt;必须以字母开头&lt;/li&gt;&#xA;&lt;li&gt;不能有空格&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;12-数据类型&#34;&gt;1.2 数据类型&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;数据类型&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;声明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;布尔型&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$BOOLEAN$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;字符型&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$CHAR$, $VARCHAR$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;位类型&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$BIT$, $BIT\ \ VARYING$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;定点数型&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$NUMERIC$, $DECIMAL$, $INTEGER$, $SMALLINT$, $BIGINT$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;浮点数型&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$FLOAT$, $REAL$, $DOUBLE\ \ PRECISION$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;日期时间型&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$DATE$, $TIME$, $TIMESTAMP$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;间隔型&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$INTERVAL$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;大对象型&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;$CHARACTER\ \ LARGE\ \ OBJECT$, $BINARY\ \ LARGE\ \ OBJECT$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;121-布尔型&#34;&gt;1.2.1 布尔型&lt;/h4&gt;&#xA;&lt;p&gt;        布尔型包括 $TRUE$ / $FALSE$ 两个值，如果没有 $NOT\ \ NULL$ 约束，也可以为 $NULL$ 。$TRUE$ 大于 $FALSE$ ，对于涉及 $NULL$ 的比较，结果都是 $UNKNOWN$ 。&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库系统（5）：SQL数据操作</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 20 May 2020 14:17:14 +0000</pubDate>
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;h2 id=&#34;1-sql简介&#34;&gt;1. &lt;code&gt;SQL&lt;/code&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;code&gt;SQL&lt;/code&gt;是关系模型发展过程中出现的一种特殊语言，已经成为了标准的关系数据库语言。&lt;code&gt;SQL&lt;/code&gt;是&lt;strong&gt;面向转换语言&lt;/strong&gt; ( $transform-oriented\ \ language$ ) 的例子，将输入关系转换为所需的输出关系，包括两个主要部分：&lt;code&gt;DML&lt;/code&gt;和&lt;code&gt;DDL&lt;/code&gt;。&lt;br&gt;&#xA;        &lt;code&gt;SQL&lt;/code&gt;具有许多实现版本，每个实现称为&lt;strong&gt;方言&lt;/strong&gt; ( $dialect$ ) ，供应商在标准之外提供的特性称为&lt;strong&gt;扩展&lt;/strong&gt; ( $extensions$ )。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-优点&#34;&gt;1.1 优点&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;满足数据库语言的思想&lt;/li&gt;&#xA;&lt;li&gt;易于学习&lt;/li&gt;&#xA;&lt;li&gt;结构简洁、轻便&lt;/li&gt;&#xA;&lt;li&gt;存在&lt;code&gt;SQL&lt;/code&gt;标准&lt;/li&gt;&#xA;&lt;li&gt;可以通过终端或者嵌入式访问&lt;/li&gt;&#xA;&lt;li&gt;所有人都可以使用&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;12-缺点&#34;&gt;1.2 缺点&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;混合了编程规范和嵌入式访问&lt;/li&gt;&#xA;&lt;li&gt;缺乏正交性，有多种表达方式&lt;/li&gt;&#xA;&lt;li&gt;语言越来越复杂和庞大&lt;/li&gt;&#xA;&lt;li&gt;聚合函数中对空的处理问题&lt;/li&gt;&#xA;&lt;li&gt;结果表中可以有重复元组，对表中的行和列都强加了一个顺序&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;2-sql命令&#34;&gt;2. &lt;code&gt;SQL&lt;/code&gt;命令&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;code&gt;SQL&lt;/code&gt;语言包括&lt;strong&gt;保留字&lt;/strong&gt; ( $reserved\ \ words$ ) 和&lt;strong&gt;用户自定义字&lt;/strong&gt; ( $user-defined\ \ words$ ) 。保留字是&lt;code&gt;SQL&lt;/code&gt;语言的固定部分，有固定含义。用户自定义字由用户定义，用于表示表、列、视图和索引等数据库对象的名称。虽然标准并没有要求，但是&lt;code&gt;SQL&lt;/code&gt;的许多实现版本要求用句子终结符来表示&lt;code&gt;SQL&lt;/code&gt;语句的结束。&lt;code&gt;SQL&lt;/code&gt;语句的多数组成部分是不区分大小写的，除了字符数据常量外。&lt;/p&gt;&#xA;&lt;h3 id=&#34;21-数据操作&#34;&gt;2.1 数据操作&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;code&gt;DML&lt;/code&gt;语句有以下几种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$SELECT$,&lt;/li&gt;&#xA;&lt;li&gt;$INSERT$,&lt;/li&gt;&#xA;&lt;li&gt;$UPDATE$,&lt;/li&gt;&#xA;&lt;li&gt;$DELETE$.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        &lt;strong&gt;常量&lt;/strong&gt; ( $Literals$ ) 是指&lt;code&gt;SQL&lt;/code&gt;语句中的&lt;strong&gt;不变量&lt;/strong&gt; ( $constants$ )。不同的数据具有不同的常量形式，所有的非数值型数据必须使用引号，而所有的非数值型数据不能使用引号。&lt;/p&gt;&#xA;&lt;h3 id=&#34;22-查询&#34;&gt;2.2 查询&lt;/h3&gt;&#xA;&lt;p&gt;        查询形式：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;DISTINCT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ALL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*|&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;columnExpression&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;AS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]][...]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TableName&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;alias&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][...]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;GROUP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;coulumnList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;HAVING&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ORDER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;columnList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;        处理顺序：&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库系统（4）：关系代数</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</link>
      <pubDate>Sun, 17 May 2020 16:05:13 +0000</pubDate>
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</guid>
      <description>&lt;p&gt;        &lt;strong&gt;关系代数&lt;/strong&gt; ( $Relational\ \ Algebra$ ) 可以看成一种过程式语言，可用于构造新关系。关系代数是一种纯理论语言，它定义了一些操作，运用这些操作可以从一个或多个关系中得到另一个关系而不改变原关系。关系代数的一个表达式可以嵌套另一个表达式，这种性质称为&lt;strong&gt;闭包&lt;/strong&gt; ( $closure$ )，即关系在关系代数下是封闭的。&lt;br&gt;&#xA;        关系代数是一种每次一关系/集合的语言，即用一条不带循环的语句处理，结果也是由所有元组组成的整个关系。关系代数中包含了许多运算，其中五个基本运算是&lt;strong&gt;选择&lt;/strong&gt; ( $Selection$ ) 、&lt;strong&gt;投影&lt;/strong&gt; ( $Projection$ ) 、&lt;strong&gt;笛卡尔乘积&lt;/strong&gt; ( $Cartesian\ \ product$ ) 、&lt;strong&gt;集合并&lt;/strong&gt; ( $Union$ ) 、&lt;strong&gt;集合差&lt;/strong&gt; ( $Set\ \ difference$ ) 。选择和投影都是一元运算，其他的运算则是二元运算。除此之外，还有&lt;strong&gt;连接&lt;/strong&gt; ( $Join$ ) 、&lt;strong&gt;集合交&lt;/strong&gt; ( $Intersection$ ) 、&lt;strong&gt;除&lt;/strong&gt; ( $Division$ ) 等，它们都能通过五个基本运算表示。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-一元运算&#34;&gt;1. 一元运算&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-选择&#34;&gt;1.1 选择&lt;/h3&gt;&#xA;&lt;div&gt;&#xA;$$&#xA;\sigma_{predicate}(R)&#xA;$$&#xA;&lt;/div&gt;&#xA;&lt;p&gt;        作用于单个关系 $R$ ，得到一个新关系，该关系由满足谓词 $predicate$ 的元组组成。可以理解为从表中选出符合条件的行构成一个新表。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-投影&#34;&gt;1.2 投影&lt;/h3&gt;&#xA;&lt;div&gt;&#xA;$$&#xA;\prod\nolimits_{a_1,a_2,...,a_n}(R)&#xA;$$&#xA;&lt;/div&gt;&#xA;&lt;p&gt;        作用于单个关系 $R$ ，得到一个由 $R$ 的垂直子集构成的新关系，该子集抽取 $R$ 中指定属性上的值并去掉重复元组。可以理解为从表中选出指定的列构成一个新表。&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库系统（3）：关系模型</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 15 May 2020 13:08:11 +0000</pubDate>
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;p&gt;        在目前使用的数据处理软件中，&lt;strong&gt;关系数据库管理系统&lt;/strong&gt; ( $Relational\ \ Database\ \ Management\ \ System$, $RDBMS$ ) 占据了统治地位。&lt;code&gt;RDBMS&lt;/code&gt;基于关系数据模型。在关系模型中，所有数据逻辑上被组织成关系（表）结构。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-基本术语&#34;&gt;1. 基本术语&lt;/h2&gt;&#xA;&lt;p&gt;        关系模型基于数学中的&lt;strong&gt;关系&lt;/strong&gt; ( $relation$ )。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-关系数据结构&#34;&gt;1.1 关系数据结构&lt;/h3&gt;&#xA;&lt;h4 id=&#34;111-关系&#34;&gt;1.1.1 关系&lt;/h4&gt;&#xA;&lt;p&gt;        关系是由行和列组成的表。在关系模型中，用关系保存数据库所描述对象的信息，关系用二维表表示。用户主要接触的就是表，但这只限于逻辑结构，即外部层和概念层。对于物理结构，由于是通过多种存储结构实现的，因此并不适用。&lt;/p&gt;&#xA;&lt;h4 id=&#34;112-属性&#34;&gt;1.1.2 属性&lt;/h4&gt;&#xA;&lt;p&gt;        &lt;strong&gt;属性&lt;/strong&gt; ( $Attribute$ ) 是关系中命名的列。在关系的二维表中，每一行对应一个单独的记录，每一列则对应一个属性。&lt;/p&gt;&#xA;&lt;h4 id=&#34;113-域&#34;&gt;1.1.3 域&lt;/h4&gt;&#xA;&lt;p&gt;        &lt;strong&gt;域&lt;/strong&gt; ( $Domain$ ) 是一个或多个属性的取值集合，必须给每一个属性定义一个域。不同属性的域可以互不相同，也可以共用。通过使用域，用户可以集中定义属性的取值范围和含义。&lt;/p&gt;&#xA;&lt;h4 id=&#34;114-元组&#34;&gt;1.1.4 元组&lt;/h4&gt;&#xA;&lt;p&gt;        &lt;strong&gt;元组&lt;/strong&gt; ( $Tuple$ ) 是关系中的行。关系的结构、域说明以及所有取值约束统称为关系的&lt;strong&gt;内涵&lt;/strong&gt; ( $intension$ )。它通常是固定的，除非关系的意义改变，需要加入新的属性。元组的集合称为&lt;strong&gt;外延&lt;/strong&gt; ( $extension$ ) /&lt;strong&gt;状态&lt;/strong&gt; ( $state$ )，它经常发生改变。&lt;/p&gt;&#xA;&lt;h4 id=&#34;115-维数&#34;&gt;1.1.5 维数&lt;/h4&gt;&#xA;&lt;p&gt;        &lt;strong&gt;维数&lt;/strong&gt; ( $Degree$ ) 是关系所包含的属性个数。只有一个属性的关系称为一元关系或者一元组，两个属性的关系称为二元关系，以此类推，$n$ 个属性的关系称为 $n$ 元组。维数是内含的性质之一。&lt;/p&gt;&#xA;&lt;h4 id=&#34;116-基数&#34;&gt;1.1.6 基数&lt;/h4&gt;&#xA;&lt;p&gt;        &lt;strong&gt;基数&lt;/strong&gt; ( $Cardinality$ ) 是关系所包含的元组的个数。基数是外延的性质之一。&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库系统（2）：数据库环境</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 14 May 2020 11:09:00 +0000</pubDate>
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/</guid>
      <description>&lt;h2 id=&#34;1-ansi-sparc三层体系结构&#34;&gt;1. &lt;code&gt;ANSI-SPARC&lt;/code&gt;三层体系结构&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;strong&gt;三层体系结构&lt;/strong&gt; ( $Three\ \ Level\ \ Architecture$ )，包括&lt;strong&gt;外部层&lt;/strong&gt; ( $External$ )、&lt;strong&gt;概念层&lt;/strong&gt; ( $Conceptual$ ) 和&lt;strong&gt;内部层&lt;/strong&gt; ( $Internal$ )。用户从外部层观察数据，&lt;code&gt;DBMS&lt;/code&gt;和操作系统从内部层观察数据。在内部层，数据使用定义的数据结构和文件组织方法进行存储。概念层则提供内部层和外部层的&lt;strong&gt;映射&lt;/strong&gt; ( $Mapping$ ) 以及必要的&lt;strong&gt;独立性&lt;/strong&gt; ( $Independence$ )。三层体系结构的目的是将用户的数据库视图与数据库的物理描述分离。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-外部层&#34;&gt;1.1 外部层&lt;/h3&gt;&#xA;&lt;p&gt;        外部层是数据库的用户视图，这一层描述数据库中与用户相关的部分。对于每一个用户，数据库中都存储着其对用的视图。并且对于同一个数据，在不同的视图中可能有着不同的表达方式。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-概念层&#34;&gt;1.2 概念层&lt;/h3&gt;&#xA;&lt;p&gt;        概念层是数据库的整体视图，这一层描述哪些数据存储在数据库中，以及这些数据之间的联系。概念层描述：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;所有的实体、实体的属性和实体间的联系&lt;/li&gt;&#xA;&lt;li&gt;数据的约束&lt;/li&gt;&#xA;&lt;li&gt;数据的语义信息&lt;/li&gt;&#xA;&lt;li&gt;安全性和完整性信息&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;        概念层支持每一个外部视图，凡是用户可访问的数据必定包含在概念层或者由概念层导出。&lt;/p&gt;&#xA;&lt;h3 id=&#34;13-内部层&#34;&gt;1.3 内部层&lt;/h3&gt;&#xA;&lt;p&gt;        内部层是数据库在计算机上的物理表示，这一层描述数据是如何存储在数据库中的。内部层与如下工作相关：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据和索引的存储空间分配&lt;/li&gt;&#xA;&lt;li&gt;存储记录的描述&lt;/li&gt;&#xA;&lt;li&gt;存储记录&lt;/li&gt;&#xA;&lt;li&gt;数据压缩和加密&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;        在内部层之下是&lt;strong&gt;物理层&lt;/strong&gt; ( $Physical\ \ Level$ ) ，物理层可能在&lt;code&gt;DBMS&lt;/code&gt;的指导下受操作系统的控制。&lt;/p&gt;&#xA;&lt;h3 id=&#34;14-模式映射和实例&#34;&gt;1.4 模式、映射和实例&lt;/h3&gt;&#xA;&lt;p&gt;        对数据库的整体描述称为&lt;strong&gt;数据库模式&lt;/strong&gt; ( $Database\ \ Schema$ ) 。在数据库中存在三种不同类型的，在外部层有若干&lt;strong&gt;外部模式&lt;/strong&gt; ( $External\ \ Schema$ ) /&lt;strong&gt;子模式&lt;/strong&gt; ( $Subschema$ )，与不同的数据视图对应。在概念层有&lt;em&gt;&lt;strong&gt;概念模式&lt;/strong&gt;&lt;/em&gt; ( $Conceptual\ \ Schema$ )，描述所有实体、属性和联系及其之间的完整性约束。在内部层，有&lt;strong&gt;内部模式&lt;/strong&gt; ( $Internal\ \ Schema$ )，是内部模型的完整描述，包括存储记录的定义、表示方法、数据域，必要时还有所使用的索引和散列方案。一个数据库可以有多个外部模式，但只能有一个概念模式和内部模式。&lt;br&gt;&#xA;        例如，对于一个数据库，其内部存储两张表 $A$, $B$ ，这是其概念模式；而 $A$, $B$ 内部行列的定义以及约束等是其内部模式；查询 $A$, $B$ 所使用的视图 $V1$, $V2&amp;hellip;$ 是其外部模式。&lt;br&gt;&#xA;        &lt;code&gt;DBMS&lt;/code&gt;负责着三类模式之间的映射。概念模式通过概念层到内部层的映射与内部模式关联，每一个外部模式通过外部层到概念层的映射与概念模式关联。&lt;br&gt;&#xA;        数据库模式是在数据库设计过程中定义的，不会轻易改变。数据库中的数据是一个&lt;strong&gt;数据库实例&lt;/strong&gt; ( $Database\ \ Instance$ )，许多数据库实例可以与相同的数据库模式对应。模式有时称为数据库的&lt;strong&gt;内含&lt;/strong&gt; ( $Intension$ )，实例称为数据库的&lt;strong&gt;外延&lt;/strong&gt; ( $Extension$ ) /&lt;strong&gt;状态&lt;/strong&gt; ( $State$ )。&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库系统（1）：数据库简介</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 13 May 2020 14:23:36 +0000</pubDate>
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;h2 id=&#34;1-基于文件的系统&#34;&gt;1. 基于文件的系统&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;strong&gt;基于文件的系统&lt;/strong&gt; ( $Traditional\ \ File-Based\ \ Systems$ ) 是一组为终端用户提供服务的应用程序，每一个程序定义和管理它自己的数据。相较于使用纸质文件进行管理的手工文件系统，基于文件的系统更加高效。但是它未能集中存储组织机构的运行数据，而是采用了分散的方法，即每一个部门在&lt;strong&gt;数据处理&lt;/strong&gt; ( $DP$ ) 人员的帮助下存储和控制它们的数据。通过编写应用程序来管理和查询数据，具有&lt;strong&gt;程序-数据依赖性&lt;/strong&gt; ( $Program-data\ \ Dependence$ ) 。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-术语&#34;&gt;1.1 术语&lt;/h3&gt;&#xA;&lt;p&gt;        &lt;strong&gt;文件&lt;/strong&gt; ( $File$ ) 是一些&lt;strong&gt;记录&lt;/strong&gt; ( $Records$ ) 的简单集合，这些记录中包含逻辑上相关的数据。每一条记录包含一组逻辑上相关的一个或多个&lt;strong&gt;数据项/域&lt;/strong&gt; ( $Fields$ ) 。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-局限性&#34;&gt;1.2 局限性&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据被分离和孤立&lt;/strong&gt;&lt;br&gt;&#xA;数据被孤立在分离的文件中，如果要访问处于不同文件之间的数据，需要创建一个临时文件。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据存在冗余&lt;/strong&gt;&lt;br&gt;&#xA;由于文件间的分离，有时需要重复记录一些数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据存在依赖性&lt;/strong&gt;&lt;br&gt;&#xA;数据文件的物理结构和存储方式是由应用程序定义的，很难做出改变，也即程序-数据依赖性。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;文件格式不相容&lt;/strong&gt;&lt;br&gt;&#xA;文件结构嵌入应用程序，因此由应用程序语言决定。难以兼容其他使用不同语言的文件结构。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;需要不断更改应用程序&lt;/strong&gt;&lt;br&gt;&#xA;完全依赖于开发人员，要求开发人员以编程方式实现所有查询和表。如果查询需求发生了变化，需要重新编写程序或更改文件。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;2-数据库方法&#34;&gt;2. 数据库方法&lt;/h2&gt;&#xA;&lt;p&gt;        基于文件的系统存在许多问题，总结原因是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据内嵌应用程序&lt;/li&gt;&#xA;&lt;li&gt;无法实现程序规定之外的操作&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;        因此我们需要一种更加高效的方法，&lt;strong&gt;数据库&lt;/strong&gt; ( $Database$ ) 和 &lt;strong&gt;数据库管理系统&lt;/strong&gt; ( $Database\ \ Management\ \ System,\ \ DBMS$ ) 应运而生。&lt;/p&gt;&#xA;&lt;h3 id=&#34;21-数据库&#34;&gt;2.1 数据库&lt;/h3&gt;&#xA;&lt;p&gt;        数据库是为满足某个组织机构的信息要求而设计的一个逻辑相关数据及其描述的共享集合。在数据库内，所有的数据项都被集中起来，具有很少的冗余，为所有部门共享的资源。在其内部不仅含有组织的运行数据，还含有对这些数据的描述。因此，有时数据库也被定义为&lt;em&gt;一组集成记录的自描述的集合&lt;/em&gt;。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
