<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DBS on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/dbs/</link>
    <description>Recent content in DBS on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Thu, 04 Mar 2021 22:16:20 +0800</lastBuildDate><atom:link href="https://z217blog.cn/tags/dbs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL索引介绍</title>
      <link>https://z217blog.cn/post/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 04 Mar 2021 22:16:20 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/</guid>
      <description>索引 ( 在MySQL中也叫做键 ( $key$ )) 是存储引擎用于快速找到记录的一种数据结构。索引优化是查询性能优化最有效的手段。
1. 基础  MySQL中，索引引擎首先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。
1.1 类型  索引有很多类型。在MySQL中，索引是在存储引擎层而不是服务层实现的，所以并没有统一的索引标准。
1.1.1 B-Tree  如果没有特别指明类型，那么通常所说的索引都是B-Tree索引，顾名思义，即使用B-Tree数据结构来存储数据。大多数MySQL引擎都支持这种索引。不过，底层的存储引擎也可能使用不同的存储结构，例如InnoDB使用的是B+Tree。存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。 B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。 B-Tree索引适用于全键值、键值范围或键值前缀查找。其中键值前缀查找只适用于根据最左前缀的查找。上述的索引对如下类型的查询有效：
 全值匹配 匹配最左前缀 匹配列前缀 匹配范围值 精确匹配某一列并范围匹配另外一列 只访问索引的查询   因为索引树的节点是有序的，所以除了按值查找外，索引还可以用于查询中的 $ORDER\ \ BY$ 操作。一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。
1.2 哈希索引  哈希索引 ( $hash\ \ index$ ) 基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，并存储在索引中，同时在哈希表中保存指向每个数据行的指针。在MySQL中，只有Memory引擎显式支持哈希索引，同时也是默认索引类型。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。 InnoDB引擎有一个特殊的功能叫做自适应哈希索引 ( $adaptive\ \ hash\ \ index$ )。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引。 如果存储引擎不支持哈希索引，可以模拟创建哈希索引，即增加一列，存储哈希值。MySQL提供了 $CRC32$ 函数用于计算哈希值，通过设置触发器，可以在每次插入时自动插入索引。不要使用 $SHA1$ 和 $MD5$ 作为哈希函数，因为这两个函数计算出来的哈希值是非常长的字符串。如果数据表非常大，$CRC32$ 会出现大量哈希冲突，这时也可以考虑自己实现哈希函数。
2. 优点  索引可以让服务器快速地定位到表的指定位置，但并非唯一作用。最常见的B-Tree索引，按照顺序存储数据，可以用于 $ORDER\ \ BY$ 和 $GROUP\ \ BY$ 操作。利用数据有序的特点，索引有如下三个优点：</description>
    </item>
    
    <item>
      <title>MySQL架构介绍</title>
      <link>https://z217blog.cn/post/mysql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 04 Mar 2021 22:16:10 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/mysql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</guid>
      <description>1. MySQL逻辑架构  最上层服务并不是MySQL独有，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构，比如连接处理、授权认证、安全等； 第二层架构是MySQL比较有意思的部分。大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等； 第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。存储引擎多种多样，服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含了几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析SQL ( InnoDB会解析外键定义 ) ，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。  1.1 连接管理与安全性  每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。在连接建立后，服务器会验证客户端是否具有执行某个特定查询的权限。
1.2 优化与执行  MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准。 对于 $SELECT$ 语句，在解析查询之前，服务器会先检查查询缓存 ( $Query\ \ Cache$ )，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。
2. 并发控制  在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL会通过锁定防止其他用户读取统一数据。大多数时候，MySQL的内部管理都是透明的。 所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。大多数商业数据库系统没有提供更多的选择，一般都是在表上施加行级锁 ( $row-level\ \ lock$ )，并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能地提供更好的性能。而MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。在存储引擎的设计中，锁管理是个非常重要的决定。将锁粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能，但同时却会失去对另外一些应用场景的良好支持。好在MySQL支持多个存储引擎的架构，所以不需要单一的通用解决方案。
 表锁 ( $table\ \ lock$ )：表锁是MySQL中最基本的锁策略，并且是开销最小的策略，它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他的读取的用户才能获得读锁，读锁之间是不相互阻塞的。尽管存储引擎可以管理自己的锁，但MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如 $ALTER\ \ TABLE$ 之类的语句使用表锁，而忽略存储引擎锁机制； 行级锁 ( $row\ \ lock$ )：行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。众所周知，在InnoDB和XtraDB，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。  3. 事务  事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。
 原子性 ( $atomicity$ )：一个事务必须被视为一个不可分割的最小工作单元； 一致性 ( $consistency$ )：数据库总是从一个一致性的状态转换到另外一个一致性的状态； 隔离性 ( $isolation$ )：一个事务所做的修改在最终提交以前，对其他事务是不可见的； 持久性 ( $durability$ )：一旦事务提交，其所做的修改就会永久保存到数据库中。   一个运行良好的事务处理系统，必须满足ACID特性。但在应用逻辑中，要想实现这一点很困难，甚至可以说是不可能完成的任务。一个兼容ACID的数据库系统，需要做很多复杂但可能用户并没有觉察到的工作。</description>
    </item>
    
    <item>
      <title>数据库系统（9）：事务管理</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 13 Jun 2020 17:55:26 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</guid>
      <description>DBMS应该具备的功能中，有三个密切相关的功能，用以保证数据库的可靠性和一致性，即事务支持、并发控制服务和恢复服务。它们之间是相互依赖的。并发控制和恢复主要用于保护数据库，避免数据库发生数据不一致或者数据丢失。许多DBMS都允许用户对数据库进行并发操作。如果对这些操作不加控制，对数据库的访问将互相干扰，使得数据库出现不一致的情况。为了解决这个问题，DBMS实现了并发控制 ( $concurrency\ \ control$ ) 协议，来阻止数据库访问之间的相互干扰。数据库恢复 ( $Database\ \ recovery$ ) 是指在故障以后将数据库还原到正确状态的过程。
1. 支持事务处理  事务 ( $Transaction$ ) 是由单个用户或者应用程序执行的，完成读取或者更新数据库内容的一个或者一串操作。事务是数据库的逻辑操作单位 ( $logical\ \ unit\ \ of\ \ work$ ) 。它可以是整个程序、部分程序或者一条命令，也可以是涉及数据库的任意多个操作。从数据库的角度来看，应用程序的一次执行就是一个事务或者多个事务，若看成多个事务，在事务与事务之间只会出现非数据库操作。复杂的事务由很多操作构成。若并非所有操作都被执行，那么可能会出现不一致状态 ( $inconsistent\ \ state$ ) 。在事务处理过程中，尽管我们允许数据库的一致性遭到暂时破坏，但是事务应该总是能将数据库从一种一致的状态转移到另一种一致的状态。
事务可能有以下两种结果中的一种。如果执行成功，也就是说事务最终被提交 ( $committed$ )，数据库也将到达一种新的一致状态。另一种情况下，事务没有执行成功，则会被撤销 ( $aborted$ )。如果事务被撤销，则数据库必须要还原到事务开始之前的一致的状态。我们称这样的事务被回滚 ( $rolled\ \ back$ ) /撤销 ( $undone$ )。已经提交的事务无法撤销。如果发现已提交的事务存在错误，必须执行另一个补偿事务 ( $compensating\ \ transaction$ ) 来消除该事务已经产生的影响。
DBMS无法得知哪些更新操作将被组合在一起以构成一个独立的逻辑事务。因此很多数据操作语言中都使用关键字 $BEGIN$, $TRANSACTION$, $COMMIT$, $ROLLBACK$ 来划定界限。如果不使用，通常会将整个程序视为一个事务。
1.1 事务的性质  原子性 ( $Atomicity$ )：事务是一个不可分割的单元，要么全执行，要么全不执行。事务的原子性由DBMS的恢复子系统负责保证。 一致性 ( $Consistency$ )：事务必须将数据库从一种一致的状态转换到另一种一致的状态。事务的一致性是由DBMS和应用程序的开发者共同保证的。DBMS可以通过强制实施所有在数据库模式中定义的约束（如完整性约束和企业自定义约束）来保证一致性。 隔离性 ( $Isolation$ )：事务的执行是相互独立的，即未完成事务的中间结果对其他事务来说应该是不可见的。事务的隔离性由并发控制子系统负责保证。 持久性 ( $Durability$ )：成功完成的事务的结果要永久地记录在数据库中。事务的持久性由恢复子系统负责保证。  1.</description>
    </item>
    
    <item>
      <title>数据库系统（8）：规范化</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/</link>
      <pubDate>Fri, 22 May 2020 16:13:29 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/</guid>
      <description>规范化 ( $Normalization$ ) 是一种数据库设计技术，从分析属性之间的联系入手。规范化使用一系列测试，描述为范式 ( $normal\ \ forms$ ) 帮助我们确定这些属性的最佳组合，最终生成一组适当关系。
1. 目的  规范化的目的是确定一组合适的关系以支持企业的数据需求。该关系具有以下性质：
 属性的个数最少，且是必需的 具有紧密逻辑联系，描述为函数依赖 ( $functional\ \ dependency$ ) 的所有属性均在一个关系中 最少的冗余，即每个属性仅出现一次，除了作为外键的属性，因为连接相关关系必须用到外键   具有一组合适的关系，数据库会易于用户访问，数据易于维护，在计算机上也会占有较小的存储空间。
2. 支持  规范化有两种使用方法。方法 $1$ 将规范化视为一种自下而上 ( $bottom-up$ ) 的独立的数据库设计技术。方法 $2$ 将规范化作为一种确认技术使用，即用规范化检验关系的结构，而这些关系的建立可能采用自上而下的方法，如ER建模等。
3. 数据冗余与更新异常  关系数据库设计的一个目的就是将属性组合成关系时保证最少的数据冗余。当然，关系数据库的运行也依赖于一定的数据冗余的存在，一般是以主键或者候选键的多个副本的形式出现，作为外键表示数据间联系。存在冗余数据的关系可能存在一些问题，如更新异常 ( $update\ \ anomalies$ )。更新异常又可分为插入异常、删除异常和修改异常。
 $Staff$ 和 $Branch$ 是不存在数据冗余的两个表。$StaffBranch$ 是将上两个表合起来的存在数据冗余的表，同一个分公司的信息会重复出现。
3.1 插入异常  插入异常主要有两类：
 在向 $StaffBranch$ 中插入新员工时，若同一家分公司信息不同，则会产生一致性问题； 在向 $StaffBranch$ 中插入新的分公司时，由于没有员工，因此员工信息都应设为 $null$ 。但是主键 $staffNo$ 不能为空，否则会违反实体完整性约束。  3.</description>
    </item>
    
    <item>
      <title>数据库系统（7）：ER模型</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 21 May 2020 15:51:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/</guid>
      <description>ER模型是一种自上而下 ( $top-down$ ) 的数据库设计方法，该方法首先确定那些被称为实体的重要数据和这些数据之间的联系，实体和联系时ER模式中必备的元素。然后添加更多的细节信息，如属性、约束等。
统一建模语言 ( $Unified\ \ Modeling\ \ Language$, $UML$ ) 是软件工程项目的工业标准建模语言，我们使用UML的符号集来绘制ER模型。
1 实体类型  实体类型 ( $Entity\ \ types$ ) 是被企事业单位认可的、能够独立存在的一组具有相同属性的对象，是ER模型的基本概念。实体类型既可以是物理 ( 真实 ) 存在的，也可以是概念 ( 抽象 ) 存在的对象。实体出现 ( $entity\ \ occurrence$ ) 是实体类型中可唯一标识的一个对象。在没有歧义的时候，实体类型和实体出现都可以直接简称为实体。
在UML中，实体类型通过一个标有名字的矩形标识，每个实体名字的首字母是大写的。
2. 联系类型  联系类型 ( $Relationship\ \ types$ ) 是实体类型间一组有意义的关联。每个联系类型都被赋予一个能够描述其功能的名字。联系出现 ( $Relationship\ \ occurrence$ ) 是由参与该联系的各个实体类型的一个出现组成的可被唯一标识的关联。
在UML中，每个联系类型都表现为用线将相关的实体类型联系起来，并在线上标上联系的名字，通常使用一个动词或者动词短语命名。同样的，首字母也应该大写。一个联系还要标识方向，意味着这个联系仅在一个方向上有意义。可以在名字旁边添加一个箭头符号，如 $\blacktriangleleft$ 来标识方向。当我们要表示 $A\ \ Has\ \ B$ ( $A$，$B$ 为实体，$Has$ 为联系类型 ) 时可以用如下方法：</description>
    </item>
    
    <item>
      <title>数据库系统（6）：SQL数据定义</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Wed, 20 May 2020 16:46:30 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</guid>
      <description>1. 数据类型 1.1 标识符  SQL标识符 ( $identifier$ ) 用于表示数据库中的对象，如表名、列名、视图名等。用户定义标识符所用的字符必须是字符集 ( $character\ \ set$ ) 中存在的。默认的字符集包括 $A-Z$, $a-z$ 和 $_$ ，也可以另外指定其他字符集。标识符的限制有：
 不能长于 $128$ 个字符（在一些方言中会更短） 必须以字母开头 不能有空格  1.2 数据类型    数据类型 声明     布尔型 $BOOLEAN$   字符型 $CHAR$, $VARCHAR$   位类型 $BIT$, $BIT\ \ VARYING$   定点数型 $NUMERIC$, $DECIMAL$, $INTEGER$, $SMALLINT$, $BIGINT$   浮点数型 $FLOAT$, $REAL$, $DOUBLE\ \ PRECISION$   日期时间型 $DATE$, $TIME$, $TIMESTAMP$   间隔型 $INTERVAL$   大对象型 $CHARACTER\ \ LARGE\ \ OBJECT$, $BINARY\ \ LARGE\ \ OBJECT$    1.</description>
    </item>
    
    <item>
      <title>数据库系统（5）：SQL数据操作</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 20 May 2020 14:17:14 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</guid>
      <description>1. SQL简介  SQL是关系模型发展过程中出现的一种特殊语言，已经成为了标准的关系数据库语言。SQL是面向转换语言 ( $transform-oriented\ \ language$ ) 的例子，将输入关系转换为所需的输出关系，包括两个主要部分：DML和DDL。
SQL具有许多实现版本，每个实现称为方言 ( $dialect$ ) ，供应商在标准之外提供的特性称为扩展 ( $extensions$ )。
1.1 优点  满足数据库语言的思想 易于学习 结构简洁、轻便 存在SQL标准 可以通过终端或者嵌入式访问 所有人都可以使用  1.2 缺点  混合了编程规范和嵌入式访问 缺乏正交性，有多种表达方式 语言越来越复杂和庞大 聚合函数中对空的处理问题 结果表中可以有重复元组，对表中的行和列都强加了一个顺序  2. SQL命令  SQL语言包括保留字 ( $reserved\ \ words$ ) 和用户自定义字 ( $user-defined\ \ words$ ) 。保留字是SQL语言的固定部分，有固定含义。用户自定义字由用户定义，用于表示表、列、视图和索引等数据库对象的名称。虽然标准并没有要求，但是SQL的许多实现版本要求用句子终结符来表示SQL语句的结束。SQL语句的多数组成部分是不区分大小写的，除了字符数据常量外。
2.1 数据操作  DML语句有以下几种：
 $SELECT$, $INSERT$, $UPDATE$, $DELETE$.   常量 ( $Literals$ ) 是指SQL语句中的不变量 ( $constants$ )。不同的数据具有不同的常量形式，所有的非数值型数据必须使用引号，而所有的非数值型数据不能使用引号。</description>
    </item>
    
    <item>
      <title>数据库系统（4）：关系代数</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</link>
      <pubDate>Sun, 17 May 2020 16:05:13 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</guid>
      <description>关系代数 ( $Relational\ \ Algebra$ ) 可以看成一种过程式语言，可用于构造新关系。关系代数是一种纯理论语言，它定义了一些操作，运用这些操作可以从一个或多个关系中得到另一个关系而不改变原关系。关系代数的一个表达式可以嵌套另一个表达式，这种性质称为闭包 ( $closure$ )，即关系在关系代数下是封闭的。
关系代数是一种每次一关系/集合的语言，即用一条不带循环的语句处理，结果也是由所有元组组成的整个关系。关系代数中包含了许多运算，其中五个基本运算是选择 ( $Selection$ ) 、投影 ( $Projection$ ) 、笛卡尔乘积 ( $Cartesian\ \ product$ ) 、集合并 ( $Union$ ) 、集合差 ( $Set\ \ difference$ ) 。选择和投影都是一元运算，其他的运算则是二元运算。除此之外，还有连接 ( $Join$ ) 、集合交 ( $Intersection$ ) 、除 ( $Division$ ) 等，它们都能通过五个基本运算表示。
1. 一元运算 1.1 选择  $$ \sigma_{predicate}(R) $$   作用于单个关系 $R$ ，得到一个新关系，该关系由满足谓词 $predicate$ 的元组组成。可以理解为从表中选出符合条件的行构成一个新表。
1.2 投影  $$ \prod\nolimits_{a_1,a_2,...,a_n}(R) $$   作用于单个关系 $R$ ，得到一个由 $R$ 的垂直子集构成的新关系，该子集抽取 $R$ 中指定属性上的值并去掉重复元组。可以理解为从表中选出指定的列构成一个新表。</description>
    </item>
    
    <item>
      <title>数据库系统（3）：关系模型</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 15 May 2020 13:08:11 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</guid>
      <description>在目前使用的数据处理软件中，关系数据库管理系统 ( $Relational\ \ Database\ \ Management\ \ System$, $RDBMS$ ) 占据了统治地位。RDBMS基于关系数据模型。在关系模型中，所有数据逻辑上被组织成关系（表）结构。
1. 基本术语  关系模型基于数学中的关系 ( $relation$ )。
1.1 关系数据结构 1.1.1 关系  关系是由行和列组成的表。在关系模型中，用关系保存数据库所描述对象的信息，关系用二维表表示。用户主要接触的就是表，但这只限于逻辑结构，即外部层和概念层。对于物理结构，由于是通过多种存储结构实现的，因此并不适用。
1.1.2 属性  属性 ( $Attribute$ ) 是关系中命名的列。在关系的二维表中，每一行对应一个单独的记录，每一列则对应一个属性。
1.1.3 域  域 ( $Domain$ ) 是一个或多个属性的取值集合，必须给每一个属性定义一个域。不同属性的域可以互不相同，也可以共用。通过使用域，用户可以集中定义属性的取值范围和含义。
1.1.4 元组  元组 ( $Tuple$ ) 是关系中的行。关系的结构、域说明以及所有取值约束统称为关系的内涵 ( $intension$ )。它通常是固定的，除非关系的意义改变，需要加入新的属性。元组的集合称为外延 ( $extension$ ) /状态 ( $state$ )，它经常发生改变。
1.1.5 维数  维数 ( $Degree$ ) 是关系所包含的属性个数。只有一个属性的关系称为一元关系或者一元组，两个属性的关系称为二元关系，以此类推，$n$ 个属性的关系称为 $n$ 元组。维数是内含的性质之一。</description>
    </item>
    
    <item>
      <title>数据库系统（2）：数据库环境</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 14 May 2020 11:09:00 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/</guid>
      <description>1. ANSI-SPARC三层体系结构  三层体系结构 ( $Three\ \ Level\ \ Architecture$ )，包括外部层 ( $External$ )、概念层 ( $Conceptual$ ) 和内部层 ( $Internal$ )。用户从外部层观察数据，DBMS和操作系统从内部层观察数据。在内部层，数据使用定义的数据结构和文件组织方法进行存储。概念层则提供内部层和外部层的映射 ( $Mapping$ ) 以及必要的独立性 ( $Independence$ )。三层体系结构的目的是将用户的数据库视图与数据库的物理描述分离。
1.1 外部层  外部层是数据库的用户视图，这一层描述数据库中与用户相关的部分。对于每一个用户，数据库中都存储着其对用的视图。并且对于同一个数据，在不同的视图中可能有着不同的表达方式。
1.2 概念层  概念层是数据库的整体视图，这一层描述哪些数据存储在数据库中，以及这些数据之间的联系。概念层描述：
 所有的实体、实体的属性和实体间的联系 数据的约束 数据的语义信息 安全性和完整性信息   概念层支持每一个外部视图，凡是用户可访问的数据必定包含在概念层或者由概念层导出。
1.3 内部层  内部层是数据库在计算机上的物理表示，这一层描述数据是如何存储在数据库中的。内部层与如下工作相关：
 数据和索引的存储空间分配 存储记录的描述 存储记录 数据压缩和加密   在内部层之下是物理层 ( $Physical\ \ Level$ ) ，物理层可能在DBMS的指导下受操作系统的控制。
1.4 模式、映射和实例  对数据库的整体描述称为数据库模式 ( $Database\ \ Schema$ ) 。在数据库中存在三种不同类型的，在外部层有若干外部模式 ( $External\ \ Schema$ ) /子模式 ( $Subschema$ )，与不同的数据视图对应。在概念层有概念模式 ( $Conceptual\ \ Schema$ )，描述所有实体、属性和联系及其之间的完整性约束。在内部层，有内部模式 ( $Internal\ \ Schema$ )，是内部模型的完整描述，包括存储记录的定义、表示方法、数据域，必要时还有所使用的索引和散列方案。一个数据库可以有多个外部模式，但只能有一个概念模式和内部模式。</description>
    </item>
    
    <item>
      <title>数据库系统（1）：数据库简介</title>
      <link>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 13 May 2020 14:23:36 +0000</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 基于文件的系统  基于文件的系统 ( $Traditional\ \ File-Based\ \ Systems$ ) 是一组为终端用户提供服务的应用程序，每一个程序定义和管理它自己的数据。相较于使用纸质文件进行管理的手工文件系统，基于文件的系统更加高效。但是它未能集中存储组织机构的运行数据，而是采用了分散的方法，即每一个部门在数据处理 ( $DP$ ) 人员的帮助下存储和控制它们的数据。通过编写应用程序来管理和查询数据，具有程序-数据依赖性 ( $Program-data\ \ Dependence$ ) 。
1.1 术语  文件 ( $File$ ) 是一些记录 ( $Records$ ) 的简单集合，这些记录中包含逻辑上相关的数据。每一条记录包含一组逻辑上相关的一个或多个数据项/域 ( $Fields$ ) 。
1.2 局限性  数据被分离和孤立
数据被孤立在分离的文件中，如果要访问处于不同文件之间的数据，需要创建一个临时文件。 数据存在冗余
由于文件间的分离，有时需要重复记录一些数据。 数据存在依赖性
数据文件的物理结构和存储方式是由应用程序定义的，很难做出改变，也即程序-数据依赖性。 文件格式不相容
文件结构嵌入应用程序，因此由应用程序语言决定。难以兼容其他使用不同语言的文件结构。 需要不断更改应用程序
完全依赖于开发人员，要求开发人员以编程方式实现所有查询和表。如果查询需求发生了变化，需要重新编写程序或更改文件。  2. 数据库方法  基于文件的系统存在许多问题，总结原因是：
 数据内嵌应用程序 无法实现程序规定之外的操作   因此我们需要一种更加高效的方法，数据库 ( $Database$ ) 和 数据库管理系统 ( $Database\ \ Management\ \ System,\ \ DBMS$ ) 应运而生。</description>
    </item>
    
  </channel>
</rss>
