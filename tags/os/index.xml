<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OS on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/os/</link>
    <description>Recent content in OS on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2021, z217 and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Wed, 25 Aug 2021 17:25:27 +0800</lastBuildDate><atom:link href="https://z217blog.cn/tags/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>进程、线程和协程</title>
      <link>https://z217blog.cn/post/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Wed, 25 Aug 2021 17:25:27 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</guid>
      <description>进程 线程 协程     CPU 系统负责执行线程 一个进程含有多个线程，系统分配线程在不同的CPU上执行 线程上执行   内存 进程管理自己的内存区域 多线程共享进程的内存区域 同线程   栈  系统负责在内存中分配调用栈，默认为 $8MB$ 用户程序在堆上分配栈，切换的时候修改 $SP$ 、$PC$ 、$BP$   切换方式  时间片耗尽后触发中断处理程序，内核负责切换线程 主动切换，让出CPU   切换内容 通用寄存器，$PC$ 寄存器，页表寄存器，TLB，CPU缓存 通用寄存器，$PC$ 寄存器，CPU缓存 通用寄存器，$PC$ 寄存器   上下文 $task_-struct$ ，页表 $task_-struct$ ，页表 运行栈，寄存器    1. CPU和内存  操作系统为进程分配了一个专门的数据结构称为进程控制块 ( $Process\ \ Control\ \ Block$ ，$PCB$ )。系统利用PCB来描述进程基本情况和运行状态，进而实现对进程的控制和管理。程序段、相关数据段和PCB构成了进程实体。PCB内的信息包括：
 进程描述信息：进程标识符 ( $PID$ ) 和用户标识符 ( $UID$ )； 进程控制和管理信息：进程状态信息，进程优先级，代码运行入口，程序外存地址，处理机占用时间等； 资源分配清单：代码段指针、数据段指针、堆栈段指针和文件描述符等； 处理机相关信息：通用寄存器，地址寄存器，控制寄存器，状态字等。   线程的最直接理解就是轻量级进程，是CPU的基本执行单元，也是程序执行的最小单元，包括：</description>
    </item>
    
    <item>
      <title>I/O多路复用</title>
      <link>https://z217blog.cn/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Sun, 22 Aug 2021 15:30:25 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>1. 基本概念  操作系统内核 ( $kernel$ ) 是操作系统的核心，独立于普通应用程序，可以访问受保护的内存空间，也有权访问所有底层硬件设备。为了保证用户进程不能直接操作内核，操作系统将内存空间划为两部分，内核空间和用户空间。对于linux系统，如果是 $32$ 位系统，虚拟内存中最高的 $1G$ 字节 ( $0xC0000000 \sim 0xFFFFFFFF$ ) 为内核空间；如果是 $64$ 位系统，指针的前 $16$ 位保留，从而只有 $48$ 位寻址空间，于是最高的 $128T$ 字节 ( $0x0000000000000000 \sim 0x00007FFFFFFFF000$ ) 作为系统空间，中间部分 ( $0x00007FFFFFFFFFFF \sim 0xFFFF800000000000$ ) 作为保留，其余部分为用户空间。
正在执行的进程由于某些期待的事件未发生，如资源请求失败或者等待某些操作完成等，会自动执行阻塞原语，使自己由运行态变为阻塞态。进程的阻塞是一种主动行为，只有处于运行态的进程才可以触发，并且阻塞后不占用CPU资源。
文件描述符 ( $fd$ ) 是一个指向文件引用的概念，在形式上是一个非负整数，实际上是一个索引值，指向内核打开文件表中的对应记录。打开文件表中记录了文件的属性，包括磁盘位置、访问权限、文件位置指针以及打开计数。
缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux中，操作系统会将I/O数据缓存在文件系统的 $Page\ \ Cache$ 中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
在BIO模式下，当线程接收一个请求后，在等待I/O的时间内，调用会被阻塞，无法接受其他请求。在多线程环境下，如果想要接受大量请求，就需要创建大量线程，占用大量系统空间，并且线程切换会带来很大的开销。$10000$ 个线程真正发生读写的实际的线程数不会超过 $20\%$ 。
在NIO模式下，当线程接收一个请求后，会加入 $fd_-set$ 集合，每次轮询集合接收数据，如果没有数据会返回错误。每次都要轮询所有集合，包括未发生实际读写的 $fd$ ，会浪费CPU资源。
在I/O多路复用模式下，服务端通过 $select$ / $poll$ / $epoll$ 等系统调用获取 $fd$ 列表，遍历有事件的 $fd$ 进行数据接收，可以支持更多并发连接请求。
 I/O多路复用是一种同步I/O模型，多路指网络连接，复用指一个线程，即一个线程可以监视多个文件句柄； 一旦某个文件句柄就绪，就可以通知应用程序进行相应的读写操作； 没有文件句柄就会阻塞线程。  2.</description>
    </item>
    
    <item>
      <title>缓存一致性协议MESI</title>
      <link>https://z217blog.cn/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/</link>
      <pubDate>Mon, 16 Aug 2021 11:02:05 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/</guid>
      <description>高速缓冲存储器一致性 ( $Cache\ \ coherence$ )，也称缓存一致性，是指在采用层次结构存储系统的计算机系统中，保证告诉缓冲存储器中数据与主存储器中数据相同的机制。在有多个CPU的多处理机系统中特别容易出现高速缓存中数据不一致的问题。
在CPU缓存设计中，L1高速缓存包含指令缓存和数据缓存，位于CPU芯片上，访问速度几乎和寄存器一样快。L2高速缓存在L1和主存之间，连接到存储器总线或者高速缓存总线上。有些高性能系统还会在存储器总线上设置L3高速缓存。L1和L2是每个CPU内核间独立的，L3是所有CPU内核间共享的。
对于单核CPU来说，数据更新时缓存更新只用考虑自己的就行了，主要有两种处理方法。写回法 ( $write\ \ back$ )，是当处理器执行写操作时，信息只写入cache，当cache中的数据被替换出去时写回主存。为了减少内存写操作，cache中通常还会设置一个脏位 ( $dirty\ \ bit$ )，标识该块在被载入后是否发生了更新。直写法 ( $write\ \ through$ ) 是当处理器执行写操作时，既向cache中写入也向主存中写入。直写法会造成大量写内存操作，需要设置一个缓冲来减少硬件冲突，称为写缓冲器 ( $write\ \ buffer$ )，通常不超过 $4$ 个缓存块的大小，也适用于写回法。
相比于单核CPU，多核CPU除了要保证L1和L2最新外还要考虑到其他核中L1和L2的实时性和有效性。MESI协议是一个基于失效的缓存一致性协议，是支持写回缓存的最常用协议。该协议对总线上的操作进行监听，即核 $A$ 可以窥探到核 $B$ 对过期值的读操作，并更新主存中的过期值。MESI把cache中的数据分为几个状态：
   状态 描述 监听     $Invalid$ 该cache字段失效 无   $Shared$ 字段数据一致并且多核cache共享该字段 监听其他缓存使该字段无效或者变为 $Exclusive$ 的请求，监听到对应事件后会将该字段设为 $Invalid$   $Exclusive$ 字段数据一致并且只在当前核cache中独有 监听其他缓存读主存中该字段的操作，监听到对应事件后将该字段变为 $Shared$   $Modified$ 该字段有效但是与主存不一致，只存在于当前核cache中 监听所有试图读该字段对应主存字段的操作，该操作会被延迟到当前缓存字段写回主存并将状态设为 $Shared$ 之后执行       事件 描述     $Local\ \ Read$ 读取本地cache字段   $Local\ \ Write$ 写入本地cache字段   $Remote\ \ Read$ 其他cache读取字段   $Remote\ \ Write$ 其他cache写入字段     对于 $Modified$ 和 $Exclusive$ 状态，数据是精确的，而 $Shared$ 状态可能是非一致的。如果一个处于 $Shared$ 的缓存字段作废了，另一个缓存实际上可能已经独享了该缓存字段，但是该缓存不会转为 $Exclusive$ ，因为其他缓存并不会广播他们作废该缓存字段的通知。如果一个CPU想修改一个处于 $Shared$ 状态的缓存字段，总线事务需要将所有该缓存字段的副本变为 $Invalid$ 状态，而修改 $Exclusive$ 状态的缓存字段不需要总线事务。</description>
    </item>
    
    <item>
      <title>CSAPP笔记</title>
      <link>https://z217blog.cn/post/csapp%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 19 May 2021 15:06:19 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/csapp%E7%AC%94%E8%AE%B0/</guid>
      <description>1. 计算机系统漫游 #include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;#34;hello, world\n&amp;#34;); return 0; }  $hello$ 程序生命周期的一开始是一个高级C程序，因为处于这种形式时，它是能够被人读懂的。为了运行 $hello.c$ ，每条C语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序 ( $executable\ \ object\ \ program$ ) 的格式打包，并以二进制磁盘文件的形式存放起来。在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序 ( $compiler\ \ driver$ ) 完成的，这个过程可以分成四个阶段，执行这四个阶段的程序一起构成了编译系统：
 预处理阶段。预处理器 ( $cpp$ ) 根据以字符 $\#$ 开头的命令 ( $directives$ )，修改原始的C程序。修改完成后得到另一个C程序，通常是以 $.i$ 作为文件扩展名； 编译阶段：编译器 ( $ccl$ ) 将文本文件 $hello.i$ 翻译成文本文件 $hello.s$ ，它包含一个汇编语言程序； 汇编阶段：汇编器 ( $as$ ) 将 $hello.s$ 翻译成机器语言指令，并把这些指令打包成一种叫做可重定位 ( $relocatable$ ) 目标程序的格式，将结果保存在目标文件 $hello.o$ 中； 链接阶段：$hello.c$ 调用了C库函数 $printf$ ，后者存在于名为 $printf.</description>
    </item>
    
    <item>
      <title>操作系统笔记</title>
      <link>https://z217blog.cn/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 10 May 2021 20:54:33 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</guid>
      <description>计算机操作系统概述
1. 概述  操作系统 ( $Operating\ \ System$, $OS$ ) 是指控制和管理整个计算机系统的硬件和软件资源，以提供给用户和其他软件方便的接口和环境的程序集合，是计算机系统中最基本的系统软件。没有任何软件支持的计算机称为裸机。裸机在最里层，外面是操作系统。
操作系统是计算机系统资源的管理者：
 处理机管理：处理机的分配和运行以进程（或线程）为基本单位，因为对处理机的管理可以归结为对进程的管理； 存储器管理：对内存的管理； 文件管理：文件系统； 设备管理：I/O。   操作系统还提供了用户接口：
 命令接口：使用命令接口进行作业控制的方式有两种：联机控制方式和脱机控制方式。进一步的，按照控制方式，可以将命令接口分为联机命令接口和脱机命令接口。  联机命令接口适用于分时或实时系统的接口，由一组键盘操作命令组成。用户通过控制台或者终端输入命令； 脱机命令接口又称批处理命令接口，适用于批处理系统，由一组作业控制命令组成，用户不能直接干预作业运行，实现用相应的作业控制命令做成一份作业操作说明书，连同作业一起提交给系统。   程序接口由一组系统调用组成，用户通过在程序中使用这些系统调用命令来请求操作系统为其提供服务。   计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统内核程序，另一种是用户自编程序或者系统外层的应用程序。对于操作系统而言，前者是后者的管理者。内核程序可以执行一些特权指令，如I/O、中断、管理程序状态字寄存器等，出于安全考虑，这些程序不能被用户直接使用。操作系统在实现上划分了核心态（管态）和用户态（目态）以严格区分两类程序。
内核是计算机上配置的底层软件，大多数操作系统的内核包括四个方面的内容：
 时钟管理：时钟的第一功能是计时，通过时钟可以提供系统时间。此外，通过时钟中断，也可以实现进程切换； 中断机制：现代操作系统是靠中断驱动的软件。中断机制中，只有一小部分功能属于内核，负责保护和恢复中断现场信息，转移控制权，这样可以减少中断的处理时间； 原语 ( $Atomic\ \ Operation$ ) ：原语是一些可以被调用的小程序，处于操作系统的最底层，是最接近硬件的部分，具有原子性，且运行时间短、调用频繁； 系统控制的数据结构及处理：操作系统中存在许多记录状态信息的数据结构，如作业控制块、进程控制块、内存分配表等，操作系统需要一些对这些数据结构进行管理的基本操作。   从上述内容可知，核心态指令包括系统调用类指令和一些针对时钟、中断和原语的操作指令。
操作系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能。因此，需要实现核心态和用户态之间的转换。在实际操作系统中，CPU运行上层程序时的唯一转换途径是通过中断或异常。当中断或异常发生时，运行用户态的CPU会立即进入核心态，这是通过硬件实现的（例如用一个特殊寄存器表示）。
中断 ( $Interruption$ ) 指来自CPU执行指令以外的事件的发生，如设备I/O中断、时钟中断等。访管指令是一条可以在用户态下执行的指令，用于产生一个中断，称为访管中断，系统会根据访管指令的操作数执行对应的访管中断处理程序。异常 ( $Exception$ )，也称为陷入 ( $Trap$ ) ，指来自CPU执行指令内部的事件的发生，如程序的非法操作码、地址越界、内存缺页以及专门的陷入指令等。对异常的处理一般要依赖于当前程序的运行现场，并且异常不能被屏蔽，一旦出现应立即处理。
系统调用是用户在程序中调用操作系统提供的一些子功能，可以把系统调用看作是特殊的公共子程序。在用户程序中，凡是与资源有关的操作，都必须通过系统调用向操作系统提出服务请求，并由操作系统代为完成。系统调用大致可以分为如下几类：
 设备管理：设备请求、启动以及释放等； 文件管理：对文件的读写、创建和删除等； 进程控制：对进程的创建、销毁、阻塞和唤醒等； 进程通信：进程之间的消息传递； 内存管理：对内存的分配、回收以及获取内存区大小和地址等。   用户通过操作系统运行上层程序，上层程序依赖于操作系统的底层管理程序提供服务支持。当需要管理程序服务时，系统通过硬件中断机制进入核心态；当程序运行出现异常时，系统通过异常处理机制进入核心态。当管理程序结束时，用户程序继续运行，通过之前中断处理程序或者异常处理程序保存的中断现场，返回断点处继续执行。</description>
    </item>
    
    <item>
      <title>进程间通信</title>
      <link>https://z217blog.cn/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Thu, 18 Mar 2021 19:44:57 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</guid>
      <description>进程经常需要与其他进程通信。进程间通信 ( $Inter\ \ Process\ \ Communication$, $IPC$ ) 最好使用一种结构良好的方式并且不要使用中断。进程间通信存在三个问题：一个进程如何把信息传递给另一个，如何确保两个或更多的进程在关键活动中不会出现交叉，以及进程之间执行顺序的正确性。 在一些操作系统中，协作的进程可能共享一些彼此都能读写的公用存储区，可能是一块内存，也可能是一个共享文件。当两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，就称为竞争条件 ( $race\ \ condition$ )。包含有竞争条件的程序在大多数情况下都不会出错，但在极少数情况下会产生一些奇怪的现象，尤其是在多核环境中更为明显。而要避免竞争条件带来的错误，关键是要找出某种途径来阻止多个进程同时读写共享数据。换言之，我们需要的是互斥 ( $mutual\ \ exclusion$ )，即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。 避免竞争条件的问题也可以用一种抽象的方式进行描述。一个进程的一部分时间做内部计算或另外一些不会引发竞争条件的操作。在某些时候进程可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作。我们把对共享内存进行访问的程序片段称作临界区域 ( $critical\ \ region$ ) 或临界区 ( $critical\ \ section$ )。如果我们能适当地安排，使得两个进程不可能同时处于临界区中，就能避免竞争条件。 尽管这样的要求避免了竞争条件，但它还不能保证使用共享数据的并发进程能够正确和高效地进行协作。对于一个好的解决方案，需要满足以下 $4$ 个条件：
 任何两个进程不能同时处于临界区； 不应对CPU的速度和数量做任何假设； 临界区外运行的进程不得阻塞其他进程； 不得使进程无限期等待进入临界区。  1. 互斥 1.1 屏蔽中断  在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽。CPU只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断后CPU将不会被切换到其他进程。于是，一旦某个进程屏蔽中断后，它就可以检查和修改共享内存，而不必担心其他进程介入。 但是这个方案并不好，因为屏蔽中断的权力交给了用户进程。而且对于多处理器系统，屏蔽中断指令仅仅对执行 $disable$ 指令的那个CPU有效，其他CPU仍然可以运行。另一方面，对于内核来说，屏蔽中断指令是非常方便的。所以屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。
1.2 锁变量  设想有一个共享锁变量，其初始值为 $0$ 。当一个进程想进入临界区时，会首先测试锁。如果锁的值为 $0$ ，则进程将其设置为 $1$ 并进入临界区。否则，进程等待直到值变为 $0$ 。虽然实现简单，但是却存在着多个进程同时读到 $0$ 的可能。
1.3 严格轮换法 // 进程a while (1) { while (turn !</description>
    </item>
    
  </channel>
</rss>
