<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OS on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/os/</link>
    <description>Recent content in OS on z217&#39;s blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2026, z217 and the hugo authors, all rights reserved.</copyright>
    <lastBuildDate>Wed, 25 Aug 2021 17:25:27 +0800</lastBuildDate>
    <atom:link href="https://z217blog.cn/tags/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>进程、线程和协程</title>
      <link>https://z217blog.cn/post/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Wed, 25 Aug 2021 17:25:27 +0800</pubDate>
      <guid>https://z217blog.cn/post/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</guid>
      <description>&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;进程&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;线程&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;协程&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;code&gt;CPU&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;系统负责执行线程&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;一个进程含有多个线程，系统分配线程在不同的&lt;code&gt;CPU&lt;/code&gt;上执行&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;线程上执行&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;内存&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;进程管理自己的内存区域&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;多线程共享进程的内存区域&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;同线程&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;栈&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;系统负责在内存中分配调用栈，默认为 $8MB$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;用户程序在堆上分配栈，切换的时候修改 $SP$ 、$PC$ 、$BP$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;切换方式&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;时间片耗尽后触发中断处理程序，内核负责切换线程&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;主动切换，让出&lt;code&gt;CPU&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;切换内容&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;通用寄存器，$PC$ 寄存器，页表寄存器，&lt;code&gt;TLB&lt;/code&gt;，&lt;code&gt;CPU&lt;/code&gt;缓存&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;通用寄存器，$PC$ 寄存器，&lt;code&gt;CPU&lt;/code&gt;缓存&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;通用寄存器，$PC$ 寄存器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;上下文&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$task_-struct$ ，页表&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$task_-struct$ ，页表&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;运行栈，寄存器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;1-cpu和内存&#34;&gt;1. &lt;code&gt;CPU&lt;/code&gt;和内存&lt;/h2&gt;&#xA;&lt;p&gt;        操作系统为进程分配了一个专门的数据结构称为进程控制块 ( $Process\ \ Control\ \ Block$ ，$PCB$ )。系统利用&lt;code&gt;PCB&lt;/code&gt;来描述进程基本情况和运行状态，进而实现对进程的控制和管理。程序段、相关数据段和&lt;code&gt;PCB&lt;/code&gt;构成了进程实体。&lt;code&gt;PCB&lt;/code&gt;内的信息包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程描述信息：进程标识符 ( $PID$ ) 和用户标识符 ( $UID$ )；&lt;/li&gt;&#xA;&lt;li&gt;进程控制和管理信息：进程状态信息，进程优先级，代码运行入口，程序外存地址，处理机占用时间等；&lt;/li&gt;&#xA;&lt;li&gt;资源分配清单：代码段指针、数据段指针、堆栈段指针和文件描述符等；&lt;/li&gt;&#xA;&lt;li&gt;处理机相关信息：通用寄存器，地址寄存器，控制寄存器，状态字等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        线程的最直接理解就是轻量级进程，是&lt;code&gt;CPU&lt;/code&gt;的基本执行单元，也是程序执行的最小单元，包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程&lt;code&gt;ID&lt;/code&gt;；&lt;/li&gt;&#xA;&lt;li&gt;程序计数器；&lt;/li&gt;&#xA;&lt;li&gt;寄存器；&lt;/li&gt;&#xA;&lt;li&gt;堆栈。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        线程是进程中的一个实体，是系统独立调度和分派的基本单位，只拥有一些运行中必不可少的资源，共享其所在线程的全部资源。在多线程操作系统中，进程的执行实际上是进程中的某个线程正在执行。&lt;code&gt;Linux&lt;/code&gt;系统中进程和线程都使用 $task_-struct$ 结构描述，存储在一个双端循环列表中，列表存储在内核栈的末尾。&lt;br&gt;&#xA;        线程的实现可以分为两类，用户级线程 ( $User-Level\ \ Thread$ ) 和内核级线程 ( $Kernel-Level\ \ Thread$ )。用户级线程中，有关线程管理的所有工作都交由应用程序完成；内核级线程中，线程管理的所有工作都交由内核完成，应用程序只有一个到内核级线程的编程接口，内核为进程及其内部的每个线程维护上下文信息。&lt;br&gt;&#xA;        协程并不是一个新概念，它在 $1958$ 年就被提出。协程就是一个子任务，特点是非抢占式的调度。协程会自己判断运行状况，当满足一定条件就会主动让出&lt;code&gt;CPU&lt;/code&gt;给其他协程，而进程或者线程的切换需要进入内核态交给内核处理。协程其实就是用户级线程。协程中的信息只包括运行栈和寄存器，后者决定了程序在代码中的执行位置。&lt;/p&gt;</description>
    </item>
    <item>
      <title>I/O多路复用</title>
      <link>https://z217blog.cn/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Sun, 22 Aug 2021 15:30:25 +0800</pubDate>
      <guid>https://z217blog.cn/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>&lt;h2 id=&#34;1-基本概念&#34;&gt;1. 基本概念&lt;/h2&gt;&#xA;&lt;p&gt;        操作系统&lt;strong&gt;内核&lt;/strong&gt; ( $kernel$ ) 是操作系统的核心，独立于普通应用程序，可以访问受保护的内存空间，也有权访问所有底层硬件设备。为了保证用户进程不能直接操作内核，操作系统将内存空间划为两部分，内核空间和用户空间。对于&lt;code&gt;linux&lt;/code&gt;系统，如果是 $32$ 位系统，虚拟内存中最高的 $1G$ 字节 ( $0xC0000000 \sim 0xFFFFFFFF$ ) 为内核空间；如果是 $64$ 位系统，指针的前 $16$ 位保留，从而只有 $48$ 位寻址空间，于是最高的 $128T$ 字节 ( $0x0000000000000000 \sim 0x00007FFFFFFFF000$ ) 作为系统空间，中间部分 ( $0x00007FFFFFFFFFFF \sim 0xFFFF800000000000$ ) 作为保留，其余部分为用户空间。&lt;br&gt;&#xA;        正在执行的进程由于某些期待的事件未发生，如资源请求失败或者等待某些操作完成等，会自动执行阻塞原语，使自己由运行态变为阻塞态。进程的阻塞是一种主动行为，只有处于运行态的进程才可以触发，并且阻塞后不占用&lt;code&gt;CPU&lt;/code&gt;资源。&lt;br&gt;&#xA;        文件描述符 ( $fd$ ) 是一个指向文件引用的概念，在形式上是一个非负整数，实际上是一个索引值，指向内核打开文件表中的对应记录。打开文件表中记录了文件的属性，包括磁盘位置、访问权限、文件位置指针以及打开计数。&lt;br&gt;&#xA;        缓存&lt;code&gt;I/O&lt;/code&gt;又称为标准&lt;code&gt;I/O&lt;/code&gt;，大多数文件系统的默认&lt;code&gt;I/O&lt;/code&gt;操作都是缓存&lt;code&gt;I/O&lt;/code&gt;。在&lt;code&gt;Linux&lt;/code&gt;中，操作系统会将&lt;code&gt;I/O&lt;/code&gt;数据缓存在文件系统的 $Page\ \ Cache$ 中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。&lt;br&gt;&#xA;        在&lt;code&gt;BIO&lt;/code&gt;模式下，当线程接收一个请求后，在等待&lt;code&gt;I/O&lt;/code&gt;的时间内，调用会被阻塞，无法接受其他请求。在多线程环境下，如果想要接受大量请求，就需要创建大量线程，占用大量系统空间，并且线程切换会带来很大的开销。$10000$ 个线程真正发生读写的实际的线程数不会超过 $20\%$ 。&lt;br&gt;&#xA;        在&lt;code&gt;NIO&lt;/code&gt;模式下，当线程接收一个请求后，会加入 $fd_-set$ 集合，每次轮询集合接收数据，如果没有数据会返回错误。每次都要轮询所有集合，包括未发生实际读写的 $fd$ ，会浪费&lt;code&gt;CPU&lt;/code&gt;资源。&lt;br&gt;&#xA;        在&lt;code&gt;I/O&lt;/code&gt;多路复用模式下，服务端通过 $select$ / $poll$ / $epoll$ 等系统调用获取 $fd$ 列表，遍历有事件的 $fd$ 进行数据接收，可以支持更多并发连接请求。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;I/O&lt;/code&gt;多路复用是一种同步&lt;code&gt;I/O&lt;/code&gt;模型，多路指网络连接，复用指一个线程，即一个线程可以监视多个文件句柄；&lt;/li&gt;&#xA;&lt;li&gt;一旦某个文件句柄就绪，就可以通知应用程序进行相应的读写操作；&lt;/li&gt;&#xA;&lt;li&gt;没有文件句柄就会阻塞线程。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-select&#34;&gt;2. &lt;code&gt;select&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;        $select$ 是仅仅知道了有&lt;code&gt;I/O&lt;/code&gt;事件发生，但是无法确定是哪几个流 ( 一个或多个，甚至全部 )，只能无差别的轮询所有流，直到找出所有能读出或写入数据的流，具有 $O(n)$ 的无差别轮询复杂度。&lt;/p&gt;</description>
    </item>
    <item>
      <title>缓存一致性协议MESI</title>
      <link>https://z217blog.cn/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/</link>
      <pubDate>Mon, 16 Aug 2021 11:02:05 +0800</pubDate>
      <guid>https://z217blog.cn/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/</guid>
      <description>&lt;p&gt;        &lt;strong&gt;高速缓冲存储器一致性&lt;/strong&gt; ( $Cache\ \ coherence$ )，也称缓存一致性，是指在采用层次结构存储系统的计算机系统中，保证告诉缓冲存储器中数据与主存储器中数据相同的机制。在有多个&lt;code&gt;CPU&lt;/code&gt;的多处理机系统中特别容易出现高速缓存中数据不一致的问题。&lt;br&gt;&#xA;        在&lt;code&gt;CPU&lt;/code&gt;缓存设计中，&lt;code&gt;L1&lt;/code&gt;高速缓存包含指令缓存和数据缓存，位于&lt;code&gt;CPU&lt;/code&gt;芯片上，访问速度几乎和寄存器一样快。&lt;code&gt;L2&lt;/code&gt;高速缓存在&lt;code&gt;L1&lt;/code&gt;和主存之间，连接到存储器总线或者高速缓存总线上。有些高性能系统还会在存储器总线上设置&lt;code&gt;L3&lt;/code&gt;高速缓存。&lt;code&gt;L1&lt;/code&gt;和&lt;code&gt;L2&lt;/code&gt;是每个&lt;code&gt;CPU&lt;/code&gt;内核间独立的，&lt;code&gt;L3&lt;/code&gt;是所有&lt;code&gt;CPU&lt;/code&gt;内核间共享的。&lt;br&gt;&#xA;        对于单核&lt;code&gt;CPU&lt;/code&gt;来说，数据更新时缓存更新只用考虑自己的就行了，主要有两种处理方法。&lt;strong&gt;写回法&lt;/strong&gt; ( $write\ \ back$ )，是当处理器执行写操作时，信息只写入&lt;code&gt;cache&lt;/code&gt;，当&lt;code&gt;cache&lt;/code&gt;中的数据被替换出去时写回主存。为了减少内存写操作，&lt;code&gt;cache&lt;/code&gt;中通常还会设置一个脏位 ( $dirty\ \ bit$ )，标识该块在被载入后是否发生了更新。&lt;strong&gt;直写法&lt;/strong&gt; ( $write\ \ through$ ) 是当处理器执行写操作时，既向&lt;code&gt;cache&lt;/code&gt;中写入也向主存中写入。直写法会造成大量写内存操作，需要设置一个缓冲来减少硬件冲突，称为写缓冲器 ( $write\ \ buffer$ )，通常不超过 $4$ 个缓存块的大小，也适用于写回法。&lt;br&gt;&#xA;        相比于单核&lt;code&gt;CPU&lt;/code&gt;，多核&lt;code&gt;CPU&lt;/code&gt;除了要保证&lt;code&gt;L1&lt;/code&gt;和&lt;code&gt;L2&lt;/code&gt;最新外还要考虑到其他核中&lt;code&gt;L1&lt;/code&gt;和&lt;code&gt;L2&lt;/code&gt;的实时性和有效性。&lt;code&gt;MESI&lt;/code&gt;协议是一个基于失效的缓存一致性协议，是支持写回缓存的最常用协议。该协议对总线上的操作进行监听，即核 $A$ 可以窥探到核 $B$ 对过期值的读操作，并更新主存中的过期值。&lt;code&gt;MESI&lt;/code&gt;把&lt;code&gt;cache&lt;/code&gt;中的数据分为几个状态：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;状态&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;描述&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;监听&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$Invalid$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;该&lt;code&gt;cache&lt;/code&gt;字段失效&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;无&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$Shared$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;字段数据一致并且多核&lt;code&gt;cache&lt;/code&gt;共享该字段&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;监听其他缓存使该字段无效或者变为 $Exclusive$ 的请求，监听到对应事件后会将该字段设为 $Invalid$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$Exclusive$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;字段数据一致并且只在当前核&lt;code&gt;cache&lt;/code&gt;中独有&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;监听其他缓存读主存中该字段的操作，监听到对应事件后将该字段变为 $Shared$&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$Modified$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;该字段有效但是与主存不一致，只存在于当前核&lt;code&gt;cache&lt;/code&gt;中&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;监听所有试图读该字段对应主存字段的操作，该操作会被延迟到当前缓存字段写回主存并将状态设为 $Shared$ 之后执行&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://z217blog.cn/image/2021-08-16-01.png&#34; alt=&#34;状态机&#34;&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;事件&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$Local\ \ Read$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;读取本地&lt;code&gt;cache&lt;/code&gt;字段&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$Local\ \ Write$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;写入本地&lt;code&gt;cache&lt;/code&gt;字段&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$Remote\ \ Read$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;其他&lt;code&gt;cache&lt;/code&gt;读取字段&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;$Remote\ \ Write$&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;其他&lt;code&gt;cache&lt;/code&gt;写入字段&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;        对于 $Modified$ 和 $Exclusive$&#xA;状态，数据是精确的，而 $Shared$ 状态可能是非一致的。如果一个处于 $Shared$ 的缓存字段作废了，另一个缓存实际上可能已经独享了该缓存字段，但是该缓存不会转为 $Exclusive$ ，因为其他缓存并不会广播他们作废该缓存字段的通知。如果一个&lt;code&gt;CPU&lt;/code&gt;想修改一个处于 $Shared$ 状态的缓存字段，总线事务需要将所有该缓存字段的副本变为 $Invalid$ 状态，而修改 $Exclusive$ 状态的缓存字段不需要总线事务。&lt;br&gt;&#xA;        缓存的一致性消息传递是需要时间的，这就使其切换时产生延迟。当一个缓存被切换状态时其他缓存收到消息完成各自的切换并且发出回应消息这么长一段时间中&lt;code&gt;CPU&lt;/code&gt;都会等待所有缓存响应完成。为了避免这种&lt;code&gt;CPU&lt;/code&gt;运算能力的浪费，$Store\ \ Buffer$ ( 写缓存 ) 被引入。处理器会将想要写入主存的值写到 $Store\ \ Buffer$ 中再去处理其他事情。&lt;br&gt;&#xA;        同样的，&lt;code&gt;CPU&lt;/code&gt;在收到无效化通知后，也不会立即将数据无效化，因为发出通知的&lt;code&gt;CPU&lt;/code&gt;在等待响应，而无效化需要时间。所以&lt;code&gt;CPU&lt;/code&gt;会将数据存入无效化队列，在存入之后就返回 $Ack$ ，以免阻塞&lt;code&gt;CPU&lt;/code&gt;。&lt;br&gt;&#xA;        写缓冲器和无效化队列也会带来新的问题：&lt;/p&gt;</description>
    </item>
    <item>
      <title>CSAPP笔记</title>
      <link>https://z217blog.cn/post/csapp%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 19 May 2021 15:06:19 +0800</pubDate>
      <guid>https://z217blog.cn/post/csapp%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;1-计算机系统漫游&#34;&gt;1. 计算机系统漫游&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello, world&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;        $hello$ 程序生命周期的一开始是一个高级&lt;code&gt;C&lt;/code&gt;程序，因为处于这种形式时，它是能够被人读懂的。为了运行 $hello.c$ ，每条&lt;code&gt;C&lt;/code&gt;语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为&lt;strong&gt;可执行目标程序&lt;/strong&gt; ( $executable\ \ object\ \ program$ ) 的格式打包，并以二进制磁盘文件的形式存放起来。在&lt;code&gt;Unix&lt;/code&gt;系统上，从源文件到目标文件的转化是由&lt;strong&gt;编译器驱动程序&lt;/strong&gt; ( $compiler\ \ driver$ ) 完成的，这个过程可以分成四个阶段，执行这四个阶段的程序一起构成了编译系统：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;预处理阶段。预处理器 ( $cpp$ ) 根据以字符 $\#$ 开头的命令 ( $directives$ )，修改原始的&lt;code&gt;C&lt;/code&gt;程序。修改完成后得到另一个&lt;code&gt;C&lt;/code&gt;程序，通常是以 $.i$ 作为文件扩展名；&lt;/li&gt;&#xA;&lt;li&gt;编译阶段：编译器 ( $ccl$ ) 将文本文件 $hello.i$ 翻译成文本文件 $hello.s$ ，它包含一个汇编语言程序；&lt;/li&gt;&#xA;&lt;li&gt;汇编阶段：汇编器 ( $as$ ) 将 $hello.s$ 翻译成机器语言指令，并把这些指令打包成一种叫做&lt;strong&gt;可重定位&lt;/strong&gt; ( $relocatable$ ) 目标程序的格式，将结果保存在目标文件 $hello.o$ 中；&lt;/li&gt;&#xA;&lt;li&gt;链接阶段：$hello.c$ 调用了&lt;code&gt;C&lt;/code&gt;库函数 $printf$ ，后者存在于名为 $printf.o$ 的单独的预编译目标文件中。链接器 ( $ld$ ) 负责处理目标文件的并入，处理完成后得到可执行文件。可执行文件加载到存储器后，由系统负责执行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://z217blog.cn/image/2021-05-19-01.png&#34; alt=&#34;一个典型系统的硬件组成&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统笔记</title>
      <link>https://z217blog.cn/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 10 May 2021 20:54:33 +0800</pubDate>
      <guid>https://z217blog.cn/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/cpp/u/xitong_1/&#34;&gt;计算机操作系统概述&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-概述&#34;&gt;1. 概述&lt;/h2&gt;&#xA;&lt;p&gt;        &lt;strong&gt;操作系统&lt;/strong&gt; ( $Operating\ \ System$, $OS$ ) 是指控制和管理整个计算机系统的硬件和软件资源，以提供给用户和其他软件方便的接口和环境的程序集合，是计算机系统中最基本的系统软件。没有任何软件支持的计算机称为裸机。裸机在最里层，外面是操作系统。&lt;br&gt;&#xA;        操作系统是计算机系统资源的管理者：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;处理机管理：处理机的分配和运行以进程（或线程）为基本单位，因为对处理机的管理可以归结为对进程的管理；&lt;/li&gt;&#xA;&lt;li&gt;存储器管理：对内存的管理；&lt;/li&gt;&#xA;&lt;li&gt;文件管理：文件系统；&lt;/li&gt;&#xA;&lt;li&gt;设备管理：&lt;code&gt;I/O&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        操作系统还提供了用户接口：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;命令接口：使用命令接口进行作业控制的方式有两种：联机控制方式和脱机控制方式。进一步的，按照控制方式，可以将命令接口分为联机命令接口和脱机命令接口。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;联机命令接口适用于分时或实时系统的接口，由一组键盘操作命令组成。用户通过控制台或者终端输入命令；&lt;/li&gt;&#xA;&lt;li&gt;脱机命令接口又称批处理命令接口，适用于批处理系统，由一组作业控制命令组成，用户不能直接干预作业运行，实现用相应的作业控制命令做成一份作业操作说明书，连同作业一起提交给系统。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;程序接口由一组系统调用组成，用户通过在程序中使用这些系统调用命令来请求操作系统为其提供服务。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        计算机系统中，通常&lt;code&gt;CPU&lt;/code&gt;执行两种不同性质的程序：一种是操作系统内核程序，另一种是用户自编程序或者系统外层的应用程序。对于操作系统而言，前者是后者的管理者。内核程序可以执行一些特权指令，如&lt;code&gt;I/O&lt;/code&gt;、中断、管理程序状态字寄存器等，出于安全考虑，这些程序不能被用户直接使用。操作系统在实现上划分了&lt;strong&gt;核心态&lt;/strong&gt;（管态）和&lt;strong&gt;用户态&lt;/strong&gt;（目态）以严格区分两类程序。&lt;br&gt;&#xA;        &lt;strong&gt;内核&lt;/strong&gt;是计算机上配置的底层软件，大多数操作系统的内核包括四个方面的内容：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;时钟管理：时钟的第一功能是计时，通过时钟可以提供系统时间。此外，通过时钟中断，也可以实现进程切换；&lt;/li&gt;&#xA;&lt;li&gt;中断机制：现代操作系统是靠中断驱动的软件。中断机制中，只有一小部分功能属于内核，负责保护和恢复中断现场信息，转移控制权，这样可以减少中断的处理时间；&lt;/li&gt;&#xA;&lt;li&gt;原语 ( $Atomic\ \ Operation$ ) ：原语是一些可以被调用的小程序，处于操作系统的最底层，是最接近硬件的部分，具有原子性，且运行时间短、调用频繁；&lt;/li&gt;&#xA;&lt;li&gt;系统控制的数据结构及处理：操作系统中存在许多记录状态信息的数据结构，如作业控制块、进程控制块、内存分配表等，操作系统需要一些对这些数据结构进行管理的基本操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        从上述内容可知，核心态指令包括系统调用类指令和一些针对时钟、中断和原语的操作指令。&lt;br&gt;&#xA;        操作系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能。因此，需要实现核心态和用户态之间的转换。在实际操作系统中，&lt;code&gt;CPU&lt;/code&gt;运行上层程序时的唯一转换途径是通过中断或异常。当中断或异常发生时，运行用户态的&lt;code&gt;CPU&lt;/code&gt;会立即进入核心态，这是通过硬件实现的（例如用一个特殊寄存器表示）。&lt;br&gt;&#xA;        &lt;strong&gt;中断&lt;/strong&gt; ( $Interruption$ ) 指来自&lt;code&gt;CPU&lt;/code&gt;执行指令以外的事件的发生，如设备&lt;code&gt;I/O&lt;/code&gt;中断、时钟中断等。访管指令是一条可以在用户态下执行的指令，用于产生一个中断，称为访管中断，系统会根据访管指令的操作数执行对应的访管中断处理程序。&lt;strong&gt;异常&lt;/strong&gt; ( $Exception$ )，也称为&lt;strong&gt;陷入&lt;/strong&gt; ( $Trap$ ) ，指来自&lt;code&gt;CPU&lt;/code&gt;执行指令内部的事件的发生，如程序的非法操作码、地址越界、内存缺页以及专门的陷入指令等。对异常的处理一般要依赖于当前程序的运行现场，并且异常不能被屏蔽，一旦出现应立即处理。&lt;br&gt;&#xA;        系统调用是用户在程序中调用操作系统提供的一些子功能，可以把系统调用看作是特殊的公共子程序。在用户程序中，凡是与资源有关的操作，都必须通过系统调用向操作系统提出服务请求，并由操作系统代为完成。系统调用大致可以分为如下几类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设备管理：设备请求、启动以及释放等；&lt;/li&gt;&#xA;&lt;li&gt;文件管理：对文件的读写、创建和删除等；&lt;/li&gt;&#xA;&lt;li&gt;进程控制：对进程的创建、销毁、阻塞和唤醒等；&lt;/li&gt;&#xA;&lt;li&gt;进程通信：进程之间的消息传递；&lt;/li&gt;&#xA;&lt;li&gt;内存管理：对内存的分配、回收以及获取内存区大小和地址等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;        用户通过操作系统运行上层程序，上层程序依赖于操作系统的底层管理程序提供服务支持。当需要管理程序服务时，系统通过硬件中断机制进入核心态；当程序运行出现异常时，系统通过异常处理机制进入核心态。当管理程序结束时，用户程序继续运行，通过之前中断处理程序或者异常处理程序保存的中断现场，返回断点处继续执行。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-进程和线程&#34;&gt;2. 进程和线程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-进程&#34;&gt;2.1 进程&lt;/h3&gt;&#xA;&lt;p&gt;        在多道程序环境下，多个程序可以并发执行，为此引入了&lt;strong&gt;进程&lt;/strong&gt; ( $Process$ )。为了使参与并发执行的程序能够独立地执行，操作系统为之配置了一个专门的数据结构称为&lt;strong&gt;进程控制块&lt;/strong&gt; ( $Process\ \ Control\ \ Block$, $PCB$ )。系统利用&lt;code&gt;PCB&lt;/code&gt;来描述进程的基本情况和运行状态，进而实现对进程的控制和管理。程序段、相关数据段和&lt;code&gt;PCB&lt;/code&gt;构成了进程实体，进程实体是静态的，但是进程是动态的。进程创建实质上是创建&lt;code&gt;PCB&lt;/code&gt;，撤销实质上是撤销&lt;code&gt;PCB&lt;/code&gt;，&lt;code&gt;PCB&lt;/code&gt;是进程存在的唯一标志。&lt;code&gt;PCB&lt;/code&gt;通常包含以下内容：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
