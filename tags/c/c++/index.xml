<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; on z217&#39;s blog</title>
    <link>https://z217blog.cn/tags/c/c&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on z217&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright © 2020–2021, z217 and the Hugo Authors; all rights reserved.</copyright><atom:link href="https://z217blog.cn/tags/c/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unix网络编程（2）：基本TCP套接字编程</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</link>
      <pubDate>Sat, 29 Jan 2022 18:38:32 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/</guid>
      <description>1. 基本TCP套接字编程 1.1 socket函数  为了执行网络I/O，进程必须做的第一件事就是调用 $socket$ 函数。
#include &amp;lt;sys/socket.h&amp;gt; // 成功返回套接字描述符，失败返回-1 int socket(int family, int type. int protocol);  $family$ 为协议族，由于历史问题，一些实现中还存在以 $PF$ 开头的协议族，但基本等价；$type$ 指明套接字类型；$protocol$ 为某个协议类型常值。
   $family$ 说明     $AF_-INET$ IPv4协议   $AF_-INET6$ IPv6协议   $AF_-LOCAL$ Unix域协议   $AF_-ROUTE$ 路由套接字   $AF_-KEY$ 密钥套接字        $type$ 说明     $SOCK_-STREAM$ 字节流套接字   $SOCK_-DGRAM$ 数据报套接字   $SOCK_-SEQPACKET$ 有序分组套接字   $SOCK_-RAW$ 原始套接字        $protocol$ 说明     $IPPROTO_-TCP$ TCP传输协议   $IPPROTO_-UDP$ UDP传输协议   $IPPROTO_-SCTP$ SCTP传输协议        组合 $AF_-INET$ $AF_-INET6$ $AF_-LOCAL$ $AF_-ROUTE$ $AF_-KEY$     $SOCK_-STREAM$ TCP｜SCTP TCP｜SCTP 有效     $SOCK_-DGRAM$ UDP UDP 有效     $SOCK_-SEQPACKET$ SCTP SCTP 有效     $SOCK_-RAW$ IPv4 IPv6  有效 有效    1.</description>
    </item>
    
    <item>
      <title>Unix网络编程（1）：套接字编程简介</title>
      <link>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</link>
      <pubDate>Wed, 26 Jan 2022 17:10:43 +0800</pubDate>
      
      <guid>https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B1/</guid>
      <description>1. 传输层  TCP建立一个连接需要三次握手：
 服务器准备接受外部连接，通常通过调用 $socket$ 、$bind$ 、$listen$ 这 $3$ 个函数完成，称为被动打开 ( $passive$ $open$ )； 客户端通过调用 $connect$ 发起主动打开 ( $active$ $open$ )，即发送一个SYN报文； 服务器确认 ( ACK ) 客户端的SYN，同时也发送一个SYN； 客户端确认服务器的SYN。   TCP终止一个连接需要四次挥手：
 某个进程调用 $close$ ，称为主动关闭 ( $active$ $close$ )，该端发送一个FIN报文； 对端接受FIN，执行被动关闭 ( $passive$ $close$ )。这个FIN由TCP确认，接收也作为一个文件结束符 ( $end-of-file$ , $EOF$ ) 传递给接收端应用程序 ( 放在已排队等候该应用进程接收的任何其他数据之后 )； 一段时间后，接收到EOF的进程调用 $close$ 关闭套接字，并发送一个FIN报文； 接收到FIN的原端TCP确认。   TCP状态转换图可参考TCP、UDP和DNS简介。
SCTP建立一个连接的过程为：
 服务器准备接受外部连接，通常通过调用 $socket$ 、$bind$ 、$listen$ 这 $3$ 个函数完成，称为被动打开； 客户端通过调用 $connect$ 或者发送一个隐式打开该关联的消息进行主动打开，从而发送一个INIT消息，告知服务器客户端的IP地址清单、初始序列号、分组起始标记、客户端请求的外出流数目以及客户端能支持的外出流的数目； 服务器以一个INIT ACK消息确认，其中含有服务器的IP地址清单、初始序列号、起始标记、请求的外出流数目、支持的外出流数目和一个状态cookie，包含服务器用于确认本次连接有效所需的所有状态； 客户端以一个COOKIE ECHO消息回射状态cookie； 服务器以一个COOKIE ACK消息确认cookie正确，于是连接建立。   SCTP不像TCP那样允许”半关闭“的连接，而是当某一端关闭时，另一端必须停止发送新数据，在发送完所有队列中的数据后关闭。</description>
    </item>
    
  </channel>
</rss>
