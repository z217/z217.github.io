<!DOCTYPE html>
<html lang="zh-CN"><head>
	<meta name="generator" content="Hugo 0.122.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="z217&#39;s blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/jquery.floatingscroll.css>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  <script src=https://z217blog.cn/js/jquery.floatingscroll.min.js></script>
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/navbutton.js></script>
<script src=https://z217blog.cn/js/lightswitcher.js></script>
<script src=https://z217blog.cn/js/toc.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>
        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a><br/>
        <a href="javascript:void(0)" id="scroll-top" onclick="scrollToTop()">回到顶部</a>
        <a href="javascript:void(0)" id="light-switcher">暗色模式</a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B3%E7%90%86%E8%A7%A3promise%E7%B1%BB%E5%9E%8B/">C&#43;&#43;协程（3）：理解promise</a>
        
        
        <p>无栈协程介绍，翻译自 https://lewissbaker.github.io/</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2024 Jan 27 16:19
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&amp;C&#43;&#43;
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/">C&#43;&#43;协程（2）：理解co_await</a>
        
        
        <p>无栈协程介绍，翻译自 https://lewissbaker.github.io/</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2024 Jan 25 00:00
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&amp;C&#43;&#43;
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/">C&#43;&#43;协程（1）：协程理论</a>
        
        
        <p>无栈协程介绍，翻译自 https://lewissbaker.github.io/</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2024 Jan 23 23:59
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&amp;C&#43;&#43;
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">分布式数据系统：共识算法</a>
        
        
        <p>数据密集型应用系统设计：分布式事务与共识</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Nov 13 16:18
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Arch
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9/">分布式数据系统：主从节点</a>
        
        
        <p>数据密集型应用系统设计：分布式数据系统</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Nov 06 15:24
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Arch
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B3%E7%90%86%E8%A7%A3promise%E7%B1%BB%E5%9E%8B/">C&#43;&#43;协程（3）：理解promise</a></h1>
            <div class="post-content">
                
                
                <p>        这篇文章是<a href="http://wg21.link/N4736"><code>C++</code>协程标准</a>系列的第三篇文章。<br>
        之前的文章可以在这里查看：</p>
<ul>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/">协程理论</a></li>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/">理解co_await</a></li>
</ul>
<p>        在这篇文章我会讲解你写的代码是怎么被编译器编译成协程代码的，并且你可以通过定义自己的 $Promise$ 类型来自定义协程行为。</p>
<h2 id="协程concepts">协程<code>concepts</code></h2>
<p>        协程标准添加了三个新的关键字：$co_-await$，$co_-yield$ 和 $co_-return$ 。无论你在函数体里使用哪个，编译器都会把这个函数编译成协程，这个函数也不再是普通函数。<br>
        编译器使用一些相当机械的转换来把你写的代码变成状态机，从而可以在函数内的特定点暂停，并在之后恢复执行。<br>
        在之前的文章我描述了协程标准引入的两个接口中的第一个接口：$Awaitable$ 接口。而第二个接口, $Promise$ 接口则对于这种代码转换来说十分重要。<br>
        $Promise$ 接口规定了自定义它所在协程行为的方法。库开发者可以用它定义协程被调用时的行为，协程返回的行为 ( 包括普通方式返回或者通过未处理异常返回 )，协程内使用 $co_-await$ 或者 $co_-yield$ 表达式的行为。</p>
<h2 id="promise对象">Promise对象</h2>
<p>        $Promise$ 对象通过实现协程执行过程中特定点的调用方法的形式来定义和控制对应协程的行为。</p>
<blockquote>
<p>在继续之前，我希望你能忘掉之前所有关于 $promise$ 是什么的记忆。在一些用例中，协程的 $promise$ 对象与 $std$::$future$ 的 $std$::$promise$ 的功能很相似，但在其他用例中，并不能拿来相比。可能把协程的 $promise$ 对象想象成一个用于控制协程行为、跟踪协程状态的“协程状态控制器”会更合适。</p>
</blockquote>
<p>        $promise$ 对象实例会跟随着每个协程函数调用时创建的协程帧一起被构造。<br>
        编程器会在协程执行的关键点生成对 $promise$ 对象的特定方法的调用。<br>
        在接下来的例子中，我们假设某个特定协程调用创建的 $promise$ 对象叫做 $promise$ 。<br>
        当你编写一个协程函数体 &lt;$body$-$statement$&gt; ，函数体包含了某个协程关键字 ( $co_-return$，$co_-await$，$co_-yield$ )，那么协程体将转变为 ( 大致地 ) 如下形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">body</span><span class="o">-</span><span class="n">statement</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">catch</span> <span class="p">(...)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nl">FinalSuspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        一个协程函数被调用后，在执行之前会有一系列的准备步骤，这些步骤与常规的函数会有些不同。<br>
        以下是一个步骤总结 ( 我会在接下来详细介绍每个步骤 )：</p>
<ol>
<li>通过 $operator$ $new$ ( 可选的 ) 分配协程帧。</li>
<li>将所有函数参数拷贝到协程帧。</li>
<li>调用 $promise$ 对象的构造函数，$promise$ 类型记为 $P$ 。</li>
<li>调用 $promise.get_-return_-object\left(\right)$ 方法获取协程首次暂停时需要返回给主调的返回值，并保存为一个局部变量。</li>
<li>$co_-await$ 调用 $promise.initial_-suspend\left(\right)$ 方法获取结果。</li>
<li>当 $co_-await$ $promise.initial_-suspend\left(\right)$ 表达式恢复 ( 可能立即恢复或者异步恢复 ) 后，协程开始执行你编写的协程体语句。</li>
</ol>
<p>        当协程执行到 $co_-return$ 语句时，会进行一些额外的步骤：</p>
<ol>
<li>调用 $promise.return_-void\left(\right)$ 或者 $promise.return_-value$(&lt;$expr$&gt;)。</li>
<li>以与创建顺序相反的顺序自动销毁所有具有自动生命周期的变量。</li>
<li>$co_-await$ 调用 $promise.final_-suspend\left(\right)$ 获取结果。</li>
</ol>
<p>        如果执行因为一个未处理异常停止，那么会发生：</p>
<ol>
<li>在<code>catch</code>块中捕获异常，调用 $promise.unhandled_-exception\left(\right)$ 。</li>
<li>$co_-await$ 调用 $promise.final_-suspend\left(\right)$ 获取结果。</li>
</ol>
<p>        一旦执行到协程体之外，协程帧就会被销毁。通过以下步骤销毁协程帧：</p>
<ol>
<li>调用 $promise$ 对象的析构函数。</li>
<li>调用拷贝的函数参数的析构函数。</li>
<li>调用 $operator$ $delete$ 释放协程帧的内存空间 ( 可选的 )。</li>
<li>返回控制权给主调/恢复者。</li>
</ol>
<p>        当执行首次到达 $co_-await$ 表达式的 &lt;$return$-$to$-$caller$-$resumer$&gt; 点，或者协程没有到达任何 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点就完成时，协程要么被暂停，要么被销毁，然后之前 $promise.get_-return_-object\left(\right)$ 调用返回的结果就会被返回给协程的主调。</p>
<h3 id="分配协程帧">分配协程帧</h3>
<p>        首先，编译器生成一个对协程帧的 $operator$ $new$ 调用来分配内存。<br>
        如果 $promise$ 类型 $P$，定义了一个特殊的 $operator$ $new$ ，那么就会调用它定义的，否则就调用全局的。<br>
        这里有几个重要点需要注意：<br>
        传给 $operator$ $new$ 的大小不是 $sizeof\left(P\right)$ ，而是整个编译过程中编译器计算出来的协程帧大小，包括了入参的数量和大小、$promise$ 对象的大小、局部变量的数量和大小，以及一些其他编译器相关的用来管理协程状态的空间。<br>
        如果满足以下条件，编译器可以省掉对 $operator$ $new$ 的调用：</p>
<ul>
<li>协程帧的生命周期严格内嵌于主调。</li>
<li>编译器可以在调用点知道协程帧需要的内存大小。</li>
</ul>
<p>        在这种情况下，编译器可以在主调的调用栈 ( 栈帧部分或者协程帧部分 ) 上分配协程帧的空间。<br>
        协程标准没有定义什么情况下需要跳过分配，所以你需要在协程帧分配可能抛出 $std$::$bad_-alloc$ 异常的前提下编写代码。这意味着你不应该把一个协程函数声明成<code>noexcept</code>，除非你确定协程分配协程帧内存失败后会调用 $std$::$terminate\left(\right)$ 。<br>
        然而，有一个后备方案可以处理协程帧分配失败。在不允许异常的环境下，例如集成场景或者高性能场景这种不能容忍异常开销的场景，这种方式十分必要。<br>
        如果 $promise$ 类型提供了一个静态的 $P$::$get_-return_-object_-on_-allocation_-failure\left(\right)$ 成员函数，编译器会生成一个对 $operator$ $new$($size_-t$, $nothrow_-t$) 的重载调用。如果调用返回<code>nullptr</code>，那么协程会立即调用 $P$::$get_-return_-object_-on_-allocation_-failure\left(\right)$ 并把结果返回给主调，而不是抛出异常。</p>
<h4 id="自定义协程帧内存分配">自定义协程帧内存分配</h4>
<p>        你的 $promise$ 类型可以重载 $operator$ $new$ ，这样如果编译器需要分配协程帧内存，就会使用你定义的 $operator$ $new$ 而不是全局的 $operator$ $new$ 。<br>
        例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_promise_type</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">my_custom_allocate</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">my_custom_free</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        我知道你想问什么：“但是自定义 $allocator$ 呢?”。<br>
        你也可以提供 $P$::$operator$ $new\left(\right)$ 的重载，接收额外的参数，如果能找到合适的重载，将使用协程函数参数的左值引用调用。这种方式可以用来 $hook$ $operator$ $new$ ，使其调用某个作为参数传递给协程函数的 $allocator$ 的 $allocate\left(\right)$ 方法。<br>
        你需要做一些额外工作来在分配好的内存中拷贝一份 $allocator$ 的副本，这样才能在相应的 $operator$ $delete$ 调用中引用它，因为 $allocator$ 不会作为参数传递给的 $operator$ $delete$ 。这是因为入参会被存储在协程帧，所以他们有可能会在 $operator$ $delete$ 调用之前就被销毁了。<br>
        例如，你可以实现 $operator$ $new$ 来给协程帧分配一些额外内存，并利用这个空间来存储 $allocator$，用于释放协程帧内存。<br>
        例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ALLOCATOR</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_promise_type</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">sz</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">ALLOCATOR</span><span class="o">&amp;</span> <span class="n">allocator</span><span class="p">,</span> <span class="n">ARGS</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Round up sz to next multiple of ALLOCATOR alignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">allocatorOffset</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="n">sz</span> <span class="o">+</span> <span class="k">alignof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// CAll onto allocator to allocate space for coroutine frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">allocatorOffset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Take a copy of the allocator (assuming noexcept copy constructor here)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">new</span> <span class="p">(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">)</span> <span class="o">+</span> <span class="n">allocatorOffset</span><span class="p">)</span> <span class="n">ALLOCATOR</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">sz</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">allocatorOffset</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="n">sz</span> <span class="o">+</span> <span class="k">alignof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ALLOCATOR</span><span class="o">&amp;</span> <span class="n">allocator</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">ALLOCATOR</span><span class="o">*&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">)</span> <span class="o">+</span> <span class="n">allocatorOffset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Move allocator to local variable first so it isn&#39;t freeing its
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// own memory from underneath itself.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Assuming allocator move-constructor is noexcept here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ALLOCATOR</span> <span class="n">allocatorCopy</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// But don&#39;t forget to destruct allocator object in coroutine frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">allocator</span><span class="p">.</span><span class="o">~</span><span class="n">ALLOCATOR</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Finally, free the memory using the allocator.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">allocatorFactory</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">allocatorOffset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        为了 $hook$ 成功，让自定义的 $my_-promise_-type$ 被协程使用，需要让 $std$::$allocator_-arg$ 作为第一个入参，这需要通过 $coroutine_-traits$ 类 ( 详细见后续的 $coroutine_-traits$ 章节 ) 来指定。<br>
        例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ALLOCATOR</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_traits</span><span class="o">&lt;</span><span class="n">my_return_type</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">ALLOCATOR</span><span class="p">,</span> <span class="n">ARGS</span><span class="p">...</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="n">my_promise_type</span><span class="o">&lt;</span><span class="n">ALLOCATOR</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        注意，即使你自定义了协程的内存分配策略，编译器还是可以跳过你的内存分配过程。</p>
<h3 id="拷贝参数到协程帧">拷贝参数到协程帧</h3>
<p>        协程需要从原始主调中把所有传给协程的参数拷贝到协程帧，这样才能保证协程被暂停后，它们依然有效。<br>
        如果参数是值传递的，那么这些参数将会通过移动构造函数拷贝到协程帧。<br>
        如果参数以引用传递 ( 左值或者右值 )，那么只有引用会被拷贝到协程帧，而不是它们指向的值。<br>
        注意如果类型的析构函数是默认的，并且在到达 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点后不再引用，编译器可以跳过析构该参数副本。<br>
        在以引用方式传递参数给协程的过程中，存在几个陷阱，也因此你不能在协程生命周期中依赖引用。许多常见的用于普通函数的技术，例如完美转发和通用引用，用到协程上可能导致代码出现未定义行为。如果你想了解更多，Toby Allsopp 写了一篇关于这个主题的<a href="https://toby-allsopp.github.io/2017/04/22/coroutines-reference-params.html">好文章</a>。<br>
        如果某个参数的拷贝/移动构造函数抛出了异常，那么已经构造好的参数的析构函数将被调用，协程帧会被释放，异常会传播给主调。</p>
<h3 id="构造-promise-对象">构造 promise 对象</h3>
<p>        一旦所有参数被拷贝到协程帧，协程会构造 $promise$ 对象。<br>
        参数在 $promise$ 对象之前构造的原因是让 $promise$ 对象可以在构造函数中访问先前拷贝的参数。<br>
        首先，编译器检查 $promise$ 构造函数是否存在接收每个拷贝的参数左值引用的重载函数，如果找到了这种函数，编译器会生成对这个构造函数的调用，如果没有找到，编译器会使用 $promise$ 类型的默认构造函数。<br>
        注意 $promise$ 构造函数可以“看到”入参是一个对协程标准相对较新的改动，在 Jacksonville 2018 会议的<a href="http://wg21.link/N4723">N4723</a> 中被采纳，提案为<a href="http://wg21.link/P0914R1">P0914R1</a>。因此对于一些较老版本的<code>Clang</code>或者<code>MSVC</code>来说可能还不支持。<br>
        如果 $promise$ 构造函数抛出了一个异常，那么入参的拷贝会析构，协程帧会在异常传播回给主调之前被释放。</p>
<h3 id="获取返回对象">获取返回对象</h3>
<p>        协程要对 $promise$ 对象做的第一件事是调用 $promise.get_-return_-object\left(\right)$ 获取返回对象。<br>
        返回对象是协程函数初始暂停或者运行完成移交控制权后要返回给主调的值。<br>
        你可以认为控制流是这样的 ( 大致的 )：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// Pretend there&#39;s a compiler-generated structure called &#39;coroutine_frame&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1">// thta holds all of the state needed for the coroutines. It&#39;s constructor
</span></span></span><span class="line"><span class="cl"><span class="c1">// takes a copy of parameters and default-constructs a promise object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">coroutine_frame</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="nf">some_corouine</span><span class="p">(</span><span class="n">P</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">coroutine_frame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">returnObject</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Start execution of the coroutine body by resuming it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This call will return when the coroutine gets to the first.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// suspend-point or when the coroutine runs to completion.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">promise</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">promise</span><span class="p">).</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Then the return object is returned to the caller.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">returnObject</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        注意我们需要在协程体之前获取返回对象，因为协程帧 ( 或者说 $promise$ 对象 ) 可能在 $coroutine_-handle$::$resume\left(\right)$ 调用返回前就被销毁，可能在当前线程销毁，也可能在其他线程，所以在协程体开始执行后调用 $get_-return_-object\left(\right)$ 是不安全的。</p>
<h3 id="初始暂停点">初始暂停点</h3>
<p>        协程帧初始化，获取返回对象之后，要做的下一件事是执行 $co_-await$ $promise.initial_-suspend\left(\right);$ 。<br>
        这让 $promise$ 类型的开发者可以控制协程在执行编写好的协程体代码之前是否需要等待，或者立即执行协程体。<br>
        如果协程在初始暂停点暂停，那么它可以在之后你选择的某个时间点对 $coroutine_-handle$ 调用 $resume\left(\right)$ 来恢复，或者调用 $destroy\left(\right)$ 销毁。<br>
        $co_-await$ $promise.initial_-suspend\left(\right)$ 表达式的结果会被丢弃，所以实现 $awaiter$ 的 $await_-resume\left(\right)$ 函数实现应该返回<code>void</code>。<br>
        注意这个语句是在<code>try/catch</code>块保护之外的 ( 如果你忘记了，可以往上翻翻再看下代码 )。这意味着 $co_-await$ $promise.initial_-suspend\left(\right)$ 抛出的异常等同于到达它的 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点，会在协程销毁调用栈和返回对象后，再抛回给主调。<br>
        要明白如果你的返回对象是<code>RAII</code>，即会在协程帧被析构的时候销毁，那么你需要保证 $co_-await$ $promise.initial_-suspend\left(\right)$ 是<code>noexcept</code>的，这样才能避免 double-free。</p>
<blockquote>
<p>注意这里有个提案，希望调整语义，以便 $co_-await$ $promise.initial_-suspend\left(\right)$ 表达的全部或者部分位于<code>try/catch</code>块内，所以这里的明确语义可能会在最终确定前发生变化。</p>
</blockquote>
<p>        对于许多协程类型来说，$initial_-suspend\left(\right)$ 方法要么返回 $std$::$experimental$::$suspend_-always$ ( 如果操作懒开始 )，要么返回 $std$::$experimental$::$suspend_-never$ ( 如果操作立即开始 )。而它们都是<code>noexcept</code>的 $awaitable$ ，所以这通常不是问题。</p>
<h3 id="返回给主调">返回给主调</h3>
<p>        当协程函数达到首个 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点 ( 或者没有到达，但是协程执行完成 ) 时，通过 $get_-return_-object\left(\right)$ 获取的返回对象会返回给协程的主调。<br>
        注意返回对象的类型并不需要与协程函数的返回类型相同。在必要的时候，返回对象可以是一个能够隐式转换为协程返回类型的类型。</p>
<blockquote>
<p>注意<code>Clang</code>的协程实现 ( 从$5.0$ 开始 ) 会在返回对象从协程调用返回后才会转换，而<code>MSVC</code>自从 2017 Update 3 开始会在 $get_-return_-object\left(\right)$ 调用之后立即转换。虽然协程标准没有显式给出预期行为，我相信<code>MSVC</code>有计划把它们的实现改成更像<code>Clang</code>的实现，因为这种实现允许一些<a href="https://github.com/toby-allsopp/coroutine_monad">有趣的用例</a>。</p>
</blockquote>
<h3 id="使用-co_return-从协程返回">使用 co_return 从协程返回</h3>
<p>        当协程到达 $co_-return$ 语句，它会被翻译成一个 $promise.return_-void\left(\right)$ 调用或者 $promise.return_-value$(&lt;$expr$&gt;) 以及一个 $goto$ $FinalSuspend$ 调用。<br>
        翻译规则如下：</p>
<ul>
<li>$co_-return$;
<ul>
<li>-&gt; $promise.return_-void\left(\right)$</li>
</ul>
</li>
<li>$co_-return$ &lt;$expr$&gt;
<ul>
<li>-&gt; 如果 &lt;$expr$&gt; 类型为<code>void</code>，&lt;$expr$&gt;; $promise.return_-void\left(\right)$;</li>
<li>-&gt; 如果 &lt;$expr$&gt; 类型不为<code>void</code>，$promise.return_-value$(&lt;$expr$&gt;);</li>
</ul>
</li>
</ul>
<p>        随后的 $goto$ $FinalSuspend;$ ，会在 $co_-await$ $promise.final_-suspend\left(\right)$ 之前触发所有自动生命周期的局部变量按照与构造顺序相反的顺序析构。<br>
        注意如果协程函数体代码没有以 $co_-return$ 语句结束，会等同于以 $co_-return;$ 结束。在这个例子中，如果 $promise$ 类型没有 $return_-void\left(\right)$ 方法，那么行为会是未定义的。<br>
        如果 &lt;$expr$&gt; 或者 $promise.return_-void\left(\right)$ 调用或者 $promise.return_-value\left(\right)$ 抛出了一个异常，那么异常仍然会传给 $promise.unhandled_-exception\left(\right)$ ( 见以下 )。</p>
<h3 id="处理传播到协程体以外的异常">处理传播到协程体以外的异常</h3>
<p>        如果一个异常传播到协程体之外，那么异常会被<code>catch</code>块捕获，并调用 $promise.unhandled_-exception\left(\right)$ 方法。<br>
        这个方法典型实现是调用 $std$::$current_-exception\left(\right)$ 来捕获异常的副本，在后续抛出到其他上下文。<br>
        其他可选实现是立即通过 $throw;$ 语句重新抛出异常，例如 <a href="https://github.com/facebook/folly/blob/4af3040b4c2192818a413bad35f7a6cc5846ed0b/folly/Optional.h#L587">$folly$::$Optional$</a>。然而，这么做会 ( 或者说很可能，见以下 ) 导致协程帧被立即销毁，并将异常传播回主调 / 恢复者。这可能会导致某些 $abstractions$ 出现问题，因为它们假设 / 要求对 $coroutine_-handle$::$resume\left(\right)$ 的调用是<code>noexcept</code>，所以你应该只在能够完全控制谁 / 什么调用 $resume\left(\right)$ 时使用这种方式。<br>
        注意现在<a href="http://wg21.link/N4736">协程标准</a>在调用 $unhandled_-exception\left(\right)$ 时重新抛出异常 ( 或者在<code>try-catch</code>块之外抛出异常 ) 的预期行为描述<a href="https://github.com/GorNishanov/CoroutineWording/issues/17">并不是很清晰</a>。<br>
        我现在对标准的解释是如果控制权离开了协程体，可以通过 $co_-await$ $promise.initial_-suspend\left(\right)$ 、$promise.unhandled_-exception\left(\right)$ 或者 $co_-await$ $promise.final_-suspend\left(\right)$ 把异常传播出去，也可以通过 $co_-await$ $promise.final_-suspend\left(\right)$ 调用同步结束协程执行。无论哪种方式，都会在返回给主调 / 恢复者前自动销毁协程帧。然而，这种解释也有问题。<br>
        我希望在未来版本中能够细化并阐述清楚这种情况。不管如何，在那之前我不会从 $initial_-suspend\left(\right)$ 、$final_-suspend\left(\right)$ 或者 $unhandled_-exception\left(\right)$ 中抛出异常。敬请关注！</p>
<h3 id="最终暂停点">最终暂停点</h3>
<p>        一旦协程体执行离开了用户定义的部分后，结果会通过 $return_-void\left(\right)$ 、$return_-value\left(\right)$ 或者 $unhandled_-exception\left(\right)$ 调用捕获，所有局部变量被析构，在返还控制权给主调 / 恢复者之前，协程可以执行一些额外的逻辑。<br>
        这时候协程执行的是 $co_-await$ $promise.final_-suspend\left(\right);$ 语句。<br>
        它允许协程执行一些逻辑，比如生成结果，发出完成信号或者恢复一个任务。它也允许协程选择性地在协程完成、协程帧被销毁前立即暂停。<br>
        注意 $resume\left(\right)$ 一个在 $final_-suspend$ 点暂停的协程是未定义行为。对于这种协程，你只能调用 $destroy\left(\right)$。<br>
        根据 Gor Nishanov 的观点，这种限制的理由是它能减少一些协程的暂停状态，以及一些潜在的分支，让编译器可以做出更好的优化。<br>
        注意协程也可以不在 $final_-suspend$ 点暂停，<strong>只是建议你设计一个会在这个点暂停的协程</strong>。因为这样可以强制你在协程外调用 $.destroy\left(\right)$ ( 通常通过<code>RAII</code>对象的析构函数调用 )，并且可以方便编译器确定协程帧的生命周期是否内嵌于主调，从更让编译器更有可能优化掉协程帧的内存分配。</p>
<h3 id="编译器怎么选择-promise-类型">编译器怎么选择 promise 类型</h3>
<p>        让我们看看编译器怎么决定协程使用的 $promise$ 类型。<br>
        协程 $promise$ 对象的类型通过 $std$::$experimental$::$coroutine_-traits$ 类决定。<br>
        如果你有一个协程函数签名如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">x</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flag</span><span class="p">);</span>
</span></span></code></pre></div><p>        那么编译器会通过返回类型和参数类型作为 $coroutine_-traits$ 的模板参数来推导协程的 $promise$ 类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">coroutine_traits</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span></code></pre></div><p>        如果函数是非静态成员函数，<code>class</code>类型会作为第二个模板参数传递给 $coroutine_-traits$。注意如果你的方法是右值引用重载的，那么第二个模板参数也会是右值引用。<br>
        例如，如果你有以下方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">my_class</span><span class="o">::</span><span class="n">method1</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">task</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span> <span class="n">my_class</span><span class="o">::</span><span class="n">method2</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
</span></span></code></pre></div><p>        编译器会使用以下 $promise$ 类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// method1 promise type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typename</span> <span class="n">coroutine_traits</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">const</span> <span class="n">my_class</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// method2 promise type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typename</span> <span class="n">coroutine_traits</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">my_class</span><span class="o">&amp;&amp;&gt;::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span></code></pre></div><p>        $coroutine_-traits$ 模板会默认查找返回类型是否存在内嵌 $promise$ 类型，并使用其作为 $promise$ 类型，例如这样 ( 不过通过一些<code>SFINAE</code>魔法，如果 $RET$::$promise_-type$ 没有定义，那么 $promise$ 类型也是未定义的 )：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RET</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_traits</span><span class="o">&lt;</span><span class="n">RET</span><span class="p">,</span> <span class="n">ARGS</span><span class="p">...</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">RET</span><span class="o">::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        所以对于你可以控制的协程返回类型，你可以在里面定义一个内嵌的 $promise$ 类型，让编译器直接使用作为协程的 $promise$ 对象。<br>
        例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">task</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="n">task_promise</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        然而，对于你无法控制的协程返回类型，你可以在不修改类型的前提下，通过指定 $coroutine_-traits$ 来控制 $promise$ 类型。<br>
        例如，给一个返回 $std$::$optional$&lt;$T$&gt; 的协程定义 $promise$ 类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_traits</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ARGS</span><span class="p">...</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="n">optional_promise</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="识别特定协程调用栈">识别特定协程调用栈</h3>
<p>        当你调用一个协程函数时，协程帧会被创建。为了恢复协程或者销毁协程帧，你需要一些方法识别或者引用对应的协程帧。<br>
        协程标准通过 $coroutine_-handle$ 类型提供了这个机制。<br>
        类型接口 ( 大致的 ) 如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Type-erased coroutine handle. Can refer to any kind of coroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Doesn&#39;t allow access to the promise object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Constructs to the null handle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">constexpr</span> <span class="nf">coroutine_handle</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Convert to/from a void* for passing into C-style interop functions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">constexpr</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Query if the handle is non-null.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">constexpr</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Query if the coroutine is suspended at the final_suspend point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Undefined behavior if coroutine is not currently suspend.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Resume/Destroy the suspended coroutinie
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Coroutine handle for coroutines with a known promise type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Template argument must exactly match coroutine&#39;s promise type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span> <span class="o">:</span> <span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">coroutine_handle</span><span class="o">&lt;&gt;::</span><span class="n">coroutine_handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Access to the coroutine&#39;s promise object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// You can reconstruct the coroutine handle from the promise object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_promise</span><span class="p">(</span><span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        你可以通过两种方式获取一个协程的 $coroutine_-handle$ ：</p>
<ol>
<li>$coroutine_-handle$ 会在 $co_-await$ 表达式中被传递给 $await_-suspend\left(\right)$ 。</li>
<li>如果你有一个协程 $promise$ 对象的引用，你可以通过 $coroutine_-handle$&lt;$Promise$&gt;::$from_-promise\left(\right)$ 重新构造它的 $coroutine_-handle$ 。</li>
</ol>
<p>        挂起协程的 $coroutine_-handle$ 会在 $co_-await$ 表达式中，协程到达 &lt;$suspend$-$point$&gt; 被暂停后，传给 $awaiter$ 的 $await_-suspend\left(\right)$ 方法。你可以认为这个 $coroutine_-handle$ 代表 <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">连续传递风格</a> ( $continuation-passing$ $style$ ) 调用协程的连续传递。<br>
        注意 $coroutine_-handle$ <strong>不是</strong><code>RAII</code>对象。你必须手动调用 $.destroy\left(\right)$ 来销毁协程帧，释放资源。可以把它视为一个用于管理内存的 $void*$ 值。这么设计是出于性能原因：<code>RAII</code>会带来额外的开销，比如需要引用计数管理。<br>
        你应该尝试使用更高级的支持协程<code>RAII</code>语义的类型，例如<a href="https://github.com/lewissbaker/cppcoro">cppcoro</a>提供的 ( 不要脸地打广告 )，或者编写一个你自己的更高级的类型，封装你协程类型的协程帧生命周期。</p>
<h3 id="自定义-co_await-行为">自定义 co_await 行为</h3>
<p>        $promise$ 类型可以自定义出现在协程体内的每个 $co_-await$ 表达式行为。<br>
        通过简单地定义 $promise$ 类型的 $await_-transform\left(\right)$ 方法，编译器会把协程体里的每个 $co_-await$ &lt;$expr$&gt; 转换成 $co_-await$ $promise.await_-transform$(&lt;$expr$&gt;)。<br>
        这里有一些重要且有用的用法：<br>
        <strong>它能挂起一些非 $awaitable$ 类型。</strong><br>
        例如，一个返回 $std$::$optional$&lt;$T$&gt; 类型的协程可能会重载 $promise$ 类型的 $await_-transform\left(\right)$ ，使用 $std$::$optional$&lt;$U$&gt; 并返回一个 $awaitable$ 类型，该类型会返回类型 $U$ 的值，或者在<code>nullopt</code>时暂停协程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">optional_promise</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">await_transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">awaiter</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">explicit</span> <span class="n">awaiter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">has_value</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="kt">void</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">      <span class="n">U</span><span class="o">&amp;</span> <span class="n">await_resume</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">awaiter</span><span class="p">{</span> <span class="n">value</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        <strong>它可以让你通过删除 $await_-transform$ 方法来禁止挂起一个特定类型。</strong><br>
        例如，一个 $std$::$generator$&lt;$T$&gt; 返回类型的 $promise$ 类型可能会声明一个已删除的 $await_-transform\left(\right)$ 且接收所有类型的模板成员函数。这基本上禁止了所有在协程内的 $co_-await$ 调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">generator_promise</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Disable any use of co_await within this type of coroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">suspend_never</span> <span class="n">await_transform</span><span class="p">(</span><span class="n">U</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        <strong>它可以适配和改变一般 $awaitable$ 值的行为。</strong><br>
        例如，你可以定义一个协程类型，通过把 $awaitable$ 包装在 $resume_-on\left(\right)$ 操作中 ( 参考 $cppcoro$::$resume_-on\left(\right)$ )，保证协程始终在关联的 $executor$ 上的 $co_-await$ 表达式中恢复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Executor</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">executor_task_promise</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Executor</span> <span class="n">executor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Awaitable</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">await_transform</span><span class="p">(</span><span class="n">Awaitable</span><span class="o">&amp;&amp;</span> <span class="n">awaitable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">resume_on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">resume_on</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">executor</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        作为 $await_-transform\left(\right)$ 介绍的最后一句话，要注意的是，如果 $promise$ 类型定义了 $await_-transform\left(\right)$ 成员，编译器就会把所有 $co_-await$ 替换成 $promise.await_-transform\left(\right)$ 调用。这意味着如果你想要只给某些类型定制 $co_-await$ 行为，你也需要重载默认的只转发参数的 $await_-transform\left(\right)$ 实现。</p>
<h3 id="自定义-co_yield-行为">自定义 co_yield 行为</h3>
<p>        最后一个你可以通过 $promise$ 类型自定义行为的是 $co_-yield$ 关键字。<br>
        如果 $co_-yield$ 关键字在协程内出现，编译器会把表达式 $co_-yield$ &lt;$expr$&gt; 翻译成 $co_-await$ $promise.yield_-value$(&lt;$expr$&gt;) 。因此 $co_-yield$ 的行为可以通过定义一个或多个 $promise$ 类型的 $yield_-value\left(\right)$ 方法定制。<br>
        注意，不像 $await_-transform$ ，如果 $promise$ 类型没有定义 $yield_-value\left(\right)$ 方法，$co_-yield$ 没有默认行为。所以如果需要禁止 $co_-await$ 表达式，$promise$ 类型需要显式删除 $await_-transform\left(\right)$ 方法，但是 $co_-yield$ 则不用。<br>
        一种典型的 $promise$ 类型的 $yield_-value\left(\right)$ 方法实现是 $generator$&lt;$T$&gt; 类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">generator_promise</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">*</span> <span class="n">valuePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">suspend_always</span> <span class="n">yield_value</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Stash the address of the yielded value and then return an awaitable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// that will cause the coroutine to suspend at the co_yield expression.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Execution will then return from the call to coroutine_handle&lt;&gt;::resume()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// inside either generator&lt;T&gt;::begin() or generator&lt;T&gt;::iterator::operator++().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">valuePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="总结">总结</h2>
<p>        在这篇文章中，我依次介绍了编译器将函数编译成协程时的每个转换。<br>
        希望这篇能够帮你理解怎么通过定义自己的 $promise$ 类型的方式来定制不同类型的协程行为。协程机制中有许多可以变动的部分，所以有许多种自定义行为的方式。<br>
        然而，编译器有一个更重要的转换我还没讲——把协程体转换成状态机。不过要是讲这块的话，这篇文章就太长了，所以我把它放到了下一篇文章。请保持关注！</p>

            </div>
            <div class="meta post-footer">
                <span>2024 Jan 27 16:19</span>
                <a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B3%E7%90%86%E8%A7%A3promise%E7%B1%BB%E5%9E%8B/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/">C&#43;&#43;协程（2）：理解co_await</a></h1>
            <div class="post-content">
                
                
                <p>        在之前的文章中，我介绍了函数和协程在高级表现的区别，但还没有讲到到<code>C++</code>协程标准的语法和语义。<br>
        <code>C++</code>协程标准提供的一个关键能力是暂停协程，并在之后恢复。这个机制是通过 $co_-await$ 提供的。<br>
        在揭开协程的神秘面纱前，我们需要理解 $co_-await$ 的工作方式，了解它是如何暂停和恢复协程的。在这篇文章中，我会解释 $co_-await$ 的机制，并介绍<strong>Awaitable</strong>与<strong>Awaiter</strong>的概念。<br>
        在这之前，作为背景，我想先简单回顾下协程标准。</p>
<h2 id="协程标准带来了什么">协程标准带来了什么？</h2>
<ul>
<li>三个关键字 $co_-await$ ，$co_-yield$ 和 $co_-return$</li>
<li>一些 $std$::$experimental$ 命名空间的新类型：
<ul>
<li>$coroutine_-handle$&lt;$P$&gt;</li>
<li>$coroutine_-traits$&lt;$Ts$&hellip;&gt;</li>
<li>$suspend_-always$</li>
<li>$suspend_-never$</li>
</ul>
</li>
<li>一种允许库开发者与协程交互、客制化行为的机制</li>
<li>一个让异步代码更容易编写的语言能力</li>
</ul>
<p>        <code>C++</code>协程标准可以认为在语言层面提供了一个低级汇编语言协程。这些功能很难以一种安全的方式直接使用，主要是提供给库开发者来实现高级抽象，从而应用开发者可以安全使用。<br>
        之后的语言标准 ( 希望是<code>C++20</code> ) 计划加入这些低级功能，同时让标准库提供一些包装了这些功能的高级类型，让应用开发者以更方便安全的方式使用。</p>
<h2 id="编译器-lt-gt-库交互">编译器 &lt;-&gt; 库交互</h2>
<p>        有趣的是，协程标准并没有明确定义协程语义，包括协程如何把值返回给主调，$co_-return$ 如何处理返回值，如何处理传播到协程之外的异常，以及协程应该在哪个线程恢复。<br>
        相反的，它指定了一种可以让库代码客制化协程行为的机制，通过实现特定的接口类型。编译器使用库代码生成对应的调用。这种方式很像<code>range</code>模式，后者可以让库开发者通过定义 $begin\left(\right)$ / $end\left(\right)$ 和 $iterator$ 类型，来客制化代码。<br>
        协程的这种没有给机制定义特殊语义的方式，让它变成了一个强大的工具，允许库开发者实现各种类型的协程，以各种方式，出于各种目的。<br>
        例如，你可以实现一个异步生成单个值的协程，或者一个 $Lazy$ 生成值序列的协程，或者一个遇到 $nullopt$ 就提前退出的，简化 $optional$&lt;$T$&gt; 值的协程。<br>
        协程标准定义了两个接口：$Promise$ 和 $Awaitable$ 。<br>
        $Promise$ 接口指定了协程客制化行为的方法。库开发者可以通过该接口，实现当协程被调用时的行为，协程返回时的行为 ( 包括正常返回和抛出未处理异常 )，协程内使用 $co_-await$ 或者 $co_-yield$ 的行为。<br>
        $Awaitable$ 接口指定控制 $co_-await$ 语义的方法。当一个值是可以 $co_-await$ 的，代码就会被翻译成一系列的对 $awaitable$ 对象方法的调用。这个对象可以决定是否暂停当前协程，在暂停前执行一些逻辑用于后续的恢复，以及在恢复后生成 $co_-await$ 表达式的值。<br>
        我会在之后的文章再介绍 $Promise$ ，现在先来看看 $Awaitable$ 接口。</p>
<h2 id="awaiter和-awatiable解释co_await">Awaiter和 Awatiable：解释<code>co_await</code></h2>
<p>        $co_-await$ 运算符是一个新的一元运算符，接收一个值，比如：$co_-await$ $someValue$ 。<br>
        $co_-await$ 运算符只能在协程上下文中使用。这有一点重言了，因为根据定义，包含 $co_-await$ 操作符的函数都应该被编译成协程。<br>
        支持 $co_-await$ 运算符的类型被叫做 $Awaitable$ 类型。<br>
        注意，$co_-await$ 运算符能否对一个类型使用，取决于 $co_-await$ 出现的协程上下文。协程使用的 $promise$ 类型可以通过 $await_-transform$ 方法 ( 之后介绍 )，决定 $co_-await$ 的语义。<br>
        为了更精确，我喜欢使用术语<strong>一般 Awaitable</strong> ( $Normally$ $Awaitable$ ) 来描述一个协程上下文的 $promise$ 类型没有 $await_-transform$ 方法且支持 $co_-await$ 的协程。使用术语<strong>上下文 Awaitable</strong>来描述一个协程上下文的 $promise$ 类型存在 $await_-transform$ 方法的协程，这种类型仅在某些特别的上下文中才支持 $co_-await$ 运算符。<br>
        一个<strong>Awaiter</strong>类型实现了 $co_-await$ 调用会时使用到的三个方法：$await_-ready$ ，$await_-suspend$ 和 $await_-resume$ 。<br>
        注意我不要脸地从<code>C#</code> <code>asnyc</code>关键字中“借了” $Awaiter$ 这个术语。<code>C#</code>中这个术语指代可以通过 $GetAwaiter\left(\right)$ 方法返回类似于<code>C++</code> $Awaiter$ 对象的类型，而<code>C#</code>的 $Awaiter$ 也与<code>C++</code>有着诡异的相似，具体可以看<a href="https://weblogs.asp.net/dixin/understanding-c-sharp-async-await-2-awaitable-awaiter-pattern">这篇文章</a>。<br>
        注意一个类型既可以是 $Awaitable$ 类型，也可以是 $Awaiter$ 类型。<br>
        当编译器看到 $co_-awaiter$&lt;$expr$&gt; 表达式时，根据类型的不同，可能会有多种行为。</p>
<h3 id="获取-awaiter">获取 Awaiter</h3>
<p>        编译器要做的第一件事就是生成从挂起对象上获取 $Awaiter$ 对象的代码。$N4680$ 在 $5.3.8\left(3\right)$ 小节中列出了一系列的获取 $awaiter$ 的步骤。<br>
        假设挂起协程的 $promise$ 类型是 $P$ ，并且 $promise$ 在当前协程中是一个左值引用。<br>
        如果 $promise$ 类型 $P$ ，存在 $await_-transform$ 方法，&lt;$expr$&gt; 会被传入 $promise$.$await_-transform$(&lt;$expr$&gt;) 调用来获取 $Awaitable$ 值，记为 $awaitable$ 。相反，如果 $promise$ 类型没有 $await_-transform$ 成员，我们会直接使用 &lt;$expr$&gt; 来作为 $Awaitable$ 对象，同样记为 $awaitable$ 。<br>
        然后，如果 $Awaitable$ 对象 $awaitable$ 重载了 $operator$ $co_-awaiter\left(\right)$ ，那么这个函数就会被调用，来获取 $Awaiter$ 对象。否则，$awaitable$ 会被直接作为 $awaiter$ 对象使用。<br>
        如果我们把这些规则使用函数 $get_-awaitable\left(\right)$ 和 $get_-awaiter\left(\right)$ 来编码，看起来就是这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">P</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get_awaitable</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">expr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">has_any_await_transform_member_v</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">promise</span><span class="p">.</span><span class="n">await_transform</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Awaitable</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get_awaiter</span><span class="p">(</span><span class="n">Awaitable</span><span class="o">&amp;&amp;</span> <span class="n">awaitable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">has_member_operator_co_await_v</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">has_non_member_operator_co_await_v</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">operator</span> <span class="k">co_await</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="挂起-awaiter">挂起 Awaiter</h3>
<p>        假设我们把逻辑封装成上面那种获取 $Awaiter$ 对象的函数，那么 $co_-await$&lt;$expr$&gt; 可以简单翻译成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">awaitable</span> <span class="o">=</span> <span class="n">get_awaitable</span><span class="p">(</span><span class="n">promise</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">awaiter</span> <span class="o">=</span> <span class="n">get_awaiter</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">awaitable</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)(</span><span class="n">awaitable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">awaiter</span><span class="p">.</span><span class="n">await_ready</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">handle_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">await_suspend_result_t</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="k">decltype</span><span class="p">(</span><span class="n">awaiter</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">handle_t</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">p</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">suspend</span><span class="o">-</span><span class="n">coroutine</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_void_v</span><span class="o">&lt;</span><span class="n">await_suspend_result_t</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">awaiter</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">handle_t</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="k">return</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">caller</span><span class="o">-</span><span class="n">or</span><span class="o">-</span><span class="n">resumer</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">static_assert</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">await_suspend_result_t</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="s">&#34;await_suspend() must reutrn &#39;void&#39; or &#39;bool&#39;.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">awaiter</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">handle_t</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">&lt;</span><span class="k">return</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">caller</span><span class="o">-</span><span class="n">or</span><span class="o">-</span><span class="n">resumer</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">resume</span><span class="o">-</span><span class="n">point</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">awaiter</span><span class="p">.</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        <code>void</code>版本的 $await_-suspend\left(\right)$ 无条件地在调用返回后交还控制权，而<code>bool</code>版本的则允许 $awaiter$ 对象有条件地在返回后恢复协程执行。<br>
        <code>bool</code>版本的 $await_-suspend\left(\right)$ 在 $awaiter$ 发起一个需要异步完成的操作时十分有用。在这种情况下，当任务异步完成后，$await_-suspend$ 可以返回<code>false</code>，表示协程应该立即恢复并继续执行。<br>
        在 &lt;$suspend$-$coroutine$&gt; ( 暂停协程 ) 处，编译器会生成一些代码来保存协程状态，并准备好被恢复。这些状态包括存储恢复点的位置，以及将一些寄存器值保存到当前协程帧内存中。<br>
        当前协程在 &lt;$suspend$-$coroutine\left(\right)$&gt; 操作完成后，就被认为已暂停。协程是在 $await_-suspend$ 调用内部被暂停的，一旦被暂停，就可以在之后被恢复或者销毁。<br>
        一旦 $await_-suspend\left(\right)$ 操作完成，就要在之后对这个协程进行恢复 ( 或者销毁 )。注意 $await_-suspend\left(\right)$ 返回<code>false</code>相当于在当前线程中立即恢复协程。<br>
        $await_-ready\left(\right)$ 方法可以让你避免 &lt;$suspend$-$coroutine$&gt; 带来的开销，因为它可以返回操作是否可以在不需要暂停的前提下同步完成。<br>
        在 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点，控制权会返还给主调或者恢复者，并弹出协程调用栈帧，保留协程栈帧。<br>
        当 ( 或者 ) 执行到 &lt;$resume$-$point$&gt; ( 恢复点 )，暂停的协程将被恢复。例如，在通过 $await_-resume\left(\right)$ 方法获取结果之前。<br>
        $await_-resume\left(\right)$ 方法的返回值会作为 $co_-await$ 表达式的结果。$await_-resume\left(\right)$ 方法也可以抛出一个异常，并将其传播到 $co_-await$ 表达式之外。<br>
        注意如果一个异常传播到 $await_-suspend\left(\right)$ 调用之外，协程将在没有 $await_-resume\left(\right)$ 调用的情况下被自动恢复，并将异常传播到 $co_-await$ 表达式之外。</p>
<h2 id="协程句柄">协程句柄</h2>
<p>        你可能注意到了，$coroutine_-handle$&lt;$P$&gt; 类型会被作为参数，在 $co_-await$ 表达式中传给 $await_-suspend\left(\right)$ 调用。 <br>
        这个类型代表一个无主的协程帧句柄，可以用来恢复协程执行，或者销毁协程帧。它可以用来获取协程的 $promise$ 对象。<br>
        $coroutine_-handle$ 类型有着如下 (省略了的) 接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span> <span class="o">:</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_promise</span><span class="p">(</span><span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        实现一个 $Awaitable$ 类型的时候，与 $coroutine_-handle$ 相关的关键方法是 $.resume\left(\right)$，它会在在操作完成并且想要恢复挂起中的协程执行的时候被调用。对 $coroutine_-handle$ 调用 $.resume\left(\right)$ 会在 &lt;$resume$-$point$&gt; 重新激活一个暂停的协程，在到达下一个 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点处返回。<br>
        $.destroy\left(\right)$ 方法摧毁协程帧，调用作用域内的变量析构器，释放协程帧使用的内存空间。一般情况下，你不需要主动 (  事实上真的需要避免 ) 调用 $.destroy\left(\right)$，除非你是一个正在实现协程 $promise$ 类型的库开发者。通常，协程帧会被某些协程返回的<code>RAII</code>类型所持有。所以再调用 $.destroy\left(\right)$ 可能导致一个双重析构的bug。<br>
        $.promise\left(\right)$ 方法返回一个协程 $promise$ 对象的引用。然后，就像 $.destroy\left(\right)$，一般只会在需要编写 $promise$ 类型时有用。你应该把 $promise$ 对象视为协程的一个内部细节实现。对于大部分一般 $Awaitable$ 类型，你应该使用 $coroutine_-handle$&lt;$void$&gt; 而不是 $coroutine_-handle$&lt;$Promise$&gt; 作为 $await_-suspend\left(\right)$ 方法的参数。<br>
        $coroutine_-handle$&lt;$P$&gt;::$from_-promise$($P$&amp; $promise$) 函数允许从协程 $promise$ 对象引用中重新构造协程。注意你必须保证类型 $P$ 与某个正在使用的协程帧匹配，如果 $P$ 的类型继承了 $promise$ 类型，并用于构造 $coroutine_-handle$&lt;$Base$&gt; ，会导致一些未定义行为。<br>
        $.address\left(\right)$ / $from_-address\left(\right)$ 函数允许把一个协程句柄转换成 $void*$ 指针，或者从一个 $void*$ 指针转换协程句柄。</p>
<h2 id="不需要同步的异步代码">不需要同步的异步代码</h2>
<p>        $co_-await$ 的一个十分有用的设计是协程可以在被暂停后，把控制权移交给主调 / 恢复者前执行代码。<br>
        这可以让 $Awaiter$ 对象在被暂停后发起一个异步操作，把被暂停协程的 $coroutine_-handle$ 传给该操作，并在不需要任何额外同步的前提下安全地恢复操作 ( 可能在其他线程上 )。<br>
        例如，在 $await_-suspend\left(\right)$ 调用中，发起一个异步读操作，当协程被暂停，意味着我们可以在读操作完成后，恢复协程的执行。这一步不需要任何线程同步操作，不需要协调发起线程和执行线程的关系。</p>
<pre tabindex="0"><code>Time     Thread 1                           Thread 2
  |      --------                           --------
  |      ....                               Call OS - Wait for I/O event
  |      Call await_ready()                    |
  |      &lt;supend-point&gt;                        |
  |      Call await_suspend(handle)            |
  |        Store handle in operation           |
  V        Start AsyncFileRead ---+            V
                                  +-----&gt;   &lt;AsyncFileRead Completion Event&gt;
                                            Load coroutine_handle from operation
                                            Call handle.resume()
                                              &lt;resume-point&gt;
                                              Call to await_resume()
                                              execution continues....
           Call to AsyncFileRead returns
         Call to await_suspend() returns
         &lt;return-to-caller/resumer&gt;
</code></pre><p>        当使用这种方便的方式时，你需要小心的一点是，当把协程句柄发给其他线程时，其他线程可能在 $await_-suspend\left(\right)$ 调用返回前就尝试恢复协程执行，导致在 $await_-suspend\left(\right)$ 未完成时，协程继续执行了。<br>
        当协程恢复后，做的第一件事是调用 $await_-resume\left(\right)$ 获取结果，然后通常立马析构 $Awaiter$ 对象 ( 例如，$await_-suspend\left(\right)$ 调用的<code>this</code>指针 )。然后协程可能执行直到完成，在 $await_-suspend\left(\right)$ 返回前销毁协程和 $promise$ 对象。<br>
        所以在 $await_-suspend\left(\right)$ 方法，一旦协程有可能被另一个线程并行地恢复，你就需要避免访问<code>this</code>或者协程的 $.promise\left(\right)$ 对象，因为两者都可能被摧毁。总的来说，当暂停操作从发起到完成期间，只有局部变量是安全的。</p>
<h3 id="与有栈协程相比">与有栈协程相比</h3>
<p>        我想换个话题，快速地与现有的其他有栈协程比较下无栈协程在暂停后执行逻辑的能力，比如<code>Win32 fibers</code>或者<code>boost::context</code>。<br>
        对于许多有栈协程来说，暂停和恢复操作被合并成了“上下文切换”操作。通过“上下文切换”操作，当前协程在暂停后没有机会去执行逻辑，只是单纯地将控制权移交给其他协程。<br>
        这意味着，如果我们想要基于有栈协程实现一个类似于异步文件读取操作，我们需要在暂停协程之前发起操作。因此有可能操作会在线程被暂停之前就在其他线程上完成了，并等待恢复。这种潜在的其他线程完成操作和协程暂停之间的竞态，需要一些线程同步机制来选择并决定胜者。<br>
        一种可选的方式是使用内嵌上下文 ( $tranpoline$ $context$ )，它可以通过暂停发起操作的上下文来表示发起某个操作。然而，这可能需要额外的架构，和另外的上下文切换来保证正常使用，并且成本可能大于它试图避免的同步操作的成本。</p>
<h2 id="减少内存分配">减少内存分配</h2>
<p>        异步操作经常需要给每个操作分配状态，用于跟踪操作执行阶段。这些状态需要在操作执行过程中保留，直到操作完成才会被释放。<br>
        例如，调用异步<code>Win32 I/O</code>函数需要你分配并传递一个 $OVERLAPPED$ 结构指针。主调需要保证指针在操作完成前都是有效的。<br>
        典型的基于回调的<code>API</code>要求这些状态分配在堆上，并保证它们有着合适的生命周期。如果你正在执行很多操作，你可能需要给每个操作都分配和释放状态。如果这导致性能问题，你可能需要通过内存池来分配这些状态。<br>
        然而，当使用协程时，利用局部变量在协程帧内的特性，我们可以避免堆分配存储，因为协程帧内的变量在协程被暂停时也是存活的。<br>
        通过把 $co_-await$ 表达式中每个操作状态放到 $Awaiter$ 对象中，我们可以有效的从协程帧中“借用”内存。一旦操作完成，协程被恢复，$Awaiter$ 对象被摧毁，释放协程帧中其他局部变量使用的内存。<br>
        最终，协程帧还是分配在堆上。然而，只需要一次堆分配，协程帧就可以被用来执行许多异步操作。<br>
        你想一想，协程帧其实就是<code>arena</code>内存分配器的一种高级表现。编译器计算出所有局部变量需要的<code>arena</code>大小，然后零成本地分配所有局部变量！试着用传统的分配器来战胜它;)</p>
<h2 id="例子实现一个单线程同步原语">例子：实现一个单线程同步原语</h2>
<p>        现在我们已经讲了许多 $co_-await$ 运算符的机制，我想实现一个基本的 $awaitable$ 同步原语：一个异步手动重置 $event$，来把这些知识运用到实践上。<br>
        这个 $event$ 的基本需求是对许多并行执行的协程来说是 $Awaitble$ 的，挂起操作会等暂停挂起协程，直到一个线程调用 $.set\left(\right)$ 方法，此时恢复所有挂起的协程。如果一个线程已经调用了 $.set\left(\right)$，协程应该在不暂停的前提下继续执行。<br>
        理想情况下，我想要让方法<code>noexcept</code>，这需要避免堆分配，以及无锁实现。<br>
        <strong>2017/11/23 编辑：增加 async_manual_reset_event 的用例</strong><br>
        用例看起来像是这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">T</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// A single call to produce a value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">value</span> <span class="o">=</span> <span class="n">some_long_running_computation</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Publish the value by setting the event.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">event</span><span class="p">.</span><span class="n">set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Supports multiple concurrent consumers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">consumer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Wait until the event is signalled by call to event.set()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// in the producer() function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">co_await</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Now it&#39;s safe to consume &#39;value&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This is guaranteed to &#39;happen after&#39; assignment to &#39;value&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        让我们先想想这个 $event$ 可能的状态：$not$ $set$ 和 $set$ 。<br>
        当处于 $not$ $set$ 状态，存在一个等待 $set$ 状态挂起协程的列表 ( 可能为空 )。<br>
        当设置 $set$ 状态，就不应该存在挂起的协程，因为正在 $co_-await$ 这个 $event$ 的协程可以不暂停地继续执行。<br>
        这个状态可以通过一个 $std$::$atomic$&lt;$void*$&gt; 表示：</p>
<ul>
<li>保存一个特殊指针，指向 $set$ 状态。我们使用 $event$ 的<code>this</code>指针来表示，因为它不可能跟列表中其他对象的地址相同。</li>
<li>否则，$event$ 处于 $not$ $set$ 状态，指针值是一个单独的挂起协程的链表头。</li>
</ul>
<p>        我们可以通过把状态存储在协程帧的 $awaiter$ 对象的方式，避免在堆上对节点进行额外分配。<br>
        让我们实现一个类似如下的类接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">async_manual_reset_event</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="kt">bool</span> <span class="n">initiallySet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// No copying/moving
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="k">const</span> <span class="n">asnyc_manual_reset_event</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="n">async_manual_reset_event</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">asnyc_manual_reset_event</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">async_manual_reset_event</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">is_set</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">awaiter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span> <span class="k">operator</span> <span class="nf">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">set</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">struct</span> <span class="nc">awaiter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// - &#39;this&#39; =&gt; set state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// - otherwise =&gt; not set, head of linked list of awaiter*.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span> <span class="n">m_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        这里我们给出了一个相当简单直接的接口。主要要注意的点是 $operator$ $co_-await\left(\right)$ 返回一个未定义的 $awaiter$ 类型。<br>
        让我们先实现 $awaiter$ 。</p>
<h3 id="实现-awaiter">实现 Awaiter</h3>
<p>        首先，需要知道正在等待哪个 $async_-manual_-reset_-event$ ，所以需要一个 $event$ 引用和一个初始化它的构造器。<br>
        它同样需要作为 $awaiter$ 链表的节点，所以也需要保存下一个 $awaiter$ 对象的指针。<br>
        它还需要保存正在执行 $co_-await$ 的挂起协程的 $coroutine_-handle$ ，用来在 $event$ 被 $set$ 之后恢复协程。我们不关心协程的 $promise$ 类型，所以只需要使用 $coroutine_-handle$&lt;&gt; ( $coroutine_-handle$&lt;$void$&gt; 的缩写 )。<br>
        最后，它需要实现 $Awaiter$ 接口，所以需要三个特殊方法 $await_-ready$ ，$await_-suspend$ 和 $await_-resume$ 。我们不需要 $co_-await$ 返回值，所以 $await_-resume$ 可以返回 $void$ 。<br>
        一旦我们把所有东西放到一起，基本的 $awaiter$ 接口看起来就像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">async_manual_reset_event</span><span class="o">::</span><span class="n">awaiter</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span><span class="p">(</span><span class="k">const</span> <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">m_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaitinigCoroutine</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">class</span> <span class="nc">async_manual_reset_event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="n">m_event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">m_awaitingCoroutine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span><span class="o">*</span> <span class="n">m_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        当 $co_-await$ 一个 $event$ 时，我们不想让挂起协程在 $event$ 被 $set$ 的时候暂停。所以我们让 $await_-ready\left(\right)$ 在 $event$ 已经 $set$ 的时候返回<code>true</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">awaiter</span><span class="o">::</span><span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">m_event</span><span class="p">.</span><span class="n">is_set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        接下来，让我们看看 $await_-suspend\left(\right)$ 方法，许多 $awaitable$ 类型的有趣行为都发生在这里。<br>
        首先它需要在 $m_-awaitingCoroutine$ 成员中保存协程句柄，用于后续调用 $.resume\left(\right)$ 。<br>
        保存句柄之后，需要把 $awaiter$ 自动地加入链表中。成功入队之后，如果 $event$ 还没有被设置成 $set$ 状态，返回<code>true</code>表示我们不希望立即恢复协程，否则返回<code>false</code>，表示协程应该立马恢复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="nl">awaiter</span><span class="p">:</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaitingCoroutine</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Special m_state value that indicates the event is in the &#39;set&#39; state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="k">const</span> <span class="n">setState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Remember the handle of the awaiting coroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">m_awaitingCoroutine</span> <span class="o">=</span> <span class="n">awaitingCoroutine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Try to atomically push this awaiter onto the front of the list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span><span class="o">*</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">m_event</span><span class="p">.</span><span class="n">m_state</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Resume immediately if already in &#39;set&#39; state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">oldValue</span> <span class="o">==</span> <span class="n">setState</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Upload linked list to point at current head.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">m_next</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">awaiter</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">oldValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Finally, try to swap the old list head, inserting this awaiter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// as the new list head.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">m_event</span><span class="p">.</span><span class="n">m_state</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">oldValue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// Successfully enqueued. Remain suspend.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        注意我们使用 $acquire$ 内存序读取旧状态，这样我们就可以看到所有发生在 $set\left(\right)$ 调用之前的写操作了。<br>
        我们需要用 $release$ 内存序调用 $compare$-$exchange$ ，这样之后的 $set\left(\right)$ 就可以看到我们写入的 $m_-awaitingCoroutine$ 和更早写入的协程状态。</p>
<h3 id="完成-event-类的剩余实现">完成 event 类的剩余实现</h3>
<p>        我们已经定义好了 $awaiter$ 类型，再看回来 $async_-manual_-reset_-event$ 的方法。<br>
        首先是构造函数，它需要使用空的链表 ( 比如<code>nullptr</code>) 初始化为 $not$ $set$ 状态，或者初始化为 $set$ 状态 ( 比如<code>this</code> )。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">async_manual_reset_event</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">initiallySet</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="n">m_state</span><span class="p">(</span><span class="n">initiallySet</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span></code></pre></div><p>        接下来，$is_-set\left(\right)$ 方法更直接，如果持有<code>this</code>指针，那么就是 $set$ 状态。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">is_set</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">m_state</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">==</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        接着是 $reset\left(\right)$ 方法，如果当前是 $set$ 状态，我们需要重置为空链表的 $not$ $set$ 状态，否则不做任何事：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">reset</span><span class="p">()</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span><span class="o">*</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">m_state</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">oldValue</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        通过 $set\left(\right)$ 方法，我们可以用特殊的<code>this</code>指针与当前值交换，从而设置状态为 $set$。如果存在挂起的协程，我们需要在返回前依次恢复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">set</span><span class="p">()</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Needs to be &#39;release&#39; so that subsequent &#39;co_await&#39; has
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// visibility of our prior writes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Needs to be &#39;acquire&#39; so that we have visibility of prior
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// writes by awaiting coroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span><span class="o">*</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">m_state</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">oldValue</span> <span class="o">!=</span> <span class="k">this</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Wasn&#39;t already in &#39;set&#39; state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Treat old value as head of a linked-list of waiters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// which we have now acquired and need to resume.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span><span class="o">*</span> <span class="n">waiters</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">awaiter</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">oldValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">waiters</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Read m_next before resuming the coroutines as resuming
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the coroutine will likely destroy the awaiter object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">auto</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">waiters</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">waiters</span><span class="o">-&gt;</span><span class="n">m_awaitingCoroutine</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">waiters</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        最后我们需要实现 $operator$ $co_-await\left(\right)$ 方法，只需要构造一个 $awaiter$ 对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">awaiter</span>
</span></span><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span><span class="o">::</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">awaiter</span><span class="p">{</span> <span class="o">*</span><span class="k">this</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        这样我们就完成了一个无锁，无额外内存分配，<code>noexcept</code>实现的 $awaitable$ 的异步手动-重置 $event$ 。<br>
        如果你想要试试这段代码，看看它在<code>MSVC</code>和<code>Clang</code>下的编译结果，可以看一下<a href="https://godbolt.org/g/Ad47tH">godbolt上的源码</a>。<br>
        你也可以在<a href="https://github.com/lewissbaker/cppcoro">cppcoro库</a> 上看到这段实现，以及更多的其他的有用的 $awaitable$ 类型，例如 $async_-mutex$ 和 $async_-auto_-reset_-event$ 。</p>
<h2 id="写在结尾">写在结尾</h2>
<p>        这篇文章介绍了 $operator$ $co_-await$ 是怎么通过 $Awaitable$ 和 $Awaiter$ 这两个<code>concept</code>实现的。<br>
        同样也讲了怎么实现一个 $awaitable$ 的异步线程同步原语，使用了 $awaiter$ 对象在协程帧上分配的优点，避免了额外的堆分配。<br>
        我希望这篇文章可以帮助你理解新的 $co_-await$ 运算符。<br>
        在下一篇文章中，我将介绍 $Promise$ <code>concept</code>，以及一个协程类型的开发者可以怎样设计协程的行为。</p>
<h2 id="致谢">致谢</h2>
<p>        这段就不翻了吧~</p>

            </div>
            <div class="meta post-footer">
                <span>2024 Jan 25 00:00</span>
                <a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/">C&#43;&#43;协程（1）：协程理论</a></h1>
            <div class="post-content">
                
                
                <p>        这是<code>C++</code> <code>Coroutines</code>标准 ( <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf">C++ Coroutines TS</a> ) 系列的第一篇文章，协程作为新技术被引入<code>C++20</code>标准。<br>
        在这个系列里我会介绍<code>C++</code>协程的底层机制，以及如何使用它们实现一些更高级的抽象，就像 <a href="https://github.com/lewissbaker/cppcoro">cppcoro</a> 库一样。<br>
        在这篇文章，我会介绍函数和协程的区别，以及相应的一些他们所支持的行为的理论。文章的目标是介绍一些基础概念，帮助你理解<code>C++</code>协程。</p>
<h2 id="协程是函数函数是协程">协程是函数，函数是协程</h2>
<p>        协程是一种允许<strong>暂停</strong> ( $suspend$ ) 和<strong>恢复</strong> ( $resume$ ) 的函数的统称。<br>
        在解释这个含义之前，我们先复习一下一个“普通”<code>C++</code>函数的行为是什么。</p>
<h2 id="普通函数">“普通”函数</h2>
<p>        一个普通函数具有两种行为：<strong>调用</strong> ( $call$ ) 和<strong>返回</strong> ( $return$ , 注意这里返回涵盖了抛出异常 )。<br>
        <strong>调用</strong>创建一个<strong>调用栈</strong> ( $activation$ $frame$ )，暂停主调函数，执行被调函数的第一条命令。<br>
        <strong>返回</strong>会把返回值传回给主调，销毁调用栈，然后在主调函数的调用点处，恢复主调函数的执行。<br>
        让我们再分析一下这些语义&hellip;&hellip;</p>
<h3 id="调用栈">调用栈</h3>
<p>        什么是“调用栈”？<br>
        你可以认为调用栈是一块存储着当前函数调用的内存。这些状态包括了入参和局部变量。<br>
        对于“普通”函数，调用栈也包含返回地址——函数返回时将跳转到的指令，和主调函数的调用栈地址。你可以认为这些信息是用来保持函数继续调用的，比如，它们描述了函数调用结束后，该继续执行哪个函数。<br>
        对于“普通”函数，所有的调用栈都有着严格嵌套的生命周期。严格嵌套可以更有效的分配和释放每个函数调用的内存。这种数据结构也被称为“栈”。<br>
        调用栈分配在栈上，也被称为“栈帧”。<br>
        栈是一种十分常见的数据结构，大部分<code>CPU</code>架构都有个专门的寄存器来保存栈顶地址 ( 例如，<code>X64</code>的<code>rsp</code>寄存器 )。<br>
        分配一个调用栈，只需要让寄存器加上栈帧大小的值。同样的，释放一个调用栈，也只需要让寄存器减去栈帧大小。</p>
<h3 id="调用">调用</h3>
<p>        当一个函数调用另一个函数，主调必须暂停自己。<br>
        “暂停”一般指保存当前<code>CPU</code>寄存器中的值，并在之后恢复的时候重新设置这些值。保存寄存器这一步，可以是主调执行，也可以是被调执行，取决于不同的调用方式，但你可以认为它们都是调用的其中一部分。<br>
        调用也会把入参在新的调用栈里保存一份，让被调可以访问。<br>
        最后，主调在新调用栈里面写入恢复点的地址，并把执行权让出给被调函数。<br>
        在<code>X86/X64</code>架构，最后一步有单独对应的 $call$ 指令，会把当前指令的下一条指令地址写入栈，递增栈寄存器，然后跳转到指令操作地址。</p>
<h3 id="返回">返回</h3>
<p>        当一个函数通过 $return$ 返回，函数会先把返回值保存到主调可以访问的地方，可以在主调调用栈，也可以在当前调用栈 ( 对于跨越两个调用栈的参数和返回值，这种概念可能没有明确的区别 )。<br>
        然后函数通过以下步骤销毁调用栈：</p>
<ul>
<li>在返回点销毁所有局部变量</li>
<li>销毁所有入参对象</li>
<li>释放调用占内存</li>
</ul>
<p>        最后，通过以下步骤恢复主调执行：</p>
<ul>
<li>栈寄存器指向当前调用存储的主调调用栈地址，恢复所有当前函数可能修改的<code>CPU</code>寄存器</li>
<li>跳转到之前“调用”操作存储的恢复点</li>
</ul>
<p>        注意，与“调用”操作一样，一些“返回”操作中主调和被调的细分职责可能不一样。</p>
<h2 id="协程">协程</h2>
<p>        协程是一种在函数的<strong>调用</strong>和<strong>返回</strong>操作的基础上细分出<strong>暂停</strong>、<strong>恢复</strong>和<strong>销毁</strong>三种额外操作的操作行为统称。<br>
        <strong>暂停</strong> ( $Suspend$ ) 操作让协程在当前函数的执行点处暂停，在不销毁调用栈的前提下，将控制权交还给主调函数的操作。协程执行过程中的所有对象在暂停之后依然存活。<br>
        注意，就像函数的<strong>返回</strong>操作一样，协程需要在预先定义好的暂停点处主动暂停。<br>
        <strong>恢复</strong>操作将在先前的暂停点处恢复协程的执行，这将会重新激活协程的调用栈。<br>
        <strong>销毁</strong>会在不恢复协程的前提下，销毁协程的调用栈，暂停点作用域内的所有对象也会被一并销毁。</p>
<h3 id="协程调用栈">协程调用栈</h3>
<p>        因为协程可以在不销毁调用栈的前提下被暂停，我们也就无法保证调用栈之间是严格嵌套的了。这意味着，调用栈不再能使用栈结构分配，取而代之的，是更多的堆存储。<br>
        <code>C++</code>协程标准中有些规定，允许在主调的调用栈上分配协程调用栈，只要编译器能保证协程的生命周期与主调严格嵌套。如果编译器足够智能，这种方式可以在一定程度上减少堆分配。<br>
        协程调用栈有一部分需要在协程暂停时保留，而另一个部分只会在协程执行时被用到。例如，不在协程暂停点上的变量，这些变量可以在栈上存储。<br>
        你可以认为协程调用栈由两部分组成：“协程帧”和“栈帧”。<br>
        “协程帧”指代调用栈中需要在协程暂停期间保留的部分，“栈帧”则指只需要在协程执行期间存在的部分，负责在协程暂停时将控制权移交给主调或者协程的恢复者 ( $resumer$ ) 并释放。</p>
<h3 id="暂停">暂停</h3>
<p>        <strong>暂停</strong>允许一个协程在函数执行的中间点暂停执行，并将控制权移交给主调 / 协程的恢复者。<br>
        <code>C++</code>协程标准定义协程内有几个指定暂停点，它们会使用 $co_-await$ 或者 $co_-yield$ 关键字标识。<br>
        当一个协程执行到暂停点时，会通过以下几步来暂停：</p>
<ul>
<li>确保寄存器值已写入协程帧</li>
<li>将暂停点写入协程帧，用于后续恢复操作恢复执行，或者销毁操作销毁暂停点前的变量</li>
</ul>
<p>        一旦协程准备好被恢复，就可以认为“已暂停”。<br>
        协程在把控制权交还给主调 / 恢复者之前，有机会执行一些额外的逻辑，返回当前协程帧的句柄，用于后续恢复或者销毁。<br>
        在暂停后允许执行额外逻辑的能力，让协程可以在不同步的前提下恢复。否则因为暂停和恢复的竞态，这种操作可能需要同步执行。我将在后续的文章中详细讨论。<br>
        协程可以选择立即恢复 / 继续协程执行，或者可以选择移交控制权给主调 / 恢复者。<br>
        如果控制权被移交给主调 / 恢复者，协程调用栈的栈帧部分将被释放。</p>
<h3 id="恢复">恢复</h3>
<p>        <strong>恢复</strong>可以对一个处于“暂停”状态的协程使用。<br>
        当一个函数恢复一个协程时，它需要快速地跳到对应函数执行的中间点。恢复者通过调用 $void$ $resume()$ 来在暂停返回的协程帧上，找到对应的指令。<br>
        就像普通函数调用，$resume()$ 会分配一个新的调用栈，并在移交控制权之前保存主调调用栈的返回地址。<br>
        然而，并非将移交控制权到被调函数的开始，而是从协程帧中读取最后的暂停点，并跳转到那里。<br>
        当协程下一次暂停或者完成调用，$resume()$ 调用将会返回，恢复主调执行。</p>
<h3 id="销毁">销毁</h3>
<p>        <strong>销毁</strong>操作可以在不恢复协程执行的前提下销毁协程帧。<br>
        这个操作只能对已暂停的协程使用。<br>
        销毁操作就像恢复操作那样，重新激活协程调用栈，包括分配一个新的栈帧，保存主调返回地址。<br>
        然而，并非将控制权移交到上个暂停点，而是移交到一个可选的代码路径上，调用协程暂停点之前作用域内所有局部变量的析构器，然后释放协程帧的内存。<br>
        类似于恢复操作，销毁需要对协程暂停时返回的句柄调用 $void$ $destroy()$ 函数。</p>
<h3 id="协程调用">协程调用</h3>
<p>        协程调用几乎跟普通函数调用一样，事实上，对于主调来说，它们之间毫无区别。<br>
        然而，不像函数调用必须执行完才会返回，协程调用可以在到达暂停点处返回，并且主调可以在后续恢复。<br>
        对协程执行调用，主调会分配一个新的栈帧，把入参、返回地址写入栈帧，移交控制权。这些步骤和普通函数调用一样。<br>
        协程要做的第一件事是在堆上分配一个协程帧，并把入参从栈帧拷贝到协程帧，保证它们的生命周期和协程一样。</p>
<h3 id="协程返回">协程返回</h3>
<p>        协程返回与普通函数有一点不同。<br>
        当一个协程执行 $return$ 语句 ( 标准里是 $co_-return$ 语句 ) 时，他会把返回值存储到某个地方 ( 可以被协程修改的地方 )，接着销毁作用域内的局部变量 ( 不包括入参 )。<br>
        然后协程有机会在移交控制权之前，执行一些额外的逻辑。<br>
        额外的逻辑可能会返回值，或者恢复另一个等待返回值的协程。这些逻辑时完全客制化的。<br>
        协程然后执行暂停 ( 协程帧继续存活 ) 或者销毁 ( 协程帧销毁 ) 操作。<br>
        控制权在暂停 / 销毁操作后被移交给主调 / 恢复者，最后弹出栈帧。<br>
        需要注意的是，返回操作的返回值与调用操作的返回值不一样，因为返回可能是在初始调用之后很长时间后才执行的。</p>
<h2 id="例子">例子</h2>
<p>        为了以图像形式表达这些概念，我会通过一个简单的示例来演示协程暂停，并在之后恢复过程中的情况。<br>
        假设函数 ( 或者协程 ) $f()$ 调用一个协程 $x(int\ \ a)$ 。<br>
        调用前大概是这样的：</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP

                          +------+
+---------------+ &lt;------ | rsp  |
|  f()          |         +------+
+---------------+
| ...           |
|               |
</code></pre><p>        然后调用 $x(42)$ ，创建一个栈帧，就像普通函数那样。</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
+----------------+ &lt;-+
|  x()           |   |
| a  = 42        |   |
| ret= f()+0x123 |   |    +------+
+----------------+   +--- | rsp  |
|  f()           |        +------+
+----------------+
| ...            |
|                |
</code></pre><p>        然后，一旦协程 $x()$ 在堆上分配协程帧，并且将入参拷贝到协程帧，我们就得到了下面的图。注意编译器一般使用一个单独的寄存器存储协程帧地址 ( 例如<code>MSVC</code>使用<code>rbp</code>寄存器 )。</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
+----------------+ &lt;-+
|  x()           |   |
| a  = 42        |   |                   +--&gt;  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     +-----------+
+----------------+        | rbp  | ------+
| ...            |        +------+
|                |
</code></pre><p>        如果协程 $x()$ 之后调用另一个普通函数 $g()$ ，就会像这样：</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
+----------------+ &lt;-+
|  g()           |   |
| ret= x()+0x45  |   |
+----------------+   |
|  x()           |   |
| coroframe      | --|-------------------+
| a  = 42        |   |                   +--&gt;  +-----------+
| ret= f()+0x123 |   |    +------+             |  x()      |
+----------------+   +--- | rsp  |             | a =  42   |
|  f()           |        +------+             +-----------+
+----------------+        | rbp  |
| ...            |        +------+
|                |
</code></pre><p>        当 $g()$ 返回，他会销毁自己的调用栈，然后恢复 $x()$ 的调用栈。假设 $g()$ 的返回值存储在协程帧的局部变量 $b$ 中。</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
+----------------+ &lt;-+
|  x()           |   |
| a  = 42        |   |                   +--&gt;  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     | b = 789   |
+----------------+        | rbp  | ------+     +-----------+
| ...            |        +------+
|                |
</code></pre><p>        如果 $x()$ 执行到暂停点，并暂停执行，他会把控制权返回给 $f()$ 。<br>
        这导致 $x()$ 的栈帧会弹出，但是协程帧会保留。当协程被暂停，返回值返回给主调。返回值通常是协程句柄，指向堆上已暂停的协程帧，可以用于后续的恢复。当 $x()$ 暂停后，协程帧中会存储恢复点 ( 记为 $RP$ )。</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
                                        +----&gt; +-----------+
                          +------+      |      |  x()      |
+----------------+ &lt;----- | rsp  |      |      | a =  42   |
|  f()           |        +------+      |      | b = 789   |
| handle     ----|---+    | rbp  |      |      | RP=x()+99 |
| ...            |   |    +------+      |      +-----------+
|                |   |                  |
|                |   +------------------+
</code></pre><p>        这个句柄现在可以作为一个普通值在函数间传递。在一些点之后，可能是另一个调用栈，或者另一个线程，在某个时机，例如异步<code>I/O</code>完成的时候，另一个调用 $h()$ 恢复了协程。<br>
        恢复协程的函数调用 $void$ $resume(handle)$ ，恢复了协程执行。对于主调来说，就好像调用了一个 $void$ 返回的函数。<br>
        这会创建一个新的栈帧，记录 $resume()$ 调用的返回，激活协程栈，重新设置寄存器，在上一个暂停点处恢复 $x()$ 的执行。</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
+----------------+ &lt;-+
|  x()           |   |                   +--&gt;  +-----------+
| ret= h()+0x87  |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  h()           |        +------+       |     | b = 789   |
| handle         |        | rbp  | ------+     +-----------+
+----------------+        +------+
| ...            |
|                |
</code></pre><h2 id="总结">总结</h2>
<p>        这篇文章中，我把协程描述为一种不仅具有调用和返回操作，还具有暂停、恢复和销毁这三种额外操作的函数。<br>
        我希望这对你理解协程及其控制流有帮助。<br>
        下一篇文章我将介绍<code>C++</code>协程标准语言扩展的机制，以及编译器是怎么把你写的代码翻译成协程的。</p>

            </div>
            <div class="meta post-footer">
                <span>2024 Jan 23 23:59</span>
                <a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">分布式数据系统：共识算法</a></h1>
            <div class="post-content">
                
                
                <p>        分布式计算中有很多重要场景需要集群节点达成某种一致，例如：</p>
<ul>
<li>主节点选举：对于主从模式的数据库，节点间需要对谁来充当主节点达成一致。如果由于网络故障原因出现节点之间无法通信，就很容易出现争议；</li>
<li>原子事务提交：对于支持跨节点或跨分区事务的数据库，某个事务可能在一些节点上执行成功，而在另一些节点上失败。为了维护事务的原子性，所有节点必须对事务结果达成一致。</li>
</ul>
<h2 id="1-原子提交与两阶段提交">1. 原子提交与两阶段提交</h2>
<p>        对于单节点事务，原子性通常由存储引擎负责。当客户端请求数据库节点提交事务时，数据库首先使事务的写入持久化 ( 通常保存在<code>WAL</code>中 )，然后把提交记录追加到磁盘的日志文件中。如果数据库在该过程中发生了崩溃，在节点重启后，可以通过日志恢复事务。如果崩溃之前已经写入了提交记录，则认为事务已经成功，否则，回滚该事务。因此，单节点事务十分依赖于数据写入磁盘的顺序：先写入数据，再提交记录。<br>
        将单节点事务延伸到多节点，虽然大多数<code>NoSQL</code>分布式数据库都不支持这种分布式事务，但是有很多集群关系型数据库支持。向所有节点发送请求，然后各节点独立执行是不够的，这样很容易发生不一致，从而违反了原子性。一旦某个节点提交了事务，即使事后发现其他节点发生了中止，它也无法再撤销已提交的事务，所以，如果有部分节点提交了事务，所有节点也必须一起提交。<br>
        事务提交不可撤销，一旦数据被提交，就代表其他事务可见，继而客户端会依赖这些数据做出相应决策。这是事务<strong>提交读</strong>隔离级别的基础，如果事务在提交后还能撤销，就违反了提交读的原则，从而被迫产生级联式的追溯和撤销。当然，已提交事务可以被另一个新的事务覆盖，即<em><strong>补偿性事务</strong></em>。不过，在数据库的角度，它们是两个完全独立的事务，这种跨事务的正确性保证需要应用层负责。</p>
<h3 id="11-两阶段提交">1.1 两阶段提交</h3>
<p>        <strong>两阶段提交</strong> ( $two-phase\ commit$ , $2PC$ ) 是一种在多节点之间实现事务原子提交的算法，用来确保所有节点要么全部提交，要么全部中止。<code>2PC</code>在某些数据库内存使用，或者以<code>XA</code>事务的形式提供给应用程序使用。<br>
        <code>2PC</code>引入了单节点事务所没有的新组件：协调者 ( 也被称为事务管理器 )，通常实现为共享库。<code>2PC</code>事务从应用程序在多个数据库节点上执行数据读/写开始，数据库节点称为事务的参与者。当应用程序准备提交事务时，协调者发送一个准备请求到所有节点，询问它们是否可以进行事务提交：</p>
<ul>
<li>如果所有参与者回答是，表示它们已经准备好提交，协调者会发出提交请求，所有节点开始执行事务提交；</li>
<li>如果有任何参与者回答否，协调者会放弃发送提交请求。</li>
</ul>
<p>        为了理解<code>2PC</code>，我们可以分解这个过程：</p>
<ol>
<li>应用程序启动一个分布式事务，首先向协调者请求一个全局唯一的事务<code>ID</code>；</li>
<li>应用程序在每个参与节点上执行单节点事务，并将全局唯一事务<code>ID</code>附加到事务上。此时，每个节点独立执行事务，如果有任何一个节点执行失败，协调者和其他参与者都可以安全回滚事务；</li>
<li>应用程序准备提交事务，协调者向所有参与者发送准备请求，附带全局事务<code>ID</code>。如果接收到拒绝或者超时响应，协调者会通知所有节点放弃事务；</li>
<li>参与者在收到准备请求后，检查事务是否可以提交，是否存在冲突或者违反约束。一旦向协调者返回确认响应，无论发生什么情况，都不能拒绝提交事务；</li>
<li>协调者收到所有准备请求的响应后，会将决定写入磁盘中，用于崩溃后恢复决定，这个时刻称为提交点；</li>
<li>协调者将决定写入磁盘后，向所有参与者发送提交或者放弃请求。如果请求出现失败或者超时，协调者会一种重试，直到成功。所有参与者都不能拒绝该请求，即使需要很多重试，或者中间出现崩溃。</li>
</ol>
<p>        如果参与者或者网络在<code>2PC</code>期间发生故障，比如在准备请求期间，协调者就会决定回滚事务；或者在提交请求期间，协调者会不断重试。而对于协调者故障，如果协调者在准备请求之前故障，参与者可以安全地回滚；而一旦参与者收到了准备请求并回答是，参与者便无法单方面放弃，必须一直等待协调者的决定，此时如果协调者故障，参与者便处于一种不确定的状态。理论上，参与者之间可以互相通信，了解每个参与者的投票情况，并达成一致，但是这已经不是<code>2PC</code>的范畴了。<code>2PC</code>能够顺利完成的唯一办法是等待协调者恢复，因此协调者在发送提交请求之前要将决定写入磁盘的事务日志。<br>
        <code>2PC</code>也被称为阻塞式原子提交协议，因为等待协调者从故障恢复的这个过程是阻塞的。理论上，也可以改为非阻塞的，这种称为<strong>三阶段提交</strong>。<code>3PC</code>假定一个有限的网络延迟，要求节点在规定时间内响应。然而实际情况是，网络延迟可能是无限的。通常，非阻塞原子提交依赖一个完美的故障检测器，即一种十分可靠的可以判断节点是否崩溃的机制。但是，在一个网络延迟可能是无限的场景中，超时并非一种可靠的判断机制。正常情况下，请求也可能由于网络问题而超时。正是这些原因，大家更倾向于<code>2PC</code>而非<code>3PC</code>。</p>
<h2 id="2-分布式事务实践">2. 分布式事务实践</h2>
<p>        分布式事务，尤其是那些通过<code>2PC</code>实现的事务，声誉混杂。一方面，它们提供了一种其他方案难以企及的安全保证。但是另一方面，由于操作、性能上的缺陷，以及并非完全可靠，一直被人诟病。目前，许多云服务商由于运维方面的问题而决定不支持分布式事务。分布式事务的某些实现存在严重的性能问题，例如，有报告显示<code>MySQL</code>的分布式事务比单节点事务慢 $10$ 倍以上。<code>2PC</code>性能下降的主要原因是与协调者通信带来额外的网络开销，以及为了协调者崩溃恢复做的磁盘<code>I/O</code> ( $fsync$ )。<br>
        目前存在着两种不同的分布式事务概念：</p>
<ul>
<li>数据库内部的分布式事务：某些分布式事务支持的跨数据节点的内部事务，即所有参与者节点运行着相同的数据库软件；</li>
<li>异构分布式事务：存在两种或两种以上不同参与者软件的事务，例如来自不同供应商的数据库，甚至可以是非数据库。</li>
</ul>
<p>        对于数据库内部事务，由于不需要考虑不同系统之间的兼容，可以采用任何形式的协议，并进行针对性优化，这些分布式事务往往可行。但是异构分布式事务就没那么简单了。</p>
<h3 id="21-exactly-once消息处理">2.1 <code>Exactly-once</code>消息处理</h3>
<p>        异构分布式事务旨在无缝集成多种不同的系统。例如，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息已处理完毕。这个过程是通过自动提交消息确认和数据库写入实现的。即使消息系统和数据库运行在不同节点上，分布式事务也能实现上述目标。如果消息发送失败或者某个节点事务失败，两者都必须中止。消息队列可以在之后重传消息。因此通过自动提交和消息处理结果，可以确保消息有效处理只有一次。<br>
        需要注意，只有所有相关系统都使用相同的原子性提交协议的前提下，这种分布式事务才是可行的。例如，如果处理结果之一是发送邮件，而邮件服务器不支持<code>2PC</code>，此时某个过程出错，消息重新入队重试，邮件就可能会被发送多次。</p>
<h3 id="22-xa事务">2.2 <code>XA</code>事务</h3>
<p>        <code>X/Open XA</code> ( $eXtended\ Architecture$ , $XA$ ) 是异构环境下进行<code>2PC</code>的一个工业标准。目前，许多关系型数据库 ( <code>PostgreSQL</code>、<code>MySQL</code>、<code>Oracle</code>等 ) 和消息队列 ( <code>ActiveMQ</code>、<code>MSMQ</code>、<code>IBM MQ</code>等 ) 都支持<code>XA</code>。<code>XA</code>并不是一个网络协议，而是一个与事务协调者进行通信的<code>C API</code>。当然，它也支持与其他语言的<code>API</code>绑定，例如<code>Java</code>。<br>
        <code>XA</code>假定应用程序通过网络或客户端的库函数与参与者节点进行通信，如果驱动程序支持<code>XA</code>，意味着应用程序可以调用<code>XA API</code>确定操作是否属于异构分布式事务的一部分。如果是，则发送必要的信息给数据库服务器。它还支持回调，这样协调者可以通过回调函数通知所有参与者执行准备或者提交 ( 或者中止 )。<br>
        协调者需要实现<code>XA API</code>。虽然标准没有规定如何实现，但实际上，协调者也通常是一个<code>API</code>库，与产生事务的应用程序运行在相同进程中。这些<code>API</code>跟踪事务的参与者，收集投票，并在本地磁盘中记录决定。如果应用程序发生崩溃，或者节点故障，在重启后，协调者会通过<code>XA API</code>读取日志，恢复决定。完成这些后，协调者才能继续通过回调函数来要求参与者执行提交或者中止。数据库服务器无法直接与协调者通信，必须通过相应<code>API</code>。</p>
<h3 id="23-协调者故障">2.3 协调者故障</h3>
<p>        数据库事务通常持有待修改行的行锁，用于防止脏写。此外，如果要使用串行化的隔离级别，<code>2PC</code>还会对曾经读取的行持有读锁。在事务提交之前，这些锁都不会被释放。因此，在<code>2PC</code>中，如果出现协调者故障带来的停顿，那么这些锁在停顿期间都不会被释放。长时间持有锁是一件坏事，这意味着其他事务无法有效执行，使得许多上层应用处于不可用状态。<br>
        理论上，如果协调者崩溃后重新启动，它应该可以从日志中恢复那些停顿的事务。然而，实践中，孤立的不确定事务是可能发生的，例如由于软件 $bug$ 导致交易日志丢失或者损坏。这些事务无法自己解决，而是一直停留在那里，即使重启节点也无法解决，因为<code>2PC</code>要求重启后继续保持重启前的事务状态。<br>
        唯一的办法就是让管理员手动决定提交还是回滚。这可能会带来大量的手工操作，并且可能在关键生产环境的中断间隙，存在巨大的压力和时间限制。许多<code>XA</code>的实现都支持某种紧急避险措施，称为<strong>启发式决策</strong>：允许参与者节点在紧急情况下单方面做出决定，放弃或者继续停顿的事务。这种做法可能会破坏事务的原子性，违背了<code>2PC</code>原则。要注意，这种做法只是为了应急，不能作为常规手段使用。</p>
<h3 id="24-分布式事务的限制">2.4 分布式事务的限制</h3>
<p>        <code>XA</code>事务解决了多个参与者之间达成一直的问题，但是也引入了很多操作限制。特别是，核心的事务协调者本身就是一种数据库，因此需要和其他重要的数据库一样格外小心：</p>
<ul>
<li>如果协调者不支持数据复制，在单节点上运行，那么它就是整个系统的单点故障。实际上，许多协调者并非高可用，或者只支持最基本的复制；</li>
<li>许多服务端应用程序都倾向于无状态模式 ( 更适合<code>HTTP</code> )，将所有持久状态都保存在数据库中。这样应用服务器可以轻松地添加或者删除实例。但是当协调者本身就是服务器的一部分时，协调者的日志就成为了可靠系统的重要组成部分，与数据库本身一样重要，这样的服务器本身就不是无状态的了；</li>
<li><code>XA</code>需要与各种数据系统保持兼容，最终其实是多系统可兼容的最低标准。例如，它无法检测不同系统的死锁条件 ( 这需要其他标准化协议，多个系统需要交换锁信息 )；</li>
<li>数据库内部的分布式事务比起<code>XA</code>来说，限制要少很多。然而对于<code>2PC</code>还是存在潜在的限制，比如所有参与者必须投票赞成。所以分布式事务扩大了事务失败的可能性，与构建容错系统的目标背道而驰。</li>
</ul>
<h2 id="3-共识算法">3. 共识算法</h2>
<p>        共识是让几个节点就某项提议达成一致，通常形式化描述为：一个或多个节点可以提议某些值，由共识算法来决定最终值。共识算法必须满足以下性质：</p>
<ul>
<li><strong>协商一致性</strong> ( $Uniform\ agreement$ )：所有节点都接受相同决议；</li>
<li><strong>诚实性</strong> ( $Integrity$ )：所有节点做出决定后都不能反悔，即一个决议不能有两个结果；</li>
<li><strong>合法性</strong> ( $Validity$ )：决议的结果一定是由某个节点提议的；</li>
<li><strong>可终止性</strong> ( $Termination$ )：节点在不崩溃的前提下一定可以达成协议。</li>
</ul>
<p>        如果不关心容错，满足前三个属性很容易：可以强行指定某个节点为“独裁者”，由它做出所有决定，唯一要注意的就是该节点失败的情况。上述共识的系统模型假定当某个节点崩溃后，节点就彻底消失，永远不会回来。在这种条件下，<code>2PC</code>显然不满足可终止性。当然，如果所有节点都崩溃了，那么无论哪种算法都不能继续做出决定。因此，可终止性的前提是，发生崩溃或者不可用的节点数必须小于半数节点。<br>
        最著名的共识算法包括<code>VSR</code>、<code>Paxos</code>、<code>Raft</code>和<code>Zab</code>，这些算法存在很多相似之处，但又不完全相同。它们大部分并不是直接使用形式化模式，而是决定了一系列值，再通过全序关系广播算法。全序关系广播通常指节点之间交换消息的某种协议，下面是一个非正式定义，要求满足两个基本安全属性：</p>
<ul>
<li>可靠发送：没有消息丢失，如果某个消息发送到了一个节点，那么它也要发送给其他节点；</li>
<li>严格有序：消息总是以相同顺序发送。</li>
</ul>
<p>        即使节点或者网络出现故障，全序关系广播算法的实现也必须保证以上两条。实现全序关系广播，要求消息顺序在发送前就已确定。理解全序关系广播的另一种方式是将其视为日志，传递消息就像追加日志，所有节点都可以读取日志并看到相同的消息序列。共识算法的全序关系广播相当于持续的多轮共识：</p>
<ul>
<li>由于协商一致性，所有节点以相同顺序发送相同消息；</li>
<li>由于诚实性，消息不能重复；</li>
<li>由于合法性，消息不会被破坏；</li>
<li>由于可终止性，消息不会丢失。</li>
</ul>
<p>        <code>VSR</code>、<code>Raft</code>和<code>Zab</code>都直接采取了全序关系广播，而<code>Paxos</code>则有对应的优化版本，称为<code>Multi-Paxos</code>。</p>
<h3 id="31-epoch和quorum">3.1 <code>Epoch</code>和<code>Quorum</code></h3>
<p>        目前所讨论的素有共识协议在内部都使用了某种形式的主节点，虽然主节点并不是固定的。相反，它们都采用了一种弱保证：定义一个世代编号 ( $epoch$ $number$ )，并保证在每个世代中，主节点是唯一的。如果发现当前主节点失效，节点间就开始新一轮投票，选举新的主节点。每次选举都会被赋予一个单调递增的<code>epoch</code>，如果出现了两个不同的主节点对应于不同<code>epoch</code>好，则更高<code>epoch</code>的主节点将获胜。<br>
        主节点做出任何决定前，都必须检查是否存在更高的<code>epoch</code>，否则就会产生冲突的决定。主节点如果想要做出某个决定，需要将提议发送给其他节点，等待<code>quorum</code>节点响应。<code>quorum</code>节点通常不是由多数节点组成的，并且，只有当没有发现更高<code>epoch</code>主节点存在时，才会对当前提议 ( 带有<code>epoch</code> ) 进行投票。因此，这里其实是有两轮不同的投票：首先投票决定主节点，然后再投票决定提议。其中关键一点是，两轮投票的<code>quorum</code>必须存在重叠。<br>
        投票的过程很像<code>2PC</code>，最大区别是，<code>2PC</code>并不需要通过选举产生协调者，共识算法只需要多数节点同意即可通过。此外，共识算法还定义了恢复过程，出现故障后，通过该过程即可以选举出新的主节点，重新进入一致状态。</p>
<h3 id="32-共识的局限">3.2 共识的局限</h3>
<p>        共识算法为一切不确定系统带来了明确的安全属性，还支持容错。但是这种好处也是有代价的：</p>
<ul>
<li>达成一致之前的投票是一个同步复制过程。但是对于数据库，通常为了更好的性能，会采用异步复制；</li>
<li>共识体系需要严格多数节点；</li>
<li>多数共识算法假定一组固定参与投票的节点集，意味着不能动态添加或删除节点；</li>
<li>共识系统通常依靠超时机制来检测节点失效，在网络延迟高度不确定的环境中，特别是跨区域分布的系统，经常由于网络延迟的原因，节点会被错误地认为发生了故障。虽然这种误判不会影响安全，但是频繁的主节点选举会影响性能；</li>
<li>共识算法对网络问题特别敏感。例如，<code>Raft</code>被发现存在不合理的边界处理：如果网络中存在某一条网络连接持续不可靠，它会在两个节点之间反复切换主节点，当前主节点会被不断赶下台。其他的共识算法也会有类似问题，所以面对不可靠网络，如何设计更具鲁棒性的共识算法仍然是一个开放性的研究问题。</li>
</ul>
<h3 id="33-paxos">3.3 <code>Paxos</code></h3>
<p>        <code>Paxos</code>算法运行在允许宕机的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用多数机制，在具有 $2F + 1$ 个节点的系统中，最多允许 $F$ 个节点的故障。<code>Paxos</code>具有以下系统角色：</p>
<ul>
<li>提议者 ( $Proposer$ )：提出提议，包含提议编号 ( $Proposal$ $ID$ ) 和提议值 ( $Value$ )；</li>
<li>决策者 ( $Acceptor$ )：参与决策，回应提议者的提议；</li>
<li>学习者 ( $Learner$ )：不参与决策，从其他节点学习最终的提议值。</li>
</ul>
<p>        在多副本状态机中，每个副本都是提议者、决策者和学习者。<br>
        <code>Paxos</code>算法分为两阶段：</p>
<ol>
<li>准备阶段：提议者向决策者发出准备请求，决策者针对收到的准备请求进行承诺；</li>
<li>决策阶段：提议者在接收到多数决策者的回应 ( $Promise$ ) 之后，向决策者发出提议请求，决策者收到请求后处理；</li>
<li>学习阶段：提议者在接收到多数决策者的决策之后，标记本次决策成功，将提议值发送给所有学习者。</li>
</ol>
<p>        决策者会对提议者的准备请求做出两个承诺和一个回应：</p>
<ul>
<li>承诺不再接收<code>ID</code>小于等于当前准备请求<code>ID</code>的准备请求；</li>
<li>承诺不再接收<code>ID</code>小于当前准备请求的决策请求；</li>
<li>回应之前接收过的<code>ID</code>最大的提议的<code>ID</code>和提议值。</li>
</ul>
<p>        原始的<code>Paxos</code>算法只能对一个值进行决策，每次决策需要至少两次收发请求，在高并发场景下可能需要更多次沟通，极端情况下还会形成<strong>活锁</strong>，即两个提议者交替发起请求，不断递增 $Proposal$ $ID$ 。因此，这种<code>Paxos</code>只适合理论研究，不适合应用在实际生产环境中。<br>
        实际生产环境中往往需要连续确定多个值，而且具有更高效率。<code>Multi-Paxos</code>就是为此提出的，它作出了两点改进：</p>
<ul>
<li>针对每个提议者，生成一个 $Instance$ $ID$ ，每个提议者由一个<code>ID</code>标识；</li>
<li>在所有提议者中选举一个主节点，由主节点将提议提交给决策者进行决策。这样就可以跳过准备请求阶段，因为实际上只有一个提议者会提议。</li>
</ul>
<p>        <code>Multi-Paxos</code>首先需要选举一个主节点，选举的过程也可以通过<code>Paxos</code>算法决策，一种简单的方式如下：</p>
<ul>
<li>具有最高<code>ID</code>的服务器作为主节点，每个服务器定时向其他服务器发送心跳消息检查状态；</li>
<li>如果没有收到比它高的<code>ID</code>的节点的心跳消息，它就会尝试发起一轮选举，选举自己作为领导者；</li>
<li>非主节点只会作为决策者，提议者只有主节点一个。</li>
</ul>
<p>        <code>Multi-Paxos</code>通过改变准备阶段的作用范围，使得多个实例的提交只需要一次决策，将两阶段变为一阶段，提高了效率。即使存在多个主节点 ( 脑裂 )，也不影响安全性，这时候只是会退化为原始的<code>Paxos</code>。</p>
<h3 id="34-raft">3.4 <code>Raft</code></h3>
<p>        <code>Raft</code>实现了和<code>Paxos</code>相同的功能，将共识问题分解为多个子问题，使用了更强的假设来减少需要考虑的状态。<code>Raft</code>将系统分为以下角色：</p>
<ul>
<li>领导者 ( $Leader$ )：接收客户端请求，同步给跟随者，当同步到多数节点后提交请求；</li>
<li>跟随者 ( $Follower$ )：接收并持久化领导者的请求，在接收到领导者的提交请求后，进行提交；</li>
<li>候选人 ( $Candidate$ )：可以参与选举的节点。</li>
</ul>
<p>        <code>Raft</code>算法只允许一个领导者的存在。节点之间存在心跳检测，如果跟随者长时间没有接收到来自领导者的心跳消息，则会开启新一轮选举。收到多数投票的候选人会称为新的领导者，直到其出现故障。<code>Raft</code>通过任期 ( $term$ ) 管理选举，任期通过时间划分，每个 $term$ 的开始都是选举，选举完成后，在这个任期内领导者会负责管理集群。<br>
        <code>Raft</code>拥有两条限制，用于保证安全性：</p>
<ul>
<li>拥有最大偏移量的候选人才可以成为领导者。这要求候选人在选举中发送自己的偏移量；</li>
<li>只允许提交当前任期的请求，之前任期的无法不能再提交。这要求领导者在请求中带上任期。</li>
</ul>
<h2 id="4-成员与协调服务">4. 成员与协调服务</h2>
<p>        <code>ZooKeeper</code>或者<code>etcd</code>这样的项目通常称为“分布式键值存储”或者“协调与配置服务”。它们对外提供的<code>API</code>与数据库非常相像：读取、写入对应主键值，或者按序便利主键。应用程序开发者其实很少直接使用<code>ZooKeeper</code>，因为它并非通用数据库，绝大部分通过其他项目来间接依赖，比如<code>HBase</code>、<code>Hadoop YARN</code>、<code>Kafka</code>等。<code>ZooKeeper</code>和<code>etcd</code>主要针对保存少量、可完全载入内存的数据 ( 即使最终还是要写入磁盘 )，不适合用于保存大量数据。它们通常采用容错的全序广播算法在所有节点上复制数据从而实现高可靠。<code>ZooKeeper</code>的实现其实模仿了<code>Google</code>的<code>Chubby</code>分布式锁服务，不仅实现了全序广播，还提供了其他有趣的特性：</p>
<ul>
<li>线性化的原子操作：使用<code>CAS</code>操作，实现加锁服务。例如多个节点同时尝试执行相同操作，则确保只会有一个节点成功。共识算法满足了原子性和线性化，即使某些节点发生故障或者网络中断。分布式锁通常是一个带有过期时间的租约，保证即使某些客户端故障也可被释放；</li>
<li>操作全序：<code>fencing</code>令牌保证每次加锁的数字总是单调递增的，<code>ZooKeeper</code>会对所有操作执行全局排序，为每个操作赋予一个唯一的事务<code>ID</code>和版本号；</li>
<li>故障检测：客户端与<code>ZooKeeper</code>之间会维持一个长期会话，客户端会周期性地与<code>ZooKeeper</code>服务节点互相交换心跳信息，以检查对方是否存活。即使出现连接中断，或者某个<code>ZooKeeper</code>节点失效，会话仍处于活动状态。如果连接断开时间超过了超时时间，<code>ZooKeeper</code>会声明会话失败，此时该会话持有的所有锁资源会被自动释放 ( 即<code>ZooKeeper</code>中的临时节点 )；</li>
<li>更改通知：客户端不仅可以读取其他客户端所创建的锁和键值，还可以监视它们的变化。因此，客户端可以知道其他客户端何时加入了集群，以及客户端是否发生了故障。通过订阅机制，客户端不需要频繁轮询服务。</li>
</ul>
<h3 id="41-节点任务分配">4.1 节点任务分配</h3>
<p>        <code>ZooKeeper</code>和<code>Chubby</code>的一个非常适合的场景是，如果系统有多个流程或服务的实例，并且需要其中一个实例充当主节点，在主节点失效时由其他节点接管。显然，这是主从模型的特征。此外，它对于作业调度系统也十分有用。还有另一个场景，对于一些分区资源 ( 数据库、消息流、文件存储等 )，需要决定节点分区分配。当有新节点加入集群时，需要将某些现有分区从当前节点迁移到新节点，从而实现动态的负载均衡。<br>
        上述场景都可以借助<code>ZooKeeper</code>的原子操作 ( 临时节点和订阅机制 ) 来实现。应用程序最初可能只运行在单节点，之后扩展到数千节点。在这么多节点上进行投票是很低效的。而<code>ZooKeeper</code>通常是在固定数量的节点上运行，可以非常高效的支持大量客户端。通常，<code>ZooKeeper</code>管理的数据变化十分缓慢，更改频率往往是分钟级甚至小时级，如果需要频繁修改，应该考虑其他工具。</p>
<h3 id="42-服务发现">4.2 服务发现</h3>
<p>        <code>ZooKeeper</code>、<code>etcd</code>和<code>Consul</code>经常用于服务发现。在典型的云环境中，虚拟机可能会动态变化，这时无法提前知道服务节点的<code>IP</code>地址，因此，可以在每次节点启动时将网络端口信息向<code>ZooKeeper</code>等服务注册，其他人只需要向<code>ZooKeeper</code>的注册表请求即可。<br>
        但是，关于服务发现是否需要共识还缺乏统一认识，习惯上是通过<code>DNS</code>来将服务名称转为<code>IP</code>。从<code>DNS</code>读取肯定不满足线性化，然而现实情况是，如果<code>DNS</code>返回的是过期值也不会有什么大问题。总体来讲，<code>DNS</code>更看重网络中断时的可用性和鲁棒性。</p>
<h3 id="43-成员服务">4.3 成员服务</h3>
<p>        <code>ZooKeeper</code>还可以作为成员服务的一部分，用于确定当前哪些节点处于活动状态，并且是集群的有效成员。这里依然存在误判的可能，即使这样，系统就成员资格的认识是一致的。</p>

            </div>
            <div class="meta post-footer">
                <span>2022 Nov 13 16:18</span>
                <a href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:zihan.zhouchn@outlook.com">zihan.zhouchn@outlook.com</a>
            </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2024, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
    <script>
        InitLightSwitcher()
    </script>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
</main>
</body>

</html>