<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.74.3" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
        
        <a href="http://123.57.12.189"  target="_blank" >
            <i class="fas fa-link fa-sm"></i>
            <span>二站</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm10%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">JVM（10）：线程安全与锁优化</a>
        
        
        <p>深入理解Java虚拟机（10）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Jan 13 21:17
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm9%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">JVM（9）：内存模型与线程</a>
        
        
        <p>深入理解Java虚拟机（9）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Jan 12 21:13
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm8%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/">JVM（8）：后端编译与优化</a>
        
        
        <p>深入理解Java虚拟机（8）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Jan 09 20:58
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm7%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/">JVM（7）：前端编译与优化</a>
        
        
        <p>深入理解Java虚拟机（7）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Jan 08 20:09
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm6%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/">JVM（6）：字节码执行引擎</a>
        
        
        <p>深入理解Java虚拟机（6）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Oct 14 17:02
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm10%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">JVM（10）：线程安全与锁优化</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-线程安全">1. 线程安全</h2>
<p>        按照线程安全程度由强到弱，可以将<code>Java</code>语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<h3 id="11-不可变">1.1 不可变</h3>
<p>        在<code>Java</code>语言里，不可变 ( $Immutable$ ) 对象一定是线程安全对象，因此不需要进行任何线程安全保障措施。对于基本数据类型，只需要在定义时使用 $final$ 关键字即可保证不可变。而对于对象类型，<code>Java</code>语言目前暂时还没有提供支持，因此只能让对象自行保证行为不会影响状态，其中最简单的一种方式就是把所有带有状态的变量都声明为 $final$ 。</p>
<h3 id="12-绝对线程安全">1.2 绝对线程安全</h3>
<p>        绝对线程安全指的是当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果。而实际上，要想达到绝对线程安全可能需要付出非常高昂的代价。<code>Java API</code>中标注线程安全的类，大多数都不是绝对线程安全的。例如 $java.util.Vector$ 是一个线程安全的容器，因为它的很多方法被 $synchronized$ 修饰，但是在以下情况下还是线程不安全的：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">vector</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">&lt;&gt;();</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">vector</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

        <span class="n">Thread</span> <span class="n">removeThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vector</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="n">vector</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">Thread</span> <span class="n">printThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vector</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">vector</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">removeThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">printThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        而要想做到线程安全，需要将上述代码改为如下形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Thread</span> <span class="n">removeThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">vector</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vector</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="n">vector</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">});</span>

<span class="n">Thread</span> <span class="n">printThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">vector</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vector</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">vector</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div><p>        而 $Vector$ 要想做到绝对线程安全，就需要在内部维护一组一致性的快照访问，在每次对元素进行改动的时候都要产生新的快照，因此需要付出极大的空间成本和时间成本。</p>
<h3 id="13-相对线程安全">1.3 相对线程安全</h3>
<p>        相对线程安全是我们通常意义上的线程安全，需要保证对对象单次的操作是线程安全的，即将上述绝对线程安全的定义中的“调用这个对象的行为”改为“单次调用”。<code>Java API</code>中大部分标注线程安全的类都属于相对线程安全，比如上面提到的 $java.util.Vector$ 类。</p>
<h3 id="14-线程兼容">1.4 线程兼容</h3>
<p>        线程兼容是指对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段保证对象在并发环境中安全使用，也就是我们通常所说的线程不安全类。<code>Java API</code>中大部分类都是线程兼容的。</p>
<h3 id="15-线程对立">1.5 线程对立</h3>
<p>        线程对立是指不管调用端采取了什么同步措施都不能在多线程中并发使用代码。线程对立的代码极少出现，而且通常都是有害的，应当尽量避免。</p>
<h2 id="2-线程安全的实现">2. 线程安全的实现</h2>
<h3 id="21-互斥同步">2.1 互斥同步</h3>
<p>        互斥同步 ( $Mutal\ \ Exclusion\ \ \And\ \ Synchronization$ ) 是最常见也是最主要的实现手段。同步即保证共享数据在一个时刻只能被一个线程使用，互斥则是实现同步的手段。<code>Java</code>内最基本的互斥同步手段就是 $synchronized$ 关键字，经过<code>Javac</code>编译后生成 $monitorenter$ 和 $monitorexit$ 字节码指令。这两条指令都要指定一个 $reference$ 类型的参数，如果源码中指定的是对象，那么就以对象作为参数；如果没有明确指定，则根据其修饰的方法类型决定是以对象实例作为参数还是以 $Class$ 对象作为参数。执行 $monitorenter$ 时，如果对象没有被锁定，或者已经持有对象锁，就把锁计数器值加一，并在执行 $monitorexit$ 时减一。如果对象锁计数器为零，代表锁被释放。持有的对象锁只能被当前线程所释放，另一个线程无法强制释放，只能被阻塞。<br/>
        从执行成本的角度来看，持有锁是一个重量级 ( $Heavy-Weight$ ) 操作。在采用操作系统原生内核线程的情况下，阻塞或者唤醒一个线程都需要操作系统完成，因此需要进行用户态和核心态的转换，所以应当只有在必要的情况下才使用 $synchronized$ 。虚拟机也会进行一些优化，比如在阻塞之前加入一段自旋等待过程，从而避免频繁切换到核心态。<br/>
        除了 $synchronized$ 外，我们也可以使用 $java.util.concurrent$ 包，其中的 $locks.Lock$ 接口允许用户以非块结构完成互斥同步。重入锁 ( $ReentrantLock$ ) 是最常见的一种实现，它与 $synchronized$ 一样是可重入的，而且还增加了一些高级功能：等待可中断（等待线程可以放弃等待）、公平锁（按照申请顺序获得锁，但会导致性能下降）、锁绑定多个条件（一个 $ReentrantLock$ 可以绑定多个 $Condition$ 对象）。</p>
<h3 id="22-非阻塞同步">2.2 非阻塞同步</h3>
<p>        互斥同步在线程阻塞和线程唤醒的时候会带来额外开销，因此也被称为阻塞同步 ( $Blocking\ \ Synchronization$ )，从解决方式上来看属于悲观锁。而与之相反的基于冲突检测的乐观并发策略就是允许线程进行操作，如果在操作过程中出现了冲突则进行补偿，最常见的补偿措施是不断重试。这种方式称为非阻塞同步 ( $Non-Blocking\ \ Synchronization$ )，使用这种措施的代码也被称为无锁 ( $Lock-Free$ ) 编程。乐观并发策略要求操作和冲突检测的步骤具备原子性，因此需要依赖一定的硬件指令集。</p>
<h3 id="23-无同步">2.3 无同步</h3>
<p>        保证线程安全并不一定需要进行阻塞或者非阻塞同步，同步只是一个保证数据正确的手段。如果能够让一个方法本来就不涉及共享数据，那么就不需要同步。这类型的典型例子是可重入代码 ( $Reentrant\ \ Code$ ) 和线程本地存储 ( $Thread\ \ Local\ \ Storage$ )。<br/>
        可重入代码是指可以在执行的任何时刻中断，并在控制权返回后也不会出错的代码。我们可以把可重入作为线程安全的一个条件，但并不是所有的线程安全代码都要求可重入。可重入代码具有一些共同特征，如不依赖全局变量，存储在堆上的数据和公用的系统资源、状态量由参数传入、不调用非可重入方法等。如果一个方法的返回结果是可预测的，那么就可以认为是可重入代码。<br/>
        线程本地存储是指如果一段代码中所需要的数据必须与其他代码共享，并且这些共享数据的代码可以在同一个线程中执行，那么就把共享数据的可见范围限制在同一个线程中。符合线程本地存储的典型例子就是“生产者-消费者模式”。<code>Java</code>语言中并没有方式让一个变量被某个线程独占，但是可以通过 $java.lang.ThreadLocal$ 类实现本地存储。</p>
<h2 id="3-锁优化">3. 锁优化</h2>
<h3 id="31-自旋锁与自适应自旋">3.1 自旋锁与自适应自旋</h3>
<p>        互斥同步在阻塞和唤醒的过程中需要完成用户态和核心态的转换，为了避免频繁转换，可以让线程执行一个忙等待，这就是自旋锁。自旋等待虽然避免了线程切换的开销，但是还是会占用处理器时间。所以如果锁被占用的时间很短，那么自旋等待的效果就会很好，反之会很差。因此可以给自旋等待设置一个时间限度，在限定次数内没有获得锁的线程就使用传统方式挂起，这个值默认是十次，可以通过 $-XX:PreBlockSpin$ 设置。<br/>
        <code>JDK 6</code>中引入了自适应自旋，这使得自旋等待的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。如果在同一个锁对象上，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就认为这次自旋很有可能再次成功，从而允许自旋等待更长时间。</p>
<h3 id="32-锁消除">3.2 锁消除</h3>
<p>        锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除，主要判定依据是逃逸分析。<code>Java</code>语言内部存在许多同步代码，锁消除主要是针对<code>Java</code>语言内部的锁。</p>
<h3 id="33-锁粗化">3.3 锁粗化</h3>
<p>        大多数情况下，我们应当把同步块的作用范围限制到尽量小，从而减少同步操作。但是如果一系列的连续操作都对同一个对象进行上锁和解锁，那么会带来额外的性能损耗。锁粗化就是针对这种情况，扩展同步块的作用范围，从而避免额外的性能损耗。</p>
<h3 id="34-轻量级锁">3.4 轻量级锁</h3>
<p>        轻量级锁是<code>JDK 6</code>中加入的新型锁机制，轻量是相对于使用操作系统实现的传统锁而言的。轻量级锁的目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量带来的性能损耗。<code>HotSpot</code>虚拟机的对象头分为两部分，一部分用于存储对象自身的运行时数据（如哈希码、分代年龄），另一部分用于存储指向方法区对象类型数据的指针。前者在 $32$ 位和 $64$ 位的虚拟机中分别占用 $32$ 位和 $64$ 位大小，称为 $Mark\ \ Word$ 。$Mark\ \ Word$ 被设计为非固定的动态数据结构，可以根据对象状态复用存储空间，这是轻量级锁实现的关键。在代码即将进入同步块时，如果同步对象没有被锁定，虚拟机会在当前线程的栈帧中建立一个名为锁记录 ( $Lock\ \ Record$ ) 的空间，存储锁对象目前的 $Mark\ \ Word$ 的拷贝。之后虚拟机尝试使用 $CAS$ 操作更新 $Mark Word$ 为指向 $Lock\ \ Record$ 的指针，代表线程拥有对象锁。如果更新失败，代表存在另一个线程与之竞争，虚拟机会检查对象的 $Mark\ \ Word$ ，判断当前的锁情况。如果出现两个以上的线程竞争使用同一个锁，轻量级锁就不再有效，需要改为使用重量级锁。在不存在竞争的情况下，轻量级锁因为避免了使用互斥量的开销，所以性能方面要比重量级锁高；反过来如果存在竞争，性能就会更低。</p>
<h3 id="35-偏向锁">3.5 偏向锁</h3>
<p>        偏向锁也是<code>JDK 6</code>中引入的，目的是消除数据在无竞争情况下的同步原语。与轻量级锁的不同之处在于轻量级锁是为了消除同步过程中使用的互斥量，而偏向锁是为了消除整个同步过程。偏向锁会偏向于第一个获得它的线程，并且在接下来的执行过程中，如果锁一直没有被其他线程获取，那么持有偏向锁的线程将永远不需要同步。偏向锁的实现与轻量级锁类似，不同之处在于 $Mark\ \ Word$ 中会记录获得偏向锁的线程<code>ID</code>，并在之后同一个线程进入同步块时不再进行任何同步操作。一旦出现另一个线程尝试获取锁，偏向模式立即结束，根据当前对象的锁定状态决定是否撤销偏向。偏向锁可以提高带有同步但是无竞争的程序性能，同样也并非总是有利，对于大多数总是被多个线程访问的情况，偏向模式就是多余的。<br/>
        偏向锁的实现需要占用 $Mark\ \ Word$ 中存储哈希码的区域。哈希码依赖于 $Object::hashCode(\ )$ 方法，会在第一次调用后存储在对象头中，从而保证哈希码的一致性。因此如果一个对象计算过一次哈希码之后，就不能再使用偏向锁，一个处于偏向锁状态的对象需要计算哈希码时，它的偏向锁状态会被立即撤销，并膨胀为重量级锁。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Jan 13 21:17</span> <a href="/post/jvm10%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm9%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">JVM（9）：内存模型与线程</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-内存模型">1. 内存模型</h2>
<h3 id="11-主内存与工作内存">1.1 主内存与工作内存</h3>
<p>        <code>Java</code>内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。在这里主要考虑的问题是多线程对同一块内存区域进行的操作，因此并不需要考虑一些线程私有的变量比如局部变量和方法参数。<code>Java</code>内存模型规定了所有变量都存储在主内存 ( $Main\ \ Memory$ ) 中，每条线程允许拥有自己的工作内存 ( $Working\ \ Memory$ )，保存了主内存中要使用的变量的副本。对于引用对象，工作内存中并不会包含整个对象的副本，而是对象引用以及对象中要使用的字段的副本。通过工作内存，线程的所有的对变量的操作都会在工作内存中进行，即通过工作内存间接访问主内存。</p>
<h3 id="11-内存间交互">1.1 内存间交互</h3>
<p>        主内存与工作内存之间的交互协议指的是一个变量如何从主内存拷贝到工作内存，并从工作内存同步至主内存的过程。<code>Java</code>内存模型定义了 $8$ 种原子性操作：</p>
<ol>
<li>$lock$ ：作用于主内存变量，将变量标识为线程独占状态；</li>
<li>$unlock$ ：作用于主内存变量，把释放一个处于线程独占状态的变量；</li>
<li>$read$ ：作用于主内存变量，将一个变量传输到工作内存中；</li>
<li>$load$ ：作用于工作内存变量，将一个主内存传输的变量载入工作内存的副本中；</li>
<li>$use$ ：作用于工作内存变量，每当虚拟机遇到一个需要使用变量的字节码指令时，将变量传递给执行引擎；</li>
<li>$assign$ ：作用于工作内存变量，每当虚拟机遇到一个给变量赋值的字节码指令时，从执行引擎接收值并赋给变量；</li>
<li>$store$ ：作用于工作内存变量，将一个变量传送到主内存中；</li>
<li>$write$ ：作用于主内存变量，将一个工作内存传送的变量写入主内存的变量中。</li>
</ol>
<p>        如果要把一个变量从主内存拷贝到工作内存中，就需要顺序执行 $read$ 和 $load$ 操作；反过来，如果要把一个变量从工作内存拷贝到主内存中，就需要顺序执行 $store$ 和 $write$ 操作。<code>Java</code>内存模型虽然规定了上述操作要顺序执行，但并没有要求连续执行，也就是说可以读取多个变量后再依次载入，或者存储多个变量后再依次写入。除此之外，还有其他规则：</p>
<ul>
<li>不允许 $read$ 和 $load$ 、$store$ 和 $write$ 单独出现；</li>
<li>不允许线程丢弃 $assign$ 操作；</li>
<li>不允许线程在没有进行 $assign$ 操作时同步内存；</li>
<li>不允许在工作内存中直接 $use$ 一个未被初始化的变量；</li>
<li>一个变量在一个时刻只能被一个线程 $lock$ ，一个线程可以多次执行 $lock$ 操作，后续需要执行相应次数的 $unlock$ 才能解锁；</li>
<li>对一个变量执行 $lock$ 操作会清除变量值，需要重新执行 $load$ 或者 $assign$ 进行赋值；</li>
<li>不允许对一个没有被锁定的变量 $unlock$ ，也不允许 $unlock$ 其他线程独占的变量；</li>
<li>$unlock$ 变量前需要先对其进行 $store$ 和 $write$ 。</li>
</ul>
<h3 id="12-volatile">1.2 <code>volatile</code></h3>
<p>        $volatile$ 具有一些特殊的访问规则。当一个变量被定义为 $volatile$ 之后，它将具有两条性质：一是保证变量是所有线程可见的，即一个线程的修改可以在之后被另一个线程所发现；二是指令重排序优化会被禁止，以保证语句之间的相对执行顺序。虽然可见性使得线程间变量值的传递不再需要经过对主内存的读取和写入，但这并不意味读取到的变量值是正确的。因为 $volatile$ 允许多线程同时对变量进行写操作，这就意味着对于一些非原子性的操作，譬如<code>Java</code>中的运算操作符（需要先将值读取到操作栈之后才能进行运算），$volatile$ 只能保证值被读取的时候是正确的，并不能保证在之后进行运算的过程中值不会发生改变。因此对于第一条性质，要保证运算结果并不依赖变量的当前值，或者只有一个线程会修改变量值。<br/>
        保证 $volatile$ 可见性的关键在于 $lock$ 操作，它会清空变量值，并在之后对变量进行 $store$ 和 $write$ 操作，从而保证了对变量的修改可以被其他线程发现。同时，$lock$ 操作也充当着内存屏障的功能，即执行 $lock$ 操作代表之前的操作已经执行完毕，从而可以利用 $lock$ 操作保证指令之间的相对执行顺序。也因此，$volatile$ 相比于 $synchronized$ 或者 $java.util.concurrent$ ，读操作速度没有什么差别，但是写操作会慢上一些，因为需要插入许多内存屏障以保证执行顺序，当然总体上来讲还是要快于后两者的。<br/>
        <code>Java</code>内存模型也对 $volatile$ 变量定义了特殊规则，设 $V$ 和 $W$ 代表两个 $volatile$ 变量，则有：</p>
<ul>
<li>只有前一条指令是 $load$ 时才能 $use$ ；只有后一条指令是 $use$ 时才能 $load$ ，即 $load$ 和 $use$ 必须连续一起出现；</li>
<li>只有前一条指令是 $assign$ 时才能 $store$ ；只有后一条指令是 $store$ 时才能 $assign$ ，即 $assign$ 和 $store$ 必须连续一起出现；</li>
<li>在一个线程中，如果对 $V$ 执行 $use$ 或者 $assign$ 操作优先于对 $W$ 执行 $use$ 或者 $assign$ 操作，那么对 $V$ 执行的 $read$ 或者 $write$ 操作必须优先于对 $W$ 执行的 $read$ 或者 $write$ 操作。</li>
</ul>
<h3 id="13-long和double">1.3 <code>long</code>和<code>double</code></h3>
<p>        $long$ 和 $double$ 是 $64$ 位的数据类型。对于 $64$ 位的数据类型，<code>Java</code>内存模型定义了一条特殊的规则：允许将其划分为两次 $32$ 位的操作进行，即 “ $long$ 和 $double$ 非原子性协定 ” ( $Non-Atomic\ \ Treatment\ \ of\ \ double\ \ and\ \ long\ \ Variables$ )。如果有多个线程共享一个未声明 $volatile$ 的 $long$ 或者 $double$ 类型的变量，并且同时对它们进行读写操作，那么某些线程可能会读取到一个修改了一半的数值。当然这种情况很罕见，因为常用的 $64$ 位虚拟机中并不会出现非原子性访问行为。</p>
<h3 id="14-原子性可见性与有序性">1.4 原子性、可见性与有序性</h3>
<h4 id="141-原子性">1.4.1 原子性</h4>
<p>        <code>Java</code>内存模型直接保证的原子性变量操作包括：$read$ 、$load$ 、$assign$ 、$use$ 、$store$ 和 $write$ 。如果需要一个更大范围的原子性保证，<code>Java</code>内存模型还提供了 $lock$ 和 $unlock$ 操作，即 $synchronized$ 块之间的操作也具备原子性。</p>
<h4 id="142-可见性">1.4.2 可见性</h4>
<p>        <code>Java</code>内存模型通过在变量修改后将新值同步回主内存，并在变量被读取时从主内存刷新变量值的方式实现可见性。除了 $volatile$ 之外，还可以使用 $synchronized$ 和 $final$ 保证可见性。</p>
<h4 id="143-有序性">1.4.3 有序性</h4>
<p>        有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在另一个线程中观察，所有的操作都是无序的。</p>
<h3 id="15-先行发生原则">1.5 先行发生原则</h3>
<p>        先行发生是<code>Java</code>内存模型中定义的两项操作之间的偏序关系。如果操作 $A$ 先行发生于操作 $B$ ，指的就是操作 $B$ 能够观测到操作 $A$ 产生的影响，影响指的是修改变量值、发送消息、调用方法等。<code>Java</code>内存模型之中存在一些天然的先行发生关系：</p>
<ul>
<li><strong>程序次序规则</strong> ( $Program\ \ Order\ \ Rule$ )：线程内按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li><strong>管程锁定规则</strong> ( $Monitor\ \ Lock\ \ Rule$ )：$unlock$ 操作先行发生于后续对同一个锁的 $lock$ 操作；</li>
<li>$volatile$ <strong>变量规则</strong> ( $Volatile\ \ Variable\ \ Rule$ )：对一个 $volatile$ 变量的写操作先行发生于读操作；</li>
<li><strong>线程启动规则</strong> ( $Thread\ \ Start\ \ Rule$ )：$Thread$ 的 $start(\ )$ 方法先行发生于所有动作；</li>
<li><strong>线程终止规则</strong> ( $Thread\ \ Termination\ \ Rule$ )：$Thread$ 的所有操作都先行发生于对其的终止检测 ( $join(\ )$ 和 $isAlive(\ )$ 等 )；</li>
<li><strong>线程中断规则</strong> ( $Thread\ \ Interruption\ \ Rule$ )：$Thread$ 的 $interrupt(\ )$ 方法先行发生于对其的中断事件检测 ( $interrupted(\ )$ )；</li>
<li><strong>对象终结规则</strong> ( $Finalizer\ \ Rule$ )：对象的初始化先行发生于其 $finalize(\ )$ 方法的开始；</li>
<li><strong>传递性</strong> ( $Transitivity$ )：如果操作 $A$ 先行发生于操作 $B$ ，操作 $B$ 先行发生于操作 $C$ ，那么操作 $A$ 先行发生于操作 $C$ 。</li>
</ul>
<p>        对于没有出现在上述列表里的操作关系，或者不能由上述列表关系推导出来的操作关系，虚拟机可以随意对它们进行重排。</p>
<h2 id="2-线程">2. 线程</h2>
<h3 id="21-线程实现">2.1 线程实现</h3>
<p>        虽然并发并不一定依赖于线程，但在<code>Java</code>中基本都离不开线程。线程允许在共享进程资源的同时又可以分离资源分配和执行调度，是<code>Java</code>里面进行处理器资源调度的最基本单位。</p>
<h4 id="211-内核线程实现">2.1.1 内核线程实现</h4>
<p>        内核线程 ( $Kernel-Level\ \ Thread$ ，$KLT$ ) 就是直接由操作系统内核支持的线程，即内核负责线程切换，通过操纵调度器 ( $Scheduler$ ) 对线程进行调度，并将线程处理的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，支持多线程的内核就称为多线程内核 ( $Multi-Threads\ \ Kernel$ )。程序一般不会直接使用内核线程，而是使用其高级接口轻量级进程 ( $Light\ \ Weight\ \ Process$ ，$LWP$ )，也就是我们通常讲的线程。一个系统能支持的轻量级进程的数量是有限的，取决于内核线程的数量。基于内核线程实现的线程的各种操作都是系统调用，而系统调用需要在用户态和内核态之间不断切换，从而会带来较高的代价。内核线程实现也称为 $1:1$ 实现。</p>
<h4 id="212-用户线程实现">2.1.2 用户线程实现</h4>
<p>        广义上来讲，一个线程只要不是内核线程，都可以称为用户线程 ( $User\ \ Thread$ ，$UT$ )。而狭义上的用户线程指的是完全建立在用户空间的线程库上，从而系统内核无法感知到的线程。用户线程的建立、调度和销毁完全可以在用户态下完成，而且如果建立得当，所有操作都可以在用户态下完成，从而拥有更高的效率。但是反过来，缺少了系统内核的支持，线程的创建、销毁、切换和调度就交给了用户，从而带来了一些更加复杂的问题。用户线程实现也称为 $1:N$ 实现。</p>
<h4 id="213-混合实现">2.1.3 混合实现</h4>
<p>        混合实现指的是同时使用内核线程和用户线程的方式，也称为 $N:M$ 实现。在这种方式下，用户线程还是建立在用户空间中，而 $LWP$ 充当了用户线程和内核线程之间的桥梁，一个 $LWP$ 可以对应多个用户线程。这样可以使用内核提供的线程调度功能和处理器映射功能，用户线程的系统调用也要通过 $LWP$ 完成，降低了阻塞风险。</p>
<h4 id="214-java实现">2.1.4 <code>Java</code>实现</h4>
<p>        从<code>JDK 1.3</code>起，主流<code>JVM</code>的线程模型普遍替换为基于操作系统原生线程模型的方式实现，即 $1:1$ 线程模型。<code>HotSpot</code>虚拟机中，每个<code>Java</code>线程都直接映射到一个操作系统的原生线程上，中间没有额外的间接结构，即把线程调度完全交给操作系统。</p>
<h3 id="22-线程调度">2.2 线程调度</h3>
<p>        线程调度主要有两种方式：协同式 ( $Cooperative\ \ Threads-Scheduling$ ) 和抢占式 ( $Preemptive\ \ Threads-Scheduling$ )。在协同式线程调度下，线程的执行时间由线程本身控制，线程在执行完成后会通知另一个线程；在抢占式线程调度下，线程的执行时间和切换由系统决定。虽然<code>Java</code>的线程调度由系统完成，但是可以通过设置线程优先级的方式，建议系统优先执行某些线程。</p>
<h3 id="23-状态转换">2.3 状态转换</h3>
<p>        线程具有 $6$ 种状态：新建、运行、无限期等待、限期等待、阻塞和结束。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Jan 12 21:13</span> <a href="/post/jvm9%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm8%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/">JVM（8）：后端编译与优化</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-即时编译器">1. 即时编译器</h2>
<p>        目前主流的两款商用<code>Java</code>虚拟机里，<code>Java</code>程序最初都是通过解释器执行的。当虚拟机发现某个方法或者代码块运行频繁，就会把代码认为是热点代码 ( $Hot\ \ Spot\ \ Code$ )，并将这些代码编译为本地机器码，同时进行代码优化。完成这个任务的后端编译器就称为即时编译器。</p>
<h3 id="11-解释器与编译器">1.1 解释器与编译器</h3>
<p>        当程序需要迅速启动和执行时，解释器可以省去编译时间立即运行；当程序启动后，越来越多的代码会被编译成本地代码，从而减少解释器带来的中间损耗，获得更快的执行速度。如果程序运行环境中内存限制过大，可以使用解释执行从而节约内存，反之可以使用编译执行提升效率。当编译器采取的优化手段出现罕见陷阱 ( $Uncommon\ \ Trap$ ) 时，可以通过逆优化 ( $Deoptimization$ ) 退回到解释状态执行。<br/>
        <code>HotSpot</code>虚拟机中内置了两个（或三个）即时编译器，其中两个存在已久的编译器分别称为客户端编译器 ( $Client\ \ Compiler$ ) 和服务端编译器 ( $Server\ \ Compiler$ )，简称为 $C1$ 编译器和 $C2$ 编译器。第三个编译器是<code>JDK 10</code>时出现的，目标是替代 $C2$ 的 $Graal$ 编译器。<br/>
        在分层编译 ( $Tiered\ \ Compilation$ ) 的工作模式出现前，通常采用解释器与一个编译器直接搭配的方式工作，这时用户也可以通过 $-client$ 和 $-server$ 参数直接运行模式。解释器与编译器搭配使用的方式称为混合模式 ( $Mixed\ \ Mode$ )，也可以通过 $-Xint$ 或者 $-Xcomp$ 强制运行解释模式或者编译模式。<br/>
        即时编译需要占用程序运行时间，而且编译过程中还需要进行优化。要想达到好的优化效果，解释器需要替编译器收集性能监控信息。当然，这也会影响解释执行的速度。为了寻求启动响应速度与运行效率之间的平衡，<code>HotSpot</code>虚拟机在编译子系统中加入了分层编译，包括：</p>
<ol>
<li>第 $0$ 层，程序解释执行，不开启性能监控；</li>
<li>第 $1$ 层，使用客户端编译器，进行简单优化，不开启性能监控；</li>
<li>第 $2$ 层，使用客户端编译器，开启方法和回边次数统计等监控；</li>
<li>第 $3$ 层，使用客户端编译器，开启全部性能监控，除了第 $2$ 层的统计信息外，还会收集分支跳转、虚方法等统计信息；</li>
<li>第 $4$ 层，使用服务端编译器将字节码编译为本地代码，需要更多的优化，还可能采取一些不可靠的激进优化。</li>
</ol>
<p>        实施分层编译后，解释器、客户端编译器、服务端编译器就会同时工作，热点代码可能会被多次编译。使用客户端编译器编译可以获得更高的编译速度，使用服务端编译器可以获得更好的编译质量。</p>
<h3 id="12-编译对象与触发条件">1.2 编译对象与触发条件</h3>
<p>        即时编译器的编译目标是热点代码，在这里热点代码主要有两类：</p>
<ul>
<li>多次调用的方法</li>
<li>多次执行的循环体</li>
</ul>
<p>        后者主要是解决少次调用方法内存在循环次数较多的循环体的问题，因此这两类热点代码的编译对象都是整个方法体，不同之处在于执行入口点字节码序号 ( $Byte\ \ Code\ \ Index$, $BCI$ )，因为后者的编译发生在方法执行过程中，所以栈中的方法会在执行的过程中被替换，称为栈上替换 ( $On\ \ Stack\ \ Replacement$, $OSR$ )。<br/>
        判断一段代码是不是热点代码的行为称为热点探测 ( $Hot\ \ Spot\ \ Code\ \ Detection$ )。主流的热点探测方式有两种：</p>
<ul>
<li>基于采样 ( $Sample\ \ Based$ ) 的热点探测：通过周期性地检查调用栈顶发现热点代码</li>
<li>基于计数器 ( $Counter\ \ Based$ ) 的热点探测：为每个方法建立计数器，统计执行次数</li>
</ul>
<p>        <code>HotSpot</code>虚拟机中采用的是第二种方法，每个方法有两个计数器：方法调用计数器 ( $Invocation\ \ Counter$ ) 和回边（在循环边界往回跳转）计数器 ( $Back\ \ Edge\ \ Counter$ )。这两个计数器都存在一个阈值，只要超过这个阈值，就认为方法为热点代码。<br/>
        对于方法调用计数器，在方法被调用时，虚拟机会先检查方法是否已被即时编译，如果没有则递增计数器，超过阈值便提交编译请求。在客户端编译器中，阈值为 $1500$ ；在服务端编译器中，阈值为 $10000$ 。可以通过 $-XX:CompileThreshold$ 设定。默认情况下执行引擎不会等待编译请求完成，而是会继续解释执行字节码，直到编译完成。方法调用计数器存储的并不是方法被调用的次数，而是一个相对频率。如果在一定时间内方法调用次数没有超过阈值，那么计数器数值就会减半，称为热度衰减 ( $Counter\ \ Decay$ )，衰减的周期称为半衰周期 ( $Counter\ \ Half\ \ Life\ \ Time$ )。虚拟机会在垃圾收集的过程中顺便执行热度衰减操作，可以通过 $-XX:-UserCounterDecay$ 来关闭热度衰减，或者通过 $-XX:CounterHalfLifeTime$ 设置半衰周期，单位是秒。<br/>
        对于回边计数器，在遇到字节码的控制流向后跳转指令时就递增，同样在默认情况下不会同步编译请求。回边计数器不存在热度衰减的过程，也就是说统计的是方法循环执行的绝对次数。当回边计数器溢出时，还会将方法调用计数器的值也调整为溢出，从而使得下次进入该方法时执行标准编译过程。虽然<code>HotSpot</code>虚拟机中提供了 $-XX:BackEdgeThreshold$ 参数，但是实际上并没有作用。我们通过另一个参数 $-XX:OnStackReplacePercentage$ ( $OSR$ 比率 ) 间接调整回边计数器阈值，计算公式有两种：</p>
<ul>
<li>客户端模式下：方法调用计数器阈值 $\times\ \ OSR$ 比率 $/\ \ 100$ ，在客户端模式下 $OSR$ 比率默认为 $933$ ，默认情况下回边计数器阈值为 $13995$ ；</li>
<li>服务端模式下：方法调用计数器阈值 $\times\ \ (OSR$ 比率 $-$ 解释器监控比率 ( $-XX:InterpreterProfilePercentage$ ) $)\ \ /\ \ 100$ ，在服务端模式下 $OSR$ 比率默认为 $140$ ，解释器监控比率默认为 $33$ ，默认情况下回边计数器阈值为 $10700$ 。</li>
</ul>
<h3 id="13-编译过程">1.3 编译过程</h3>
<p>        默认情况下，解释器不会同步编译请求，用户可以通过 $-XX:-BackgroundCompilation$ 禁止。对于客户端编译器来说，后台编译是一个三段式的编译过程：</p>
<ul>
<li>第一阶段，前端将字节码构造成高级中间代码 ( $High-Level\ \ Intermediate\ \ Representation$, $HIR$ ) ，中间代码使用静态单分配 ( $Static\ \ Single\ \ Assignment$, $SSA$ ) 的形式代表代码值，这个过程会进行一些基础优化如方法内联、常量传播等；</li>
<li>第二阶段，完成另一些优化如消除空值检查和范围检查等，之后后端会从 $HIR$ 中产生低级中间代码 ( $Low-Level\ \ Intermediate\ \ Representation$, $LIR$ )；</li>
<li>第三阶段，使用线性扫描算法 ( $Linear\ \ Scan\ \ Register\ \ Allocation$ ) 在 $LIR$ 上分配寄存器，这个过程会进行窥孔 ( $Peephole$ ) 优化，最后产生机器码。</li>
</ul>
<p>        服务端编译使用的是经过针对性调整后的可以容忍很高优化复杂度的高级编译器，执行大部分优化动作如无用代码消除、循环展开、循环外提、消除公共表达式、常量传播、基本块重排等，以及一些与<code>Java</code>相关的优化技术如消除范围检查和空值检查等，此外还有可能根据性能监控信息进行一些激进优化，如守护内联、分支频率预测等。服务端编译采用的寄存器分配器是一个全局图着色分配器，可以充分利用某些处理器架构上的大寄存器集合。因此，虽然服务端编译的速度很慢，但是能够产生可以大幅减少执行时间的代码，从而抵消掉编译开销，这也使得一些非服务端应用选择使用服务端模式运行。</p>
<h2 id="2-提前编译器">2. 提前编译器</h2>
<p>        提前编译器存在两条分支，一条是在程序运行前将程序代码编译成机器码，另一条是把原本即时编译器在运行时要做的工作提前做好并保存下来。<code>Java</code>的即时编译需要占用程序运行时间和运算资源，而提前编译可以在一定程度上减少即时编译的工作量，这也是提前编译的目的之一。因为不需要考虑执行时间和资源消耗等问题，所以提前编译可以使用重负载的优化手段。但是即时编译相较于提前编译还是存在着天然优势：</p>
<ul>
<li>性能分析制导优化 ( $Profile-Guided\ \ Optimization$, $PGO$ )：通过解释器收集性能监控信息，从而动态获取热点代码，这是提前编译无法做到的。在获得热点代码之后，可以对它们进行集中优化，分配更好的资源；</li>
<li>激进预测性优化 ( $Aggressive\ \ Speculative\ \ Optimization$ )：静态优化必须保证优化后所有程序的外部可见影响与优化前等效，然而即时编译可以利用性能监控信息进行一些激进优化，如果优化失败则进行逆优化；</li>
<li>链接时优化 ( $Link-Time\ \ Optimization$, $LTO$ )：<code>Java</code>是一门动态链接语言，而提前编译无法解决动态链接库之间的边界隔阂问题，还会产生优化问题。</li>
</ul>
<h2 id="3-编译器优化技术">3. 编译器优化技术</h2>
<h3 id="31-方法内联">3.1 方法内联</h3>
<p>        方法内联即将方法实现复制到调用方法中，从而避免方法调用。但是<code>JVM</code>中，只有 $invokespecial$ 和 $invokestatic$ 调用的方法才会在编译期进行解析，其他方法都必须在运行时进行多态选择，即<code>Java</code>中默认的实例方法都是虚方法。为了解决虚方法带来的问题，<code>JVM</code>引入了类型继承关系分析 ( $Class\ \ Hierarchy\ \ Analysis$, $CHA$ ) 技术，用于确定目前已加载的类中某个接口是否存在多于一种方式的实现、某个类是否存在子类、子类是否存在方法覆盖等。如果方法只有一个版本，那么就可以假设应用程序的全貌就是现在这样，从而进行内联，这种方式称为守护内联 ( $Guarded\ \ Inlining$ )。当之前的条件假设不成立时，虚拟机加载到令方法接收者的继承关系发生变化的类，也就是守护内联失败时，就必须抛弃已经编译的代码，退回解释状态。如果方法存在多个版本，那么即时编译器会采用内联缓存 ( $Inling\ \ Cache$ ) 的方式减少开销，即记录方法接收者的版本信息，并在之后比较版本信息，如果相同，则为单态内联缓存 ( $Monomorphic\ \ Inline\ \ Cache$ )，比普通方法调用的开销要小一些，因为不需要查询虚方法表；如果不同，则退化为超多态内联缓存 ( $Megamorphic\ \ Inline\ \ Cache$ )，相当于普通调用的方法开销。</p>
<h3 id="32-逃逸分析">3.2 逃逸分析</h3>
<p>        逃逸分析 ( $Escape\ \ Analysis$ ) 并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。基本原理是：分析对象动态作用域，对象在方法内被定义后又被外部方法引用，称为方法逃逸；被外部线程访问，称为线程逃逸。对象的逃逸程度按从低到高排为不逃逸、方法逃逸和线程逃逸。对于不逃逸或者逃逸程度低的对象，可以进行优化：</p>
<ul>
<li>栈上分配 ( $Stack\ \ Allocations$ )：对于非线程逃逸对象，可以分配在栈上；</li>
<li>标量替换 ( $Scalar\ \ Replacement$ )：将一个聚合量拆为多个原始类型的过程称为标量替换。对于不逃逸对象，可以将它们的创建过程改为创建多个原始类型变量，从而方便后续优化；</li>
<li>同步消除 ( $Synchronization\ \ Elimination$ )：对于非线程逃逸对象，可以消除其同步措施。</li>
</ul>
<h3 id="33-数组边界检查消除">3.3 数组边界检查消除</h3>
<p>        对于<code>JVM</code>的执行子系统来说，每次数组元素的读写都有一次隐式地边界检查。如果可以在编译期根据数据流分析确定数组长度，并对一些代码进行下标判断，就可以提前发现其是否越界，从而避免了每次执行时的判断，这个过程称为数组边界检查消除。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Jan 9 20:58</span> <a href="/post/jvm8%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm7%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/">JVM（7）：前端编译与优化</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-javac编译器">1. <code>Javac</code>编译器</h2>
<p>        <code>Javac</code>是一个由<code>Java</code>语言编写的程序，从其代码总体结构来看，可以将编译过程大致分为 $1$ 个准备过程和 $3$ 个处理过程：</p>
<ol>
<li>准备过程：初始化插入式注解处理器</li>
<li>解析与填充符号表过程，包括词法分析、语法分析和符号表创建</li>
<li>插入式注解处理器的注解处理过程</li>
<li>分析与字节码生成过程，包括标注检查、数据流及控制流分析、解语法糖和字节码生成</li>
</ol>
<p>        在上述处理过程中，执行插入式注解时可能又会产生新的符号。如果产生新的符号，就必须对它们进行解析，因此又回到了步骤 $2$ 。<code>Javac</code>编译动作得入口是 $com.sun.tools.javac.main.JavaCompiler$ 类，上述 $3$ 个过程的代码逻辑集中在这个类的 $compiler(\ )$ 和 $compiler2(\ )$ 方法。</p>
<h3 id="11-解析与填充符号表">1.1 解析与填充符号表</h3>
<p>        解析过程通过 $JavaCompiler.parseFiles(\ )$ 方法发起。</p>
<h4 id="111-词法语法分析">1.1.1 词法、语法分析</h4>
<p>        词法分析过程由 $com.sun.tools.javac.parser.Scanner$ 类完成。语法分析过程由 $com.sun.tools.javac.parser.Parser$ 类完成，产出的抽象语法树以 $com.sun.tools.javac.tree.JCTree$ 类表示。在完成词法、语法分析之后，编译器后续的操作都建立在抽象语法树的基础上，不会再对源码进行操作了。</p>
<h4 id="112-填充符号表">1.1.2 填充符号表</h4>
<p>        填充符号表过程通过 $JavaCompiler.enterTrees(\ )$ 方法发起，由 $com.sun.tools.javac.comp.Enter$ 类完成，产出一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级结点。</p>
<h3 id="12-注解处理器">1.2 注解处理器</h3>
<p>        在<code>JDK 5</code>时，注解只会在程序运行期间发挥作用。<code>JDK 6</code>中提供了一组称为“插入式注解处理器”的标准<code>API</code>，使得特定注解的处理可以提前至编译期进行。插入式注解处理器可以读取、修改和添加抽象语法树的元素。如果在这个过程中发生了修改操作，那么编译器需要返回解析与填充符号表过程重新处理。</p>
<h3 id="13-语义分析与字节码生成">1.3 语义分析与字节码生成</h3>
<p>        抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义符合逻辑，因此需要进行语义分析对源程序进行上下文相关性质的检查，譬如类型检查、控制流检查、数据流检查等。</p>
<h4 id="131-标注检查">1.3.1 标注检查</h4>
<p>        标注检查由 $JavaCompiler.attribute(\ )$ 方法发起。标注检查步骤要检查的内容包括变量使用前是否已声明、变量与赋值之间的数据类型是否匹配等。此外还会进行常量折叠 ( $Constant\ \ Folding$ ) 。</p>
<h4 id="132-数据及控制流分析">1.3.2 数据及控制流分析</h4>
<p>        数据及控制流分析是对程序上下文逻辑的更进一步验证，可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有受查异常都被正确处理等。编译期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上可以看作是一致的，但有一些校验项只有在编译期或者运行期才能进行。数据及控制流分析由 $JavaCompiler.flow(\ )$ 方法发起，由 $com.sun.tools.javac.comp.Flow$ 类完成。</p>
<h4 id="133-解语法糖">1.3.3 解语法糖</h4>
<p>        <code>Java</code>中最常见的语法糖包括泛型、变长参数、自动装箱拆箱等。<code>JVM</code>并不支持这些语法，它们会在编译期还原为基础语法结构，这个过程称为解语法糖。解语法糖过程由 $JavaCompiler.desugar(\ )$ 方法发起，由 $com.sun.tools.javac.comp.TransTypes$ 类和 $com.sun.tools.javac.comp.Lower$ 类完成。</p>
<h4 id="134-字节码生成">1.3.4 字节码生成</h4>
<p>        字节码生成过程由 $com.sun.tools.javac.jvm.Gen$ 类完成，除了把之前步骤生成的信息（语法树、符号表）转化成字节码指令之外，还进行少量的代码添加和转换工作。例如实例构造器 &lt;$init$&gt;$(\ )$ 和类构造器 &lt;$clinit$&gt;$(\ )$ 就是在这个阶段被添加到语法树中的。要注意的是这里的构造器并非默认构造器，默认构造器的产生是在填充符号表的过程中执行的。除了生成构造器外，还有一些其他的代码替换工作比如将字符串连接替换为 $StringBuffer$ 或者 $StringBuilder$ 的 $append(\ )$ 等。在完成上述步骤后，$com.sun.tools.javac.jvm.ClassWriter.writeClass(\ )$ 方法将会输出<code>Class</code>文件，代表编译完成。</p>
<h2 id="2-语法糖">2. 语法糖</h2>
<h3 id="21-泛型">2.1 泛型</h3>
<p>        泛型的本质是参数化类型 ( $Parameterized\ \ Type$ ) 或者参数化多态 ( $Parametric\ \ Polymorphism$ ) 的应用。<code>Java</code>选择的泛型实现方式称为“类型擦除式泛型” ( $Type\ \ Erasure\ \ Generics$ ) ，即泛型只在源码中存在，在字节码文件中被替换为裸类型 ( $Raw\ \ Type$ )，并且在相应的地方插入了强制转型代码。裸类型可以视为所有该类型泛型化实例的父类，因而可以将泛型化实例赋值给裸类型实例。<code>Java</code>在编译时会将泛型化实例，如 $ArrayList$&lt;$Integer$&gt;还原为裸类型实例，如 $ArrayList$ ，并在元素访问和修改时插入一些强制类型转换和类型检查指令。因为不能将原生类型转换为 $Object$ ，因此<code>Java</code>不支持原生类型的泛型，同时也增加了对原生类型的装箱拆箱工作。</p>
<h3 id="22-自动装箱拆箱与遍历循环">2.2 自动装箱、拆箱与遍历循环</h3>
<p>        自动装箱、拆箱与遍历循环是<code>Java</code>语言中使用的最多的语法糖。使用语法糖的示例如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">4</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>对上述代码进行编译和反编译后得到的结果为：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="k">new</span> <span class="n">Integer</span><span class="o">[]</span> <span class="o">{</span>
        <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">1</span><span class="o">),</span>
        <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">2</span><span class="o">),</span>
        <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">3</span><span class="o">),</span>
        <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">4</span><span class="o">)</span>
    <span class="o">});</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Iterator</span> <span class="n">localIterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">localIterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">((</span><span class="n">Integer</span><span class="o">)</span><span class="n">localIterator</span><span class="o">.</span><span class="na">next</span><span class="o">()).</span><span class="na">intValue</span><span class="o">();</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>        类似的还有变长参数，它通过在编译时转换为一个数组类型的参数实现。</p>
<h3 id="23-条件编译">2.3 条件编译</h3>
<p>        在<code>C/C++</code>中，我们可以通过预处理器实现条件编译。虽然<code>Java</code>中并没有预处理器，但是也可以实现条件编译，即通过条件为常量的 $if$ 语句。在编译的过程中，编译器会删去分支中无法到达的代码，这一工作也属于解语法糖的范畴。</p>
<p>        除了上述所提到的以外，内部类、枚举类、断言、数值字面量、对枚举的 $switch$ 支持、$try-with-resources$ 、$Lambda$ 表达式（虽然不能算单纯的语法糖，但也在前端编译器中做了大量的转换工作）等都属于语法糖。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Jan 8 20:09</span> <a href="/post/jvm7%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>