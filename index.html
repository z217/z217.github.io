<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.82.1" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/">进程、线程和协程</a>
        
        
        <p>进程、线程和协程介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Aug 25 17:25
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: OS
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">HashMap源码解读</a>
        
        
        <p>HashMap源码解读</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Aug 23 15:01
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">I/O多路复用</a>
        
        
        <p>操作系统I/O多路复用介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Aug 22 15:30
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: OS
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/">缓存一致性协议MESI</a>
        
        
        <p>缓存一致性协议MESI介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Aug 16 11:02
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: OS
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/mysql%E7%AC%94%E8%AE%B0/">MySQL笔记</a>
        
        
        <p>MySQL笔记</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Jun 21 20:33
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: DBS
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/">进程、线程和协程</a></h1>
            </center>
            <div class="post-content">
                <table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">进程</th>
<th style="text-align:center">线程</th>
<th style="text-align:center">协程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>CPU</code></td>
<td style="text-align:center">系统负责执行线程</td>
<td style="text-align:center">一个进程含有多个线程，系统分配线程在不同的<code>CPU</code>上执行</td>
<td style="text-align:center">线程上执行</td>
</tr>
<tr>
<td style="text-align:center">内存</td>
<td style="text-align:center">进程管理自己的内存区域</td>
<td style="text-align:center">多线程共享进程的内存区域</td>
<td style="text-align:center">同线程</td>
</tr>
<tr>
<td style="text-align:center">栈</td>
<td style="text-align:center"></td>
<td style="text-align:center">系统负责在内存中分配调用栈，默认为 $8MB$</td>
<td style="text-align:center">用户程序在堆上分配栈，切换的时候修改 $SP$ 、$PC$ 、$BP$</td>
</tr>
<tr>
<td style="text-align:center">切换方式</td>
<td style="text-align:center"></td>
<td style="text-align:center">时间片耗尽后触发中断处理程序，内核负责切换线程</td>
<td style="text-align:center">主动切换，让出<code>CPU</code></td>
</tr>
<tr>
<td style="text-align:center">切换内容</td>
<td style="text-align:center">通用寄存器，$PC$ 寄存器，页表寄存器，<code>TLB</code>，<code>CPU</code>缓存</td>
<td style="text-align:center">通用寄存器，$PC$ 寄存器，<code>CPU</code>缓存</td>
<td style="text-align:center">通用寄存器，$PC$ 寄存器</td>
</tr>
<tr>
<td style="text-align:center">上下文</td>
<td style="text-align:center">$task_-struct$ ，页表</td>
<td style="text-align:center">$task_-struct$ ，页表</td>
<td style="text-align:center">运行栈，寄存器</td>
</tr>
</tbody>
</table>
<h2 id="1-cpu和内存">1. <code>CPU</code>和内存</h2>
<p>        操作系统为进程分配了一个专门的数据结构称为进程控制块 ( $Process\ \ Control\ \ Block$ ，$PCB$ )。系统利用<code>PCB</code>来描述进程基本情况和运行状态，进而实现对进程的控制和管理。程序段、相关数据段和<code>PCB</code>构成了进程实体。<code>PCB</code>内的信息包括：</p>
<ul>
<li>进程描述信息：进程标识符 ( $PID$ ) 和用户标识符 ( $UID$ )；</li>
<li>进程控制和管理信息：进程状态信息，进程优先级，代码运行入口，程序外存地址，处理机占用时间等；</li>
<li>资源分配清单：代码段指针、数据段指针、堆栈段指针和文件描述符等；</li>
<li>处理机相关信息：通用寄存器，地址寄存器，控制寄存器，状态字等。</li>
</ul>
<p>        线程的最直接理解就是轻量级进程，是<code>CPU</code>的基本执行单元，也是程序执行的最小单元，包括：</p>
<ul>
<li>线程<code>ID</code>；</li>
<li>程序计数器；</li>
<li>寄存器；</li>
<li>堆栈。</li>
</ul>
<p>        线程是进程中的一个实体，是系统独立调度和分派的基本单位，只拥有一些运行中必不可少的资源，共享其所在线程的全部资源。在多线程操作系统中，进程的执行实际上是进程中的某个线程正在执行。<code>Linux</code>系统中进程和线程都使用 $task_-struct$ 结构描述，存储在一个双端循环列表中，列表存储在内核栈的末尾。<br>
        线程的实现可以分为两类，用户级线程 ( $User-Level\ \ Thread$ ) 和内核级线程 ( $Kernel-Level\ \ Thread$ )。用户级线程中，有关线程管理的所有工作都交由应用程序完成；内核级线程中，线程管理的所有工作都交由内核完成，应用程序只有一个到内核级线程的编程接口，内核为进程及其内部的每个线程维护上下文信息。<br>
        协程并不是一个新概念，它在 $1958$ 年就被提出。协程就是一个子任务，特点是非抢占式的调度。协程会自己判断运行状况，当满足一定条件就会主动让出<code>CPU</code>给其他协程，而进程或者线程的切换需要进入内核态交给内核处理。协程其实就是用户级线程。协程中的信息只包括运行栈和寄存器，后者决定了程序在代码中的执行位置。</p>
<ul>
<li>$PC$ 寄存器：指向下一条指令的位置；</li>
<li>$BP$ 寄存器：当前函数栈帧的起始位置，用于定位函数参数以及函数内变量的位置；</li>
<li>$SP$ 寄存器：当前函数栈帧的结束位置，也即下一个函数栈帧的起始位置。</li>
</ul>
<h2 id="2-栈">2. 栈</h2>
<ul>
<li>每次函数调用的时候，对于通用寄存器传参的冲突，我们可以先将通用寄存器临时压入栈中，在子函数调用完毕后，再将栈顶参数弹出，恢复寄存器值；</li>
<li>局部变量也是在栈中申请空间的，每次申请时都要向下移动栈指针，指针回移即可完成局部变量的释放；</li>
<li>函数的返回地址也是在子函数调用前压入栈中，待子函数调用完毕后弹出到 $PC$ 寄存器中。</li>
</ul>
<p>        进程的内存空间中有一块栈区，<code>PCB</code>会存储栈区指针，表示用户空间栈。栈的初始化是由编译器和链接器计算出来的，但是栈的实时大小并不是固定的，栈也不是能无限增长的，一般为 $8MB$ 。对于主线程，其栈实际上就是进程栈。然而对于主线程生成的子线程来说，其栈是固定的，使用 $mmap(\ )$ 系统调用，也就是说不会动态增长，一旦用尽就没了。由于线程栈是从进程地址空间中 $mmap(\ )$ 映射的一块内存区域，原则上是线程私有的。<br>
        在每一个进程的生命周期中，必然会通过系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，称作进程内核栈。进程内核栈通过 $slab$ 分配器从 $thread_-info_-cache$ 缓存池中分配出来，其大小为 $THREAD_-SIZE$ ，一般来说是一个页大小 ( $4K$ )。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">union</span> <span class="n">thread_union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">thread_info</span> <span class="n">thread_info</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack</span><span class="p">[</span><span class="n">THREAD_SIZE</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)];</span>
<span class="p">}</span>
</code></pre></div><p>        $thread_-union$ 进程内核栈和 $task_-struct$ 进程描述符有着紧密的联系，内核经常要访问 $task_-struct$ ，高效获取当前进程描述符是一个很重要的事。因此内核在进程内核栈头部存放了 $thread_-union$ ，从而记录了对应的进程描述符。<br>
        进程陷入内核栈的时候，需要内核栈来支持内核函数调用，中断也是如此。当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的，具体是否共享，和处理器架构有关。<br>
        协程可以被分为两类，一种是有栈协程，例如 $goroutine$ 和 $libco$ ，一种是无栈协程，例如<code>C++</code>。有栈和无栈的区别并不是运行的时候有没有栈，而是协程之间是否存在调用栈。<br>
       很多地方又把协程称为 $subroutine$ ，也即函数，而 $coroutine$ 就是可以中断并恢复执行的 $subroutine$ 。如果把协程当作一个特殊的函数调用，那么有栈协程就是我们理想中的协程实现形式。把协程当作一个函数调用，难点在于如何切换函数，也即切换协程，最后还要切换回来。一种做法是在协程内部存储自身的上下文，并在需要的时候进行切换。上下文的本质是寄存器，所以保存上下文实际上就是把寄存器的值保存下来。在<code>Go</code>程序中，每个 $goroutine$ 都有自己的栈区，各个栈区隔离，初始大小为 $2KB$ ，可以按照需求增长和收缩，最大限制为 $1GB$ 。<br>
        无栈协程的本质就是一个状态机，即所有协程本质都是同一个协程，而协程切换不过是寄存器状态的改变。从执行时栈的角度来看，所有协程共用一个系统栈，也就不必给协程分配栈。相比于有栈协程把局部变量放在新开的空间上，无栈协程直接使用系统栈，具有更好的局部性，而且中断和函数返回没有区别，更加高效。</p>
<h2 id="3-调度">3. 调度</h2>
<p>        通常进程的创建、撤销以及要求系统设备完成<code>I/O</code>操作都是利用系统调用进入内核模式，再由内核中相应的处理程序完成的。进程切换也是内核模式下完成的，过程为：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和寄存器；</li>
<li>更新<code>PCB</code>；</li>
<li>把<code>PCB</code>移入相应的就绪队列或者事件的阻塞队列；</li>
<li>找到下一个要执行的进程，更新<code>PCB</code>；</li>
<li>更新内存管理的数据结构；</li>
<li>恢复处理机上下文。</li>
</ol>
<p>        线程只持有一些必不可少的资源，包括线程<code>ID</code>、程序计数器、寄存器集合和堆栈。在进行线程切换时，只需要保存和设置少量寄存器内容即可。由于<code>Linux</code>中线程和进程使用相同的结构，因此在<code>Linux</code>中，线程和进程调度算法相同。<br>
        <code>Linux</code>系统使用了一种叫做<code>CFS</code> ( $Completely\ \ Fair\ \ Scheduler$ ) 的可抢占支持优先级时间片动态轮转调度算法。首先会根据<code>CPU</code>的负载状况确定一个调度的时间区间，然后将这个区间根据各个可运行进程的静态优先级 划分给每个进程一个时间片，这个时间片即动态优先级，跟虚拟运行时间有关 ( 虚拟运行时间 = 实际运行时间 $\times$ $nice$ 值 / 权重 )。然后将所有进程按照时间片的大小构建成一颗红黑树，每次调度时取红黑树中边上时间片最多的进程 ( 也即虚拟运行时间最少的进程 ) 运行，直到红黑树所有节点都用完了时间片就会触发下一轮调度。基本思路就是让虚拟运行时间最少的进程运行，所以叫做基本公平调度算法。<br>
        $goroutine$ 就是协程，不同的是<code>Go</code>在运行时、系统调用等多方面对 $goroutine$ 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 $goroutine$ 的<code>CPU</code>转让出去，让其他 $goroutine$ 能被调度执行。在内部实现上，进程内维护了一组数据结构和 $n$ 个线程，协程执行的代码在一个待执行队列中，由 $n$ 个线程消费。<code>Go</code>对<code>I/O</code>函数进行封装，内部使用异步<code>I/O</code>模式，在异步<code>I/O</code>执行的过程中，将现有执行序列入栈，让另一个协程执行。<br>
        <code>Go</code>协程使用了<code>M-P-G</code>模型。$M$ 为 $Machine$ ，即一个底层的操作系统线程；$G$ 即 $goroutine$ ，也就是协程；$P$ 为 $Processor$ ，是协程的管理者，<code>Go</code>抽象的一个处理器，通常数量等于<code>CPU</code>数量，运行时会绑定一个 $M$ ，当 $M$ 不可运行，比如陷入的时候，会转移到其他 $M$ 中。$P$ 中存在一个协程队列，$M$ 会消费这个队列，中途出现阻塞或者占用时间片过久都会触发协程调度。<br>
        <code>Go</code>协程采用了一种无优先级可抢占<code>FIFO</code>时间片轮转调度算法，调度本质是给绑定在 $P$ 的 $M$ 选择下一个可以运行的 $G$ 。$P$ 中的队列会被 $M$ 按照顺序消费，同时<code>Go</code>启动一个特殊的不绑定 $P$ 的线程 $sysmon$ ( $System\ \ Monitor$ )，会遍历所有 $P$ ，将在 $P$ 上运行超过 $10ms$ 的协程标记为可抢占。被标记为可抢占的协程在函数调用时会触发抢占调度，重新回到队列中。当 $P$ 的队列消费完毕，就会尝试去全局的协程队列中寻找任务，如果还是没有，就会从其他 $P$ 中窃取一半任务到当前队列上。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Aug 25 17:25</span> <a href="/post/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">HashMap源码解读</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-字段">1. 字段</h2>
<p>        字段设置为 $transient$ ，因为 $HashMap$ 通过 $Object.hashCode(\ )$ 获取哈希值，并通过哈希值与桶个数取模确定对象。$Object.hashCode(\ )$ 是一个本地方法，依赖于<code>JVM</code>实现，存在跨平台问题，所有 $HashMap$ 在序列化时会先保存所有 $Key$ ，再在反序列化时重新插入。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 最大容量
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">30</span><span class="o">;</span>

<span class="c1">// 默认负载因子，大小/容量超过这个比例就会扩容
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">float</span> <span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="n">0</span><span class="o">.</span><span class="na">75f</span><span class="o">;</span>

<span class="c1">// 当桶中节点数不小于该值时树化
</span><span class="c1">// 树节点大小是常规节点两倍，应该在有足够的节点后树化
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="n">8</span><span class="o">;</span>

<span class="c1">// 当桶中节点数小于该值时链表化
</span><span class="c1">// 不设为TREEIFY_THRESHOLD，避免抖动
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">UNTREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="n">6</span><span class="o">;</span>

<span class="c1">// 当容量不小于该值时才会树化，否则会优先扩容
</span><span class="c1">// 应当至少为 4 * TREEIFY_THRESHOLD
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MIN_TREEIFY_CAPACITY</span> <span class="o">=</span> <span class="n">64</span><span class="o">;</span>

<span class="c1">// 初次使用时初始化，长度为 2 的幂次
</span><span class="c1"></span><span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>

<span class="c1">// entrySet() 缓存
</span><span class="c1"></span><span class="kd">transient</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">entrySet</span><span class="o">;</span>

<span class="c1">// 改变次数，每次修改都会增加
</span><span class="c1"></span><span class="kd">transient</span> <span class="kt">int</span> <span class="n">modCount</span><span class="o">;</span>
</code></pre></div><h2 id="2-构造函数">2. 构造函数</h2>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal initial capacity: &#34;</span> <span class="o">+</span>
                                            <span class="n">initialCapacity</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span>
        <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="o">||</span> <span class="n">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal load factor: &#34;</span> <span class="o">+</span>
                                            <span class="n">loadFactor</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="o">;</span>
    <span class="c1">// tableSizeFor会获得不小于当前数字的最小的2的幂次
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">;</span> <span class="c1">// all other fields defaulted
</span><span class="c1"></span><span class="o">}</span>

<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">;</span>
    <span class="n">putMapEntries</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/** 计算大于等于输入参数的最小的 2 的幂次 */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">tableSizeFor</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">1</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">2</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">4</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">8</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">16</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">1</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">:</span> <span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h2 id="3-内部类">3. 内部类</h2>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>
    <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span>
    <span class="n">V</span> <span class="n">value</span><span class="o">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">^</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="4-插入">4. 插入</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 高低16位异或
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">h</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">())</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">16</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span> <span class="o">}</span>

<span class="c1">// @param onlyIfAbsent 如果为true，则不会改变已存在的value
</span><span class="c1">// @param evict        如果为false，说明处于构造模式
</span><span class="c1"></span><span class="kd">final</span> <span class="n">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
        <span class="c1">// 表为空，创建表
</span><span class="c1"></span>        <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="c1">// 对应位置为空，直接创建节点
</span><span class="c1"></span>        <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="c1">// 碰撞处理
</span><span class="c1"></span>    <span class="k">else</span> <span class="o">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span> <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
            <span class="c1">// 节点key相同
</span><span class="c1"></span>            <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
            <span class="c1">// 树状节点，向树中插入
</span><span class="c1"></span>            <span class="n">e</span> <span class="o">=</span> <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 尾插法
</span><span class="c1"></span>                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="c1">// -1 for 1st
</span><span class="c1"></span>                        <span class="c1">// 超过阈值，树化
</span><span class="c1"></span>                        <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                    <span class="c1">// 节点key相同
</span><span class="c1"></span>                    <span class="k">break</span><span class="o">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// existing mapping for key
</span><span class="c1"></span>            <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="c1">// 更新值
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="c1">// 超过阈值，扩容
</span><span class="c1"></span>        <span class="n">resize</span><span class="o">();</span>
    <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 扩容方法
</span><span class="c1"></span><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="nf">resize</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">oldCap</span> <span class="o">=</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">oldTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">oldThr</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">newCap</span><span class="o">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">oldTab</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">newCap</span> <span class="o">=</span> <span class="n">oldCap</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span>
                    <span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">)</span>
            <span class="c1">// 两倍扩容
</span><span class="c1"></span>            <span class="n">newThr</span> <span class="o">=</span> <span class="n">oldThr</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">;</span> <span class="c1">// double threshold
</span><span class="c1"></span>    <span class="o">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">oldThr</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// initial capacity was placed in threshold
</span><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">oldThr</span><span class="o">;</span>
    <span class="k">else</span> <span class="o">{</span>               <span class="c1">// zero initial threshold signifies using defaults
</span><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span>
        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">newThr</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">newCap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">;</span>
        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">MAXIMUM_CAPACITY</span> <span class="o">?</span>
                    <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">ft</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 设置新阈值并创建新表
</span><span class="c1"></span>    <span class="n">threshold</span> <span class="o">=</span> <span class="n">newThr</span><span class="o">;</span>
    <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">&#34;rawtypes&#34;</span><span class="o">,</span><span class="s">&#34;unchecked&#34;</span><span class="o">})</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">newCap</span><span class="o">];</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 迁移节点
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldCap</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="c1">// 没有碰撞
</span><span class="c1"></span>                    <span class="n">newTab</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">-</span> <span class="n">1</span><span class="o">)]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
                    <span class="c1">// 树分裂，这一步会判断是否链表化
</span><span class="c1"></span>                    <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">e</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">newTab</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">oldCap</span><span class="o">);</span>
                <span class="k">else</span> <span class="o">{</span> <span class="c1">// preserve order
</span><span class="c1"></span>                    <span class="c1">// 链表分裂
</span><span class="c1"></span>                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
                    <span class="k">do</span> <span class="o">{</span>
                        <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">oldCap</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                                <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="k">else</span>
                                <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="k">else</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                                <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="k">else</span>
                                <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">oldCap</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">newTab</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h2 id="5-删除">5. 删除</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">V</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span>
        <span class="kc">null</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// @param value      值
</span><span class="c1">// @param matchValue true表示只有value相同时才会移除
</span><span class="c1">// @param movable    false则移除时不会移动其他节点
</span><span class="c1"></span><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">removeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">,</span>
                            <span class="kt">boolean</span> <span class="n">matchValue</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">movable</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">index</span><span class="o">;</span>
    <span class="c1">// 表存在、节点存在
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
        <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">e</span><span class="o">;</span> <span class="n">K</span> <span class="n">k</span><span class="o">;</span> <span class="n">V</span> <span class="n">v</span><span class="o">;</span>
        <span class="c1">// 查找节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
                <span class="n">node</span> <span class="o">=</span> <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                        <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span>
                            <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span> <span class="o">{</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 找到对应节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">matchValue</span> <span class="o">||</span> <span class="o">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">==</span> <span class="n">value</span> <span class="o">||</span>
                                <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">v</span><span class="o">))))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
                <span class="c1">// 树移除节点，这一步如果红黑树太小会链表化
</span><span class="c1"></span>                <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">node</span><span class="o">).</span><span class="na">removeTreeNode</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">movable</span><span class="o">);</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span>
                <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
            <span class="o">--</span><span class="n">size</span><span class="o">;</span>
            <span class="n">afterNodeRemoval</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h2 id="6-区别">6. 区别</h2>
<ol>
<li><code>JDK1.7</code>使用头插法，<code>JDK1.8</code>使用尾插法，避免多线程同时扩容时的死循环；</li>
<li><code>JDK1.7</code>是先扩容后插入的，<code>JDK1.8</code>反过来，避免无效扩容；</li>
<li><code>JDK1.7</code>只有数组+链表，<code>JDK1.8</code>引入红黑树；</li>
</ol>

            </div>
            <div class="meta post-footer"> <span>2021 Aug 23 15:01</span> <a href="/post/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">I/O多路复用</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-基本概念">1. 基本概念</h2>
<p>        操作系统<strong>内核</strong> ( $kernel$ ) 是操作系统的核心，独立于普通应用程序，可以访问受保护的内存空间，也有权访问所有底层硬件设备。为了保证用户进程不能直接操作内核，操作系统将内存空间划为两部分，内核空间和用户空间。对于<code>linux</code>系统，如果是 $32$ 位系统，虚拟内存中最高的 $1G$ 字节 ( $0xC0000000 \sim 0xFFFFFFFF$ ) 为内核空间；如果是 $64$ 位系统，指针的前 $16$ 位保留，从而只有 $48$ 位寻址空间，于是最高的 $128T$ 字节 ( $0x0000000000000000 \sim 0x00007FFFFFFFF000$ ) 作为系统空间，中间部分 ( $0x00007FFFFFFFFFFF \sim 0xFFFF800000000000$ ) 作为保留，其余部分为用户空间。<br>
        正在执行的进程由于某些期待的事件未发生，如资源请求失败或者等待某些操作完成等，会自动执行阻塞原语，使自己由运行态变为阻塞态。进程的阻塞是一种主动行为，只有处于运行态的进程才可以触发，并且阻塞后不占用<code>CPU</code>资源。<br>
        文件描述符 ( $fd$ ) 是一个指向文件引用的概念，在形式上是一个非负整数，实际上是一个索引值，指向内核打开文件表中的对应记录。打开文件表中记录了文件的属性，包括磁盘位置、访问权限、文件位置指针以及打开计数。<br>
        缓存<code>I/O</code>又称为标准<code>I/O</code>，大多数文件系统的默认<code>I/O</code>操作都是缓存<code>I/O</code>。在<code>Linux</code>中，操作系统会将<code>I/O</code>数据缓存在文件系统的 $Page\ \ Cache$ 中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。<br>
        在<code>BIO</code>模式下，当线程接收一个请求后，在等待<code>I/O</code>的时间内，调用会被阻塞，无法接受其他请求。在多线程环境下，如果想要接受大量请求，就需要创建大量线程，占用大量系统空间，并且线程切换会带来很大的开销。$10000$ 个线程真正发生读写的实际的线程数不会超过 $20\%$ 。<br>
        在<code>NIO</code>模式下，当线程接收一个请求后，会加入 $fd_-set$ 集合，每次轮询集合接收数据，如果没有数据会返回错误。每次都要轮询所有集合，包括未发生实际读写的 $fd$ ，会浪费<code>CPU</code>资源。<br>
        在<code>I/O</code>多路复用模式下，服务端通过 $select$ / $poll$ / $epoll$ 等系统调用获取 $fd$ 列表，遍历有事件的 $fd$ 进行数据接收，可以支持更多并发连接请求。</p>
<ul>
<li><code>I/O</code>多路复用是一种同步<code>I/O</code>模型，多路指网络连接，复用指一个线程，即一个线程可以监视多个文件句柄；</li>
<li>一旦某个文件句柄就绪，就可以通知应用程序进行相应的读写操作；</li>
<li>没有文件句柄就会阻塞线程。</li>
</ul>
<h2 id="2-select">2. <code>select</code></h2>
<p>        $select$ 是仅仅知道了有<code>I/O</code>事件发生，但是无法确定是哪几个流 ( 一个或多个，甚至全部 )，只能无差别的轮询所有流，直到找出所有能读出或写入数据的流，具有 $O(n)$ 的无差别轮询复杂度。</p>
<ol>
<li>使用 $copy_-from_-user$ 从用户空间拷贝 $fd_-set$ 到内核空间；</li>
<li>注册回调函数 $\_\_pollwait$ ，负责将当前进程挂载到设备的等待队列中，在设备收到一条消息或者完成磁盘写入后，会唤醒等待队列上等待的进程；</li>
<li>遍历所有 $fd$ ，调用其对应的 $poll$ 方法，$poll$ 方法的核心就是 $\_\_pollwait$ ，返回一个描述读写操作是否完成的 $mask$ ，根据这个 $mask$ 给 $fd\_set$ 赋值；</li>
<li>如果遍历完所有的 $fd$ 还没有返回一个可读写的 $mask$ ，调用 $schedule_-timeout$ 使调用 $select$ 的进程睡眠；</li>
<li>设备驱动发现自身资源可读写后，唤醒等待队列上的进程。如果超过了 $schedule_-timeout$ 设定的时间，调用 $select$ 的进程会被重新唤醒，重新开始遍历；</li>
<li>把 $fd_-set$ 从内核空间拷贝回用户空间。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// fd_set为数组，通过FD_SETSIZE定义
</span><span class="c1">// readfds、writefds和exceptfds分别对应读、写和异常条件fd
</span><span class="c1">// timeout为超时时间，select会一直阻塞到有事件到达或者等待时间超过timeout
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</code></pre></div><p>        $select$ 本质上是通过设置或者检查存放 $fd$ 标志位的数据结构来进行下一步处理，缺点是：</p>
<ul>
<li>单个进程打开的 $fd$ 是有上限的，通过 $FD_-SETSIZE$ 设置，默认为 $1024$ ；</li>
<li>每次调用 $select$ 都需要把 $fd$ 集合从用户空间拷贝到内核空间；</li>
<li>采用轮询方式进行线性扫描，效率较低。</li>
</ul>
<h2 id="4-poll">4. <code>poll</code></h2>
<p>        $poll$ 本质和 $select$ 一样，也是将 $fd$ 拷贝到内核空间并轮询设备状态，但是没有最大连接数的限制。与 $select$ 的不同之处在于：</p>
<ul>
<li>$select$ 会修改 $fd$ ，$poll$ 不会；</li>
<li>$select$ 的 $fds$ 使用标志位，有数量限制；$poll$ 没有数量限制；</li>
<li>$select$ 会检测每个<code>bit</code>位，无论有没有 $fd$ ；$poll$ 检测数组，效率更高；</li>
<li>$poll$ 提供了更多的事件类型，对 $fd$ 的重复利用比 $select$ 高；</li>
<li>如果一个线程对某个 $fd$ 调用了 $select$ 或者 $poll$ ，另一个线程关闭了该 $fd$ ，会导致结果不确定。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">pollfd</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

    <span class="c1">// 期待事件
</span><span class="c1"></span>    <span class="kt">short</span> <span class="n">events</span><span class="p">;</span>

    <span class="c1">// 监听到的事件
</span><span class="c1"></span>    <span class="kt">short</span> <span class="n">revents</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre></div><p>        缺点是：</p>
<ul>
<li>每次调用都需要把 $fd$ 集合从用户空间拷贝到内核空间；</li>
<li>采用轮询方式进行线性扫描，效率较低。</li>
</ul>
<h2 id="5-epoll">5. <code>epoll</code></h2>
<p>        $epoll$ 可以理解为 $event\ \ poll$ ，不同于忙轮询和无差别轮询，每个流发生了怎样的<code>I/O</code>事件都会通知 $epoll$ ，也就是说 $epoll$ 是事件驱动的，从而将复杂度降低到了 $O(1)$ 。<br>
        当进程调用 $epoll_-create$ 时，<code>Linux</code>内核会创建 $eventpoll$ 结构体，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 每个epoll对象都有一个独立的eventpoll结构体
</span><span class="c1"></span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="p">{</span>
    <span class="c1">// 红黑树根节点，存储所有事件
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">rbr</span><span class="p">;</span>

    <span class="c1">// 双链表存储发生事件
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdlist</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 创建epoll对象
</span><span class="c1"></span><span class="kt">int</span> <span class="n">epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="c1">// 添加/删除事件
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

<span class="c1">// 检查事件集合，没有可读流则阻塞进程
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>

<span class="c1">// 事件结构
</span><span class="c1"></span><span class="k">struct</span> <span class="n">epitem</span> <span class="p">{</span>
    <span class="c1">// 红黑树节点
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rbn</span><span class="p">;</span>

    <span class="c1">// 双向链表节点
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdllink</span><span class="p">;</span>

    <span class="c1">// 事件句柄
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="n">ffd</span><span class="p">;</span>

    <span class="c1">// 所属eventpoll对象
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

    <span class="c1">// 期待发生的事件类型
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        通过 $epoll_-ctl$ 向 $eventpoll$ 对象中添加的事件都会存储在红黑树中，红黑树的高效性保证了重复事件可以被快速识别出来。所有添加到了 $epoll$ 的事件都会与设备 ( 网卡 ) 驱动程序建立回调关系，当相应事件发生时就会回调 $ep_-poll_-callback$ ，将发生的事件添加到双链表中。$epoll_-wait$ 检查是否有事件发生，即链表是否存在节点，如果存在，则复制回用户空间，并返回事件数量。<br>
        $epoll$ 的优点有：</p>
<ul>
<li>不限制并发连接上限 ( $1G$ 内存上能监听 $10$ 万个端口 )；</li>
<li>非轮询，效率高；</li>
<li>利用 $mmap(\ )$ 的将内核空间的一段区域映射到用户空间，只有第一次调用 $epoll_-ctl$ 时需要拷贝。</li>
</ul>
<p>        $epoll$ 有 $EPOLLLT$ 和 $EPOLLET$ 两种触发模式，$LT$ ( $level-triggered$ ) 是默认模式，$ET$ ( $edge-triggered$ ) 是高速模式。</p>
<ul>
<li>$LT$ ：只要 $fd$ 还有数据可读，每次 $epoll_-wait$ 都会返回该事件，即每次触发；</li>
<li>$ET$ ：每个 $fd$ 只会返回一次事件，直到下次有数据流入，即数据到来触发。</li>
</ul>
<h2 id="6-应用场景">6. 应用场景</h2>
<h3 id="61-对比">6.1 对比</h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$select$</th>
<th style="text-align:center">$poll$</th>
<th style="text-align:center">$epoll$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方式</td>
<td style="text-align:center">轮询</td>
<td style="text-align:center">轮询</td>
<td style="text-align:center">回调</td>
</tr>
<tr>
<td style="text-align:center">数据结构</td>
<td style="text-align:center">$bitmap$</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">红黑树</td>
</tr>
<tr>
<td style="text-align:center">最大连接数</td>
<td style="text-align:center">$1024$ ( $x86$ )/ $2048$ ( $x64$ )</td>
<td style="text-align:center">无上限</td>
<td style="text-align:center">无上限</td>
</tr>
<tr>
<td style="text-align:center">拷贝</td>
<td style="text-align:center">每次调用都需要进行拷贝</td>
<td style="text-align:center">每次调用都需要进行拷贝</td>
<td style="text-align:center">内核空间和用户空间共享一块内存</td>
</tr>
<tr>
<td style="text-align:center">工作模式</td>
<td style="text-align:center">$LT$</td>
<td style="text-align:center">$LT$</td>
<td style="text-align:center">$LT$ / $ET$</td>
</tr>
<tr>
<td style="text-align:center">复杂度</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
</tr>
</tbody>
</table>
<ul>
<li>$select$ 应用场景
<ul>
<li>$timeout$ 参数精度为微妙，$poll$ 和 $epoll$ 为毫秒，更适用于对实时性要求高的场景；</li>
<li>几乎所有主流平台都支持 $select$ ，移植性更好；</li>
</ul>
</li>
<li>$poll$ 应用场景
<ul>
<li>没有 $fd$ 数量限制，如果没有实时性要求，应该使用 $poll$ ；</li>
</ul>
</li>
<li>$epoll$ 应用场景
<ul>
<li>只能运行在<code>Linux</code>上，如果存在大量 $fd$ ，并且都是长连接，应该使用 $epoll$ ；</li>
<li>如果需要同时监控的 $fd$ 小于 $1000$ 个，就没必要使用 $epoll$ ，连接数量较少的场景无法体现 $epoll$ 的优势；</li>
<li>如果连接数量很多，但都是短连接，也没必要使用 $epoll$ ，因为 $epoll$ 的所有 $fd$ 都存储在内核空间，频繁调用 $epoll_-ctl(\ )$ 改变状态会导致过多的系统调用，降低效率；</li>
<li>$epoll$ 的 $fd$ 存储在内核空间，不利于调试。</li>
</ul>
</li>
</ul>
<h3 id="62-nginx">6.2 <code>Nginx</code></h3>
<p>        <code>Nginx</code>支持多种并发模型，具体实现根据系统平台而有所不同，在支持多种并发模型的平台上会自动选择最高效的模型，也可以通过 $use$ 指令在配置文件中显示指定。</p>
<h3 id="63-redis">6.3 <code>Redis</code></h3>
<p>        <code>Redis</code>采用<code>I/O</code>多路复用保证在多连接时候的吞吐量，主要是基于 $epoll$ 实现的，也提供了 $select$ 和 $kqueue$ 实现，默认采用 $epoll$ 。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Aug 22 15:30</span> <a href="/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/">缓存一致性协议MESI</a></h1>
            </center>
            <div class="post-content">
                <p>        <strong>高速缓冲存储器一致性</strong> ( $Cache\ \ coherence$ )，也称缓存一致性，是指在采用层次结构存储系统的计算机系统中，保证告诉缓冲存储器中数据与主存储器中数据相同的机制。在有多个<code>CPU</code>的多处理机系统中特别容易出现高速缓存中数据不一致的问题。<br>
        在<code>CPU</code>缓存设计中，<code>L1</code>高速缓存包含指令缓存和数据缓存，位于<code>CPU</code>芯片上，访问速度几乎和寄存器一样快。<code>L2</code>高速缓存在<code>L1</code>和主存之间，连接到存储器总线或者高速缓存总线上。有些高性能系统还会在存储器总线上设置<code>L3</code>高速缓存。<code>L1</code>和<code>L2</code>是每个<code>CPU</code>内核间独立的，<code>L3</code>是所有<code>CPU</code>内核间共享的。<br>
        对于单核<code>CPU</code>来说，数据更新时缓存更新只用考虑自己的就行了，主要有两种处理方法。<strong>写回法</strong> ( $write\ \ back$ )，是当处理器执行写操作时，信息只写入<code>cache</code>，当<code>cache</code>中的数据被替换出去时写回主存。为了减少内存写操作，<code>cache</code>中通常还会设置一个脏位 ( $dirty\ \ bit$ )，标识该块在被载入后是否发生了更新。<strong>直写法</strong> ( $write\ \ through$ ) 是当处理器执行写操作时，既向<code>cache</code>中写入也向主存中写入。直写法会造成大量写内存操作，需要设置一个缓冲来减少硬件冲突，称为写缓冲器 ( $write\ \ buffer$ )，通常不超过 $4$ 个缓存块的大小，也适用于写回法。<br>
        相比于单核<code>CPU</code>，多核<code>CPU</code>除了要保证<code>L1</code>和<code>L2</code>最新外还要考虑到其他核中<code>L1</code>和<code>L2</code>的实时性和有效性。<code>MESI</code>协议是一个基于失效的缓存一致性协议，是支持写回缓存的最常用协议。该协议对总线上的操作进行监听，即核 $A$ 可以窥探到核 $B$ 对过期值的读操作，并更新主存中的过期值。<code>MESI</code>把<code>cache</code>中的数据分为几个状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">监听</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$Invalid$</td>
<td style="text-align:center">该<code>cache</code>字段失效</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">$Shared$</td>
<td style="text-align:center">字段数据一致并且多核<code>cache</code>共享该字段</td>
<td style="text-align:center">监听其他缓存使该字段无效或者变为 $Exclusive$ 的请求，监听到对应事件后会将该字段设为 $Invalid$</td>
</tr>
<tr>
<td style="text-align:center">$Exclusive$</td>
<td style="text-align:center">字段数据一致并且只在当前核<code>cache</code>中独有</td>
<td style="text-align:center">监听其他缓存读主存中该字段的操作，监听到对应事件后将该字段变为 $Shared$</td>
</tr>
<tr>
<td style="text-align:center">$Modified$</td>
<td style="text-align:center">该字段有效但是与主存不一致，只存在于当前核<code>cache</code>中</td>
<td style="text-align:center">监听所有试图读该字段对应主存字段的操作，该操作会被延迟到当前缓存字段写回主存并将状态设为 $Shared$ 之后执行</td>
</tr>
</tbody>
</table>
<p><img src="/image/2021-08-16-01.png" alt="状态机"></p>
<table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$Local\ \ Read$</td>
<td style="text-align:center">读取本地<code>cache</code>字段</td>
</tr>
<tr>
<td style="text-align:center">$Local\ \ Write$</td>
<td style="text-align:center">写入本地<code>cache</code>字段</td>
</tr>
<tr>
<td style="text-align:center">$Remote\ \ Read$</td>
<td style="text-align:center">其他<code>cache</code>读取字段</td>
</tr>
<tr>
<td style="text-align:center">$Remote\ \ Write$</td>
<td style="text-align:center">其他<code>cache</code>写入字段</td>
</tr>
</tbody>
</table>
<p>        对于 $Modified$ 和 $Exclusive$
状态，数据是精确的，而 $Shared$ 状态可能是非一致的。如果一个处于 $Shared$ 的缓存字段作废了，另一个缓存实际上可能已经独享了该缓存字段，但是该缓存不会转为 $Exclusive$
，因为其他缓存并不会广播他们作废该缓存字段的通知。如果一个<code>CPU</code>想修改一个处于 $Shared$ 状态的缓存字段，总线事务需要将所有该缓存字段的副本变为 $Invalid$ 状态，而修改 $Exclusive$ 状态的缓存字段不需要总线事务。<br>
        缓存的一致性消息传递是需要时间的，这就使其切换时产生延迟。当一个缓存被切换状态时其他缓存收到消息完成各自的切换并且发出回应消息这么长一段时间中<code>CPU</code>都会等待所有缓存响应完成。为了避免这种<code>CPU</code>运算能力的浪费，$Store\ \ Buffer$ 被引入。处理器会将想要写入主存的值写到 $Store\ \ Buffer$ 中再去处理其他事情。为了避免在 $Store\ \ Buffer$ 未保存完时其他核已经完成读取，需要引入内存屏障。写屏障保证处理器在更新数据前必须将所有 $Store\ \ Buffer$ 中的指令执行完毕，读屏障保证处理器在读之前将所有需要设置为 $Invalid$ 的字段设置完毕。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Aug 16 11:02</span> <a href="/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2021, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
        if (tocFlag) tocInit();
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>