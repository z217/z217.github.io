<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.74.3" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
        
        <a href="http://123.57.12.189"  target="_blank" >
            <i class="fas fa-link fa-sm"></i>
            <span>二站</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/%E5%BF%AB%E9%80%9F%E4%B9%98%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/">快速乘算法简介</a>
        
        
        <p>快速乘算法（俄罗斯农民乘法）简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Sep 15 15:05
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Algorithm
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/java%E6%B3%A8%E8%A7%A3/">Java注解</a>
        
        
        <p>Java注解简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Sep 07 23:32
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/java-i-o/">Java I/O</a>
        
        
        <p>Java I/O系统简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Sep 06 21:28
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/java%E6%B3%9B%E5%9E%8B/">Java泛型</a>
        
        
        <p>Java泛型简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Sep 02 21:23
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/">Java类型信息</a>
        
        
        <p>Java类型信息简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 30 16:50
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E5%BF%AB%E9%80%9F%E4%B9%98%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/">快速乘算法简介</a></h1>
            </center>
            <div class="post-content">
                <p>        快速乘算法的原理是俄罗斯农民乘法，这种乘法规则很简单：</p>
<ul>
<li>将要相乘的两个数字写在两列；</li>
<li>将第一列乘以二，第二列除以二并写在下一行；</li>
<li>如果这一行中第二列数字为偶数，删去这一行；</li>
<li>在下一行重复上述二至三步直至第二列数字为 $1$ ；</li>
<li>将第一列未被删除的数字求和即为结果</li>
</ul>
<p>        以 $48 \times 58$ 为例：</p>
<div>
$$
\require{cancel}
\bcancel{48}\qquad\bcancel{58}\\
96\qquad29\\
\bcancel{192}\qquad\bcancel{14}\\
384\qquad7\\
768\qquad3\\
1536\qquad1\\
————\\
2784\qquad
$$
</div>
<p>        从而 $48 \times 58 = 2784$ 。<br>
        运用这个原理，我们可以对二进制数进行计算，只需要将原来的规则调整下即可。对于二进制数 $A$ 和 $B$ ，如果要计算 $A \times B$ ，那么可以：</p>
<ul>
<li>如果 $B$ 末位为 $1$ ，将 $A$ 加到结果上；</li>
<li>将 $A$ 左移一位，$B$ 右移一位；</li>
<li>重复上述两步直至 $B$ 为零。</li>
</ul>
<p>        将上述步骤用代码实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">QuickMulti</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">quickMulti</span><span class="o">(</span><span class="kt">int</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">B</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">B</span> <span class="o">&amp;</span> <span class="n">1</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span> <span class="n">res</span> <span class="o">+=</span> <span class="n">A</span><span class="o">;</span>
            <span class="n">A</span> <span class="o">&lt;&lt;=</span> <span class="n">1</span><span class="o">;</span>
            <span class="n">B</span> <span class="o">&gt;&gt;=</span> <span class="n">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        在这里举一道题为例演示快速乘算法的使用：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+&hellip;+n</a> 。<br>
        题目描述很简单，但要注意不能使用循环，即迭代，因此可以使用递归代替。不能使用条件判断语句，因此需要借助 $\And\And$ 逻辑运算符近似实现 $if$ 。而在<code>Java</code>中并不能直接在一条语句中使用 $\And\And$ ，因此可以先声明一个 $boolean$ 变量。实现代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumNums</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">recurse</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">0</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">recurse</span><span class="o">(</span><span class="kt">int</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span> <span class="n">B</span><span class="o">,</span> <span class="kt">int</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span> <span class="o">!=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">B</span> <span class="o">&amp;</span> <span class="n">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">1</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">res</span> <span class="o">=</span> <span class="n">A</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">B</span> <span class="o">!=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">res</span> <span class="o">+=</span> <span class="n">recurse</span><span class="o">(</span><span class="n">A</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">,</span> <span class="n">B</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">))</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        这里使用快速乘算法计算 $n \times (n + 1)$ 的值，再最后返回的时候再将结果除以 $2$ ，即利用了公式 $\large\frac{n(n + 1)}{2}$ 计算连续自然数的和。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Sep 15 15:05</span> <a href="/post/%E5%BF%AB%E9%80%9F%E4%B9%98%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/java%E6%B3%A8%E8%A7%A3/">Java注解</a></h1>
            </center>
            <div class="post-content">
                <p>        注解为在代码中添加信息提供了一种形式化的方式。<code>Java SE5</code>内置了三种定义在 $java.lang$ 当中的注解：</p>
<ul>
<li>$@Override$ ：表示当前定义的方法将覆盖超类中的方法；</li>
<li>$@Deprecated$ ：表示方法被弃用，调用此类方法将引发警告；</li>
<li>$@SuppressWarnings$ ：关闭某些编译警告信息。</li>
</ul>
<p>        除此之外还有四种注解，用于创建新注解。</p>
<h2 id="1-语法">1. 语法</h2>
<h3 id="11-定义">1.1 定义</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">id</span><span class="o">();</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">description</span><span class="o">()</span> <span class="k">default</span> <span class="s">&#34;no description&#34;</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>        注解的定义方式很像接口，也与接口一样会被编译为<code>class</code>文件。定义注解需要一些元注解。$@Target$ 定义注解的作用对象，如方法；$@Retention$ 定义的可用级别，分为源码 ( $SOURCE$ )、类文件 ( $CLASS$ )、运行时 ( $RUNTIME$ )。<br>
        在定义注解时也可以设置一些元素表示一些值，不同于接口，你可以为这些值设置默认值。如果没有提供默认值，那么在使用注解的时候就必须进行赋值。没有元素的注解称为<em><strong>标记注解</strong></em> ( $marker\ \ annotation$ )。可用的注解元素包括以下类型：</p>
<ul>
<li>基本类型；</li>
<li>$String$ ；</li>
<li>$Class$ ；</li>
<li>$enum$ ；</li>
<li>$Annotation$ ；</li>
<li>以上类型的数组。</li>
</ul>
<h3 id="12-元注解">1.2 元注解</h3>
<p>        <code>Java</code>内置了四种元注解：</p>
<ul>
<li>$@Targe$ ：表示注解的作用对象，包括：
<ul>
<li>$CONSTRUCTOR$ ：构造器；</li>
<li>$FIELD$ ：域，包括 $enum$ 实例；</li>
<li>$LOCAL_-VARIABLE$ ：局部变量；</li>
<li>$METHOD$ ：方法；</li>
<li>$PACKAGE$ ：包；</li>
<li>$PARAMETER$ ：参数；</li>
<li>$TYPE$ ：类、接口（包括注解）和 $enum$ 声明；</li>
</ul>
</li>
<li>$@Retention$ ：表示在什么级别保存注解信息，包括：
<ul>
<li>$SOURCE$ ：源码，注解将被编译器丢弃；</li>
<li>$CLASS$ ：<code>class</code>文件，注解将被<code>JVM</code>丢弃；</li>
<li>$RUNTIME$ ：运行时，因此可以通过反射获取注解信息；</li>
</ul>
</li>
<li>$@Documented$ ：将此注解包含在<code>Javadoc</code>中；</li>
<li>$@Inherited$ ：允许子类继承父类中的注解。</li>
</ul>
<h2 id="2-注解处理">2. 注解处理</h2>
<p>        注解需要搭配注解处理器使用，可以通过反射机制创建自己的注解处理器。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestTracker</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">trackTestMethod</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">m</span> <span class="o">:</span> <span class="n">c</span><span class="o">.</span><span class="na">getDeclaredMethods</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">Test</span> <span class="n">t</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">Test</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">uc</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
                    <span class="n">m</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span>
                        <span class="o">+</span> <span class="s">&#34; use annotation @Test, id = &#34;</span>
                        <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">id</span><span class="o">()</span>
                        <span class="o">+</span> <span class="s">&#34;, description&#34;</span>
                        <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">description</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        通过传入 $Class$ 对象，可以获取到类的方法和注解。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Sep 7 23:32</span> <a href="/post/java%E6%B3%A8%E8%A7%A3/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/java-i-o/">Java I/O</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-file类">1. <code>File</code>类</h2>
<p>        $File$ 类用于储存文件路径，可以代表一个特定文件或者一组文件的名称，如果是后者，可以通过 $list(\ )$ 获得一个字符数组。在不传入参数时，$list(\ )$ 方法返回全部列表，也可以接受一个 $FilenameFilter$ 类型的参数，实现目录过滤：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">DirFilter</span> <span class="kd">implements</span> <span class="n">FilenameFilter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Pattern</span> <span class="n">pattern</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">DirFilter</span><span class="o">(</span><span class="n">String</span> <span class="n">regex</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="n">regex</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">accept</span><span class="o">(</span><span class="n">File</span> <span class="n">dir</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">name</span><span class="o">).</span><span class="na">matches</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DirList</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&#34;.&#34;</span><span class="o">).</span><span class="na">list</span><span class="o">(</span><span class="k">new</span> <span class="n">DirFilter</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">0</span><span class="o">]))));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        除了代表文件和目录之外，$File$ 对象还可以用于创建和删除目录，查看文件信息等：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$getAbsolutePath$</td>
<td align="center">返回绝对路径</td>
</tr>
<tr>
<td align="center">$canRead$</td>
<td align="center">可读性</td>
</tr>
<tr>
<td align="center">$canWrite$</td>
<td align="center">可写性</td>
</tr>
<tr>
<td align="center">$getName$</td>
<td align="center">返回名称</td>
</tr>
<tr>
<td align="center">$getParent$</td>
<td align="center">返回父目录</td>
</tr>
<tr>
<td align="center">$getPath$</td>
<td align="center">返回路径</td>
</tr>
<tr>
<td align="center">$lastModified$</td>
<td align="center">最后修改时间</td>
</tr>
<tr>
<td align="center">$isFile$</td>
<td align="center">是否为文件</td>
</tr>
<tr>
<td align="center">$isDirectory$</td>
<td align="center">是否为目录</td>
</tr>
<tr>
<td align="center">$exists$</td>
<td align="center">是否存在</td>
</tr>
<tr>
<td align="center">$mkdirs$</td>
<td align="center">创建</td>
</tr>
<tr>
<td align="center">$delete$</td>
<td align="center">删除</td>
</tr>
<tr>
<td align="center">$renameTo$</td>
<td align="center">重命名或移动文件</td>
</tr>
</tbody>
</table>
<h2 id="2-io类">2. <code>I/O</code>类</h2>
<p>        编程语言的<code>I/O</code>类库常使用流这个概念，代表任何有能力产出数据的数据源或者有接受能力的接收端对象。“流”屏蔽了设备处理<code>I/O</code>操作的细节。在<code>Java</code>中，任何由 $InputStream$ 和 $Reader$ 的类都含有 $read(\ )$ 方法，任何由 $OutputStream$ 和 $Writer$ 派生的类都含有 $write(\ )$ 方法。$InputStream$ 和 $OutputStream$ 类型用于处理单个字节，$Reader$ 和 $Writer$ 类型用于处理字节数组。一般情况下都是通过叠加多个对象提供功能，也因此，当需要一个流的时候，往往需要创建多个对象。</p>
<h3 id="21-inputstreamoutputstream">2.1 <code>InputStream</code>/<code>OutputStream</code></h3>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$ByteArrayInputStream$</td>
<td align="center">将内存缓冲区当 $InputStream$ 使用</td>
</tr>
<tr>
<td align="center">$StringBufferStream$</td>
<td align="center">将 $String$ 当 $InputStream$ 使用</td>
</tr>
<tr>
<td align="center">$FileInputStream$</td>
<td align="center">读取文件信息</td>
</tr>
<tr>
<td align="center">$PipedInputStream$</td>
<td align="center">写入相关的 $PipedOutputStream$ 数据，实现管道</td>
</tr>
<tr>
<td align="center">$SequenceInputStream$</td>
<td align="center">将多个 $InputStream$ 转换为一个</td>
</tr>
<tr>
<td align="center">$FilterInputStream$</td>
<td align="center">抽象类，作为装饰器接口，为其他 $InputStream$ 提供功能</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$ByteArrayOutputStream$</td>
<td align="center">使用内存缓冲区存储数据</td>
</tr>
<tr>
<td align="center">$FileOutputStream$</td>
<td align="center">写入文件信息</td>
</tr>
<tr>
<td align="center">$PipedOutputStream$</td>
<td align="center">写入其中的信息都会成为相关 $PipedInputStream$ 的输出，实现管道</td>
</tr>
<tr>
<td align="center">$FilterOutputStream$</td>
<td align="center">抽象类，作为装饰器接口，为其他 $OutputStream$ 提供功能</td>
</tr>
</tbody>
</table>
<h3 id="22-filterinputstreamfilteroutputstream">2.2 <code>FilterInputStream</code>/<code>FilterOutputStream</code></h3>
<p>        <code>Java</code>的<code>I/O</code>类内存在 $Filter$ 类作为所有装饰器类的基类。通过装饰器模式，我们可以根据需求定制<code>I/O</code>类。当然，这也带来了麻烦，因为我们需要创建许多类才能得到所需的对象。</p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$DataInputStream$</td>
<td align="center">搭配 $DataOutputStream$ 使用，按照可移植方式从流读取基本数据类型</td>
</tr>
<tr>
<td align="center">$BufferedInputStream$</td>
<td align="center">使用缓冲区暂时存储信息，防止每次都进行实际读操作</td>
</tr>
<tr>
<td align="center">$LineNumberInputStream$</td>
<td align="center">跟踪输入流中的行号</td>
</tr>
<tr>
<td align="center">$PushbackInputStream$</td>
<td align="center">可以回退读到的最后一个字符</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$DataOutputStream$</td>
<td align="center">搭配 $DataInputStream$ 使用，按照可移植方式向流中写入基本数据类型</td>
</tr>
<tr>
<td align="center">$PrintStream$</td>
<td align="center">产生格式化输出</td>
</tr>
<tr>
<td align="center">$BufferedOutputStream$</td>
<td align="center">使用缓冲区暂时存储信息，防止每次都进行实际写操作</td>
</tr>
</tbody>
</table>
<h3 id="23-readerwriter">2.3 <code>Reader</code>/<code>Writer</code></h3>
<p>        $Reader$ 和 $Writer$ 提供了兼容<code>Unicode</code>与面向字符的<code>I/O</code>功能。如果要把字节类和字符类结合起来，需要使用适配器，$InputStreamReader$ 可以将 $InputStream$ 转为 $Reader$ ，$OutputStreamWriter$ 可以将 $OutputStream$ 转为 $Writer$ 。几乎所有原始的<code>I/O</code>流类都有相应的 $Reader$ 和 $Writer$ ，在大部分场合，我们通常会倾向于用他们。当然，有时候，比如 $java.util.zip$ 类库，是面向字节的，因此需要使用 $InputStream$ 和 $OutputStream$ 。</p>
<table>
<thead>
<tr>
<th align="center">来源</th>
<th align="center">对应的类</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$InputStream$</td>
<td align="center">$Reader$</td>
</tr>
<tr>
<td align="center">$OutputStream$</td>
<td align="center">$Writer$</td>
</tr>
<tr>
<td align="center">$FileInputStream$</td>
<td align="center">$FileReader$</td>
</tr>
<tr>
<td align="center">$FileOutputStream$</td>
<td align="center">$FileWriter$</td>
</tr>
<tr>
<td align="center">$StringBufferInputStream$</td>
<td align="center">$StringReader$</td>
</tr>
<tr>
<td align="center">$N/A$</td>
<td align="center">$StringWriter$</td>
</tr>
<tr>
<td align="center">$ByteArrayInputStream$</td>
<td align="center">$CharArrayReader$</td>
</tr>
<tr>
<td align="center">$ByteArrayOutputStream$</td>
<td align="center">$CharArrayWriter$</td>
</tr>
<tr>
<td align="center">$PipedInputStream$</td>
<td align="center">$PipedReader$</td>
</tr>
<tr>
<td align="center">$PipedOutputStream$</td>
<td align="center">$PipedWriter$</td>
</tr>
</tbody>
</table>
<p>        对应 $FilterInputStream$ 和 $FilterOutputStream$ ，$Reader$ 和 $Writer$ 也有对应的结构。</p>
<table>
<thead>
<tr>
<th align="center">来源</th>
<th align="center">对应的类</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$FilterInputStream$</td>
<td align="center">$FilterReader$</td>
</tr>
<tr>
<td align="center">$FilterOutputStream$</td>
<td align="center">$FilterWriter$</td>
</tr>
<tr>
<td align="center">$BufferedInputStream$</td>
<td align="center">$BufferedReader$</td>
</tr>
<tr>
<td align="center">$BufferedOutputStream$</td>
<td align="center">$BufferedWriter$</td>
</tr>
<tr>
<td align="center">$DataInputStream$</td>
<td align="center">$DataInputStream$</td>
</tr>
<tr>
<td align="center">$PrintStream$</td>
<td align="center">$PrintWriter$</td>
</tr>
<tr>
<td align="center">$LineNumberInputStream$</td>
<td align="center">$LineNumberReader$</td>
</tr>
<tr>
<td align="center">$StreamTokenizer$</td>
<td align="center">$StreamTokenizer$</td>
</tr>
<tr>
<td align="center">$PushbackInputStream$</td>
<td align="center">$PushbackReader$</td>
</tr>
</tbody>
</table>
<p>        可以发现 $DataInputStream$ 是相同的，但要注意的是，使用 $DataInputStream.readLine(\ )$ 方法会触发编译器的警告，应该改为使用 $BufferedReader.readLine(\ )$ 。尽管 $BufferedOutputStream$ 是 $FilterOutputStream$ 的子类，但是 $BufferedWriter$ 并不是 $FilterWriter$ 的子类，$FilterWriter$ 是一个抽象类。</p>
<h3 id="24-radomaccessfile">2.4 <code>RadomAccessFile</code></h3>
<p>        $RadomAccessFile$ 适用于由大小已知的记录组成的文件，可以通过 $seek(\ )$ 方法移动指针，实现读取或修改特定位置的记录，它并非 $InputStream$ 或 $OutputStream$ 继承层次的一部分，甚至不使用其中已有的功能，和 $DataInputStream$ 与 $DataOutputStream$ 一样实现了 $DataInput$ 和 $DataOutput$ 接口。$RadomAccessFile$ 支持读写功能，可以通过 $getFilePointer(\ )$ 方法获取文件指针位置，$length(\ )$ 获取文件长度。在<code>JDK 1.4</code>之后，$RadomAccessFile$ 的大部分功能被 $nio$ 存储映射文件替代。</p>
<h2 id="3-io流的使用">3. <code>I/O</code>流的使用</h2>
<h3 id="31-文件输入">3.1 文件输入</h3>
<p>        $FileInputReader$ 用于文件字符输入，如果要提高速度，可以使用 $BufferedReader$ 作为参数构造，而且 $BufferedReader$ 也提供了 $readLine(\ )$ 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferedInputFile</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">read</span><span class="o">(</span><span class="n">String</span> <span class="n">filename</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">BufferedReader</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">FileReader</span><span class="o">(</span><span class="n">filename</span><span class="o">));</span>
        <span class="n">String</span> <span class="n">s</span><span class="o">;</span>
        <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">&#34;\n&#34;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">in</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="32-格式化内存输入">3.2 格式化内存输入</h3>
<p>        $DataInputStream$ 是一个面向字节的<code>I/O</code>类，可以读取格式化数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FormattedMemoryInput</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">DataInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataInputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">ByteArrayInputStream</span><span class="o">(</span><span class="s">&#34;read test&#34;</span><span class="o">.</span><span class="na">getBytes</span><span class="o">()));</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">available</span><span class="o">()</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">in</span><span class="o">.</span><span class="na">readByte</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        $ByteArrayInputStream$ 接受一个字节数组，传递给 $DataInputStream$ 。</p>
<h3 id="33-文件输出">3.3 文件输出</h3>
<p>        $FileWriter$ 可以向文件写入数据，可以通过 $BufferedWriter$ 进行缓冲输出。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BasicFileOutput</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">BufferedReader</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">StringReader</span><span class="o">(</span><span class="s">&#34;write test&#34;</span><span class="o">));</span>
        <span class="n">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PrintWriter</span><span class="o">(</span><span class="k">new</span> <span class="n">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="n">FileWriter</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">0</span><span class="o">])));</span>
        <span class="n">String</span> <span class="n">s</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">&#34;\n&#34;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        $PrintWriter$ 中存在一个辅助构造器，可以在创建文本文件并向其写入时自动进行缓冲，从而避免了装饰操作，只需以如下方式调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PrintWriter</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">0</span><span class="o">]);</span>
</code></pre></div><p>        这样的写法等价于上面的写法。</p>
<h3 id="34-数据存储和恢复">3.4 数据存储和恢复</h3>
<p>        我们可以通过 $DataInputStream$ 写入数据，并通过 $DataOutputStream$ 恢复数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StoringAndRecoveringData</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">DataOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">BufferedOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="s">&#34;Data.txt&#34;</span><span class="o">)));</span>
        <span class="n">out</span><span class="o">.</span><span class="na">writerUTF</span><span class="o">(</span><span class="s">&#34;Write Test&#34;</span><span class="o">);</span>
        <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">DataInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataInputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&#34;Data.txt&#34;</span><span class="o">)));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">readUTF</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="35-随机访问">3.5 随机访问</h3>
<p>        $RandomAccessFile$ 类类似于组合了 $DataInputStream$ 和 $DataOutputStream$ ，因为他们使用了相同的接口。在使用 $RandomAccessFile$ 之前必须先知道文件排版才能进行正确操作。$RandomAccessFile$ 构造函数的第二个参数接受一个字符串，$r$ 、 $w$ 、 $rw$ 分别对应只读、只写和读写。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UsingRandomAccessFile</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">(</span><span class="n">String</span> <span class="n">filename</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">RandomAccessFile</span> <span class="n">rf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RandomAccessFile</span><span class="o">(</span><span class="n">filename</span><span class="o">,</span> <span class="s">&#34;r&#34;</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">7</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Value &#34;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&#34;: &#34;</span> <span class="o">+</span> <span class="n">rf</span><span class="o">.</span><span class="na">readDouble</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">rf</span><span class="o">.</span><span class="na">readUTF</span><span class="o">());</span>
        <span class="n">rf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">RandomAccessFile</span> <span class="n">rf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RandomAccessFile</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="s">&#34;rw&#34;</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">7</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">rf</span><span class="o">.</span><span class="na">writeDouble</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">1</span><span class="o">.</span><span class="na">414</span><span class="o">);</span>
        <span class="n">rf</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="s">&#34;End of the file&#34;</span><span class="o">);</span>
        <span class="n">rf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">display</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">0</span><span class="o">]);</span>
        <span class="n">rf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RandomAccessFile</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">0</span><span class="o">],</span> <span class="s">&#34;rw&#34;</span><span class="o">);</span>
        <span class="n">rf</span><span class="o">.</span><span class="na">seek</span><span class="o">(</span><span class="n">5</span> <span class="o">*</span> <span class="n">8</span><span class="o">);</span>
        <span class="n">rf</span><span class="o">.</span><span class="na">writeDouble</span><span class="o">(</span><span class="n">47</span><span class="o">.</span><span class="na">001</span><span class="o">);</span>
        <span class="n">rf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">display</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="4-标准io">4. 标准<code>I/O</code></h2>
<p>        通过标准<code>I/O</code>，我们可以很容易的把程序串联起来。标准输入可以是程序输入的来源，标准输出也可以接受程序的输出，同样的，程序的所有错误信息也可以发送到标准错误。参照标准<code>I/O</code>模型，<code>Java</code>提供了 $System.in$ , $System.out$ 和 $System.err$ 。其中 $System.out$ 和 $System.err$ 被包装为 $PrintStream$ ；$System.in$ 则只是简单的 $InputStream$ ，因此在使用前要进行包装。</p>
<h3 id="41-读取">4.1 读取</h3>
<p>        通常我们会用 $readLine(\ )$ 读取一行的输入，因此可以使用 $BufferedReader$ 进行包装。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Echo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">BufferedReader</span> <span class="n">stdin</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="n">String</span> <span class="n">s</span><span class="o">;</span>
        <span class="k">while</span><span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">stdin</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="42-使用printwriter">4.2 使用<code>PrintWriter</code></h3>
<p>        默认情况下 $System.out$ 和 $System.err$ 被包装为 $PrintStream$ ，但是 $PrintWriter$ 有一个接受 $OutputStream$ 的构造器，通过该构造器可以将 $System.in$ 和 $System.err$ 包装为 $PrintWriter$ 。要注意接受两个参数的构造器，并将第二个参数设置为 $true$ 表示在每次调用 $println(\ )$ 方法后自动清空，否则可能会看不到输出。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChangeSystemOut</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PrintWriter</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="43-重定向">4.3 重定向</h3>
<p>        <code>Java</code>的 $System$ 类提供了一些静态方法，允许我们对标准<code>I/O</code>进行重定向。重定向在产生大量输出的程序中十分有用，可以通过 $System.setIn$ , $System.setOut$ 和 $System.setErr$ 方法进行重定向。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Redirecting</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">PrintStream</span> <span class="n">console</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">;</span>
        <span class="n">BufferedInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">0</span><span class="o">]));</span>
        <span class="n">PrintStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PrintStream</span><span class="o">(</span><span class="k">new</span> <span class="n">BufferedOutputStream</span><span class="o">(</span><span class="s">&#34;test.out&#34;</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">setIn</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">setOut</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">setErr</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>
        <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">setOut</span><span class="o">(</span><span class="n">console</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">setErr</span><span class="o">(</span><span class="n">console</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="5-新io">5. 新<code>I/O</code></h2>
<p>        <code>JDK 1.4</code>之后引入的 $java.nio.*$ 包引入了新的<code>I/O</code>库，目的是为了提高速度。当然，旧的<code>I/O</code>包已经使用其重新实现过。速度的提高来源于使用了更接近于系统<code>I/O</code>的方式：通道和缓冲器。数据存储在通道上，缓冲器从通道中获取信息，我们再从缓冲器中获取信息，而写过程就是反过来。唯一一个直接与通道交互的缓冲器是 $ByteBuffer$ 。旧<code>I/O</code>中的 $FileInputStream$ 、$FileOutputStream$ 和 $RandomAccessFile$ 。$Reader$ 和 $Writer$ 不能用于产生通道，但是通过 $java.nio.channels.Channels$ 类，可以在通道中产生 $Reader$ 和 $Writer$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GetChannel</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">FileChannel</span> <span class="n">fc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="s">&#34;test.txt&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">ByteBuffer</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span><span class="s">&#34;Write test 1&#34;</span><span class="o">.</span><span class="na">getBytes</span><span class="o">()));</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RandomAccessFile</span><span class="o">(</span><span class="s">&#34;test.txt&#34;</span><span class="o">,</span> <span class="s">&#34;rw&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">position</span><span class="o">(</span><span class="n">fc</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">ByteBuffer</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span><span class="s">&#34;Write test 2&#34;</span><span class="o">.</span><span class="na">getBytes</span><span class="o">()));</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&#34;test.txt&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
        <span class="n">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="n">1024</span><span class="o">);</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">hasRemaining</span><span class="o">())</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">buffer</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        $getChannel(\ )$ 产生一个 $FileChannel$ 对象，可以向其传送 $ByteBuffer$ 对象用于读写。在调用了 $read(\ )$ 向 $ByteBuffer$ 存储字节时，需要再调用 $flip(\ )$ 方法使得 $ByteBuffer$ 进入可以被读取的状态。如果需要进一步调用 $read(\ )$ 进行写入时，需要先调用 $clear(\ )$ 方法使 $ByteBuffer$ 进入可以被写入的状态。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TransferTo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">FileChannel</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">0</span><span class="o">]).</span><span class="na">getChannel</span><span class="o">(),</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">1</span><span class="o">]).</span><span class="na">getChannel</span><span class="o">();</span>
        <span class="n">in</span><span class="o">.</span><span class="na">transferTo</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">in</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="n">out</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        $transferTo(\ )$ 和 $transferFrom(\ )$ 允许我们直接连接两个通道，从而在通道间进行数据传输。</p>
<h3 id="51-数据转换">5.1 数据转换</h3>
<p>        从 $ByteBuffer$ 中读取字节时读取到的是 $byte$ 类型的数据。如果要读取字符型，可以通过类型转换。$ByteBuffer.asCharBuffer(\ )$ 返回一个 $CharBuffer$ 对象，可以利用该方法进行更方便的数据转换。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferToText</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">FileChannel</span> <span class="n">fc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="s">&#34;test.txt&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">ByteBuffer</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span><span class="s">&#34;Write test&#34;</span><span class="o">.</span><span class="na">getBytes</span><span class="o">()));</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&#34;test.txt&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
        <span class="n">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="n">1024</span><span class="o">);</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">asCharBuffer</span><span class="o">());</span> <span class="c1">// ????
</span><span class="c1"></span>        <span class="n">buffer</span><span class="o">.</span><span class="na">rewind</span><span class="o">();</span>
        <span class="n">String</span> <span class="n">encoding</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">&#34;file.encoding&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
            <span class="s">&#34;Decoded using &#34;</span> <span class="o">+</span> <span class="n">encoding</span> <span class="o">+</span> <span class="s">&#34;: &#34;</span> <span class="o">+</span> <span class="n">Charset</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">encoding</span><span class="o">).</span><span class="na">decode</span><span class="o">(</span><span class="n">buffer</span><span class="o">));</span> <span class="c1">// Decoded using UTF-8: Write test
</span><span class="c1"></span>        <span class="n">fc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="s">&#34;test.txt&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">ByteBuffer</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span><span class="s">&#34;write test&#34;</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="n">StandardCharsets</span><span class="o">.</span><span class="na">UTF_16BE</span><span class="o">)));</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&#34;test.txt&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">asCharBuffer</span><span class="o">());</span> <span class="c1">// Write test
</span><span class="c1"></span>        <span class="n">fc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="s">&#34;test.txt&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="n">24</span><span class="o">);</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">asCharBuffer</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;write test&#34;</span><span class="o">);</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&#34;test.txt&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        <span class="n">fc</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">asCharBuffer</span><span class="o">());</span>  <span class="c1">// Write test
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        可以发现，如果要使用 $asCharBuffer(\ )$ 方法，必须要使用<code>UTF-8</code>编码后写入或者在读出时使用<code>UTF-8</code>编码格式读出。$java.nip.charset.Charset$ 类提供了数据编码的功能。</p>
<h3 id="52-获取基本类型">5.2 获取基本类型</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GetData</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">ByteBuffer</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocate</span><span class="o">(</span><span class="n">1024</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">bb</span><span class="o">.</span><span class="na">limit</span><span class="o">())</span> <span class="k">if</span> <span class="o">(</span><span class="n">bb</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&#34;nonzero&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;i = &#34;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">rewind</span><span class="o">();</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">asCharBuffer</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;Howdy!&#34;</span><span class="o">);</span>
        <span class="kt">char</span> <span class="n">c</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="na">getChar</span><span class="o">())</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="s">&#34; &#34;</span><span class="o">);</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">rewind</span><span class="o">();</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">asShortBuffer</span><span class="o">().</span><span class="na">put</span><span class="o">((</span><span class="kt">short</span><span class="o">)</span> <span class="n">471142</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bb</span><span class="o">.</span><span class="na">getShort</span><span class="o">());</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">rewind</span><span class="o">();</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">asIntBuffer</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="n">99471142</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bb</span><span class="o">.</span><span class="na">getInt</span><span class="o">());</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">rewind</span><span class="o">();</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">asLongBuffer</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="n">99471142</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bb</span><span class="o">.</span><span class="na">getLong</span><span class="o">());</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">rewind</span><span class="o">();</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">asFloatBuffer</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="n">99471142</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bb</span><span class="o">.</span><span class="na">getFloat</span><span class="o">());</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">rewind</span><span class="o">();</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">asDoubleBuffer</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="n">99471142</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bb</span><span class="o">.</span><span class="na">getDouble</span><span class="o">());</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">rewind</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        通过 $asCharBuffer(\ )$ 、 $asShortBuffer(\ )$ 、$asIntBuffer(\ )$ 等方法向 $ByteBuffer$ 中写入数据，再使用 $getChar(\ )$ 、$getShort(\ )$ 、$getInt(\ )$ 等方法读出。</p>
<h3 id="53-缓冲器">5.3 缓冲器</h3>
<p>        视图缓冲器可以让我们通过某个特定的基本数据类型的视图查看其底层 $ByteBuffer$ ，对视图的任意修改都会映射到 $ByteBuffer$ 。视图还允许我们从 $ByteBuffer$ 一次一次地或者通过数组成批地获取基本类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Endians</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ByteBuffer</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">wrap</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">12</span><span class="o">]);</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">asCharBuffer</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;abcdef&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">bb</span><span class="o">.</span><span class="na">array</span><span class="o">()));</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">rewind</span><span class="o">();</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">order</span><span class="o">(</span><span class="n">ByteOrder</span><span class="o">.</span><span class="na">BIG_ENDIAN</span><span class="o">);</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">asCharBuffer</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;abcdef&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">bb</span><span class="o">.</span><span class="na">array</span><span class="o">()));</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">rewind</span><span class="o">();</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">order</span><span class="o">(</span><span class="n">ByteOrder</span><span class="o">.</span><span class="na">LITTLE_ENDIAN</span><span class="o">);</span>
        <span class="n">bb</span><span class="o">.</span><span class="na">asCharBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;abcdef&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">bb</span><span class="o">.</span><span class="na">array</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        通过 $CharBuffer$ 视图，我们可以将 $charArray$ 插入 $ByteBuffer$ 中。利用 $ByteBuffer.order(\ )$ 方法，我们可以设置字节排序方式为大端序或者小端序。<br>
        $ByteBuffer$ 是数据进出通道的唯一方式。虽然我们不能将基本类型转换为 $ByteBuffer$ ，但是可以通过视图缓冲器将基本类型从 $ByteBuffer$ 中移入和移出。<br>
        $Buffer$ 由数据和可以高效地访问及操纵这些数据的四个索引：$mark$ , $position$ , $limit$ 和 $capacity$ 组成，分别对应的操作方法有：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$capacity(\ )$</td>
<td align="center">缓冲区容量</td>
</tr>
<tr>
<td align="center">$clear(\ )$</td>
<td align="center">清空缓冲区，$position$ 清零，$limit$ 设为容量</td>
</tr>
<tr>
<td align="center">$flip(\ )$</td>
<td align="center">$limit$ 设为 $position$ ，$position$ 清零</td>
</tr>
<tr>
<td align="center">$limit(\ )$</td>
<td align="center">返回 $limit$ ，或者设置 $limit$</td>
</tr>
<tr>
<td align="center">$mark(\ )$</td>
<td align="center">$mark$ 设为 $position$</td>
</tr>
<tr>
<td align="center">$reset(\ )$</td>
<td align="center">将 $position$ 设为 $mark$</td>
</tr>
<tr>
<td align="center">$position(\ )$</td>
<td align="center">返回 $position$</td>
</tr>
<tr>
<td align="center">$remaining(\ )$</td>
<td align="center">返回 $limit - position$</td>
</tr>
<tr>
<td align="center">$hasRemaining(\ )$</td>
<td align="center">若有介于 $limit$ 和 $position$ 之间的元素，返回 $true$</td>
</tr>
</tbody>
</table>
<p>        缓冲器会先将数据存储在内存中，如果遇到那些因为过大而不能存储在内存中的文件，可以使用内存映射文件。通过内存映射文件，我们可以假定整个文件都处于内存中，可以使用类似于数组的方式进行访问。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LargeMappedFiles</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">0x8FFFFFF</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">MappedByteBuffer</span> <span class="n">out</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">RandomAccessFile</span><span class="o">(</span><span class="s">&#34;test.txt&#34;</span><span class="o">,</span> <span class="s">&#34;rw&#34;</span><span class="o">)</span>
                <span class="o">.</span><span class="na">getChannel</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">FileChannel</span><span class="o">.</span><span class="na">MapMode</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">out</span><span class="o">.</span><span class="na">put</span><span class="o">((</span><span class="kt">byte</span><span class="o">)</span> <span class="sc">&#39;x&#39;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Finished!&#34;</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">/</span> <span class="n">2</span> <span class="o">+</span> <span class="n">6</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">out</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        通过 $FileChannel.map(\ )$ 方法，我们可以获取一个 $MappedByByteBuffer$ 对象。这种特殊的缓冲器会将某个大文件的较小部分映射到内存中，也因此我们在创建的时候要指定初始位置和映射区长度。$MappedByByteBuffer$ 是 $ByteBuffer$ 的子类，因此可以使用它的所有方法。</p>
<h3 id="54-文件锁">5.4 文件锁</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FileLocking</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="s">&#34;test.txt&#34;</span><span class="o">);</span>
        <span class="n">FileLock</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">fos</span><span class="o">.</span><span class="na">getChannel</span><span class="o">().</span><span class="na">tryLock</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Locked File&#34;</span><span class="o">);</span>
            <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">100</span><span class="o">);</span>
            <span class="n">fl</span><span class="o">.</span><span class="na">release</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Released Lock&#34;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        通过 $FileChannel.tryLock(\ )$ 、$FileChannel.lock(\ )$ 和 $FileChannel.release(\ )$ 方法可以实现对文件的上锁和解锁。 $tryLock(\ )$ 是非阻塞的，这意味着如果没有获得锁的话会直接返回。相反的，$lock(\ )$ 是阻塞式的，会一直等待到获得锁。$tryLock(\ )$ 和 $lock(\ )$ 都可以接受参数，实现对文件的部分上锁，将第三个参数设置为 $true$ 还可以设置共享锁。共享锁的实现需要依赖于操作系统，通过 $FileLock.isShared(\ )$ 可以判断一个锁是共享锁还是独占锁。</p>
<h2 id="6-压缩">6. 压缩</h2>
<p>        <code>I/O</code>类库支持读写压缩格式的数据流，这些类是由 $InputStream$ 和 $OutputStream$ 派生而来的。</p>
<table>
<thead>
<tr>
<th align="center">压缩类</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$CheckedInputStream$</td>
<td align="center">$GetCheckSum(\ )$ 为任何 $InputStream$ 产生校验和</td>
</tr>
<tr>
<td align="center">$CheckedOutputStream$</td>
<td align="center">$GetCheckSum(\ )$ 为任何 $OutputStream$ 产生校验和</td>
</tr>
<tr>
<td align="center">$DeflaterOutputStream$</td>
<td align="center">压缩类基类</td>
</tr>
<tr>
<td align="center">$ZipOutputStream$</td>
<td align="center">将数据压缩为<code>Zip</code>文件格式</td>
</tr>
<tr>
<td align="center">$GZIPOutputStream$</td>
<td align="center">将数据压缩为<code>GZIP</code>文件格式</td>
</tr>
<tr>
<td align="center">$InflaterInputStream$</td>
<td align="center">解压缩类基类</td>
</tr>
<tr>
<td align="center">$ZipInputStream$</td>
<td align="center">解压缩<code>Zip</code>文件格式</td>
</tr>
<tr>
<td align="center">$GZIPInputStream$</td>
<td align="center">解压缩<code>GZIP</code>文件格式</td>
</tr>
</tbody>
</table>
<p>        <code>Zip</code>格式的<code>Java</code>类库更加全面，可以用于保存多个文件。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ZipCompress</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="s">&#34;test.zip&#34;</span><span class="o">);</span>
        <span class="n">CheckedOutputStream</span> <span class="n">csum</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CheckedOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="k">new</span> <span class="n">Adler32</span><span class="o">());</span>
        <span class="n">ZipOutputStream</span> <span class="n">zos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ZipOutputStream</span><span class="o">(</span><span class="n">csum</span><span class="o">);</span>
        <span class="n">BufferedOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedOutputStream</span><span class="o">(</span><span class="n">zos</span><span class="o">);</span>
        <span class="n">zos</span><span class="o">.</span><span class="na">setComment</span><span class="o">(</span><span class="s">&#34;A test of Java Zipping&#34;</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">arg</span> <span class="o">:</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Wrting file &#34;</span> <span class="o">+</span> <span class="n">arg</span><span class="o">);</span>
            <span class="n">BufferedReader</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">FileReader</span><span class="o">(</span><span class="n">arg</span><span class="o">));</span>
            <span class="n">zos</span><span class="o">.</span><span class="na">putNextEntry</span><span class="o">(</span><span class="k">new</span> <span class="n">ZipEntry</span><span class="o">(</span><span class="n">arg</span><span class="o">));</span>
            <span class="kt">int</span> <span class="n">c</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="n">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="n">in</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="n">out</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Checksum: &#34;</span> <span class="o">+</span> <span class="n">csum</span><span class="o">.</span><span class="na">getChecksum</span><span class="o">().</span><span class="na">getValue</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Reading file&#34;</span><span class="o">);</span>
        <span class="n">FileInputStream</span> <span class="n">fi</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&#34;test.zip&#34;</span><span class="o">);</span>
        <span class="n">CheckedInputStream</span> <span class="n">csumi</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CheckedInputStream</span><span class="o">(</span><span class="n">fi</span><span class="o">,</span> <span class="k">new</span> <span class="n">Adler32</span><span class="o">());</span>
        <span class="n">ZipInputStream</span> <span class="n">in2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ZipInputStream</span><span class="o">(</span><span class="n">csumi</span><span class="o">);</span>
        <span class="n">BufferedInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedInputStream</span><span class="o">(</span><span class="n">in2</span><span class="o">);</span>
        <span class="n">ZipEntry</span> <span class="n">ze</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">ze</span> <span class="o">=</span> <span class="n">in2</span><span class="o">.</span><span class="na">getNextEntry</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Reading file &#34;</span> <span class="o">+</span> <span class="n">ze</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">x</span> <span class="o">=</span> <span class="n">bis</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="s">&#34; &#34;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Checksum: &#34;</span> <span class="o">+</span> <span class="n">csumi</span><span class="o">.</span><span class="na">getChecksum</span><span class="o">().</span><span class="na">getValue</span><span class="o">());</span>
        <span class="n">bis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">ZipFile</span> <span class="n">zf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ZipFile</span><span class="o">(</span><span class="s">&#34;test.zip&#34;</span><span class="o">);</span>
        <span class="n">Enumeration</span> <span class="n">e</span> <span class="o">=</span> <span class="n">zf</span><span class="o">.</span><span class="na">entries</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">ZipEntry</span> <span class="n">ze2</span> <span class="o">=</span> <span class="o">(</span><span class="n">ZipEntry</span><span class="o">)</span> <span class="n">e</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;File: &#34;</span> <span class="o">+</span> <span class="n">ze2</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        $CheckSum$ 类提供了用于计算和校验文件的检验和方法，可以选择更快的 $Adler32$ 或者更准确的 $CRC32$ 类型。对于每一个要加入压缩档案的文件，都要调用 $putNextEntry(\ )$ 方法，传递一个 $ZipEntry$ 对象。通过 $ZipEntry$ 对象可以获得压缩文件的信息，比如名字、压缩后的大小、解压后的大小、日期、校验和等。虽然 $CheckSum$ 支持 $Adler32$ 和 $CRC32$ ，但是 $ZipEntry$ 类只支持 $CRC32$ 。如果要解压缩文件，$getNextEntry(\ )$ 方法可以获得 $ZipEntry$ ；也可以通过 $ZipFile$ 对象，该对象包含的 $entries(\ )$ 方法可以返回一个包含 $ZipEntry$ 的枚举。读取校验和要求拥有至少一个与之关联的 $CheckSum$ 对象，当然 $CheckedInputStream$ 和 $CheckedOutputStream$ 对象也是可以的。<br>
        <code>Zip</code>格式也可以应用于<code>Jar</code>文件中。<code>Jar</code>文件由一组压缩文件组成，还包括一张描述了这些压缩文件的清单。可以通过命令行的方式调用<code>Jar</code>文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">jar <span class="o">[</span>options<span class="o">]</span> destination <span class="o">[</span>manifest<span class="o">]</span> inputfile<span class="o">(</span>s<span class="o">)</span>
</code></pre></div><table>
<thead>
<tr>
<th align="center">$options$</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$c$</td>
<td align="center">创建新的或者空的压缩文档</td>
</tr>
<tr>
<td align="center">$t$</td>
<td align="center">列出目录表</td>
</tr>
<tr>
<td align="center">$x$</td>
<td align="center">解压所有文件</td>
</tr>
<tr>
<td align="center">$x\ \ file$</td>
<td align="center">解压该文件</td>
</tr>
<tr>
<td align="center">$f$</td>
<td align="center">指定一个文件名，从该文件中读取输入和输出（未指定则为标准<code>I/O</code>）</td>
</tr>
<tr>
<td align="center">$m$</td>
<td align="center">将文件清单名字设为第一个参数</td>
</tr>
<tr>
<td align="center">$v$</td>
<td align="center">产生详细输出</td>
</tr>
<tr>
<td align="center">$O$</td>
<td align="center">储存文件但不压缩</td>
</tr>
<tr>
<td align="center">$M$</td>
<td align="center">不自动创建文件清单</td>
</tr>
</tbody>
</table>
<p>        <code>Jar</code>工具的功能没有<code>Zip</code>那样强大，比如不能对已有的<code>Jar</code>文件进行修改，只能重新创建。但是<code>Jar</code>文件具有跨平台的便利性，只需要在一个平台上创建，就能被其他所有平台访问。</p>
<h2 id="7-对象序列化">7. 对象序列化</h2>
<p>        对象序列化会将实现了 $Serializable$ 接口的对象转换为字节序列，并且能够在之后由这个序列重新恢复为对象，而且通过序列化还可以跨平台传输对象。利用序列化可以实现轻量级持久性，即对象的声明周期并不取决于程序，因为对象可以通过序列化存储在磁盘中，然后在重新调用程序时恢复。对象序列化可以追踪对象内包含的引用，并保存那些对象。将一个序列恢复为对象时，需要注意的是必须存在对应的 $Class$ 对象，否则就会产生 $ClassNotFoundException$ 异常。要想序列化一个对象，首先要创建一些 $OutputStream$ ，并将它们封装在 $ObjectOutputStream$ 中，通过 $writeObject(\ )$ 方法将其序列化。而将一个序列还原为一个对象，则需要使用 $ObjectInputStream$ 封装 $InputStream$ 并调用 $readObject(\ )$ 方法，最终会得到一个 $Object$ 对象，需要进行向上转型。在一些特殊情况下，我们希望实现对序列化的控制，可以通过实现 $Externalizable$ 接口，$Externalizable$ 接口继承了 $Serializable$ 接口，提供了 $writeExternal(\ )$ 和 $readExternal(\ )$ 方法，会在序列化的过程中被自动调用。<br>
        通过 $transient$ 关键字，可以将某个特定的子对象不进行序列化，这对于一些敏感信息比如密码等十分有用。由于 $Externalizable$ 默认不保存字段，因此 $transient$ 只能与 $Serializable$ 一起使用。<br>
        如果不想使用 $Externalizable$ 接口，那么可以实现 $Serializable$ 接口并添加以下方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">writeObject</span><span class="o">(</span><span class="n">ObjectOutputStream</span> <span class="n">stream</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="n">ObjecetInputStream</span> <span class="n">stream</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ClassNotFoundException</span><span class="o">;</span>
</code></pre></div><p>        当对象被序列化和反序列化的时候就会自动调用这两个方法。在方法内部，还可以调用 $ObjectOutputStream.defaultWriteObject(\ )$ 和 $ObjectInputStream.defaultReadObject(\ )$ 方法执行默认序列化和反序列方法。<br>
        $Class$ 对象是序列化的，因此也可以使用序列化。如果想要序列化 $static$ 字段，那么需要声明并实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">serializeStaticState</span><span class="o">(</span><span class="n">ObjectOutputStream</span> <span class="n">stream</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">;</span>
<span class="n">deserializaStaticState</span><span class="o">(</span><span class="n">ObjectInputStream</span> <span class="n">stream</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">;</span>
</code></pre></div><p>        这两个方法会在序列化和反序列化过程中被调用，从而序列化 $static$ 字段。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Sep 6 21:28</span> <a href="/post/java-i-o/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/java%E6%B3%9B%E5%9E%8B/">Java泛型</a></h1>
            </center>
            <div class="post-content">
                <p>        泛型允许一个类应用于多种类型，实现了参数化类型的概念。促使泛型产生的原因之一就是容器类，泛型可以用于指定一个容器具体要持有怎样的类型。当然，也可以通过泛型实现持有多个类型的类，如元组类：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TwoTuple</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">A</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">B</span> <span class="n">second</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">TwoTuple</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">,</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">second</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        如果需要长度更长的元组如三元组，我们可以在二元组的基础上声明三元组类，并令其继承二元组类。<br>
        除了具体类外，泛型还可以应用于抽象类和接口当中。<br>
        <code>Java</code>泛型存在着很多局限性，第一个就是不能以基本类型作为其类型参数。当然，通过<code>Java</code>自动包装和自动拆包的功能，基本类型和其包装类型可以很方便地进行转换。<br>
        之前提到的泛型都是应用于一个类上的，但是泛型同样可以应用于方法上，而且不仅可以应用于泛型类的方法上，也可以应用于普通类的方法上。如果通过使用泛型方法就可以避免使用泛型类，那么推荐使用泛型方法。此外，由于 $static$ 方法无法获取类型参数，因此如果要让 $static$ 方法使用泛型，那么就必须让其成为泛型方法。与使用泛型类不同，使用泛型方法时可以不用指定具体类型，通过类型参数推断，编译器可以为我们找出具体类型。</p>
<h2 id="1-擦除">1. 擦除</h2>
<p>        通过泛型，我们可以声明一个 $ArrayList&lt;Integer&gt;$ 对象，然后我们可以获取 $ArraysList.class$ ，但是却不能获取 $ArrayList&lt;Integer&gt;.class$ 对象。这个行为说明了在编译器的眼中，$ArrayList&lt;Integer&gt;$ 和 $ArrayList&lt;String&gt;$ 是同一类型。更加夸张的是，不同于<code>C++</code>，在<code>Java</code>的泛型内，你无法获取任何有关于泛型参数类型的信息。这些行为的原因都是因为<code>Java</code>的泛型是使用擦除实现的。在基于擦除的实现中，泛型被认为是第二类类型，既不能在某些重要的上下文环境中使用的类型。泛型类型只有在静态类型检查期间才会出现，之后泛型类型将被擦除，并替换为非泛型边界如 $List$ , $Object$ 等。<br>
        在<code>C++</code>中，我们可以实现以下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Test</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">obj</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Test</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">obj</span><span class="p">.</span><span class="n">f</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        但是在<code>Java</code>中，这种行为就无法实现了。因为擦除的存在，<code>Java</code>编译器无法认为 $obj$ 含有 $f(\ )$ 方法。而为了调用 $f(\ )$ ，在<code>Java</code>中需要这样实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">HasF</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">HasF</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">obj</span><span class="o">;</span>
    <span class="n">Test</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">obj</span><span class="o">.</span><span class="na">f</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        通过给定泛型类的边界，泛型类只能接受符合这个边界的类型参数，从而就能确保含有 $f(\ )$ 方法了。<br>
        虽然通过擦除，<code>Java</code>保证了向后兼容。但是带来的代价也是显著的，所有关于类型参数的信息都丢失了。也因为这个原因，泛型并不是强制使用的：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Derived1</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Derived2</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">{}</span>
</code></pre></div><p>        但是擦除机制带来的最令人困惑的并不是这个，而是“看起来好像持有”：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayMaker</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">kind</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ArrayMaker</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">kind</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">kind</span> <span class="o">=</span> <span class="n">kind</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="n">T</span><span class="o">[]</span> <span class="nf">create</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">T</span><span class="o">[])</span> <span class="n">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">kind</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        即使使用了 $Class&lt;T&gt;$ 储存 $kind$ ，因为擦除的存在，它会被存储为 $Class$ 对象，从而使得创建数组时不会产生具体结果，只能配合转型使用。</p>
<h2 id="2-擦除的补偿">2. 擦除的补偿</h2>
<p>        因为擦除的原因，类内部无法得到类型参数信息，因此 $instanceof$ 不能使用。但是可以使用动态 $isInstance(\ )$ ：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Building</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">House</span> <span class="kd">extends</span> <span class="n">Building</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">ClassType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">kind</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ClassType</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">kind</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">kind</span> <span class="o">=</span> <span class="n">kind</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">f</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">kind</span><span class="o">.</span><span class="na">isInstance</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ClassType</span><span class="o">&lt;</span><span class="n">Building</span><span class="o">&gt;</span> <span class="n">classType</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassType</span><span class="o">&lt;&gt;(</span><span class="n">Building</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">classType</span><span class="o">.</span><span class="na">f</span><span class="o">(</span><span class="k">new</span> <span class="n">Building</span><span class="o">()));</span> <span class="c1">// true
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">classType</span><span class="o">.</span><span class="na">f</span><span class="o">(</span><span class="k">new</span> <span class="n">House</span><span class="o">()));</span> <span class="c1">// true
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        在泛型类中，通过类似 $new\ \ T(\ )$ 的方式创建类是不行的，因为<code>Java</code>编译器无法确认类型拥有默认构造器。而在<code>C++</code>中由于编译器的定期检查，这种行为的安全性得以确保。如果想要在<code>Java</code>中以类似方式创建对象，可以通过工厂模式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">ClassAsFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">T</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">ClassAsFactory</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">kind</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">NoSuchMethodException</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">kind</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">().</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalAccessException</span> <span class="o">|</span> <span class="n">InstantiationException</span> <span class="o">|</span> <span class="n">InvocationTargetException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        虽然编译可以通过，但是不一定每次都能成功创建，比如 $ClassAsFactory&lt;Integer&gt;$ 就会失败，因为 $Integer$ 类没有默认构造器。为了避免这个问题，可以使用显示工厂：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">Factory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">create</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">IntegerFactory</span> <span class="kd">implements</span> <span class="n">Factory</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">F</span> <span class="kd">extends</span> <span class="n">Factory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">Foo</span><span class="o">(</span><span class="n">F</span> <span class="n">factory</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        除了工厂方法之外，还可以使用模板方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">GenericWithCreate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">T</span> <span class="n">element</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">GenericWithCreate</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">create</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">T</span> <span class="nf">create</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">X</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Creator</span> <span class="kd">extends</span> <span class="n">GenericWithCreate</span><span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">X</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">X</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        在泛型类内，你无法直接通过 $new$ 创建泛型数组，一般情况下都是使用 $ArrayList$ 进行替代。但是在一些需要建立泛型数组的情况下，通过 $new$ 建立之后再进行转型这种方式是无效的。因为<code>Java</code>数组将跟踪它们被创建时的实际类型，信息在编译期存储，因此无论怎么转型，它都是 $Object$ 数组。因此最好是在集合内部使用 $Object[\ ]$ ，然后在取出元素时再将其转型为 $T$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">GenericArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">T</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">T</span><span class="o">)</span> <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        如果要获得整个数组对象，那么就不能使用 $new$ ，而要改为使用 $Class$ 对象：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericArrayWithTypeToken</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>

    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nf">GenericArrayWithTypeToken</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">array</span> <span class="o">=</span> <span class="o">(</span><span class="n">T</span><span class="o">[])</span> <span class="n">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">T</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span><span class="o">[]</span> <span class="nf">rep</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        可以发现，这两种情况都会产生大量警告。当然，警告是可以忽略的。</p>
<h2 id="3-边界">3. 边界</h2>
<p>        边界提供了一种限制泛型参数类型的机制，潜在的效果是允许泛型调用一些方法。如果能够将参数限制为某个类型的子集，那么就可以运用子集来调用方法。同时，如果你需要的话，还可以在继承的每个层次上添加不同的限制：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">B</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">C</span><span class="o">&lt;&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">B</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">D</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div><p>        再考虑一种情况，假设 $Apple$ 是 $Fruit$ 的子类，那么：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;();</span>
</code></pre></div><p>        虽然看起来好像是正确的，但却是错误的，因为 $Apple$ 的 $List$ 在类型上并不等价于 $Fruit$ 的 $List$ 。如果你想要让其正确地向上转型，就需要使用通配符：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;();</span>
</code></pre></div><p>        这种方式给定了一个“任何扩展了 $Fruit$ 对象”的边界，$List$ 就可以接受任何可以向上转型为 $Fruit$ 的类型了。除了这种方式外，还可以使用超类通配符，即声明某个特定类的基类：$&lt;?\ \ super\ \ MyClass&gt;$ ，甚至使用类型参数 $&lt;?\ \ super\ \ T&gt;$ 。<br>
        在上面的例子中使用了无界通配符 $?$ 。如果单独使用无界通配符，看起来好像就等价于原生类型。事实也确实是这样，编译器很少关心原生类型和仅使用无界通配符之间的区别。但这也并不意味着仅使用无界通配符没有意义，它可以标识你想在这里使用泛型。此外，无界通配符表示可以接受任何类型的特性还使得它成为存储泛型类的场所，可以将此特性应用于传参中。当然，编译器也会有关注它们间差异的时候：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Holder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">obj</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setObj</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">getObj</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">obj</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wildcards</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">rawArgs</span><span class="o">(</span><span class="n">Holder</span> <span class="n">holder</span><span class="o">,</span> <span class="n">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">holder</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">object</span><span class="o">);</span> <span class="c1">// warning
</span><span class="c1"></span>    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">unboundedArg</span><span class="o">(</span><span class="n">Holder</span><span class="o">&lt;?&gt;</span> <span class="n">holder</span><span class="o">,</span> <span class="n">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">holder</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">object</span><span class="o">);</span> <span class="c1">// error
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        当 $holder$ 是一个 $Holder&lt;?&gt;$ 时，调用 $rawArgs(\ )$ 后，因为编译器仍然知道它是个泛型类型，因此认为传递一个 $Object$ 类型对象是不安全的，所以会产生警告。同样的，在调用 $unboundedArg(\ )$ 时，因为 $Holder&lt;?&gt;$ 要持有一个具体类型的，因此不能只是向其传递 $Object$ 。<br>
        上面演示了需要使用原生类型的情况，也有情况需要使用 $&lt;?&gt;$ ：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CaptureConversion</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">f1</span><span class="o">(</span><span class="n">Holder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">holder</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">f2</span><span class="o">(</span><span class="n">Holder</span> <span class="n">holder</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">f1</span><span class="o">(</span><span class="n">holder</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        在上面的例子中将原生类型传入 $f1(\ )$ 会产生异常，而传入 $f2(\ )$ 不会。因为 $f2(\ )$ 使用 $&lt;?&gt;$ 作为参数，编译器可能会推断出实际类型，这种行为称为捕获转换。</p>
<h2 id="4-自限定类型">4. 自限定类型</h2>
<p>        先看下面这个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">GenericType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CuriouslyRecurringGeneric</span> <span class="kd">extends</span> <span class="n">GenericType</span><span class="o">&lt;</span><span class="n">CuriouslyRecurringGeneric</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div><p>        这种泛型称为<em><strong>古怪的循环泛型</strong></em> ( $CRG$ ) ，本质是将基类的类型参数使用导出类来代替。类似的我们还可以进行下面的声明：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">SelfBounded</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">SelfBounded</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{}</span>
</code></pre></div><p>        这样 $T$ 的类型就被限定为类似于：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">A</span> <span class="kd">extends</span> <span class="n">SelfBounded</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div><p>        通过使用自限定类型，可以保证类型参数与当前正在被定义的类相同。当然，这个规则也可以通过下面方式避免：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">SelfBounded</span> <span class="o">{}</span>
</code></pre></div><p>        上面的代码可以编译，而且不会产生警告。因此自限定并非强制保证类型相同，如果你确实需要强制保证的话，就需要外部工具的辅助。<br>
        自限定类型的价值在于它们可以产生协变参数类型：方法参数类型随子类变化。可以对比下下面的两个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Base</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Derived</span> <span class="kd">extends</span> <span class="n">Base</span> <span class="o">{}</span>

<span class="kd">interface</span> <span class="nc">OrdinaryGetter</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Base</span> <span class="n">base</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">DerivedGetter</span> <span class="kd">extends</span> <span class="n">OrdinaryGetter</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Derived</span> <span class="n">derived</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>        在这个例子中，$DerivedGetter$ 重写了 $set(\ )$ 方法，这是合理的，但是会存在两个 $set(\ )$ 方法。有时候我们想要让方法接受子类作为参数，又不想因为重写而同时存在两个同名方法，那么可以通过自限定实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">SelfBounded</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">SelfBounded</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">T</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Setter</span> <span class="kd">extends</span> <span class="n">SelfBounded</span><span class="o">&lt;</span><span class="n">Setter</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div><h2 id="5-混型">5. 混型</h2>
<p>        混型可以混合多个类，产生一个表示混型中所有类型的类，使得组装多个类变得简单。在<code>C++</code>中可以这样使用混型：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="o">&lt;</span><span class="k">template</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">public</span> <span class="n">T</span> <span class="p">{}</span>
</code></pre></div><p>        但是在<code>Java</code>中因为擦除的原因，并不能使用这种方式。一种常见的解决方案是通过接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">A</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">AImpl</span> <span class="kd">implements</span> <span class="n">A</span> <span class="o">{}</span>
</code></pre></div><p>        第二种方案是通过装饰器模式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Basic</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Decorator</span> <span class="kd">extends</span> <span class="n">Base</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Basic</span> <span class="n">basic</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Decorator</span><span class="o">(</span><span class="n">Basic</span> <span class="n">basic</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">basic</span> <span class="o">=</span> <span class="n">basic</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A</span> <span class="kd">extends</span> <span class="n">Decorator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="n">Basic</span> <span class="n">basic</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">basic</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">Decorator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">B</span><span class="o">(</span><span class="n">Basic</span> <span class="n">basic</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">basic</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="6-潜在类型机制">6. 潜在类型机制</h2>
<p>        潜在类型机制或结构化类型机制，允许我们横跨类继承结构，可以调用不属于公共接口的方法。当然，因为<code>Java</code>擦除机制的存在，类内部无法保证传入的类型包含特定方法，因此无法像<code>C++</code>那样直接使用潜在类型机制。一个简单的模仿方法是通过接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">I</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">f1</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">I</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="nf">f2</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">t</span><span class="o">.</span><span class="na">f1</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        但是通过接口方式显然存在着局限性，为了消除这个局限性，我们需要付出更多工作，使用反射机制来实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">f3</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">CommunicateReflectively</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">f4</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Method</span> <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&#34;f3&#34;</span><span class="o">);</span>
            <span class="n">f</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">NoSuchMethodException</span> <span class="o">|</span> <span class="n">IllegalAccessException</span> <span class="o">|</span> <span class="n">InvocationTargetException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        反射会在运行时进行动态检查。通过反射可以在运行时动态地确定所需要的方法是否需要并且调用，而且通过 $try-catch$ ，可以在缺少必须方法时部分实现目标。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Sep 2 21:23</span> <a href="/post/java%E6%B3%9B%E5%9E%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>