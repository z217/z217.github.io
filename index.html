<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.74.3" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
        
        <a href="http://123.57.12.189"  target="_blank" >
            <i class="fas fa-link fa-sm"></i>
            <span>二站</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/leetcode%E9%A2%98%E8%A7%A36%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/">Leetcode题解（6）：用Rand7实现Rand10</a>
        
        
        <p>LeetCode用Rand7()实现Rand10()题目解法</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 26 20:08
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Algorithm
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/">Redis底层数据结构实现</a>
        
        
        <p>Redis常见的数据结构的底层实现方式</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 25 23:02
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Other
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/reentranlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">ReentranLock源码解读</a>
        
        
        <p>ReentrantLock源码解读</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 20 22:27
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">AQS源码解读</a>
        
        
        <p>AbstractQueuedSynchronizer源码解读</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 19 20:14
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">进程间通信</a>
        
        
        <p>进程间通信的一些概念以及几种方式介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 18 19:44
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Other
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/leetcode%E9%A2%98%E8%A7%A36%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/">Leetcode题解（6）：用Rand7实现Rand10</a></h1>
            </center>
            <div class="post-content">
                <p><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">LeetCode470</a></p>
<p>        在解决这道题之前，我们可以先查看一个反过来的情况——用 $Rand10()$ 实现 $Rand7()$ ，可以直接发现实现方式就是不断用 $Rand10()$ 生成随机数，直到生成的数字处于 $1 \sim 7$ 之间即可。也就是说，如果可以生成的数字范围要大于待生成的数字范围，可以通过不断循环直到获取落在生成范围里面的数字的方式实现。<br/>
        利用上述思想，我们可以很容易的想出这道题的解法——利用 $Rand7()$ 构造一个生成的数字范围大于 $1 \sim 10$ 的随机数生成器即可。要想构造这样的生成器，我们可以再观察下 $Rand10()$ 。如果我们想要用 $Rand10()$ 构造一个生成数字范围在 $1 \sim 99$ 之间的随机数生成器，可以使用如下算法 $(Rand10() - 1) * 10 + Rand10()$ ，也就是生成两次，一个作为十位一个作为个位。可以很容易发现这种算法生成的数字是随机均匀分布的。<br/>
        使用 $Rand10()$ 的例子生成的是 $10$ 进制二位数，利用同样的思想我们也可以生成 $7$ 进制二位数，即 $(Rand7() - 1) * 7 + Rand7()$ ，使用这种方式生成的数字也是随机均匀分布的。将其转为 $10$ 进制后，数字范围落在 $1 \sim 49$ 之间，如果直接抛弃 $11 \sim 49$ 之间的数字，那么可能需要重复调用很多次。因此我们可以只抛弃 $41 \sim 49$ 之间的数字，对剩余的数字采用取模运算，实现方式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="kd">extends</span> <span class="n">SolBase</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rand10</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>
        <span class="k">do</span> <span class="o">{</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">(</span><span class="n">rand7</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">7</span> <span class="o">+</span> <span class="n">rand7</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="n">40</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">%</span> <span class="n">10</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        上述的实现方式是抛弃了 $41 \sim 49$ 之间的数字，抛弃了 $9$ 个数字的实现方式还是有点多的。从我们之前的讲解来看，可以不局限于生成两位数，三位数、四位数也是可以的，因此我们也可以这样实现：首先生成 $7$ 进制两位数，如果不大于 $40$ ，返回，否则利用两位数再次生成 $3$ 位数、$4$ 位数。对于 $Rand7()$ ，我们只需要生成到 $7$ 进制 $4$ 位数就行了，因为 $7^3=243$ ，$7^4=1701$ ，也就是 $4$ 位数最多只需要抛弃 $1$ 个数字，而如果是 $5$ 位数，则又要抛弃 $7$ 个数字才行。<br/>
        我们也可以利用取模 $10$ 这个点来进一步简化算法。如果生成的数字在 $41 \sim 49$ 之间，没有必要直接用该数字进行计算，因为 $40$ 在取模这一步会被消掉，无论乘以哪个数字，所以我们可以将生成的数字减去 $40$ 再进行计算。减去 $40$ 后生成的数字范围在 $1 \sim 63$ 之间，同样的，如果生成了 $61 \sim 63$ 之间的数字，也可以减去 $60$ 后再计算。实现方式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="kd">extends</span> <span class="n">SolBase</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rand10</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">(</span><span class="n">rand7</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">7</span> <span class="o">+</span> <span class="n">rand7</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="n">40</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">(</span><span class="n">num</span> <span class="o">-</span> <span class="n">40</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">7</span> <span class="o">+</span> <span class="n">rand7</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="n">60</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">(</span><span class="n">num</span> <span class="o">-</span> <span class="n">60</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">7</span> <span class="o">+</span> <span class="n">rand7</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="n">20</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">%</span> <span class="n">10</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2021 Mar 26 20:08</span> <a href="/post/leetcode%E9%A2%98%E8%A7%A36%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/">Redis底层数据结构实现</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-对象">1. 对象</h2>
<p>        <code>Redis</code>中的每个键值对都是由两个对象结构表示，定义在 $server.h$ 文件中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 对象类型
</span><span class="c1"></span><span class="cp">#define OBJ_STRING 0
</span><span class="cp">#define OBJ_LIST 1
</span><span class="cp">#define OBJ_SET 2
</span><span class="cp">#define OBJ_ZSET 3
</span><span class="cp">#define OBJ_HASH 4
</span><span class="cp">#define OBJ_MODULE 5
</span><span class="cp">#define OBJ_STREAM 6
</span><span class="cp"></span><span class="c1">// 对象编码
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_RAW 0 </span><span class="c1">// SDS
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_INT 1 </span><span class="c1">// 长整型
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_HT 2 </span><span class="c1">// 字典
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_ZIPMAP 3
</span><span class="cp">#define OBJ_ENCODING_LINKEDLIST 4
</span><span class="cp">#define OBJ_ENCODING_ZIPLIST 5 </span><span class="c1">// 压缩列表
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_INTSET 6 </span><span class="c1">// 整数集合
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_SKIPLIST 7 </span><span class="c1">// 跳表
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_EMBSTR 8 </span><span class="c1">// embstr编码的SDS
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_QUICKLIST 9
</span><span class="cp">#define OBJ_ENCODING_STREAM 10
</span><span class="cp"></span><span class="c1">// 对象结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="nl">type</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span> <span class="c1">// 类型
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">encoding</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span> <span class="c1">// 编码
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">lru</span><span class="p">:</span><span class="n">LRU_BITS</span><span class="p">;</span> <span class="c1">// 最后一次访问时间
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span> <span class="c1">// 引用计数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="c1">// 底层指针
</span><span class="c1"></span><span class="p">}</span> <span class="n">robj</span><span class="p">;</span>
</code></pre></div><h2 id="1-sds">1. <code>SDS</code></h2>
<p>        <strong>简单动态字符串</strong> ( $simple\ \ dynamic\ \ string$, $SDS$ ) 是<code>Redis</code>中字符串的数据结构，定义在 $sds.h$ 头文件中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sds</span><span class="p">;</span>

<span class="c1">// 不使用该结构，而是直接访问flag
</span><span class="c1"></span><span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr5</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr8</span> <span class="p">{</span>
    <span class="n">uint8_t</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 已使用的字节数，不包括&#39;\0&#39;
</span><span class="c1"></span>    <span class="n">uint8_t</span> <span class="n">alloc</span><span class="p">;</span> <span class="c1">// 总共分配的字节数，不包括&#39;\0&#39;
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="c1">// 类型
</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span> <span class="c1">// 字节数组，包括&#39;\0&#39;
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr16</span> <span class="p">{</span>
    <span class="n">uint16_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">uint16_t</span> <span class="n">alloc</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr32</span> <span class="p">{</span>
    <span class="n">uint32_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">uint32_t</span> <span class="n">alloc</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr64</span> <span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">alloc</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cp">#define SDS_TYPE_5 0
</span><span class="cp">#define SDS_TYPE_8 1
</span><span class="cp">#define SDS_TYPE_16 2
</span><span class="cp">#define SDS_TYPE_32 3
</span><span class="cp">#define SDS_TYPE_64 4
</span><span class="cp">#define SDS_TYPE_MASK 7
</span><span class="cp">#define SDS_TYPE_BITS 3
</span></code></pre></div><p>        __ $attribute$ __ $(($ __ $packed$ __ $))$ 作用是取消字节对齐，从而允许通过传入 $buf$ 的方式访问 $flags$ ，即 $buf[-1]$ 。<br/>
        <code>Redis</code>会根据字符串长度选择对应的数据结构。在 $sds.c$ 文件中定义了如下函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="nf">sdsReqType</span><span class="p">(</span><span class="n">size_t</span> <span class="n">string_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">string_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// 32
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">SDS_TYPE_5</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">string_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">// 256
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">SDS_TYPE_8</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">string_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="c1">// 65536
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">SDS_TYPE_16</span><span class="p">;</span>
<span class="cp">#if (LONG_MAX == LLONG_MAX)
</span><span class="cp"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">string_size</span> <span class="o">&lt;</span> <span class="mi">1ll</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span> <span class="c1">// 2^32
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">SDS_TYPE_32</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">SDS_TYPE_64</span><span class="p">;</span> <span class="c1">// 2^64
</span><span class="c1"></span><span class="cp">#else
</span><span class="cp"></span>    <span class="k">return</span> <span class="n">SDS_TYPE_32</span><span class="p">;</span>
<span class="cp">#endif;
</span><span class="cp"></span><span class="p">}</span>
</code></pre></div><p>        与普通的字符数组相比，$SDS$ 可以直接获取长度，并且在添加字节时不用每次都重新创建。由于底层用的也是字符数组，因此 $SDS$ 也兼容<code>C</code>库函数中的字符串操作。</p>
<h2 id="2-链表">2. 链表</h2>
<p>        链表定义在 $adlist.h$ 文件中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 节点
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">listNode</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">listNode</span><span class="p">;</span>

<span class="c1">// 迭代器
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">listIter</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">direction</span><span class="p">;</span>
<span class="p">}</span> <span class="n">listIter</span><span class="p">;</span>

<span class="c1">// 链表
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">list</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">dup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">// 节点复制
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">// 节点删除
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">// 节点查找
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 长度
</span><span class="c1"></span><span class="p">}</span> <span class="n">list</span><span class="p">;</span>
</code></pre></div><h2 id="3-整数集合">3. 整数集合</h2>
<p>        如果一个 $set$ 只包含整数，那么就会使用整数集合存储。整数集合定义在 $intset.h$ 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">intset</span> <span class="p">{</span>
    <span class="n">uint32_t</span> <span class="n">encoding</span><span class="p">;</span> <span class="c1">// 集合类型
</span><span class="c1"></span>    <span class="n">uint32_t</span> <span class="n">length</span><span class="p">;</span> <span class="c1">// 长度
</span><span class="c1"></span>    <span class="n">int8_t</span> <span class="n">contents</span><span class="p">[];</span> <span class="c1">// 以不包含重复项的形式升序排序的数组
</span><span class="c1"></span><span class="p">}</span> <span class="n">intset</span><span class="p">;</span>
</code></pre></div><p>        整数集合中保存的整数类型取决于 $encoding$ 。如果存入的整数不符合编码格式，就需要升级，升级要根据新元素的类型扩展数组并重新分配空间。</p>
<h2 id="4-hash">4. <code>Hash</code></h2>
<p>        $Hash$ 定义在 $dict.h$ 文件中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dicEntry</span> <span class="p">{</span> <span class="c1">// 节点
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span> <span class="c1">// 键
</span><span class="c1"></span>    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
        <span class="n">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
        <span class="n">int64_t</span> <span class="n">s64</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 值
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">dicEntry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="c1">// 链表结构解决冲突
</span><span class="c1"></span><span class="p">}</span> <span class="n">dictEntry</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictType</span> <span class="p">{</span> <span class="c1">// 字典类型
</span><span class="c1"></span>    <span class="n">uint64_t</span> <span class="p">(</span><span class="o">*</span><span class="n">hashFunction</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">// 计算哈希值行数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">keyDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">// 复制键
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">valDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span> <span class="c1">// 复制值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">keyCompare</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span> <span class="c1">// 查找键
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">keyDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">// 删除键
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">valDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span> <span class="c1">// 删除值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">expandAllowed</span><span class="p">)(</span><span class="n">size_t</span> <span class="n">moreMem</span><span class="p">,</span> <span class="kt">double</span> <span class="n">usedRatio</span><span class="p">);</span> <span class="c1">// 扩容
</span><span class="c1"></span><span class="p">}</span> <span class="n">dictType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictht</span> <span class="p">{</span> <span class="c1">// 哈希表
</span><span class="c1"></span>    <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span> <span class="c1">// 哈希数组
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span> <span class="c1">// 表大小，2的幂次
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizemask</span><span class="p">;</span> <span class="c1">// 计算索引，即表大小-1
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span> <span class="c1">// 已使用节点数
</span><span class="c1"></span><span class="p">}</span> <span class="n">dictht</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dict</span> <span class="p">{</span> <span class="c1">// 字典
</span><span class="c1"></span>    <span class="n">dictType</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span> <span class="c1">// 类型
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">;</span> <span class="c1">// 私有数据
</span><span class="c1"></span>    <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 两个哈希表
</span><span class="c1"></span>    <span class="kt">long</span> <span class="n">rehashidx</span><span class="p">;</span> <span class="c1">// rehash索引，不进行rehash时为-1
</span><span class="c1"></span>    <span class="n">int16_t</span> <span class="n">pauserhash</span><span class="p">;</span> <span class="c1">// 如果&gt;0说明rehash暂停，&lt;0说明发生错误
</span><span class="c1"></span><span class="p">}</span> <span class="n">dict</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictIterator</span> <span class="p">{</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">table</span><span class="p">,</span> <span class="n">safe</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">nextEntry</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">fingerprint</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictIterator</span><span class="p">;</span>
</code></pre></div><p>        <code>Redis</code>的字典使用链地址法解决哈希冲突，采用头插法。<code>Redis</code>中的字典不仅可以进行扩容操作，也可以进行收缩操作，大小固定为不小于当前使用空间的最小的 $2$ 的整数次幂。在每次执行 $CRUD$ 操作之后都会进行 $rehash$ 操作，将保存在 $ht[0]$ 中的键值对迁移到 $ht[1]$ 中，直到 $ht[0]$ 为空，然后交换 $ht[0]$ 和 $ht[1]$ ，并在 $ht[1]$ 上重建一个新表。$rehashidx$ 的作用是记录每次操作过程中应该进行迁移的键值对的索引，如果迁移完成，会重新设为 $-1$ 。</p>
<h2 id="5-压缩列表">5. 压缩列表</h2>
<p>        压缩列表是 $list$ 和 $hash$ 的底层实现之一，对于只包含少量数据的项，会使用压缩列表存储。压缩列表定义在 $ziplist.c$ 文件中，结构如下：</p>
<ol>
<li>$zlbytes$ ：$4$ 字节压缩列表长度；</li>
<li>$zltail$ ：$4$ 字节尾元素相对于压缩列表起始地址偏移量；</li>
<li>$zllen$ ：$2$ 字节压缩列表元素数目，长度超过 $2^{16}-1$ ，需要遍历压缩列表才能获取元素数目</li>
<li>$entry$ ：元素节点；</li>
<li>$zlend$ ：$1$ 字节表示压缩列表结尾，恒为 $0xFF$。</li>
</ol>
<p>        其中元素节点的编码如下：</p>
<ol>
<li>$previous_-entry_-length$ ：前一个节点的字节长度；</li>
<li>$encoding$ ：当前元素编码；</li>
<li>$content$ ：存储的数据，可以是字节数组或者整数。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// zl为char*类型，指向压缩列表首地址
</span><span class="c1"></span><span class="cp">#define ZIPLIST_BYTES(zl) (*((uint32_t*)(zl)))
</span><span class="cp"></span><span class="c1">// zl+4指向zltail字段
</span><span class="c1"></span><span class="cp">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t)((zl)+sizeof(uint32_t))))
</span><span class="cp"></span><span class="c1">// zl+zltail指向为元素首地址
</span><span class="c1"></span><span class="cp">#define ZIPLIST_ENTRY_TAIL(zl) ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))
</span><span class="cp"></span><span class="c1">// zl+8指向zllen字段
</span><span class="c1"></span><span class="cp">#define ZIPLIST_LENGTH(zl) (*((uint16_t)((zl)+sizeof(uint32_T)*2)))
</span><span class="cp"></span><span class="c1">// 最后一个字段为zlend
</span><span class="c1"></span><span class="cp">#define ZIPLIST_ENTRY_END(zl) ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)
</span><span class="cp"></span><span class="c1">// 存储经过解码后的节点
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zlentry</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prevrawlensize</span><span class="p">;</span> <span class="c1">// 前驱节点长度的字节长度
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prevrawlen</span><span class="p">;</span> <span class="c1">// 前驱节点长度
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lensize</span><span class="p">;</span> <span class="c1">// encoding字段的字节长度
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 数据字节长度
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">headersize</span><span class="p">;</span> <span class="c1">// prevrawlensize + lensize，即previous_entry_length+encoding长度
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span><span class="p">;</span> <span class="c1">// ZIP_STR_* 或者 ZIP_INT_*
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// 存储数据的首地址
</span><span class="c1"></span><span class="p">}</span> <span class="n">zlentry</span><span class="p">;</span>
</code></pre></div><h2 id="6-跳表">6. 跳表</h2>
<p>        跳表定义在 $server.h$ 文件中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="p">{</span> <span class="c1">// 跳表节点
</span><span class="c1"></span>    <span class="n">sds</span> <span class="n">ele</span><span class="p">;</span> <span class="c1">// 元素
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span> <span class="c1">// 分值
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span> <span class="n">backward</span><span class="p">;</span> <span class="c1">// 后向指针
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">zskiplistLevel</span> <span class="p">{</span> <span class="c1">// 层
</span><span class="c1"></span>        <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">forward</span><span class="p">;</span> <span class="c1">// 前向指针
</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">span</span><span class="p">;</span> <span class="c1">// 跨度，即同层相邻节点之间最底层节点的数量
</span><span class="c1"></span>    <span class="p">}</span> <span class="n">level</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">zskiplistNode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplist</span> <span class="p">{</span> <span class="c1">// 跳表
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span> <span class="c1">// 长度
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span> <span class="c1">// 最大层数
</span><span class="c1"></span><span class="p">}</span> <span class="n">zskiplist</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">zset</span> <span class="p">{</span> <span class="c1">// 有序集合
</span><span class="c1"></span>    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span> <span class="c1">// 字典
</span><span class="c1"></span>    <span class="n">zskiplist</span> <span class="o">*</span><span class="n">zsl</span><span class="p">;</span> <span class="c1">// 跳表
</span><span class="c1"></span><span class="p">}</span> <span class="n">zset</span><span class="p">;</span>
</code></pre></div><p>        $ZSKIPLIST_-P$ 为 $0.25$ ，代表每次插入的节点都有 $25\%$ 的概率上升一层。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Mar 25 23:02</span> <a href="/post/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/reentranlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">ReentranLock源码解读</a></h1>
            </center>
            <div class="post-content">
                <p>        $ReentrantLock$ 是一个可重入的独占锁，与 $synchronized$ 行为类似，但提供了额外的功能。</p>
<h2 id="1-构造函数">1. 构造函数</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 默认为非公平锁
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">()</span> <span class="o">{</span> <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span> <span class="o">}</span>

<span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span> <span class="n">sync</span> <span class="o">=</span> <span class="n">fair</span> <span class="o">?</span> <span class="k">new</span> <span class="n">FairSync</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span> <span class="o">}</span>
</code></pre></div><h2 id="2-内部类">2. 内部类</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Sync</span> <span class="kd">extends</span> <span class="n">AbstractQueuedSynchronizer</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="n">5179523762034025860L</span><span class="o">;</span>

    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">();</span>

    <span class="c1">// 非公平上锁, tryAcquire方法在子类中实现
</span><span class="c1"></span>    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">nonfairTryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 锁未被占有
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 尝试获取锁
</span><span class="c1"></span>                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span> <span class="c1">// 设置独占线程
</span><span class="c1"></span>                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 当前线程已经占有锁
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;Maximum lock count exceeded&#34;</span><span class="o">);</span>
            <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span> <span class="c1">// 添加上锁次数
</span><span class="c1"></span>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">()</span> <span class="o">-</span> <span class="n">releases</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="c1">// 当前线程非独占线程
</span><span class="c1"></span>            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
        <span class="kt">boolean</span> <span class="n">free</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 锁被释放
</span><span class="c1"></span>            <span class="n">free</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// 取消独占状态
</span><span class="c1"></span>        <span class="o">}</span>
        <span class="n">setState</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">free</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 当前实现是否持有锁
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">getExclusiveOwnerThread</span><span class="o">()</span> <span class="o">==</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="n">ConditionObject</span> <span class="nf">newCondition</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ConditionObject</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 返回持有者线程
</span><span class="c1"></span>    <span class="kd">final</span> <span class="n">Thread</span> <span class="nf">getOwner</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">getState</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">getExclusiveOwnerThread</span><span class="o">();</span> <span class="o">}</span>

    <span class="c1">// 返回当前线程上锁次数
</span><span class="c1"></span>    <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getHoldCount</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">isHeldExclusively</span><span class="o">()</span> <span class="o">?</span> <span class="n">getState</span><span class="o">()</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isLocked</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">getState</span><span class="o">()</span> <span class="o">!=</span> <span class="n">0</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">ObjectInputStream</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* 省略 */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 非公平锁
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">NonfairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="n">7316153563782823691L</span><span class="o">;</span>

    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">1</span><span class="o">))</span> <span class="c1">// 尝试上锁
</span><span class="c1"></span>            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
        <span class="k">else</span> <span class="c1">// 自旋获取锁
</span><span class="c1"></span>            <span class="n">acquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">nonfairTryAcquire</span><span class="o">(</span><span class="n">acquires</span><span class="o">);}</span> <span class="c1">// 调用父类方法
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 公平锁
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="n">3000897897090466540L</span><span class="o">;</span>

    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span> <span class="n">acquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="o">}</span> <span class="c1">// 公平方式获取锁，获取失败则自旋
</span><span class="c1"></span>
    <span class="c1">// 公平方式获取锁
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">hasQueuedPredecessors</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="c1">// 没有前驱节点
</span><span class="c1"></span>                <span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 尝试获取锁
</span><span class="c1"></span>                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 当前线程为独占线程
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span> <span class="c1">// 添加获取次数
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;Maximum lock count exceeded&#34;</span><span class="o">);</span>
            <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        其中 $acquire$ 方法的实现可以在<a href="https://z217blog.cn/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#3-%E8%8E%B7%E5%8F%96%E9%94%81">这里</a>查看。</p>
<h2 id="3-上锁和解锁">3. 上锁和解锁</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 声明了一个内部类字段作为同步器
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">final</span> <span class="n">Sync</span> <span class="n">sync</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="n">lock</span> <span class="o">{</span> <span class="n">sync</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="o">}</span> <span class="c1">// 调用lock方法，该方法在子类中被实现
</span><span class="c1"></span>
<span class="c1">// 响应中断式上锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">lockInterruptibly</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">acquireInterruptibly</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// AQS中实现
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquireInterruptibly</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
        <span class="n">doAcquireInterruptibly</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 尝试以非公平方式获取锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">nonfairTryAcquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryAcquireNanos</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// AQS中实现
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">tryAcquireNanos</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">nanosTimeout</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">||</span>
        <span class="n">doAcquireNanos</span><span class="o">(</span><span class="n">arg</span><span class="o">,</span> <span class="n">nanosTimeout</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 每次只能解一个锁，所以如果多次上锁就需要多次解锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span> <span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="o">}</span>
</code></pre></div><p>        其中 $doAcquireInterruptibly$ 方法和 $doAcquireNanos$ 方法的实现可以在<a href="https://z217blog.cn/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#33-%E5%85%B6%E4%BB%96">这里</a>查看。</p>
<h2 id="4-条件">4. 条件</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 创建条件
</span><span class="c1"></span><span class="kd">public</span> <span class="n">Condition</span> <span class="nf">newCondition</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否有线程在条件上等待
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasWaiters</span><span class="o">(</span><span class="n">Condition</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">condition</span> <span class="k">instanceof</span> <span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">))</span>
        <span class="c1">// 非AQS中定义的ConditionObject类型对象
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;not owner&#34;</span><span class="o">);</span>
    <span class="c1">// 使用AQS中的方法判断，检查条件队列中是否有状态为CONDITION的节点
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">hasWaiters</span><span class="o">((</span><span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">)</span><span class="n">condition</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 获取条件上等待的线程数量
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">getWaitQueueLength</span><span class="o">(</span><span class="n">Condition</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">condition</span> <span class="k">instanceof</span> <span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">))</span>
        <span class="c1">// 非AQS中定义的ConditionObject类型对象
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;now owner&#34;</span><span class="o">);</span>
    <span class="c1">// 使用AQS中的方法统计，遍历条件队列并统计CONDITION节点数量
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getWaitQueueLength</span><span class="o">((</span><span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">)</span><span class="n">condition</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 获取条件上等待的线程集合
</span><span class="c1"></span><span class="kd">protected</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="nf">getWaitingThreads</span><span class="o">(</span><span class="n">Condition</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">condition</span> <span class="k">instanceof</span> <span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">))</span>
        <span class="c1">// 非AQS中定义的ConditionObject类型对象
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;not owner&#34;</span><span class="o">);</span>
    <span class="c1">// 使用AQS中的方法统计，遍历条件队列并返回CONDITION节点中持有的线程集合
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getWaitingThreads</span><span class="o">((</span><span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">)</span><span class="n">condition</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><h2 id="5-其他方法">5. 其他方法</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 当前线程上锁次数
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">getHoldCount</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getHoldCount</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否被当前线程持有
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHeldByCurrentThread</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isHeldExclusively</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否上锁，即状态是否非零
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isLocked</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isLocked</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否公平锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isFair</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span> <span class="k">instanceof</span> <span class="n">FairSync</span><span class="o">;</span> <span class="o">}</span>

<span class="c1">// 获取持有者线程
</span><span class="c1"></span><span class="kd">protected</span> <span class="n">Thread</span> <span class="nf">getOwner</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getOwner</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否有等待中的线程
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedThreads</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">hasQueuedThreads</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// AQS中实现
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedThreads</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">head</span> <span class="o">!=</span> <span class="n">tail</span><span class="o">;</span> <span class="c1">// 首节点为哑节点，因此只要首尾不等即可
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// 线程是否在队列中等待，从尾部遍历等待队列，判断线程是否在其中
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedThread</span><span class="o">(</span><span class="n">Thread</span> <span class="n">thread</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isQueued</span><span class="o">(</span><span class="n">thread</span><span class="o">);</span> <span class="o">}</span>

<span class="c1">// 获取等待线程的数量，从尾部遍历等待队列，统计等待线程数
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getQueueLength</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getQueueLength</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 获取等待线程的集合，从尾部遍历等待队列，返回等待线程集合
</span><span class="c1"></span><span class="kd">protected</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="nf">getQueuedThreads</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getQueuedThreads</span><span class="o">();</span> <span class="o">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2021 Mar 20 22:27</span> <a href="/post/reentranlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">AQS源码解读</a></h1>
            </center>
            <div class="post-content">
                <p>        <code>AQS</code>提供了一个实现阻塞锁和相关的基于<code>FIFO</code>队列的同步器的框架。该类作为大部分依赖于一个状态字段的同步器的基础。子类必须定义 $protected$ 方法来改变状态，其他方法用于管理队列和实现阻塞机制。子类也可以包含其他状态字段，但必须通过原子性操作维护状态。</p>
<h2 id="1-成员变量">1. 成员变量</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 等待队列的头节点，懒加载，只能通过setHead方法修改
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>
<span class="c1">// 等待队列的尾部，懒加载，只能通过enq方法添加新节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">tail</span><span class="o">;</span>
<span class="c1">// 同步状态
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>
<span class="c1">// 如果超时时间大于该值，中断，单位为纳秒
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">spinForTimeoutThreshold</span> <span class="o">=</span> <span class="n">1000L</span><span class="o">;</span>
</code></pre></div><h2 id="2-内部类node">2. 内部类<code>Node</code></h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="c1">// 节点在共享模式等待的标志
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Node</span> <span class="n">SHARED</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
    <span class="c1">// 节点在独占模式等待的标志
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Node</span> <span class="n">EXCLUSIVE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 表示线程被取消
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CANCELLED</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
    <span class="c1">// 表示线程在释放资源后需要唤醒后继节点
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SIGNAL</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="c1">// 表示线程在等待condition
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CONDITION</span> <span class="o">=</span> <span class="o">-</span><span class="n">2</span><span class="o">;</span>
    <span class="c1">// 共享模式下表示无条件传播
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">PROPAGATE</span> <span class="o">=</span> <span class="o">-</span><span class="n">3</span><span class="o">;</span>
    <span class="c1">// 等待状态
</span><span class="c1"></span>    <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">waitStatus</span><span class="o">;</span>
    <span class="c1">// 前驱节点
</span><span class="c1"></span>    <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">prev</span><span class="o">;</span>
    <span class="c1">// 后继节点
</span><span class="c1"></span>    <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>
    <span class="c1">// 节点对应的线程
</span><span class="c1"></span>    <span class="kd">volatile</span> <span class="n">Thread</span> <span class="n">thread</span><span class="o">;</span>
    <span class="c1">// 下一个在condition上等待的节点，或者表示共享模式
</span><span class="c1"></span>    <span class="n">Node</span> <span class="n">nextWaiter</span><span class="o">;</span>

    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isShared</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">nextWaiter</span> <span class="o">==</span> <span class="n">SHARED</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">final</span> <span class="n">Node</span> <span class="nf">predecessor</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NullPointerException</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">Node</span><span class="o">()</span> <span class="o">{}</span> <span class="c1">// 用于创建头节点或者共享标记
</span><span class="c1"></span>
    <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span> <span class="n">thread</span><span class="o">,</span> <span class="n">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="n">mode</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">thread</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span> <span class="n">thread</span><span class="o">,</span> <span class="kt">int</span> <span class="n">waitStatus</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">=</span> <span class="n">waitStatus</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">thread</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="3-获取锁">3. 获取锁</h2>
<h3 id="31-独占模式">3.1 独占模式</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 独占模式获取资源，忽略中断，未获取成功则阻塞
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">acquireQueued</span><span class="o">(</span><span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">))</span>
        <span class="n">selfInterrupt</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 尝试以独占模式获取锁，需要在子类中重写
</span><span class="c1"></span><span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 根据给定模式创建队列节点
</span><span class="c1"></span><span class="kd">private</span> <span class="n">Node</span> <span class="nf">addWaiter</span><span class="o">(</span><span class="n">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(),</span> <span class="n">mode</span><span class="o">);</span>
    <span class="n">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 如果在此入队成功，直接返回
</span><span class="c1"></span>            <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 入队失败，循环直到成功
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 节点入队
</span><span class="c1"></span><span class="kd">private</span> <span class="n">Node</span> <span class="nf">enq</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(;;)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetHead</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">()))</span> <span class="c1">// 队列为空，设置哑节点
</span><span class="c1"></span>                <span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">t</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 自旋获取锁
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">acquireQueued</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span> <span class="c1">// 获取前驱节点
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 如果没有前驱节点在等待，尝试获取锁
</span><span class="c1"></span>                <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 帮助GC
</span><span class="c1"></span>                <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">interrupted</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="c1">// 根据状态判断是否阻塞
</span><span class="c1"></span>                <span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
                <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
            <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 检查和更新获取锁失败的节点状态，true表示需要阻塞
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">Node</span> <span class="n">pred</span><span class="o">,</span> <span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span> <span class="c1">// 获取前驱节点状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">)</span> <span class="c1">// SIGNAL状态下前驱节点释放资源后会通知后继节点，因而可以阻塞
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 前驱节点被取消
</span><span class="c1"></span>        <span class="k">do</span> <span class="o">{</span>
            <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">);</span> <span class="c1">// 寻找最近的一个处于正常状态的节点
</span><span class="c1"></span>        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// 其他状态则设置前驱节点为SIGNAL，令其在释放资源后通知自己
</span><span class="c1"></span>        <span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 挂起当前线程
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">parkAndCheckInterrupt</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 产生一个中断
</span><span class="c1"></span><span class="kd">static</span> <span class="kt">void</span> <span class="nf">selfInterrupt</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>        总结一下 $acquire$ 方法的执行步骤：</p>
<ol>
<li>尝试以独占方式获取锁，成功则直接返回</li>
<li>尝试以自旋等待方式获取锁，将节点加入队列</li>
<li>在自旋的过程中通过 $shouldParkAfterFailedAcquire$ 方法判断是否需要挂起，如果之间发生了中断，设置中断标志位；</li>
<li>自旋获取锁成功，如果发生了中断，通过 $selfInterrupt$ 方法产生一个中断。</li>
</ol>
<h3 id="32-共享模式">3.2 共享模式</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 共享模式获取锁，忽略中断
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tryAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
        <span class="n">doAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 共享模式获取锁，失败时返回负数，0表示获取成功但没有剩余资源，正数表示获取节点成功并且还有剩余资源
</span><span class="c1"></span><span class="kd">protected</span> <span class="kt">int</span> <span class="nf">tryAcquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 自旋获取锁
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">doAcquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">SHARED</span><span class="o">);</span> <span class="c1">// 创建节点并入队
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">tryAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 如果存在剩余资源则传播
</span><span class="c1"></span>                    <span class="n">setHeadAndPropagate</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">interrupted</span><span class="o">)</span>
                        <span class="n">selfInterrupt</span><span class="o">();</span>
                    <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                <span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
                <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
            <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 设置队列头节点并传播
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">setHeadAndPropagate</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">propagate</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 设置头节点
</span><span class="c1"></span>    <span class="c1">// 存在剩余资源、头节点为空、处于负状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">propagate</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">h</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span>
        <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">// 获取下一个节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">isShared</span><span class="o">())</span> <span class="c1">// 下一个节点为空或者处于共享模式
</span><span class="c1"></span>            <span class="n">doReleaseShared</span><span class="o">();</span> <span class="c1">// 唤醒后继并确保传播
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="33-其他">3.3 其他</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 是否存在等待中的前驱
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedPredecessors</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">s</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">h</span> <span class="o">!=</span> <span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="c1">// 队列非空
</span><span class="c1"></span>        <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">thread</span> <span class="o">!=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span> <span class="c1">// 当前等待节点非当前线程所在节点
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// 在规定时间内以独占模式获取锁
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">doAcquireNanos</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">nanosTimeout</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nanosTimeout</span> <span class="o">&lt;=</span> <span class="n">0L</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kd">final</span> <span class="kt">long</span> <span class="n">deadLine</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">()</span> <span class="o">+</span> <span class="n">nanosTimeout</span><span class="o">;</span> <span class="c1">// 到期时间
</span><span class="c1"></span>    <span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">);</span> <span class="c1">// 创建节点并加入队列
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span> <span class="c1">// 获取前驱
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 前驱为头节点，尝试获取锁
</span><span class="c1"></span>                <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">nanosTimeout</span> <span class="o">=</span> <span class="n">deadLine</span> <span class="o">-</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span> <span class="c1">// 计算剩余时间
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">nanosTimeout</span> <span class="o">&lt;=</span> <span class="n">0L</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="c1">// 判断是否应该阻塞
</span><span class="c1"></span>                <span class="n">nanosTimeout</span> <span class="o">&gt;</span> <span class="n">spinForTimeoutThreshold</span><span class="o">)</span> <span class="c1">// 超时时间大于阈值（1000），中断
</span><span class="c1"></span>                <span class="n">LockSupport</span><span class="o">.</span><span class="na">parkNanos</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nanosTimeout</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
            <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 以独占模式获取锁，可以响应中断
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">doAcquireInterruptibly</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">);</span> <span class="c1">// 添加节点
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span> <span class="c1">// 获取前驱
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 前驱为头节点，尝试获取锁
</span><span class="c1"></span>                <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="c1">// 判断是否中断
</span><span class="c1"></span>                <span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span> <span class="c1">// 不再设置中断状态，而是直接抛出线程
</span><span class="c1"></span>        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
            <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="4-释放锁">4. 释放锁</h2>
<h3 id="41-独占模式">4.1 独占模式</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 释放独占模式的锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">release</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tryRelease</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
            <span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span> <span class="c1">// 解除后继的阻塞状态
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 唤醒后继节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">unparkSuccessor</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span> <span class="c1">// 获取当前节点状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 负数则设置为正常状态
</span><span class="c1"></span>        <span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
    <span class="n">Node</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">// 获取后继
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 后继被取消
</span><span class="c1"></span>        <span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span> <span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">node</span><span class="o">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="c1">// 从尾节点开始往前遍历
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 最后一个未取消的节点
</span><span class="c1"></span>                <span class="n">s</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">thread</span><span class="o">);</span> <span class="c1">// 唤醒节点
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><h3 id="42-共享模式">4.2 共享模式</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 释放共享模式的锁
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">releaseShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tryReleaseShared</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">doReleaseShared</span><span class="o">();</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryReleaseShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 释放共享模式的锁，唤醒后继并且设置为传播状态
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">doReleaseShared</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span> <span class="o">!=</span> <span class="n">tail</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">,</span> <span class="n">0</span><span class="o">))</span> <span class="c1">// 设置正常状态
</span><span class="c1"></span>                    <span class="k">continue</span><span class="o">;</span>
                <span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span> <span class="c1">// 唤醒后继
</span><span class="c1"></span>            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="c1">// 已经是正常状态
</span><span class="c1"></span>                       <span class="o">!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">PROPAGATE</span><span class="o">))</span> <span class="c1">// 设置传播
</span><span class="c1"></span>                <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span> <span class="c1">// 设置完成后如果发现头节点改变，重新设置
</span><span class="c1"></span>            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="5-内部类conditionobject">5. 内部类<code>ConditionObject</code></h2>
<h3 id="51-成员变量">5.1 成员变量</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 队首节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="n">Node</span> <span class="n">firstWaiter</span><span class="o">;</span>
<span class="c1">// 队尾节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="n">Node</span> <span class="n">lastWaiter</span><span class="o">;</span>
<span class="c1">// 发生中断，设置该状态位，后续不抛出异常而是产生中断
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">REINTERRUPT</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
<span class="c1">// 发生中断，设置该状态位，后续抛出异常
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">THROW_IE</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</code></pre></div><h3 id="52-阻塞">5.2 阻塞</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">await</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span> <span class="c1">// 线程中断
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addConditionWaiter</span><span class="o">();</span> <span class="c1">// 添加节点
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">savedState</span> <span class="o">=</span> <span class="n">fullyRelease</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 释放当前节点所有资源
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">interruptMode</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">isOnSyncQueue</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 节点不在等待队列，则在condition的条件队列中
</span><span class="c1"></span>        <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">// 阻塞节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">((</span><span class="n">interruptMode</span> <span class="o">=</span> <span class="n">checkInterruptWhileWaiting</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 中断状态变化
</span><span class="c1"></span>            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 唤醒后重新添加到等待队列中
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">acquireQueued</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">savedState</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">interruptMode</span> <span class="o">!=</span> <span class="n">THROW_IE</span><span class="o">)</span>
        <span class="n">interruptMode</span> <span class="o">=</span> <span class="n">REINTERRUPT</span><span class="o">;</span>
    <span class="c1">// 删除非CONDITION节点
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">unlinkCancelledWaiters</span><span class="o">();</span>
    <span class="c1">// 如果发生中断，处理中断
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">interruptMode</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
        <span class="n">reportInterruptAfterWait</span><span class="o">(</span><span class="n">interruptMode</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 向等待队列中添加节点
</span><span class="c1"></span><span class="kd">private</span> <span class="n">Node</span> <span class="nf">addConditionWaiter</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">lastWaiter</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">unlinkCancelledWaiters</span><span class="o">();</span> <span class="c1">// 删除非CONDITION节点
</span><span class="c1"></span>        <span class="n">t</span> <span class="o">=</span> <span class="n">lastWaiter</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">firstWaiter</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="n">t</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="n">lastWaiter</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 删除非CONDITION节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">unlinkCancelledWaiters</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">firstWaiter</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">trail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">nextWaiter</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">t</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">trail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">firstWaiter</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">trail</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">lastWaiter</span> <span class="o">=</span> <span class="n">trail</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="n">trail</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 释放节点持有的资源
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">int</span> <span class="nf">fullyRelease</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">savedState</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span> <span class="c1">// 获取当前状态
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">release</span><span class="o">(</span><span class="n">savedState</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 完全释放锁
</span><span class="c1"></span>            <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">savedState</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span> <span class="c1">// 释放失败，取消线程
</span><span class="c1"></span>            <span class="n">node</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="na">CANCELLED</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 节点是否处于等待队列中
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isOnSyncQueue</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span> <span class="o">||</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 如果为CONDITION节点或者首节点
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 如果存在后继，则位于等待队列中
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">findNodeFromTail</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 从尾节点查找结点
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// 检查阻塞过程中的中断情况
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">int</span> <span class="nf">checkInterruptWhileWaiting</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">()</span> <span class="o">?</span>
        <span class="o">(</span><span class="n">transferAfterCancelledWait</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">?</span> <span class="n">THROW_IE</span> <span class="o">:</span> <span class="n">REINTERRUPT</span><span class="o">)</span> <span class="o">:</span>
        <span class="n">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 传输节点到等待队列
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">transferAfterCancelledWait</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span><span class="o">,</span> <span class="n">0</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 取消CONDITION状态
</span><span class="c1"></span>        <span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 加入等待队列
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">isOnSyncQueue</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="c1">// 不在等待队列，阻塞
</span><span class="c1"></span>        <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 处理中断
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">reportInterruptAfterWait</span><span class="o">(</span><span class="kt">int</span> <span class="n">interruptMode</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">interruptMode</span> <span class="o">=</span> <span class="n">THROW_IE</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">interruptMode</span> <span class="o">==</span> <span class="n">REINTERRUPT</span><span class="o">)</span>
        <span class="n">selfInterrupt</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><h3 id="53-唤醒">5.3 唤醒</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 唤醒最长等待的线程
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">signal</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">isHeldExclusively</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
    <span class="n">Node</span> <span class="n">first</span> <span class="o">=</span> <span class="n">firstWaiter</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">doSignal</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 唤醒所有线程
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">signalAll</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">isHeldExclusively</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
    <span class="n">Node</span> <span class="n">first</span> <span class="o">=</span> <span class="n">firstWaiter</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">doSignalAll</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 是否被独占
</span><span class="c1"></span><span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">doSignal</span><span class="o">(</span><span class="n">Node</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">firstWaiter</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">lastWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">transferForSignal</span><span class="o">(</span><span class="n">first</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
             <span class="o">(</span><span class="n">first</span> <span class="o">=</span> <span class="n">firstWaiter</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">doSignalAll</span><span class="o">(</span><span class="n">Node</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">lastWaiter</span> <span class="o">=</span> <span class="n">firstWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 唤醒并移除所有节点
</span><span class="c1"></span>    <span class="k">do</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span><span class="o">;</span>
        <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">transferForSignal</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 传输节点到等待队列
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">transferForSignal</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span><span class="o">,</span> <span class="n">0</span><span class="o">))</span> <span class="c1">// 取消CONDITION状态
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 加入队列
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">))</span> <span class="c1">// 节点被取消或者更改状态失败
</span><span class="c1"></span>        <span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">thread</span><span class="o">);</span> <span class="c1">// 阻塞节点线程
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h3 id="54-其他">5.4 其他</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">awaitNanos</span><span class="o">(</span><span class="kt">long</span> <span class="n">nanosTimeout</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addConditionWaiter</span><span class="o">();</span> <span class="c1">// 添加节点
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">savedState</span> <span class="o">=</span> <span class="n">fullyRelease</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 释放节点
</span><span class="c1"></span>    <span class="kd">final</span> <span class="kt">long</span> <span class="n">deadline</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">()</span> <span class="o">+</span> <span class="n">nanosTimeout</span><span class="o">;</span> <span class="c1">// 计算截止时间
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">interruptMode</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">isOnSyncQueue</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 检查节点是否处于等待队列
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">nanosTimeout</span> <span class="o">&lt;=</span> <span class="n">0L</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 超时
</span><span class="c1"></span>            <span class="n">transferAfterCancelledWait</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 传输到等待队列
</span><span class="c1"></span>            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nanosTimeout</span> <span class="o">&gt;=</span> <span class="n">spinForTimeoutThreshold</span><span class="o">)</span> <span class="c1">// 剩余时间大于阈值，阻塞
</span><span class="c1"></span>            <span class="n">LockSupport</span><span class="o">.</span><span class="na">parkNanos</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nanosTimeout</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">interruptMode</span> <span class="o">=</span> <span class="n">checkInterruptWhileWaiting</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 检查是否出现中断
</span><span class="c1"></span>            <span class="k">break</span><span class="o">;</span>
        <span class="n">nanosTimeout</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">acquireQueued</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">savedState</span><span class="o">)</span>  <span class="o">&amp;&amp;</span> <span class="n">interruptMode</span> <span class="o">!=</span> <span class="n">THROW_IE</span><span class="o">)</span> <span class="c1">// 插入等待队列
</span><span class="c1"></span>        <span class="n">interruptMode</span> <span class="o">=</span> <span class="n">REINTERRUPT</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 移除非CONDITION节点
</span><span class="c1"></span>        <span class="n">unlinkCancelledWaiters</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">interruptMode</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 处理中断
</span><span class="c1"></span>        <span class="n">reportInterruptAfterWait</span><span class="o">(</span><span class="n">interruptMode</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2021 Mar 19 20:14</span> <a href="/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
        if (tocFlag) tocInit();
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>