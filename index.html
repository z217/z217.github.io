<!DOCTYPE html>
<html lang="zh-CN"><head>
	<meta name="generator" content="Hugo 0.105.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/jquery.floatingscroll.css>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  <script src=https://z217blog.cn/js/jquery.floatingscroll.min.js></script>
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/navbutton.js></script>
<script src=https://z217blog.cn/js/lightswitcher.js></script>
<script src=https://z217blog.cn/js/toc.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>
        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a><br/>
        <a href="javascript:void(0)" id="scroll-top" onclick="scrollToTop()">回到顶部</a>
        <a href="javascript:void(0)" id="light-switcher">暗色模式</a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">分布式数据系统：共识算法</a>
        
        
        <p>数据密集型应用系统设计：分布式事务与共识</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Nov 13 16:18
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Arch
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9/">分布式数据系统：主从节点</a>
        
        
        <p>数据密集型应用系统设计：分布式数据系统</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Nov 06 15:24
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Arch
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/cpptemplates7/">C&#43;&#43; Templates（7）：深入模版基础</a>
        
        
        <p>《C&#43;&#43; Templates》读书笔记（7），个人翻译</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Mar 16 14:56
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/cpptemplates6/">C&#43;&#43; Templates（6）：模版实践与泛型库</a>
        
        
        <p>《C&#43;&#43; Templates》读书笔记（6），个人翻译</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Mar 14 15:57
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/cpptemplates5/">C&#43;&#43; Templates（5）：编译时编程</a>
        
        
        <p>《C&#43;&#43; Templates》读书笔记（5），个人翻译</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Mar 14 12:33
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&C++
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">分布式数据系统：共识算法</a></h1>
            <div class="post-content">
                
                
                <p>        分布式计算中有很多重要场景需要集群节点达成某种一致，例如：</p>
<ul>
<li>主节点选举：对于主从模式的数据库，节点间需要对谁来充当主节点达成一致。如果由于网络故障原因出现节点之间无法通信，就很容易出现争议；</li>
<li>原子事务提交：对于支持跨节点或跨分区事务的数据库，某个事务可能在一些节点上执行成功，而在另一些节点上失败。为了维护事务的原子性，所有节点必须对事务结果达成一致。</li>
</ul>
<h2 id="1-原子提交与两阶段提交">1. 原子提交与两阶段提交</h2>
<p>        对于单节点事务，原子性通常由存储引擎负责。当客户端请求数据库节点提交事务时，数据库首先使事务的写入持久化 ( 通常保存在<code>WAL</code>中 )，然后把提交记录追加到磁盘的日志文件中。如果数据库在该过程中发生了崩溃，在节点重启后，可以通过日志恢复事务。如果崩溃之前已经写入了提交记录，则认为事务已经成功，否则，回滚该事务。因此，单节点事务十分依赖于数据写入磁盘的顺序：先写入数据，再提交记录。<br>
        将单节点事务延伸到多节点，虽然大多数<code>NoSQL</code>分布式数据库都不支持这种分布式事务，但是有很多集群关系型数据库支持。向所有节点发送请求，然后各节点独立执行是不够的，这样很容易发生不一致，从而违反了原子性。一旦某个节点提交了事务，即使事后发现其他节点发生了中止，它也无法再撤销已提交的事务，所以，如果有部分节点提交了事务，所有节点也必须一起提交。<br>
        事务提交不可撤销，一旦数据被提交，就代表其他事务可见，继而客户端会依赖这些数据做出相应决策。这是事务<strong>提交读</strong>隔离级别的基础，如果事务在提交后还能撤销，就违反了提交读的原则，从而被迫产生级联式的追溯和撤销。当然，已提交事务可以被另一个新的事务覆盖，即<em><strong>补偿性事务</strong></em>。不过，在数据库的角度，它们是两个完全独立的事务，这种跨事务的正确性保证需要应用层负责。</p>
<h3 id="11-两阶段提交">1.1 两阶段提交</h3>
<p>        <strong>两阶段提交</strong> ( $two-phase\ commit$ , $2PC$ ) 是一种在多节点之间实现事务原子提交的算法，用来确保所有节点要么全部提交，要么全部中止。<code>2PC</code>在某些数据库内存使用，或者以<code>XA</code>事务的形式提供给应用程序使用。<br>
        <code>2PC</code>引入了单节点事务所没有的新组件：协调者 ( 也被称为事务管理器 )，通常实现为共享库。<code>2PC</code>事务从应用程序在多个数据库节点上执行数据读/写开始，数据库节点称为事务的参与者。当应用程序准备提交事务时，协调者发送一个准备请求到所有节点，询问它们是否可以进行事务提交：</p>
<ul>
<li>如果所有参与者回答是，表示它们已经准备好提交，协调者会发出提交请求，所有节点开始执行事务提交；</li>
<li>如果有任何参与者回答否，协调者会放弃发送提交请求。</li>
</ul>
<p>        为了理解<code>2PC</code>，我们可以分解这个过程：</p>
<ol>
<li>应用程序启动一个分布式事务，首先向协调者请求一个全局唯一的事务<code>ID</code>；</li>
<li>应用程序在每个参与节点上执行单节点事务，并将全局唯一事务<code>ID</code>附加到事务上。此时，每个节点独立执行事务，如果有任何一个节点执行失败，协调者和其他参与者都可以安全回滚事务；</li>
<li>应用程序准备提交事务，协调者向所有参与者发送准备请求，附带全局事务<code>ID</code>。如果接收到拒绝或者超时响应，协调者会通知所有节点放弃事务；</li>
<li>参与者在收到准备请求后，检查事务是否可以提交，是否存在冲突或者违反约束。一旦向协调者返回确认响应，无论发生什么情况，都不能拒绝提交事务；</li>
<li>协调者收到所有准备请求的响应后，会将决定写入磁盘中，用于崩溃后恢复决定，这个时刻称为提交点；</li>
<li>协调者将决定写入磁盘后，向所有参与者发送提交或者放弃请求。如果请求出现失败或者超时，协调者会一种重试，直到成功。所有参与者都不能拒绝该请求，即使需要很多重试，或者中间出现崩溃。</li>
</ol>
<p>        如果参与者或者网络在<code>2PC</code>期间发生故障，比如在准备请求期间，协调者就会决定回滚事务；或者在提交请求期间，协调者会不断重试。而对于协调者故障，如果协调者在准备请求之前故障，参与者可以安全地回滚；而一旦参与者收到了准备请求并回答是，参与者便无法单方面放弃，必须一直等待协调者的决定，此时如果协调者故障，参与者便处于一种不确定的状态。理论上，参与者之间可以互相通信，了解每个参与者的投票情况，并达成一致，但是这已经不是<code>2PC</code>的范畴了。<code>2PC</code>能够顺利完成的唯一办法是等待协调者恢复，因此协调者在发送提交请求之前要将决定写入磁盘的事务日志。<br>
        <code>2PC</code>也被称为阻塞式原子提交协议，因为等待协调者从故障恢复的这个过程是阻塞的。理论上，也可以改为非阻塞的，这种称为<strong>三阶段提交</strong>。<code>3PC</code>假定一个有限的网络延迟，要求节点在规定时间内响应。然而实际情况是，网络延迟可能是无限的。通常，非阻塞原子提交依赖一个完美的故障检测器，即一种十分可靠的可以判断节点是否崩溃的机制。但是，在一个网络延迟可能是无限的场景中，超时并非一种可靠的判断机制。正常情况下，请求也可能由于网络问题而超时。正是这些原因，大家更倾向于<code>2PC</code>而非<code>3PC</code>。</p>
<h2 id="2-分布式事务实践">2. 分布式事务实践</h2>
<p>        分布式事务，尤其是那些通过<code>2PC</code>实现的事务，声誉混杂。一方面，它们提供了一种其他方案难以企及的安全保证。但是另一方面，由于操作、性能上的缺陷，以及并非完全可靠，一直被人诟病。目前，许多云服务商由于运维方面的问题而决定不支持分布式事务。分布式事务的某些实现存在严重的性能问题，例如，有报告显示<code>MySQL</code>的分布式事务比单节点事务慢 $10$ 倍以上。<code>2PC</code>性能下降的主要原因是与协调者通信带来额外的网络开销，以及为了协调者崩溃恢复做的磁盘<code>I/O</code> ( $fsync$ )。<br>
        目前存在着两种不同的分布式事务概念：</p>
<ul>
<li>数据库内部的分布式事务：某些分布式事务支持的跨数据节点的内部事务，即所有参与者节点运行着相同的数据库软件；</li>
<li>异构分布式事务：存在两种或两种以上不同参与者软件的事务，例如来自不同供应商的数据库，甚至可以是非数据库。</li>
</ul>
<p>        对于数据库内部事务，由于不需要考虑不同系统之间的兼容，可以采用任何形式的协议，并进行针对性优化，这些分布式事务往往可行。但是异构分布式事务就没那么简单了。</p>
<h3 id="21-exactly-once消息处理">2.1 <code>Exactly-once</code>消息处理</h3>
<p>        异构分布式事务旨在无缝集成多种不同的系统。例如，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息已处理完毕。这个过程是通过自动提交消息确认和数据库写入实现的。即使消息系统和数据库运行在不同节点上，分布式事务也能实现上述目标。如果消息发送失败或者某个节点事务失败，两者都必须中止。消息队列可以在之后重传消息。因此通过自动提交和消息处理结果，可以确保消息有效处理只有一次。<br>
        需要注意，只有所有相关系统都使用相同的原子性提交协议的前提下，这种分布式事务才是可行的。例如，如果处理结果之一是发送邮件，而邮件服务器不支持<code>2PC</code>，此时某个过程出错，消息重新入队重试，邮件就可能会被发送多次。</p>
<h3 id="22-xa事务">2.2 <code>XA</code>事务</h3>
<p>        <code>X/Open XA</code> ( $eXtended\ Architecture$ , $XA$ ) 是异构环境下进行<code>2PC</code>的一个工业标准。目前，许多关系型数据库 ( <code>PostgreSQL</code>、<code>MySQL</code>、<code>Oracle</code>等 ) 和消息队列 ( <code>ActiveMQ</code>、<code>MSMQ</code>、<code>IBM MQ</code>等 ) 都支持<code>XA</code>。<code>XA</code>并不是一个网络协议，而是一个与事务协调者进行通信的<code>C API</code>。当然，它也支持与其他语言的<code>API</code>绑定，例如<code>Java</code>。<br>
        <code>XA</code>假定应用程序通过网络或客户端的库函数与参与者节点进行通信，如果驱动程序支持<code>XA</code>，意味着应用程序可以调用<code>XA API</code>确定操作是否属于异构分布式事务的一部分。如果是，则发送必要的信息给数据库服务器。它还支持回调，这样协调者可以通过回调函数通知所有参与者执行准备或者提交 ( 或者中止 )。<br>
        协调者需要实现<code>XA API</code>。虽然标准没有规定如何实现，但实际上，协调者也通常是一个<code>API</code>库，与产生事务的应用程序运行在相同进程中。这些<code>API</code>跟踪事务的参与者，收集投票，并在本地磁盘中记录决定。如果应用程序发生崩溃，或者节点故障，在重启后，协调者会通过<code>XA API</code>读取日志，恢复决定。完成这些后，协调者才能继续通过回调函数来要求参与者执行提交或者中止。数据库服务器无法直接与协调者通信，必须通过相应<code>API</code>。</p>
<h3 id="23-协调者故障">2.3 协调者故障</h3>
<p>        数据库事务通常持有待修改行的行锁，用于防止脏写。此外，如果要使用串行化的隔离级别，<code>2PC</code>还会对曾经读取的行持有读锁。在事务提交之前，这些锁都不会被释放。因此，在<code>2PC</code>中，如果出现协调者故障带来的停顿，那么这些锁在停顿期间都不会被释放。长时间持有锁是一件坏事，这意味着其他事务无法有效执行，使得许多上层应用处于不可用状态。<br>
        理论上，如果协调者崩溃后重新启动，它应该可以从日志中恢复那些停顿的事务。然而，实践中，孤立的不确定事务是可能发生的，例如由于软件 $bug$ 导致交易日志丢失或者损坏。这些事务无法自己解决，而是一直停留在那里，即使重启节点也无法解决，因为<code>2PC</code>要求重启后继续保持重启前的事务状态。<br>
        唯一的办法就是让管理员手动决定提交还是回滚。这可能会带来大量的手工操作，并且可能在关键生产环境的中断间隙，存在巨大的压力和时间限制。许多<code>XA</code>的实现都支持某种紧急避险措施，称为<strong>启发式决策</strong>：允许参与者节点在紧急情况下单方面做出决定，放弃或者继续停顿的事务。这种做法可能会破坏事务的原子性，违背了<code>2PC</code>原则。要注意，这种做法只是为了应急，不能作为常规手段使用。</p>
<h3 id="24-分布式事务的限制">2.4 分布式事务的限制</h3>
<p>        <code>XA</code>事务解决了多个参与者之间达成一直的问题，但是也引入了很多操作限制。特别是，核心的事务协调者本身就是一种数据库，因此需要和其他重要的数据库一样格外小心：</p>
<ul>
<li>如果协调者不支持数据复制，在单节点上运行，那么它就是整个系统的单点故障。实际上，许多协调者并非高可用，或者只支持最基本的复制；</li>
<li>许多服务端应用程序都倾向于无状态模式 ( 更适合<code>HTTP</code> )，将所有持久状态都保存在数据库中。这样应用服务器可以轻松地添加或者删除实例。但是当协调者本身就是服务器的一部分时，协调者的日志就成为了可靠系统的重要组成部分，与数据库本身一样重要，这样的服务器本身就不是无状态的了；</li>
<li><code>XA</code>需要与各种数据系统保持兼容，最终其实是多系统可兼容的最低标准。例如，它无法检测不同系统的死锁条件 ( 这需要其他标准化协议，多个系统需要交换锁信息 )；</li>
<li>数据库内部的分布式事务比起<code>XA</code>来说，限制要少很多。然而对于<code>2PC</code>还是存在潜在的限制，比如所有参与者必须投票赞成。所以分布式事务扩大了事务失败的可能性，与构建容错系统的目标背道而驰。</li>
</ul>
<h2 id="3-共识算法">3. 共识算法</h2>
<p>        共识是让几个节点就某项提议达成一致，通常形式化描述为：一个或多个节点可以提议某些值，由共识算法来决定最终值。共识算法必须满足以下性质：</p>
<ul>
<li><strong>协商一致性</strong> ( $Uniform\ agreement$ )：所有节点都接受相同决议；</li>
<li><strong>诚实性</strong> ( $Integrity$ )：所有节点做出决定后都不能反悔，即一个决议不能有两个结果；</li>
<li><strong>合法性</strong> ( $Validity$ )：决议的结果一定是由某个节点提议的；</li>
<li><strong>可终止性</strong> ( $Termination$ )：节点在不崩溃的前提下一定可以达成协议。</li>
</ul>
<p>        如果不关心容错，满足前三个属性很容易：可以强行指定某个节点为“独裁者”，由它做出所有决定，唯一要注意的就是该节点失败的情况。上述共识的系统模型假定当某个节点崩溃后，节点就彻底消失，永远不会回来。在这种条件下，<code>2PC</code>显然不满足可终止性。当然，如果所有节点都崩溃了，那么无论哪种算法都不能继续做出决定。因此，可终止性的前提是，发生崩溃或者不可用的节点数必须小于半数节点。<br>
        最著名的共识算法包括<code>VSR</code>、<code>Paxos</code>、<code>Raft</code>和<code>Zab</code>，这些算法存在很多相似之处，但又不完全相同。它们大部分并不是直接使用形式化模式，而是决定了一系列值，再通过全序关系广播算法。全序关系广播通常指节点之间交换消息的某种协议，下面是一个非正式定义，要求满足两个基本安全属性：</p>
<ul>
<li>可靠发送：没有消息丢失，如果某个消息发送到了一个节点，那么它也要发送给其他节点；</li>
<li>严格有序：消息总是以相同顺序发送。</li>
</ul>
<p>        即使节点或者网络出现故障，全序关系广播算法的实现也必须保证以上两条。实现全序关系广播，要求消息顺序在发送前就已确定。理解全序关系广播的另一种方式是将其视为日志，传递消息就像追加日志，所有节点都可以读取日志并看到相同的消息序列。共识算法的全序关系广播相当于持续的多轮共识：</p>
<ul>
<li>由于协商一致性，所有节点以相同顺序发送相同消息；</li>
<li>由于诚实性，消息不能重复；</li>
<li>由于合法性，消息不会被破坏；</li>
<li>由于可终止性，消息不会丢失。</li>
</ul>
<p>        <code>VSR</code>、<code>Raft</code>和<code>Zab</code>都直接采取了全序关系广播，而<code>Paxos</code>则有对应的优化版本，称为<code>Multi-Paxos</code>。</p>
<h3 id="31-epoch和quorum">3.1 <code>Epoch</code>和<code>Quorum</code></h3>
<p>        目前所讨论的素有共识协议在内部都使用了某种形式的主节点，虽然主节点并不是固定的。相反，它们都采用了一种弱保证：定义一个世代编号 ( $epoch$ $number$ )，并保证在每个世代中，主节点是唯一的。如果发现当前主节点失效，节点间就开始新一轮投票，选举新的主节点。每次选举都会被赋予一个单调递增的<code>epoch</code>，如果出现了两个不同的主节点对应于不同<code>epoch</code>好，则更高<code>epoch</code>的主节点将获胜。<br>
        主节点做出任何决定前，都必须检查是否存在更高的<code>epoch</code>，否则就会产生冲突的决定。主节点如果想要做出某个决定，需要将提议发送给其他节点，等待<code>quorum</code>节点响应。<code>quorum</code>节点通常不是由多数节点组成的，并且，只有当没有发现更高<code>epoch</code>主节点存在时，才会对当前提议 ( 带有<code>epoch</code> ) 进行投票。因此，这里其实是有两轮不同的投票：首先投票决定主节点，然后再投票决定提议。其中关键一点是，两轮投票的<code>quorum</code>必须存在重叠。<br>
        投票的过程很像<code>2PC</code>，最大区别是，<code>2PC</code>并不需要通过选举产生协调者，共识算法只需要多数节点同意即可通过。此外，共识算法还定义了恢复过程，出现故障后，通过该过程即可以选举出新的主节点，重新进入一致状态。</p>
<h3 id="32-共识的局限">3.2 共识的局限</h3>
<p>        共识算法为一切不确定系统带来了明确的安全属性，还支持容错。但是这种好处也是有代价的：</p>
<ul>
<li>达成一致之前的投票是一个同步复制过程。但是对于数据库，通常为了更好的性能，会采用异步复制；</li>
<li>共识体系需要严格多数节点；</li>
<li>多数共识算法假定一组固定参与投票的节点集，意味着不能动态添加或删除节点；</li>
<li>共识系统通常依靠超时机制来检测节点失效，在网络延迟高度不确定的环境中，特别是跨区域分布的系统，经常由于网络延迟的原因，节点会被错误地认为发生了故障。虽然这种误判不会影响安全，但是频繁的主节点选举会影响性能；</li>
<li>共识算法对网络问题特别敏感。例如，<code>Raft</code>被发现存在不合理的边界处理：如果网络中存在某一条网络连接持续不可靠，它会在两个节点之间反复切换主节点，当前主节点会被不断赶下台。其他的共识算法也会有类似问题，所以面对不可靠网络，如何设计更具鲁棒性的共识算法仍然是一个开放性的研究问题。</li>
</ul>
<h3 id="33-paxos">3.3 <code>Paxos</code></h3>
<p>        <code>Paxos</code>算法运行在允许宕机的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用多数机制，在具有 $2F + 1$ 个节点的系统中，最多允许 $F$ 个节点的故障。<code>Paxos</code>具有以下系统角色：</p>
<ul>
<li>提议者 ( $Proposer$ )：提出提议，包含提议编号 ( $Proposal$ $ID$ ) 和提议值 ( $Value$ )；</li>
<li>决策者 ( $Acceptor$ )：参与决策，回应提议者的提议；</li>
<li>学习者 ( $Learner$ )：不参与决策，从其他节点学习最终的提议值。</li>
</ul>
<p>        在多副本状态机中，每个副本都是提议者、决策者和学习者。<br>
        <code>Paxos</code>算法分为两阶段：</p>
<ol>
<li>准备阶段：提议者向决策者发出准备请求，决策者针对收到的准备请求进行承诺；</li>
<li>决策阶段：提议者在接收到多数决策者的回应 ( $Promise$ ) 之后，向决策者发出提议请求，决策者收到请求后处理；</li>
<li>学习阶段：提议者在接收到多数决策者的决策之后，标记本次决策成功，将提议值发送给所有学习者。</li>
</ol>
<p>        决策者会对提议者的准备请求做出两个承诺和一个回应：</p>
<ul>
<li>承诺不再接收<code>ID</code>小于等于当前准备请求<code>ID</code>的准备请求；</li>
<li>承诺不再接收<code>ID</code>小于当前准备请求的决策请求；</li>
<li>回应之前接收过的<code>ID</code>最大的提议的<code>ID</code>和提议值。</li>
</ul>
<p>        原始的<code>Paxos</code>算法只能对一个值进行决策，每次决策需要至少两次收发请求，在高并发场景下可能需要更多次沟通，极端情况下还会形成<strong>活锁</strong>，即两个提议者交替发起请求，不断递增 $Proposal$ $ID$ 。因此，这种<code>Paxos</code>只适合理论研究，不适合应用在实际生产环境中。<br>
        实际生产环境中往往需要连续确定多个值，而且具有更高效率。<code>Multi-Paxos</code>就是为此提出的，它作出了两点改进：</p>
<ul>
<li>针对每个提议者，生成一个 $Instance$ $ID$ ，每个提议者由一个<code>ID</code>标识；</li>
<li>在所有提议者中选举一个主节点，由主节点将提议提交给决策者进行决策。这样就可以跳过准备请求阶段，因为实际上只有一个提议者会提议。</li>
</ul>
<p>        <code>Multi-Paxos</code>首先需要选举一个主节点，选举的过程也可以通过<code>Paxos</code>算法决策，一种简单的方式如下：</p>
<ul>
<li>具有最高<code>ID</code>的服务器作为主节点，每个服务器定时向其他服务器发送心跳消息检查状态；</li>
<li>如果没有收到比它高的<code>ID</code>的节点的心跳消息，它就会尝试发起一轮选举，选举自己作为领导者；</li>
<li>非主节点只会作为决策者，提议者只有主节点一个。</li>
</ul>
<p>        <code>Multi-Paxos</code>通过改变准备阶段的作用范围，使得多个实例的提交只需要一次决策，将两阶段变为一阶段，提高了效率。即使存在多个主节点 ( 脑裂 )，也不影响安全性，这时候只是会退化为原始的<code>Paxos</code>。</p>
<h3 id="34-raft">3.4 <code>Raft</code></h3>
<p>        <code>Raft</code>实现了和<code>Paxos</code>相同的功能，将共识问题分解为多个子问题，使用了更强的假设来减少需要考虑的状态。<code>Raft</code>将系统分为以下角色：</p>
<ul>
<li>领导者 ( $Leader$ )：接收客户端请求，同步给跟随者，当同步到多数节点后提交请求；</li>
<li>跟随者 ( $Follower$ )：接收并持久化领导者的请求，在接收到领导者的提交请求后，进行提交；</li>
<li>候选人 ( $Candidate$ )：可以参与选举的节点。</li>
</ul>
<p>        <code>Raft</code>算法只允许一个领导者的存在。节点之间存在心跳检测，如果跟随者长时间没有接收到来自领导者的心跳消息，则会开启新一轮选举。收到多数投票的候选人会称为新的领导者，直到其出现故障。<code>Raft</code>通过任期 ( $term$ ) 管理选举，任期通过时间划分，每个 $term$ 的开始都是选举，选举完成后，在这个任期内领导者会负责管理集群。<br>
        <code>Raft</code>拥有两条限制，用于保证安全性：</p>
<ul>
<li>拥有最大偏移量的候选人才可以成为领导者。这要求候选人在选举中发送自己的偏移量；</li>
<li>只允许提交当前任期的请求，之前任期的无法不能再提交。这要求领导者在请求中带上任期。</li>
</ul>
<h2 id="4-成员与协调服务">4. 成员与协调服务</h2>
<p>        <code>ZooKeeper</code>或者<code>etcd</code>这样的项目通常称为“分布式键值存储”或者“协调与配置服务”。它们对外提供的<code>API</code>与数据库非常相像：读取、写入对应主键值，或者按序便利主键。应用程序开发者其实很少直接使用<code>ZooKeeper</code>，因为它并非通用数据库，绝大部分通过其他项目来间接依赖，比如<code>HBase</code>、<code>Hadoop YARN</code>、<code>Kafka</code>等。<code>ZooKeeper</code>和<code>etcd</code>主要针对保存少量、可完全载入内存的数据 ( 即使最终还是要写入磁盘 )，不适合用于保存大量数据。它们通常采用容错的全序广播算法在所有节点上复制数据从而实现高可靠。<code>ZooKeeper</code>的实现其实模仿了<code>Google</code>的<code>Chubby</code>分布式锁服务，不仅实现了全序广播，还提供了其他有趣的特性：</p>
<ul>
<li>线性化的原子操作：使用<code>CAS</code>操作，实现加锁服务。例如多个节点同时尝试执行相同操作，则确保只会有一个节点成功。共识算法满足了原子性和线性化，即使某些节点发生故障或者网络中断。分布式锁通常是一个带有过期时间的租约，保证即使某些客户端故障也可被释放；</li>
<li>操作全序：<code>fencing</code>令牌保证每次加锁的数字总是单调递增的，<code>ZooKeeper</code>会对所有操作执行全局排序，为每个操作赋予一个唯一的事务<code>ID</code>和版本号；</li>
<li>故障检测：客户端与<code>ZooKeeper</code>之间会维持一个长期会话，客户端会周期性地与<code>ZooKeeper</code>服务节点互相交换心跳信息，以检查对方是否存活。即使出现连接中断，或者某个<code>ZooKeeper</code>节点失效，会话仍处于活动状态。如果连接断开时间超过了超时时间，<code>ZooKeeper</code>会声明会话失败，此时该会话持有的所有锁资源会被自动释放 ( 即<code>ZooKeeper</code>中的临时节点 )；</li>
<li>更改通知：客户端不仅可以读取其他客户端所创建的锁和键值，还可以监视它们的变化。因此，客户端可以知道其他客户端何时加入了集群，以及客户端是否发生了故障。通过订阅机制，客户端不需要频繁轮询服务。</li>
</ul>
<h3 id="41-节点任务分配">4.1 节点任务分配</h3>
<p>        <code>ZooKeeper</code>和<code>Chubby</code>的一个非常适合的场景是，如果系统有多个流程或服务的实例，并且需要其中一个实例充当主节点，在主节点失效时由其他节点接管。显然，这是主从模型的特征。此外，它对于作业调度系统也十分有用。还有另一个场景，对于一些分区资源 ( 数据库、消息流、文件存储等 )，需要决定节点分区分配。当有新节点加入集群时，需要将某些现有分区从当前节点迁移到新节点，从而实现动态的负载均衡。<br>
        上述场景都可以借助<code>ZooKeeper</code>的原子操作 ( 临时节点和订阅机制 ) 来实现。应用程序最初可能只运行在单节点，之后扩展到数千节点。在这么多节点上进行投票是很低效的。而<code>ZooKeeper</code>通常是在固定数量的节点上运行，可以非常高效的支持大量客户端。通常，<code>ZooKeeper</code>管理的数据变化十分缓慢，更改频率往往是分钟级甚至小时级，如果需要频繁修改，应该考虑其他工具。</p>
<h3 id="42-服务发现">4.2 服务发现</h3>
<p>        <code>ZooKeeper</code>、<code>etcd</code>和<code>Consul</code>经常用于服务发现。在典型的云环境中，虚拟机可能会动态变化，这时无法提前知道服务节点的<code>IP</code>地址，因此，可以在每次节点启动时将网络端口信息向<code>ZooKeeper</code>等服务注册，其他人只需要向<code>ZooKeeper</code>的注册表请求即可。<br>
        但是，关于服务发现是否需要共识还缺乏统一认识，习惯上是通过<code>DNS</code>来将服务名称转为<code>IP</code>。从<code>DNS</code>读取肯定不满足线性化，然而现实情况是，如果<code>DNS</code>返回的是过期值也不会有什么大问题。总体来讲，<code>DNS</code>更看重网络中断时的可用性和鲁棒性。</p>
<h3 id="43-成员服务">4.3 成员服务</h3>
<p>        <code>ZooKeeper</code>还可以作为成员服务的一部分，用于确定当前哪些节点处于活动状态，并且是集群的有效成员。这里依然存在误判的可能，即使这样，系统就成员资格的认识是一致的。</p>

            </div>
            <div class="meta post-footer">
                <span>2022 Nov 13 16:18</span>
                <a href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9/">分布式数据系统：主从节点</a></h1>
            <div class="post-content">
                
                
                <h2 id="1-主从模式">1. 主从模式</h2>
<h3 id="11-同步复制">1.1 同步复制</h3>
<p>        对于关系型数据库，同步或者异步通常是一个可选项，而其他系统可能是硬性指定二选一。<br>
        同步复制的优点是：一旦向用户确认，从节点可以保证已经完成了与主节点的同步，数据已经处于最新版本。如果主节点发生故障，总是可以确保之后继续访问从节点的数据一定是最新的。缺点是：如果同步的从节点无法确认成功，整个写入就不能成功，主节点会阻塞之后的所有写操作，直到同步副本确认。由于该缺点的存在，把所有从节点都配置为同步复制有些不切实际。在实践中，如果数据库启用了同步复制，通常意味着其中某个从节点是同步的，其他从节点则是异步的。如果同步的从节点不可用或者性能下降，则将另一个从节点升级为同步。这样可以保证至少有两个节点拥有最新的数据，这种配置也被称为<strong>半同步</strong>。<br>
        在主从模式下，如果要提高读性能，需要添加更多的从节点。但是，这种方式实际上只能用于异步模式，因为随着从节点的增加，全同步模式需要同步的从节点数量也会增加，任何单节点的故障或者网络中断都会导致整个集群无法写入，节点的增加也会提高故障机率，所以全同步模式在实践中是非常不可靠的。</p>
<h3 id="12-异步复制">1.2 异步复制</h3>
<p>        主从复制通常会被配置为全异步模式。此时，如果主节点失败且不可恢复，则所有尚未同步的从节点的写请求都会丢失，即使已经向客户端确认了写操作完成，仍然无法保证数据的持久化。全异步模式的优点是，不管从节点的数据多么滞后，总是可以继续响应写请求，具有较高吞吐性。异步模式听起来很不靠谱，但是却被广泛使用，特别是那些从节点数据巨大，或者分布于广域地理环境的情况。<br>
        异步模式下节点的数据同步可能存在滞后，意味着对主节点和从节点同时发起相同的查询，返回的结果可能是不一致的。但是，这种不一致只是暂时的状态，在不写数据库的情况下，从节点最终会与主节点的数据保持一致，这种效应也被称为<strong>最终一致性</strong>。<br>
        理论上，复制的滞后并没有上限。正常情况下，这个延迟可能不到 $1s$ ，实践中通常不会有太大影响。但是，如果系统的性能抵达上限，或者存在网络问题，延迟可能会达到几秒甚至几分钟。</p>
<h4 id="121-读写一致性">1.2.1 读写一致性</h4>
<p>        许多应用让用户提交数据，并在之后查询这些数据。用户向主节点提交数据后，之后的查询可能是在从节点上，在大多数情况下，这是个很合适的方案。然而，异步模式下，同步可能存在滞后，意味着，返回的数据是旧数据，在用户看来，代表他刚刚提交的数据丢了。<br>
        这种情况，我们需要<strong>读写一致性</strong>，或者叫<em><strong>写后读一致性</strong></em>。该机制保证，如果用户重新加载页面，总是能看到最近提交的更新。有几种方式可以实现读写一致性：</p>
<ul>
<li>如果用户访问可能会被修改的内容，从主节点读取。这种方式要球一些方法在执行实际查询前，就知道内容是否改变。比如，社交网络上的用户信息通常只能由所有者编辑，因此，可以让用户总是从主节点读取自己的用户信息，从节点读其他人的用户信息；</li>
<li>如果应用的大部分内容都可以被所有用户修改，这种方式就不太有效了。此时需要其他方式来判断，比如跟踪更新时间，在更新后的一分钟内，总是从主节点读取；或者监控从节点的复制滞后程度，避免从滞后超过一分钟的从节点读取数据；</li>
<li>客户端记录最近更新的时间戳，附带在请求中，节点可以通过该时间戳确保返回该时间戳之后的更新，如果无法返回，交由另外一个节点处理。时间戳可以是逻辑时间戳 ( 比如日志序列号 ) 或者实际系统时间；</li>
<li>如果副本分布在多个数据中心，这时情况会比较复杂，应当将请求路由到主节点所在的数据中心，即使该数据中心可能离用户距离很远。</li>
</ul>
<p>        如果同一用户从多端访问 ( 比如<code>Web</code>端和移动端 )，情况就更加复杂了，不仅要提供跨设备的读写一致性，还有新问题：</p>
<ul>
<li>时间戳方式难以实现，因为一台设备并不知道另一台设备的操作，如果需要实现时间戳方式，元数据需要做到全局共享；</li>
<li>如果副本分布在多数据中心，无法保证来自不同设备的连接路由到同一个数据中心。</li>
</ul>
<h4 id="122-单调读">1.2.2 单调读</h4>
<p>        假定用户发起多次读取，读请求可能会被路由到不同节点，则可能会出现请求返回不同结果的情况。<strong>单调读</strong>一致性可以确保不会发生这种异常。单调读一致性比强一致性弱，但是比最终一致性强。读取数据时，单调读保证同一个用户一次发起的多次读取不会看到回滚 ( 数据不一致 ) 现象。一种实现单调读的方式是：确保每个用户总是固定读同一个节点，例如基于用户<code>ID</code>哈希。</p>
<h4 id="123-前缀一致读">1.2.3 前缀一致读</h4>
<p>        用户发起两个请求，后一个请求的内容依赖于前一个请求，比如用户先写入 $1$ ，再递增为 $2$ 。从用户的角度，这个顺序没有问题。但是在其他观察者的角度，可能会存在逻辑问题，比如由于网络延迟，观察者先观察到后一个请求，这时顺序就变成了用户先写入 $2$ ，再写入 $1$ 。为了防止这种异常，需要引入<strong>前缀一致性</strong>，即对于一系列按照某个顺序发起的写请求，读取的时候也应该按照这个顺序。<br>
        这个问题是存在于分区数据库的一个特殊问题。如果数据库总是以相同的顺序写入，那么读取的时候看到的会是一致的序列。但是，分区数据库的不同分区之间是独立运行的，所以没有一个全局的写入顺序，导致用户读取的时候，会读到一部分新值和一部分旧值。一种解决方案是：将所有具有因果关系的写入都交给同一个分区完成，但是会导致效率大打折扣。</p>
<h3 id="13-节点失效">1.3 节点失效</h3>
<h4 id="131-从节点失效">1.3.1 从节点失效</h4>
<p>        从节点的磁盘上保存了数据变更日志，如果从节点崩溃，或者与主节点之间发生暂时性的网络中断，可以通过该日志获取故障前处理的最后一个事务，向主节点请求该事务之后的中断期内所有数据变更，将其应用到本地即可，之后就可以像正常情况一样持续接收来自主节点的数据流变化。</p>
<h4 id="132-主节点失效">1.3.2 主节点失效</h4>
<p>        主节点失效，则需要选择某个从节点，将其提升为主节点。同时，客户端也要将之后的写请求发送给新的主节点。故障切换可以是手动的，也可以是自动的，自动切换的步骤如下：</p>
<ol>
<li>确认主节点失效。主节点可能出于多种原因失效，比如系统崩溃、停电、网络中断等，并没有什么办法可以检测出失效原因，所以大多数系统都采用了超时机制判断。节点间会持续地互相发送心跳消息，如果发现某个节点在一段时间 ( 比如 $30s$ ) 内都没有响应，就认为该节点已经失效；</li>
<li>选举新的主节点。新的主节点可以通过一种共识算法来选举，或者由控制节点指定。候选节点最好是与主节点之间数据差异最小的，从而最小化数据丢失的风险；</li>
<li>重新配置系统使得新主节点生效。客户端需要将写请求发送给新的主节点，如果原来的主节点之后重新上线，需要将其降级为从节点，并认可新的主节点。</li>
</ol>
<p>        切换过程中可能存在很多变数：</p>
<ul>
<li>如果使用异步复制，新的主节点相比原主节点的数据存在滞后，在选举完成后，原主节点又很快恢复并加入集群，接下来的写操作要怎么处理？新的主节点可能会收到冲突的写请求，因为原主节点并没有意识到发生了主节点切换，仍然会尝试同步其他从节点。一种常见的解决方案是，直接丢弃这些冲突的写请求，虽然这会违背数据更新持久化的承诺；</li>
<li>如果有其他依赖于数据库的组件在一起协同使用，丢弃数据的方案就很危险。例如，在<code>GitHub</code>的一个事故中，主节点在未完全同步的情况下失效，新主节点被选举，由于存在滞后，原主节点已经分配出去，存储在<code>Redis</code>中的自增主键，被新主节点再次使用，导致了<code>MySQL</code>与<code>Redis</code>之间的数据不一致；</li>
<li>某些情况下，可能会发生两个节点都认为自己是主节点的情况，称为<strong>脑裂</strong>。脑裂非常危险，它可能会导致两个主节点同时接收写请求，并且没有很好的解决数据冲突，导致数据被丢失或者被破坏。有些系统会通过强制关闭其中一个节点的方式，来解决脑裂问题。然而，如果设计或者实现考虑不周，也是有可能出现两个节点都被关闭的情况；</li>
<li>如果设置超时时间？超时时间越厂，确认主节点失效的时间也就越长，意味着总体的恢复时间就越长。例如，突发的负载峰值会导致节点的响应时间变长甚至超时，或者由于网络故障导致延迟增加，如果这时系统已经处于高负载情况，或者网络严重拥堵的情况，不必要的切换只会使情况更糟。</li>
</ul>
<h3 id="14-日志">1.4 日志</h3>
<h4 id="141-语句复制">1.4.1 语句复制</h4>
<p>        主节点记录执行的写请求语句，将该操作语句作为日志，发送给从节点。在关系型数据库中，意味着发送 $INSERT$ 、$UPDATE$ 等语句，从节点分析并执行这些语句，像来自客户端那样。基于语句复制存在一些不适用场景：</p>
<ul>
<li>调用非确定性函数的语句，比如 $NOW(\ )$ 或者 $RAND(\ )$ 函数，这会导致在不同副本产生不一样的值；</li>
<li>依赖于自增列，或者现有数据的语句，这意味着所有副本必须按照完全相同的顺序执行，否则会产生不同的结果。进而，如果存在多个并发事务，也会影响事务之间的执行；</li>
<li>存在副作用的语句（如触发器、存储过程、用户定义函数等），可能会在不同副本上产生不同副作用。</li>
</ul>
<p>        这些问题可以采取某些措施来解决，比如主节点记录操作语句时将非确定性函数替换为确定结果。遗憾的是，存在太多边界条件，因此基于语句的复制通常不是首选。</p>
<h4 id="142-wal">1.4.2 <code>WAL</code></h4>
<p>        通常，数据库的每个写操作，都会以追加形式写入<code>WAL</code>日志中，可以使用完全相同的日志在另一个节点上构建副本，即主节点不仅将<code>WAL</code>日志写入磁盘，还会通过网络发送给从节点。<br>
        基于<code>WAL</code>复制的缺点是日志描述的数据结果非常底层，比如关系型数据库，<code>WAL</code>会记录磁盘块的哪些字节发生改变，以及其他细节等，从而与具体的存储方案高度耦合，如果数据的存储格式发生了改变，之前的同步方式也会失效。如果复制协议允许从节点的软件版本比主节点更新，那么可以实现数据库软件的不停机升级；相反，如果要求版本严格一致，那么升级就只能以停机为代价。</p>
<h4 id="143-行复制">1.4.3 行复制</h4>
<p>        基于行的复制将复制和存储引擎分离，复制与存储引擎采用不同的日志，这时复制日志称为逻辑日志。</p>
<ul>
<li>对于行插入，日志包含所有相关列的新值；</li>
<li>对于行删除，日志应该以某种方式标识已删除的行 ( 通常是主键 )；</li>
<li>对于行更新，日志应该以某种方式标识被更新的行，以及被更新列的新值。</li>
</ul>
<p>        如果一个事务涉及多行数据修改，就会产生多条行日志，并在之后跟着一条记录，指出该事务已经提交。<code>MySQL</code>的<code>binlog</code>支持该种方式。由于逻辑日志与存储引擎解耦，因此数据库存储可以向后兼容，主从节点可以基于不同版本的软件，甚至是不同存储引擎运行。<br>
        对于外部应用，逻辑日志也更容易被解析。解析逻辑日志也被称为变更数据捕获。</p>
<h4 id="144-触发器">1.4.4 触发器</h4>
<p>        在某些时候，我们可能需要一种具有更高灵活性的复制方式，比如只复制一部分数据，或者从一个数据库复制到另一种数据库，或者指定冲突解决逻辑等，这种情况下，可以借助许多关系数据库都支持的功能：触发器和存储过程。触发器支持注册自己的应用层代码，当数据库系统发生数据改变时，自动执行这些代码。基于触发器的复制通常具有比其他方式更高的开销，也更容易出错。</p>
<h2 id="2-多主模式">2. 多主模式</h2>
<p>        目前为止，我们只考虑了单主节点的主从复制架构，这也是较为常见的方式。但是，也存在一些其他方式。主从复制的缺点很明显：只存在一个主节点，所有写入都必须经过主节点。如果存在某种原因，比如网络中断等，导致主节点无法连接，那么整个集群的写入都会受到影响。</p>
<h3 id="21-多主节点">2.1 多主节点</h3>
<p>        多主节点是一种对主从复制模型的扩展，允许配置多个主节点，每个主节点都可以接收写操作，并将数据更改转发到其他节点。这样，每个主节点既扮演主节点，也扮演其他主节点的从节点。<br>
        多主节点存在以下适用场景：</p>
<ul>
<li>多数据中心：为了容忍数据中心级别的故障，或者在地理上更接近用户，可以把数据库的副本横跨多个数据中心。在常规的主从复制模式中，主节点只能放在其中一个数据中心，而多主节点允许在每个数据中心都配置一个主节点。这样每个写操作都可以在本地数据中心内快速响应，并且，同数据中心之间的网络性能和稳定性通常会更好，意味着用户的体验也会更好。但是这种情况也要考虑用户同时修改相同数据的情况，必须解决潜在的写冲突；</li>
<li>离线客户端操作：如果应用需要在网络断开后继续工作，那么应当在设备提供一个充当主节点的本地数据库，所有设备之间采用异步方式同步副本，滞后时间可能是几小时或者数天。从架构层面来看，这基本上等同于数据中心之间的多主复制，但是数据中心的概念缩小到了某个具体设备上，并且网络连接十分不可靠；</li>
<li>协作编辑：实时协作编辑应用允许多个用户同时编辑文档，虽然这不能完全等价于数据库复制，但是在很多方面具有相似性。用户编辑文档时需要将修改立即应用到本地副本，再通过异步方式同步到服务器，以及一起编辑文档的其他用户。要确保不会发生编辑冲突，应用程序需要将文档锁定，再进行编辑。这也意味着一个用户要编译时，必须先等另一个用户提交修改并释放锁。为了加快编辑效率，锁的粒度应该很小，单个按键甚至可以是全程无锁的。</li>
</ul>
<h3 id="22-写冲突">2.2 写冲突</h3>
<p>        多主复制的最大问题是存在写冲突。</p>
<h4 id="221-同步与异步检测">2.2.1 同步与异步检测</h4>
<p>        如果是主从复制，发生冲突时，第二个写请求会被阻塞，直到第一个完成，或者被中止。在多主节点模式下，这两个写请求都会成功，并且只能在之后的异步检测时才能发现冲突。理论上，同步检测冲突也是可行的，但是需要写请求等待所有副本完成同步，反而会失去多主节点的优势。</p>
<h4 id="222-冲突避免">2.2.2 冲突避免</h4>
<p>        如果应用层可以保证对某个特定记录的写总是经过同一节点，就不会发生冲突。实践中，不少主节点复制模型锁实现的冲突解决方案存在瑕疵，因此，冲突避免通常是首选方案。比如，一个用户需要更新自己的数据，我们可以通过用户<code>ID</code>哈希的方式，保证同一个用户的写请求总是发送到同一个数据中心。从用户角度来看，等同于主从复制。有时候，可能需要改变指定的节点，比如数据中心故障，或者用户漫游到另一个位置，需要换到更近的数据中心，这时这种方案就不再有效了。</p>
<h4 id="223-一致收敛">2.2.3 一致收敛</h4>
<p>        主从模型下，数据更新符合顺序性原则，即对同一个字段的多次更新，字段最终值由最后一个更新操作决定。多主节点模型中，由于不存在这个顺序，所以最终值也是不确定的。如果每个副本都是按照其看到的顺序写入，那么数据最终可能会不一致。因此，数据库必须以一种收敛趋同的方式解决冲突，这也意味着所有更改被复制、同步之后，所有副本的最终值相同。一致收敛有如下解决方案：</p>
<ul>
<li>为写入分配一个唯一<code>ID</code>，比如时间戳、哈希或者随机数，选择<code>ID</code>最大的作为胜者，丢弃其他写入。如果基于时间戳，则称为最后写入者获胜。虽然这种方法很常见，但是容易造成数据丢失；</li>
<li>为每个副本分配一个<code>ID</code>，制定一个规则，比如<code>ID</code>较大的副本写入优于<code>ID</code>较小的副本。同样的，这种方式也会导致数据丢失；</li>
<li>通过某种方式将值合并，比如字母顺序排序等；</li>
<li>利用预定义格式记录和保留冲突信息，再通过应用层逻辑解决冲突，可能会经过用户。</li>
</ul>
<h4 id="224-自定义冲突解决逻辑">2.2.4 自定义冲突解决逻辑</h4>
<p>        解决冲突最合适的还是依赖于应用层代码，所以大多数多主模型都支持用户编写应用代码解决冲突：</p>
<ul>
<li>写入时执行：数据库系统在复制变更日志时检测到冲突，调用应用层代码解决；</li>
<li>读取时执行：写入时保留冲突值，读取时返回多个版本的数据，应用层可能自动解决冲突，或者将冲突交给用户解决，并将最终结果返回给数据库。</li>
</ul>
<p>        冲突解决通常针对某一行或者某个文档，而不是整个事务。如果有一个原子事务包含多个不同写请求，每个写请求仍然需要分开来考虑。</p>
<h3 id="23-拓扑结构">2.3 拓扑结构</h3>
<p>        多主模式下，写请求从一个节点传播到其他节点的路径，可以通过<strong>拓扑结构</strong>描述。最常见的拓扑结构是全链路拓扑：主节点将写入同步到其他所有主节点。除此之外，还存在着其他一些拓扑结构，例如，默认情况下<code>MySQL</code>只支持环形拓扑结构，即所有主节点围成一个环，每个节点只接收来自前序节点的写入，只会写后续节点。星形结构也是另一种流行的拓扑结构，一个指定的根节点会将写入转发给所有其他节点，其他节点只会写该根节点。类似的，也可以对星形结构进行推广，拓展到树形结构。<br>
        环形结构和星形结构下，写请求需要通过多个节点才能到达所有副本，中间节点需要转发从其他节点收到的数据变更。为了防止循环，每个节点需要一个唯一<code>ID</code>，并在变更日志中标识已经经过的节点<code>ID</code>。环形和星形的问题是，如果某个节点发生故障，会影响其他节点的转发。可以通过重新配置的方式排除故障节点。全链路拓扑也有自己的问题，通常发生在网络拥塞的情况下，某些网络链路可能会比其他网络链路更快，导致变更日志的互相覆盖。</p>
<h2 id="3-无主模式">3. 无主模式</h2>
<p>        目前为止讨论的所有复制方法，都要求客户端先向主节点发送写请求，再由数据库复制到其他副本。主节点决定写顺序，从节点重放。一些数据存储系统则采取了不同的思路，放弃主节点，允许任何节点接收来自客户端的写请求。最早的数据复制系统就是无主节点的，但是在后来被渐渐遗忘了，当亚马逊采用<code>Dynamo</code>系统之后，无主模式又成为了一种时髦的架构，<code>Riak</code>、<code>Cassandra</code>和<code>Voldemort</code>都是受<code>Dynamo</code>启发设计的无主节点的开源数据库系统，也被称为<code>Dynamo</code>风格数据库。<br>
        在一些无主节点实现中，客户端直接将写请求发送给多副本。而在一些其他实现中，会有一个协调者代表客户端写入。与主节点不同，协调者并不负责维护写入顺序。</p>
<h3 id="31-节点失效">3.1 节点失效</h3>
<p>        假设存在一个三副本数据库，一个副本不可用。用户向三个副本发起写请求，有两个副本成功确认，一个副本无法处理。用户在接收到两个成功确认后，认为写入成功。之后，失效节点重新上线，由于滞后数据尚未同步，客户端读取该节点数据，会得到过期数据。一种解决方式是，客户端读取时，不是只向一个副本发起请求，而是并行向多个副本发起请求，并通过版本号来确定哪些值更新。</p>
<h4 id="311-读修复和反熵">3.1.1 读修复和反熵</h4>
<p>        节点失效滞后重新上线，由于数据滞后，所以需要重新同步。<code>Dynamo</code>风格数据库通常使用以下两种机制：</p>
<ul>
<li>读修复：客户端并行读取多个副本时，可以通过版本号等方式，检测过期的返回值；</li>
<li>反熵：一些数据存储的后台进程会不断检测副本之间的数据差异，同步滞后的数据。与主从同步不同，这种方式并不保证顺序写入，并且会有明显的同步滞后。</li>
</ul>
<p>        要注意的是，并非所有的数据库都支持以上机制，例如<code>Voldemort</code>没有反熵。</p>
<h3 id="32-quorum">3.2 <code>quorum</code></h3>
<p>        如果有 $n$ 个副本，写入需要 $w$ 个节点确认，读取必须至少要查询 $r$ 个节点，则只需要 $w + r$ &gt; $n$ 就可以确保读取的节点一定会包含最新值。满足这些的 $r$ 、$w$ 值称为法定票数读 ( 或仲裁读 ) 或法定票数写 ( 或仲裁写 )。也可以认为 $r$ 和 $w$ 是用于判定读、写是否有效的最低票数。<br>
        在<code>Dynamo</code>风格数据库中，$n$ 、$r$ 和 $w$ 通常是可以配置的，常见的是配置 $n$ 为奇数，$w = r = \lceil (n + 1) / 2 \rceil$ ，也可以根据需求灵活调整。$w + r$ &gt; $n$ 定义了系统可容忍的失效节点数：</p>
<ul>
<li>$w$ &lt; $n$ ，如果一个节点不可用，仍然可以处理写入；</li>
<li>$r$ &lt; $n$ ，如果一个节点不可用，仍然可以处理读取；</li>
</ul>
<p>        如果可用节点数小于 $r$ 或者 $w$ ，写入或者读取就会返回错误。通常 $r$ 和 $w$ 会被设置为简单多数节点，但是<code>quorum</code>并不一定要求多数，只要读写节点之间存在重合节点即可。即使在 $w + r$ &gt; $n$ 的情况下，也可能存在返回旧值的边界条件：</p>
<ul>
<li>采用了 $sloppy\ quorum$ 的写操作节点和读操作节点可能完全不同，从而无法保证存在重合节点；</li>
<li>如果两个写操作同时发生，无法确定顺序，这时唯一安全的解决方案是合并写入。如果根据时间戳选择，会存在时钟不一致的问题；</li>
<li>如果读写同时发生，写操作可能只在一部分副本上进行，读取时返回的是新值还是旧值并不确定；</li>
<li>如果某些副本上写入成功，另一些副本写入失败，并且总成功副本数少于 $w$ ，已成功副本不会回滚，意味着之后的读操作可能返回已失败的新值；</li>
<li>如果具有新值的节点失效，之后重新加入集群后恢复的数据来自旧值，那么新值的副本数就会少于 $w$ ；</li>
<li><code>quorum</code>也存在一些线性化读取的问题。</li>
</ul>
<p>        <code>Dynamo</code>风格数据库是针对最终一致性场景设计的，$w$ 和 $r$ 不应该是一种绝对保证，而是一种可以灵活调配的配置。配置适当<code>quorum</code>的数据库系统可以容忍某些节点故障，也不需要执行故障切换。它还可以容忍某些节点变慢，因为请求并不需要等待所有 $n$ 个节点响应。对于一些需要高可用和低延迟的场景，还可以容忍偶尔读取旧值。<br>
        但是，<code>quorum</code>并不是总会提供高容错能力，一个网络中断可以很容易切断客户端到多数节点的连接。在断掉连接的客户端看来，相当于集群全部失效。在一个大规模集群中，客户端可能在网络中断时还可以连接到某些节点，但是这个节点数量又不能满足仲裁，数据库就面临一个选择：直接返回错误还是接收写请求并写入暂时可访问的节点？后一种方式称为<em><strong>宽松的仲裁</strong></em>：读写仍然需要 $r$ 和 $w$ 个成功的响应，但包含了那些并不在先前指定的 $n$ 个节点的响应。一旦网络问题解决，临时节点需要把接收到的所有写入发送给原始节点，即数据回传。$sloppy\ quorum$ 并非传统 $quorum$ ，更像是为了保证数据持久性设计的一个保证措施，除非回传结束，否则无法保证客户端一定能从 $r$ 个节点中读到新值。</p>
<h2 id="4-并发写">4. 并发写</h2>
<p>        <code>Dynamo</code>风格数据库允许多个客户端对相同主键发起写操作，意味着写冲突的存在。此外，读修复或者反熵也会导致写冲突。一个核心问题是，由于网络延迟或者部分节点失效，请求在不同节点上的顺序是不同的。如果节点每次收到写请求时就直接覆盖原有值，那么这些节点将永远也无法一致。</p>
<h3 id="41-最后写入者获胜">4.1 最后写入者获胜</h3>
<p>        一种实现收敛的方法是，每个副本总是保留最新的值。假定每个写请求都会最终同步到每个副本，我们需要一个明确的方法来确定哪个写入是最新的。多个客户端向节点发送请求时，一个客户端无法发现另一个客户端，也不知道哪个请求先发起。既然无法确定请求的自然排序，我们可以强制以某种方式排序，比如以时间戳排序。这种解决方法称为<strong>最后写入者获胜</strong> ( $last\ write\ wins$ , $LWW$ )。<code>LWW</code>可以实现最终收敛，代价是数据持久性。如果同一个主键有多个并发写，即使这些写都返回成功，但是最后只会有一个值获胜，其他的将被丢弃。<br>
        在一些场景，比如缓存中，覆盖写是可以接受的。如果覆盖、丢失不可接受，<code>LWW</code>就不是很好的解决方案了。确保<code>LWW</code>安全无副作用的唯一方法是，只写一次然后将写入值视为不可变。例如，<code>Cassandra</code>的一个推荐使用方法就是使用<code>UUID</code>作为主键，这样每个写操作都针对不同、系统唯一的主键。</p>
<h3 id="42-happens-before">4.2 Happens-before</h3>
<p>        如何判断两个操作是否并发，可以通过以下两个例子分辨：</p>
<ul>
<li>一个插入操作发生在增量修改操作之前，并且增量操作基于插入的行，也就是这两个操作间存在因果关系；</li>
<li>多个设备同时写入，一个设备并不知道另一个设备是否也对同一个主键进行写入，即操作间不存在因果关系。</li>
</ul>
<p>        如果操作 $B$ 知道操作 $A$ ，或者 $B$ 依赖于 $A$ ，则称 $A$ 和 $B$ 之间存在<code>Happens-before</code> ( 先序发生 ) 关系，这就是定义并发的关键。因此，对于两个操作 $A$ 和 $B$ ，存在三种可能：$A$ 先发于 $B$ 、$B$ 先发于 $A$ 、$A$ 和 $B$ 并发。如果属于并发，就需要解决潜在的冲突问题。</p>
<h3 id="43-合并并发写的值">4.3 合并并发写的值</h3>
<p>        通过版本号，服务器可以在不依赖值的情况下判断写是否并发。流程如下：</p>
<ul>
<li>服务器为每个主键维护一个版本号，每当主键新值写入时递增版本号；</li>
<li>客户端读取时，服务器返回所有值以及最新版本号，并且在客户端写之前，要求必须先进行一次读；</li>
<li>客户端写主键，写请求必须包含之前读到的版本号、读到的值和新值合并之后的集合。写请求可以返回当前值；</li>
<li>服务收到写请求时，根据版本号，选择性地覆盖该版本号或者更低版本的所有值 ( 这些值已经被合并到更高版本集合中 )。</li>
</ul>
<p>        如果写请求带有版本号，说明它修改的是以前的状态。如果没有版本号，将会与其他操作同时进行，不会覆盖已有值。<br>
        上述算法适用于单副本的情况，但是对于多副本的情况，它们之间的版本号并不相同。为了保证一致，我们需要为每个副本和每个主键均定义一个版本号。每个副本在写入时增加自己的版本号，跟踪从其他副本看到的版本号。所有副本的版本号集合称为<strong>版本矢量</strong>。当读取数据时，版本矢量会被返回给客户端，并在随后写入时包含在请求中一起发送给数据库。</p>

            </div>
            <div class="meta post-footer">
                <span>2022 Nov 6 15:24</span>
                <a href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/cpptemplates7/">C&#43;&#43; Templates（7）：深入模版基础</a></h1>
            <div class="post-content">
                
                
                <h2 id="1-参数化的声明">1. 参数化的声明</h2>
<p>        <code>C++</code>现在支持四种基础模版类型：类模版、函数模版、变量模版和别名模版，每个模版类型都能在命名空间作用域和类作用域中使用。在类作用域内，它们可以作为类内类模版、成员函数模版、静态数据成员模版和成员别名模版。这种模版的声明类似于普通类、函数、变量和类型别名，除了使用参数化子句开头外。<code>C++17</code>还引入了另一种使用参数化子句的结构——推导指引。<br>
        首先，让我们看一下四种模版的例子。首先是命名空间作用域：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 命名空间作用域类模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Data</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">copyable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 命名空间作用域函数模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">log</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 命名空间作用域变量模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">T</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 命名空间作用域变量模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">dataCopyable</span> <span class="o">=</span> <span class="n">Data</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">copyable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 命名空间作用域别名模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">DataList</span> <span class="o">=</span> <span class="n">Data</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">;</span>
</span></span></code></pre></div><p>        接下来是类作用域：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Collection</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 类内成员类模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 类内成员函数模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">T</span><span class="o">*</span> <span class="n">alloc</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 提供了定义，是隐式内联的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 成员变量模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">static</span> <span class="n">T</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 成员别名模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">using</span> <span class="n">NodePtr</span> <span class="o">=</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        在<code>C++17</code>，变量 ( 包括静态数据成员 ) 和变量模版可以“内联”，这意味着它们可以在翻译单元间重复定义。与成员函数不同，一个定义在封闭类中的静态数据成员不是内联的，必须在所有地方都指定 $inline$ 才行。<br>
        最后一段代码演示除别名模版外，其他模版都可以在类外定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">List</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">Handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">List</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">U</span> <span class="n">zero</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Handle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">List</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">U</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></div><p>        定义在类外的成员模版可能需要多个 $template$&lt;$\dots$&gt; 语句，从最外层到最内层的方式排列。注意一个构造函数模版会使类不生成隐式的默认构造函数，所以我们需要添加一个 $default$ 声明。<br>
        联合也可以使用模版：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">union</span> <span class="nc">AllocChunk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">object</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bytes</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        函数模版也可以有默认调用参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">report_top</span><span class="p">(</span><span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fill</span><span class="p">(</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="o">=</span> <span class="n">T</span><span class="p">{});</span>
</span></span></code></pre></div><p>        当 $fill$ 被调用时，如果提供了第二个参数，那么默认参数就不会实例化。这样就可以确保当 $T$ 没有默认构造函数时不会报错了。<br>
        类内除了可以声明四种基本模版类型外，你也可以让普通类成员通过成为类模版成员的方式实现参数化。它们通常被错误地称为成员模版。尽管可以被参数化，但是这种定义跟第一类模版是不同的，它们的参数是完全由它们所属的模版决定的。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CupBoard</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">Shelf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">open</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="nc">Wood</span> <span class="o">:</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">double</span> <span class="n">totalWeight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        相应的定义只会在父类模版中使用参数化子句，不会在成员中使用，因为它们不是模版：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CupBoard</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;::</span><span class="n">Shelf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">CupBoard</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;::</span><span class="n">open</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">CupBoard</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;::</span><span class="n">Wood</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Maple</span><span class="p">,</span> <span class="n">Cherry</span><span class="p">,</span> <span class="n">Oak</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">CupBoard</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;::</span><span class="n">totalWeight</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span></code></pre></div><p>        从<code>C++17</code>开始，静态 $totalWeight$ 成员可以在类内模版中使用 $inline$ ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CupBoard</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">inline</span> <span class="k">static</span> <span class="kt">double</span> <span class="n">totalWeight</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        尽管这种参数化定义通常被称为模版，但是这个名词不太适合它们。一个偶尔被建议用于称呼这些实体的名词是 $temploid$ 。从<code>C++17</code>开始，<code>C++</code>标准没有定义<strong>模版化实体</strong> ( $templated$ $entity$ ) 的概念，它通常包含模版和 $temploid$ ，以及任何在模版实体中定义和创建的实体。</p>
<h3 id="11-虚成员函数">1.1 虚成员函数</h3>
<p>        成员函数模版不能作为虚函数。因为通常虚函数调用机制是通过一个固定大小的表，表项指向每一个虚函数。然而，只有当整个程序都被翻译完成后，成员函数模版的数量才能确定。因此，虚成员函数模版的支持，需要<code>C++</code>编译器和链接器提供一种新机制。</p>
<h3 id="12-模版的链接性">1.2 模版的链接性</h3>
<p>        每个模版必须有个名字，并且在当前作用域内，这个名字必须是独一无二的，除非是可重载的函数模版。与类类型不同，类模版不允许在不同类型实体之间使用相同的名字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">X</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><p>        模版名具有链接性，但他们不能有<code>C</code>链接性。非标准的链接性可能具有依赖于实现的含义 ( 然而，我们并不知道支持模版的非标准名称链接性的实现 )：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">extern</span> <span class="s">&#34;C++&#34;</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">normal</span><span class="p">();</span>  <span class="c1">// 默认，可以省略链接性的指定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">invalid</span><span class="p">();</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="s">&#34;Java&#34;</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">javaLink</span><span class="p">();</span>  <span class="c1">// 非标准，但是可能有些编译器在将来会支持
</span></span></span></code></pre></div><p>        模版通常具有外部链接性。除了命名空间中指定为 $static$ 的函数模版、直接或间接作为匿名函数空间成员的模版 ( 具有内部链接性 ) 和匿名类成员模版 ( 没有链接性 )。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 作为另一个文件中名称相同的实体的声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">external</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 与另一个文件中名称相同模版没有关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="n">internal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 再次声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="n">internal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span>  <span class="c1">// 与另一个文件中名称相同的模版没有关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">otherInternal</span><span class="p">();</span>  <span class="c1">// 即使那个模版也在匿名命名空间内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span>  <span class="c1">// 再次声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">otherInternal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>  <span class="c1">// 无链接性，不能被再次声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">x</span><span class="p">;</span>
</span></span></code></pre></div><p>        注意由于最后的成员模版没有链接性，所以它必须与匿名类一起定义，因为没有办法在类外提供定义。<br>
        通常模版不能在函数作用域或者局部类作用域中声明，但是泛型<code>lambda</code>，它关联闭包类型且包含成员函数模版，可以在局部作用域中使用。<br>
        模版实例的链接性与模版的链接性相同。例如，函数 $internal$&lt;$void$&gt; 是上面声明的模版的实例化，它与模版一样具有内部链接性。对于变量模版，这会产生有趣的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">T</span><span class="p">{};</span>
</span></span></code></pre></div><p>        所有 $zero$ 的实例化都会具有外部链接性，即使是 $zero$&lt;$int$ $const$&gt; 。这可能有点反直觉，因为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="k">const</span> <span class="n">zero_int</span> <span class="o">=</span> <span class="kt">int</span><span class="p">{};</span>
</span></span></code></pre></div><p>        是具有内部链接性的，因为它声明为 $const$ 。类似的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="k">const</span> <span class="n">max_volume</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
</span></span></code></pre></div><p>        所有这个模版的实例化都具有外部链接性，尽管这些实现都具有 $const$ 限定符。</p>
<h3 id="13-主模版">1.3 主模版</h3>
<p>        一般的模版声明称为<strong>主模版</strong> ( $primary$ $templates$ )，这种模版声明没有在模版名后添加尖括号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Box</span><span class="p">;</span>  <span class="c1">// 主模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// 错误，没有特例化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">translate</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>  <span class="c1">// 主模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">translate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>  <span class="c1">// 错误，不允许这样声明函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">T</span><span class="p">{};</span>  <span class="c1">// 主模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">zero</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">T</span><span class="p">{};</span>  <span class="c1">// 错误，没有特例化
</span></span></span></code></pre></div><p>        非主模版在声明类部分特例化或这变量模版时出现。</p>
<h2 id="2-模版参数">2. 模版参数</h2>
<p>        模版参数有三种基本类型：</p>
<ol>
<li>类型参数 ( 最常见的 )；</li>
<li>非类型参数；</li>
<li>模版模版参数。</li>
</ol>
<p>        任意一种类型都可以作为模版参数集合元素。模版参数在模版参数化子句中声明，如果模版中需要参数名，那么在定义时需要给出参数名。</p>
<h3 id="21-类型参数">2.1 类型参数</h3>
<p>        类型参数可以使用 $typename$ 关键字或者 $class$ 关键字，它们是等价的。关键字之后应该是一个简单的标识符，在下一个类型参数的开始之前需要使用逗号隔开。类型参数的声明使用尖括号代表开始和结束，中间可以使用 $=$ 声明默认模版参数。<br>
        在模版声明中，类型参数类似于一个类型别名。例如，当 $T$ 是一个模版参数时，你无法使用它的全名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">List</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">Allocator</span><span class="o">*</span> <span class="n">allocptr</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Allocator</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h3 id="22-非类参数">2.2 非类参数</h3>
<p>        非类模版参数代表可以在编译期或者链接期确定的常量。这样的参数必须是：</p>
<ul>
<li>整型或枚举型；</li>
<li>指针类型；</li>
<li>成员指针；</li>
<li>左值引用类型；</li>
<li>$std::nullptr_-t$ ；</li>
<li>包含 $auto$ 或 $decltype(auto)$ 的类型。</li>
</ul>
<p>        其他类型暂不支持。出乎意料的是，非类模版参数的声明有时候也可以使用 $typename$ ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">Allocator</span><span class="o">*</span> <span class="n">Allocator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">List</span><span class="p">;</span>
</span></span></code></pre></div><p>        或者使用 $class$ ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">X</span><span class="o">*&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Y</span><span class="p">;</span>
</span></span></code></pre></div><p>        这种情况很容易区分，因为它们之后都是标识符。<br>
        也可以指定函数和数组类型，但是它们会被隐式转为指针类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Lexer</span><span class="p">;</span>  <span class="c1">// 实际上是int*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span> <span class="n">buf</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Lexer</span><span class="p">;</span>  <span class="c1">// 再次声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">fun</span><span class="p">()</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">FuncWrap</span><span class="p">;</span>  <span class="c1">// 实际上是函数指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)()</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">FuncWrap</span><span class="p">;</span>  <span class="c1">// 再次声明
</span></span></span></code></pre></div><p>        非类模版参数的声明类似于变量，但是不能具有非类标识符，像 $static$ 、$mutable$ 等。它们可以有 $const$ 和 $volatile$ 标识符，但是如果这种标识符在最外层的模版参数类型中使用就会被忽略：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span> <span class="n">length</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Buffer</span><span class="p">;</span>  <span class="c1">// const会被忽略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">length</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Buffer</span><span class="p">;</span>  <span class="c1">// 与上一种一样
</span></span></span></code></pre></div><p>        最后，非引用的非类模版参数的地址是无法获取的，所以无法被赋值。一个左值引用非类模版参数则可以这样使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">Counter</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">LocalIncrement</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">LocalIncrement</span><span class="p">()</span> <span class="p">{</span> <span class="n">Counter</span> <span class="o">=</span> <span class="n">Counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">LocalIncrement</span><span class="p">()</span> <span class="p">{</span> <span class="n">Counter</span> <span class="o">=</span> <span class="n">Counter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        右值就不可以这样做了。</p>
<h3 id="23-模版模版参数">2.3 模版模版参数</h3>
<p>        模版模版参数是类模版或者别名模版的占位符。它们的声明方式类似于类模版，但是不能使用 $struct$ 和 $union$ ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">C</span><span class="o">&gt;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="k">union</span> <span class="nc">C</span><span class="o">&gt;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">);</span>
</span></span></code></pre></div><p>        <code>C++17</code>允许使用 $typename$ 而不是 $class$ ，这个改变可能是因为模版模版参数不仅可以被类模版代替，也可以被别名模版代替。所以，<code>C++17</code>中可以这样写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">);</span>
</span></span></code></pre></div><p>        在它们的声明中，模版模版参数就类似于其他类或者别名模版。<br>
        模版模版参数也可以有默认模版参数，当对应的参数没有指定时就会使用它们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="k">typename</span> <span class="n">A</span> <span class="o">=</span> <span class="n">MyAllocator</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Container</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Adaptation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Container</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">storage</span><span class="p">;</span>  <span class="c1">// 隐式等价于Container&lt;int, MyAllocator&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        $T$ 和 $A$ 是模版模版参数 $Container$ 的模版参数名，这个模版模版参数的名字只在其他模版的声明中使用。下面这个故意的例子展示了这个概念：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">*&gt;</span> <span class="k">class</span> <span class="nc">Buf</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Lexer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">T</span><span class="o">*</span> <span class="n">storage</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        通常，模版模版参数的模版参数名不需要在其他模版参数的声明中使用，因此也可以声明为匿名。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="k">typename</span> <span class="o">=</span> <span class="n">MyAllocator</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Container</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Adaptation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Container</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">storage</span><span class="p">;</span>  <span class="c1">// 隐式等价于Container&lt;int, MyAllocator&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h3 id="24-模版参数集合">2.4 模版参数集合</h3>
<p>        从<code>C++11</code>开始，任何类型的模版参数都可以作为模版参数集合使用，只需要在模版参数名前添加 $/dots$ 。匿名参数也可以使用模版参数集合。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Tuple</span><span class="p">;</span>
</span></span></code></pre></div><p>        一个模版参数集合的行为类似于它的底层模版参数，但是有一个重要不同之处：一个普通模版参数精准匹配一个模版传入参数，而一个模版参数集合可以匹配任意数量的模版传入参数。这意味着上面声明的 $Tuple$ 可以接收任意数量的类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">IntTuple</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">IntCharTuple</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">IntTriple</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">EmptyTuple</span> <span class="o">=</span> <span class="n">Tuple</span><span class="o">&lt;&gt;</span><span class="p">;</span>
</span></span></code></pre></div><p>        类似的，模版参数集合也可以接收任意数量非类模版参数和模版模版参数。相对的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">...</span> <span class="n">Dimensions</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MultiArray</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">TransformMatrix</span> <span class="o">=</span> <span class="n">MultiArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span> <span class="k">typename</span><span class="o">&gt;</span><span class="p">...</span> <span class="n">Containers</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">testContainers</span><span class="p">();</span>
</span></span></code></pre></div><p>        <code>C++17</code>还引入了非类模版参数的推导。<br>
        主类模版、变量模版和别名模版可以含有最多一个模版参数集合，并且模版参数集合只能在模版参数的最后。函数模版有着相对宽松的限制：允许多个模版参数集合，只要每个模版参数集合之后模版参数都有一个默认值，或者可以被推导。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Last</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">LastType</span><span class="p">;</span>  <span class="c1">// 错误，模版参数集合不是最后一个模版参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">TestTypes</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">runTests</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">);</span>  <span class="c1">// 模版参数集合之后的模版参数可以被推导
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">...</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">Tensor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">...</span> <span class="n">Dims1</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">...</span> <span class="n">Dims2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">compose</span><span class="p">(</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">Dims1</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Tensor</span><span class="o">&lt;</span><span class="n">Dims2</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span>
</span></span></code></pre></div><p>        类和变量模版的部分实例化声明也可以有多个参数集合，因为部分实例化的匹配机制类似于函数模版的匹配机制。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">Typelist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">Zip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Xs</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Ys</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Zip</span><span class="o">&lt;</span><span class="n">Typelist</span><span class="o">&lt;</span><span class="n">Xs</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Typelist</span><span class="o">&lt;</span><span class="n">Ys</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span></code></pre></div><p>        一个类型参数集合不能在它自己的参数子句中展开，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">Ts</span><span class="p">...</span> <span class="n">vals</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">StaticValues</span><span class="p">{};</span>
</span></span></code></pre></div><p>        然而，类内模版可以使用相似的语句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span> <span class="n">strcut</span> <span class="n">ArgList</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span> <span class="n">vals</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">Vals</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ArgList</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;::</span><span class="n">Vals</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="sc">&#39;y&#39;</span><span class="o">&gt;</span> <span class="n">tada</span><span class="p">;</span>
</span></span></code></pre></div><p>        包含模版参数集合的模版称为变长模版，因为它可以接收任意数量的模版参数。</p>
<h3 id="25-默认模版参数">2.5 默认模版参数</h3>
<p>        任意种类的非模版参数集合的模版参数都可以指定默认参数，不过只能指定对应参数类型的值。默认参数不能依赖于它自己的参数，因为参数名并不在作用域内。但是可以依赖于之前的参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">List</span><span class="p">;</span>
</span></span></code></pre></div><p>        类模版、变量模版或者别名模版的模版参数都可以指定一个默认参数，如果指定了默认参数，那么后续参数也要指定默认参数 ( 类似的限制也适用于默认函数调用参数 )。后续的默认值通常在同个模版声明中提供，但是它们也可以在该模版先前声明中声明。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">typename</span> <span class="n">T4</span> <span class="o">=</span> <span class="kt">char</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T5</span> <span class="o">=</span> <span class="kt">char</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Quintuple</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span> <span class="o">=</span> <span class="kt">char</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">typename</span> <span class="n">T4</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T5</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Quintuple</span><span class="p">;</span>  <span class="c1">// 之前已经声明了T4和T5的默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span> <span class="o">=</span> <span class="kt">char</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">typename</span> <span class="n">T4</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T5</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Quintuple</span><span class="p">;</span>  <span class="c1">// 错误，T2没有默认值
</span></span></span></code></pre></div><p>        函数模版的默认模版参数不需要后续的默认参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span> <span class="o">=</span> <span class="kt">void</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">R</span><span class="o">*</span> <span class="n">addressof</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
</span></span></code></pre></div><p>        默认模版参数不能重复声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">=</span><span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Value</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><p>        有几种情况不能使用默认模版参数：</p>
<ul>
<li>部分特例化：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><ul>
<li>参数集合：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">X</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><ul>
<li>类模版成员的类外定义：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="nf">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>友类模版声明：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">struct</span> <span class="nc">F</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><ul>
<li>友元函数模版声明，除非给出定义，并且在当前翻译单元的其他地方没有再声明：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">();</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><h2 id="3-模版传入参数">3. 模版传入参数</h2>
<p>        当模版实例化时，模版参数会被模版传入参数代替。入参可以通过几种不同的机制指定：</p>
<ul>
<li>显式模版入参：模版名之后跟随一个尖括号括起来的模版入参列表，这个结果称为模版<code>id</code>；</li>
<li>类名注入：在具有 $P1$ 、$P2$ 等模版参数的的类模版 $X$ 中，$X$ 可以被视为 $X$&lt;$P1$ , $P2$ , $\dots$&gt; ；</li>
<li>默认模版入参：如果模版具有默认模版参数，那么可以忽略显式的模版入参。但是对于类或别名模版，即使所有默认参数都具有默认值，也要显式指定尖括号 ( 可以为空 )；</li>
<li>入参推导：如果没有显式指定函数模版入参，也可以从函数调用参数的类型中推导出来。如果所有模版入参都可以推导，那么可以省略尖括号。<code>C++17</code>还引入了从变量声明或者函数符号类型转换的初始化调用中推导出类模版参数的能力。</li>
</ul>
<h3 id="31-函数模版入参">3.1 函数模版入参</h3>
<p>        函数模版的模版入参可以显式指定，从模版使用方式或者默认模版入参中推导，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">max</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">max</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">);</span>  <span class="c1">// 显式指定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.0</span><span class="p">);</span>  <span class="c1">// 隐式推导
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">::</span><span class="n">max</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">);</span>  <span class="c1">// 显式指定为int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        有些模版入参永远也不会被推导，因为它们相应的模版参数不在函数参数类型中出现，一些其他原因也会导致这种情况出现。相应的参数通常位域模版参数列表中的首位，从而我们可以只显式指定该入参，让其他入参隐式推导。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">DstT</span><span class="p">,</span> <span class="k">typename</span> <span class="n">SrcT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">DstT</span> <span class="n">implicit_cast</span><span class="p">(</span><span class="n">SrcT</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">implicit_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        如果我们颠倒了上面模版参数的声明顺序，那么我们就需要显式指定所有模版入参。而且，这种参数不能位于模版参数集合后面，也不能部分特例化，因为这样就不能进行显式指定或者推导了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">double</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">Ts</span><span class="p">...</span> <span class="n">ps</span><span class="p">);</span>  <span class="c1">// N无法指定或推导
</span></span></span></code></pre></div><p>        因为函数模版可以重载，显式提供一个函数模版的所有入参可能还不足以确定一个函数。下面的例子就展示了这种问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Func</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">Func</span> <span class="n">funcPtr</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">funcPtr</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">single</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">multi</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">multi</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">single</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">multi</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        在这个例子中，第一个调用成功，因为没有歧义。第二个调用中，$multi$&lt;$int$&gt; 可以是两个版本中的任意一个，因此无法推导。<br>
        更进一步，使用模版入参代替函数模版可能会产生一个无效的<code>C++</code>类型或者表达式。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">RT1</span> <span class="n">test</span><span class="p">(</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">X</span> <span class="k">const</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">RT2</span> <span class="n">test</span><span class="p">(...);</span>
</span></span></code></pre></div><p>        这个例子中 $test$&lt;$int$&gt; 在第一个模版中是无意义的，因为它没有成员 $X$ 。但是第二个模版不存在这样的问题。因此，表达式 &amp;$test$&lt;$int$&gt; 就可以确定一个函数。这个原则称为<code>SFINAE</code> ( $substitution$ $failure$ $is$ $not$ $an$ $error$ )。</p>
<h3 id="32-类型入参">3.2 类型入参</h3>
<p>        模版类型参数指定的值就是模版类型入参。任意类型都可以作为模版类型入参，但是在使用入参替代之后的结构应该是一个有效的结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">clear</span><span class="p">(</span><span class="n">T</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 应该可以使用解引用运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">clear</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// 错误，不能使用解引用运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="33-非类入参">3.3 非类入参</h3>
<p>        非类模版参数指定的值是非类模版入参。这种值必须是下面其中一种：</p>
<ul>
<li>具有正确类型的非类模版参数；</li>
<li>一个整型或者枚举型的编译时常量，只有对应的参数类型符合或者不需要进行变窄转换时才可以；</li>
<li>应用了取地址运算符的外部变量或函数。对于函数和数组变量，可以省略 &amp; 。这种函数模版对应指针参数类型。<code>C++17</code>放宽了限制，允许使用产生一个变量或者函数指针的常量表达式表示；</li>
<li>与上一个一样的参数，但是不需要取地址运算符的非类引用参数的有效入参。<code>C++17</code>同样放宽了限制，允许使用产生一个变量或者函数的全局左值引用表达式表示；</li>
<li>成员常量指针。换句话说，一个具有 &amp;$C::m$ 形式的表达式，其中 $C$ 是类，$m$ 是一个非静态成员。这种情况只会匹配非类成员指针参数。<code>C++17</code>中不需要指定精确的语法形式，可以使用任何能产生成员指针常量的表达式表示；</li>
<li>对于非类指针参数或者非类成员指针参数，也可以指定非空指针常量。</li>
</ul>
<p>        对于非类整型参数，最常见的是可以隐式转为参数类型的入参。<code>C++11</code>引入了 $constexpr$ 函数，意味着入参在被转换前也可以是类类型。<code>C++17</code>之前，当入参是引用指针时，用户定义的转换 ( 单参数构造函数和转换运算符 ) 和子类到基类的转换是不会进行的，即使它们可以隐式进行。给参数加上 $const$ 或者 $volatile$ 的隐式转换是可以的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="n">nontypeParam</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">33</span><span class="o">&gt;*</span> <span class="n">c1</span><span class="p">;</span>  <span class="c1">// 整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="o">&gt;*</span> <span class="n">c2</span><span class="p">;</span>  <span class="c1">// 外部变量地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span> <span class="n">f</span><span class="o">&gt;*</span> <span class="n">c3</span><span class="p">;</span>  <span class="c1">// 函数名，隐式取地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">templ_func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">templ_func</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;*</span> <span class="n">c4</span><span class="p">;</span>  <span class="c1">// 实例化的函数模版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">bool</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">constexpr</span> <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">X</span><span class="o">::</span><span class="n">b</span><span class="o">&gt;*</span> <span class="n">c5</span><span class="p">;</span>  <span class="c1">// 静态类成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">X</span><span class="o">::*</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">n</span><span class="o">&gt;*</span> <span class="n">c6</span><span class="p">;</span>  <span class="c1">// 成员指针常量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">C</span><span class="o">&lt;</span><span class="kt">long</span><span class="p">,</span> <span class="n">X</span><span class="p">{}</span><span class="o">&gt;*</span> <span class="n">c7</span><span class="p">;</span>  <span class="c1">// X通过constexpr隐式转为int，再转为long
</span></span></span></code></pre></div><p>        模版入参的一般限制是编译器或者链接器必须在程序编译时可以表示出它们的值，程序运行时才能获得的值是不行的。当然，有些值也不行：</p>
<ul>
<li>浮点数；</li>
<li>字符串常量。</li>
</ul>
<p>        字符串常量的一个问题是两个值相同的字符串可以存储在不同地址中。一个可选 ( 但是麻烦 ) 的方法是使用一个额外的变量来指代常量字符串：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">str</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">char</span> <span class="k">const</span> <span class="n">hello</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="k">const</span> <span class="n">hello11</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">char</span> <span class="k">const</span> <span class="n">hello17</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="o">&lt;</span><span class="n">hello</span><span class="o">&gt;</span> <span class="n">msg03</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Message</span><span class="o">&lt;</span><span class="n">hello11</span><span class="o">&gt;</span> <span class="n">msg11</span><span class="p">;</span>  <span class="c1">// C++11开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Message</span><span class="o">&lt;</span><span class="n">hello17</span><span class="o">&gt;</span> <span class="n">msg17</span><span class="p">;</span>  <span class="c1">// C++17开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        在<code>C++</code>所有版本中，声明为引用或者指针的非类模版参数可以接收一个具有外部链接的常量表达式；<code>C++11</code>开始，常量表达式也可以具有内部链接；<code>C++17</code>开始，常量表达式可以具有任何链接。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="n">nontypeParam</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">derived</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">derived</span><span class="o">&gt;*</span> <span class="n">err1</span><span class="p">;</span>  <span class="c1">// 错误，不能进行子类到基类的转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">base</span><span class="p">.</span><span class="n">i</span><span class="o">&gt;*</span> <span class="n">err2</span><span class="p">;</span>  <span class="c1">// 错误，变量字段不能作为变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;*</span> <span class="n">err3</span><span class="p">;</span>  <span class="c1">// 错误，不能使用数组元素地址
</span></span></span></code></pre></div><h3 id="34-模版模版入参">3.4 模版模版入参</h3>
<p>        一个模版模版入参必须是一个与它将代替的模版模版参数类型精确匹配的类模版或者别名模版。在<code>C++17</code>之前，模版模版入参的默认模版参数会被忽略 ( 声明模版模版参数时指定的默认值不会 )。<code>C++17</code>放宽了这种限制，允许模版模版入参对应的模版模版参数是一个特例化版本。下面的代码在<code>C++17</code>之前是错误的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Cont</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Rel</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&gt;</span> <span class="n">rel</span><span class="p">;</span>  <span class="c1">// C++17之前是错误的
</span></span></span></code></pre></div><p>        因为 $std::list$ 模版参数在标准库中不止一个，所以会产生错误。尽管 $std::list$ 的第二个参数具有默认值，但是在<code>C++17</code>之前，它们还是会被忽略。<br>
        变长模版模版参数是一个例外，它不会因为上面的原因而产生错误，这个问题有一个解决方案：它们可以对模版模版参数进行一般匹配而非精确匹配。一个模版模版参数集合可以匹配任意数量的相同类型的模版参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Cont</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Rel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Rel</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&gt;</span> <span class="n">rel</span><span class="p">;</span>
</span></span></code></pre></div><p>        模版参数集合只能匹配相同种类的模版入参。例如，下面的模版参数可以被任意只具有模版类型参数的类模版或者别名模版实例化，因为模版类型参数集合可以匹配任意数量的参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">TT</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AlmostAnyTmpl</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">AlmostAnyTmpl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&gt;</span> <span class="n">withVector</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">AlmostAnyTmpl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&gt;</span> <span class="n">withMap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">AlmostAnyTmpl</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&gt;</span> <span class="n">withArray</span><span class="p">;</span>
</span></span></code></pre></div><p>        在<code>C++17</code>之前，只有 $class$ 关键字才能声明模版模版参数，但这并不意味着模版模版参数只能是 $class$ 模版。$struct$ 、$union$ 和别名模版同样可以。</p>
<h3 id="35-等价性">3.5 等价性</h3>
<p>        当所有入参都相等时，两个模版入参集合就是等价的。对于类型入参，类型别名并没有影响，比较依赖的是底层类型。对于整型非类参数，会进行值比较，不管值怎么表示。下面的例子说明了这个概念：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Mix</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">Int</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Mix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">3</span><span class="o">&gt;*</span> <span class="n">p1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Min</span><span class="o">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span><span class="o">&gt;*</span> <span class="n">p2</span><span class="p">;</span>  <span class="c1">// p2与p1类型相同
</span></span></span></code></pre></div><p>        在模版依赖上下文中，模版入参的值不是总能被确定，这时等价性的规则就会变得稍些复杂。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">I</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">I</span><span class="o">&lt;</span><span class="n">M</span> <span class="o">+</span> <span class="n">N</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">M</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">I</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">+</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">I</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">+</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">);</span>  <span class="c1">// 错误
</span></span></span></code></pre></div><p>        在第二个和第三个声明中，虽然一个声明为 $N$ 和 $M$ ，一个声明为 $M$ 和 $N$ ，但因为在函数参数中都是第一个加第二个，所以它们还是等价的。最后一个声明中，函数参数中的加法顺序是颠倒的，这导致它与上面两个声明不等价。然而，因为这样还是会产生相同的结果，即函数等价，所以会导致一个错误。错误原因是只具有函数等价的表达式不是真正的等价。然而，你的编译器不需要处理这种错误，因为一些编译器可能会直接将类似于 $N + 1 + 1$ 的表达式优化为 $N + 2$ 。<br>
        从函数模版中生成的与普通函数是永远不等价的，就算它们有着相同的名字和类型。对于类成员，这会产生两个后果：</p>
<ol>
<li>从成员函数模版中生成的函数不会覆写虚函数；</li>
<li>从构造函数模版中生成的构造函数不会作为拷贝或者移动构造函数。类似的，从赋值模版中生成的函数也不会作为拷贝或者移动赋值运算符。</li>
</ol>
<h2 id="4-变长模版">4. 变长模版</h2>
<p>        变长模版是包含至少一个模版参数集合的模版。变长模版在一个模版可以从任意数量的入参生成时十分有用。当给变长模版指定入参时，每个模版参数集合会匹配一个或多个模版参数，我们称模版入参序列为入参集合。下面的例子说明了模版参数集合怎么匹配不同入参集合：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Tuple</span><span class="o">&lt;&gt;</span> <span class="n">t0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">t2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        因为一个模版参数集合代表模版入参列表而不是一个单独的模版入参，它必须在结构支持入参集合中的所有参数的前提下使用。一个这样的结构是 $sizeof\dots$ 操作，它会返回入参集合中的参数数量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Tuple</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a1</span><span class="p">[</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">length</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a3</span><span class="p">[</span><span class="n">Tuple</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">long</span><span class="o">&gt;::</span><span class="n">length</span><span class="p">];</span>
</span></span></code></pre></div><h3 id="41-集合展开">4.1 集合展开</h3>
<p>        $sizeof\dots$ 表达式是集合展开的一个例子。集合展开会把入参集合中的参数拆分为单独的参数。$sizeof\dots$ 只是返回单独参数的个数，其他形式的参数集合可以在需要的时候展开为多个参数。这种集合展开会在集合之后使用 $\dots$ 符号。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyTuple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">MyTuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">t2</span><span class="p">;</span>
</span></span></code></pre></div><p>        模版参数 $Types\dots$ 是一个集合展开，生成一个模版参数序列。<br>
        一种直观的理解集合展开的方式是把它们视为语法展开，模版参数集合被确切数量的模版参数代替，集合展开被写成单独入参的形式，每个入参对应一个非集合模版参数。两个参数的展开就类似于：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyTuple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        然而，注意你不能直接通过名字单独访问参数集合中的某个元素，因为它们并没有定义名字。如果你需要得到某个类型，你只能递归地将它们传递给另一个类或者函数。<br>
        每个集合展开都具有模式，即每个入参的类型或者表达式，一般在 $\dots$ 之前。我们之前的例子只有最简单的模式，即获取参数集合元素的名字，其实模式可以更复杂。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PtrTuple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">*</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">PtrTuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">t3</span><span class="p">;</span>
</span></span></code></pre></div><p>        这个模式使得 $PtrTuple$ 中的模版参数都变为指针类型。我们可以把它展开来：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PtrTuple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tuple</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">*</span><span class="p">,</span> <span class="n">T2</span><span class="o">*</span><span class="p">,</span> <span class="n">T3</span><span class="o">*&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h3 id="42-集合展开的时机">4.2 集合展开的时机</h3>
<p>        集合展开可以在任意一个需要一个逗号分隔的列表的地方使用，包括：</p>
<ul>
<li>基类列表；</li>
<li>构造函数基类初始化列表；</li>
<li>调用参数列表；</li>
<li>初始化列表；</li>
<li>类、函数或者别名模版的模版参数列表；</li>
<li>函数抛出异常列表 ( <code>C++11</code>开始废弃，<code>C++17</code>中禁止 )；</li>
<li>在属性中，如果该属性支持集合展开 ( 虽然<code>C++</code>标准并没有定义这种属性 )；</li>
<li>指定声明对齐方式；</li>
<li><code>lambda</code>捕获列表；</li>
<li>函数类型的参数列表；</li>
<li>$using$ 声明 ( <code>C++17</code>开始 )。</li>
</ul>
<p>        $sizeof\dots$ 是一个集合展开机制，但是不会真正产生一个列表。<code>C++17</code>也提供了折叠表达式，这也是一个不会产生列表的机制。有些集合展开场景只是为了完整性而提及，我们实际上只需要注意那些有用的场景。因为所有场景的集合展开都遵循相同的原则和语法，你也可以根据例子来扩展。<br>
        在基类列表中使用集合展开通过<strong>混合</strong> ( $mixins$ ) 聚合外部的数据和功能，这些类会混入类层级中，提供新行为。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Mixins</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mixins</span><span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Point</span><span class="p">()</span> <span class="o">:</span> <span class="n">Mixins</span><span class="p">()...</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Visitor</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">visitMixins</span><span class="p">(</span><span class="n">Visitor</span> <span class="n">visitor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">visitor</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Mixins</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Color</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Label</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Point</span><span class="o">&lt;</span><span class="n">Color</span><span class="p">,</span> <span class="n">Label</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
</span></span></code></pre></div><p>        $Point$ 类使用集合展开来获取提供的混合类型，并在基类列表中展开。$Point$ 的默认构造函数会应用在基类初始化列表中应用集合展开来初始化每个基类。成员函数模版 $visitMixins$ 是最有趣的，它使用集合展开的结果作为参数来进行调用，将 $\star this$ 展开为对应的混合类型。<br>
        集合展开也能在模版参数列表中创建非类或者模版参数集合：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Values</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span> <span class="n">Vs</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">Holder</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Values</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">*&gt;::</span><span class="n">Holder</span><span class="o">&lt;</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">&gt;</span> <span class="n">valueHolder</span><span class="p">;</span>
</span></span></code></pre></div><p>        $Values$ 具有非类模版参数集合，每个模版参数都可以是不同类型。注意这里的 $\dots$ 有双重作用，既声明了模版参数集合，又进行集合展开。这种模版参数集合的使用很少见，相同的原理在函数参数中更常见。</p>
<h3 id="43-函数参数集合">4.3 函数参数集合</h3>
<p>        一个函数参数集合可以匹配零个或多个函数调用参数。与模版参数集合一样，函数参数集合也使用 $\dots$ 前置的方式生命，后置的方式展开。模版参数集合和函数参数集合统称为参数集合。与模版参数集合不同的是，函数参数集合总是集合展开的，这意味着他们的声明类型必须包含至少一个参数集合。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Mixins</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mixins</span><span class="p">...</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Point</span><span class="p">(</span><span class="n">Mixins</span><span class="p">...</span> <span class="n">mixins</span><span class="p">)</span> <span class="o">:</span> <span class="n">Mixins</span><span class="p">(</span><span class="n">mixins</span><span class="p">)...</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Color</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">read</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Label</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">Point</span><span class="o">&lt;</span><span class="n">Color</span><span class="p">,</span> <span class="n">Label</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">({</span><span class="mh">0x7F</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x7F</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;center&#34;</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Types</span><span class="p">...</span> <span class="n">values</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">welcom</span><span class="p">(</span><span class="s">&#34;Welcome to &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">print</span><span class="p">(</span><span class="n">welcome</span><span class="p">,</span> <span class="s">&#34;C++ &#34;</span><span class="p">,</span> <span class="mi">2011</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        当调用 $print$ 时，参数会被放入参数集合里，使用 $Types$ 这个参数集合类型表示，实参使用 $values$ 表示。$print$ 函数的实际实现方式是递归模版实例化，这是一种模版元编程技术。<br>
        在匿名函数参数集合和<code>C</code>风格的变长参数之间存在语法歧义，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">c_style</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="p">...);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">pack</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="p">...);</span>
</span></span></code></pre></div><p>        在第一个例子中，$T\dots$ 被视为 $T,\dots$ ，即一个类型为 $T$ 的匿名参数，后面为<code>C</code>风格的变长参数；在第二个例子中，$T\dots$ 结构会被视为一个函数参数集合，因为$T$ 是一个有效的展开表达式。可以通过在 $\dots$ 前面添加逗号的方式来消除歧义。在泛型<code>lambda</code>中，如果类型使用 $auto$ 声明，那么后置的 $\dots$ 会被视为参数集合。</p>
<h3 id="44-多重和内嵌集合展开">4.4 多重和内嵌集合展开</h3>
<p>        集合展开可以很复杂，也可以是多重或者单独的参数集合。当实例化一个包含多重参数集合的集合展开时，所有参数集合必须拥有相同的长度。类型或者值的结果序列是通过使用每个集合的第一个元素替换，再使用第二个元素的替换……以此类推的方式，生成的。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">forwardCopy</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">Types</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">Types</span><span class="p">(</span><span class="n">values</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        调用参数集合展开为两个参数集合，$Types$ 和 $values$ 。当实例化这个模版时，逐元素地展开，产生一系列对象结构。在经过语法解释后，三个参数的 $forwardCopy$ 会类似于这种：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">fowardCopy</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T1</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="n">T2</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span> <span class="n">T3</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v3</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">f</span><span class="p">(</span><span class="n">T1</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="n">T2</span><span class="p">(</span><span class="n">v2</span><span class="p">),</span> <span class="n">T3</span><span class="p">(</span><span class="n">v3</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        集合展开也可以内嵌。这时每个参数集合会被离它最近的展开表达式展开。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">OuterTypes</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Nested</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">InnerTypes</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">InnerTypes</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">innerValues</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">g</span><span class="p">(</span><span class="n">OuterTypes</span><span class="p">(</span><span class="n">InnerTypes</span><span class="p">(</span><span class="n">innerValues</span><span class="p">)...)...);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        在 $g$ 函数调用中，$InnerTypes(innerValuesi)$ 是最内层的集合展开，它们会生成一个序列，交给 $OuterTypes$ 继续展开。在经过语法解释后，一个例子如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">O1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">O2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Nested</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">I1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">I2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">I3</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">I1</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">iv1</span><span class="p">,</span> <span class="n">I2</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">iv2</span><span class="p">,</span> <span class="n">I3</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">iv3</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">g</span><span class="p">(</span><span class="n">O1</span><span class="p">(</span><span class="n">I1</span><span class="p">(</span><span class="n">iv1</span><span class="p">),</span> <span class="n">I2</span><span class="p">(</span><span class="n">iv2</span><span class="p">),</span> <span class="n">I3</span><span class="p">(</span><span class="n">iv3</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">      <span class="n">O2</span><span class="p">(</span><span class="n">I1</span><span class="p">(</span><span class="n">iv1</span><span class="p">),</span> <span class="n">I2</span><span class="p">(</span><span class="n">iv2</span><span class="p">),</span> <span class="n">I3</span><span class="p">(</span><span class="n">iv3</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h3 id="45-零长度集合展开">4.5 零长度集合展开</h3>
<p>        集合展开的语法解释对于理解变长模版在不同参数数量的情况下的行为很有帮助。然而，语法解释通常在零长度参数集合时会失败。为了说明这点，我们可以延用之前的 $Point$ 类声明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Point</span> <span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Point</span><span class="p">()</span> <span class="o">:</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        上面的写法是错误的，因为模版参数列表是空的，空的基类和基类初始化列表会导致只剩下一个冒号。集合展开是实际的语法构造，任意大小的参数集合替代不会影响解析。反而，当一个集合展开为一个空列表，程序行为会类似于没有提供列表。这个语义规则及时当解释一个零长度展开语法会</p>

            </div>
            <div class="meta post-footer">
                <span>2022 Mar 16 14:56</span>
                <a href="https://z217blog.cn/post/cpptemplates7/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/cpptemplates6/">C&#43;&#43; Templates（6）：模版实践与泛型库</a></h1>
            <div class="post-content">
                
                
                <h2 id="1-包含模式">1. 包含模式</h2>
<h3 id="11-链接错误">1.1 链接错误</h3>
<p>        大部分<code>C/C++</code>程序员通常以这种方式组织非模版代码：</p>
<ul>
<li>类和其他类型声明在头文件中；</li>
<li>全局变量和非内联函数只在头文件中声明，定义在另一个单独的翻译单元中。</li>
</ul>
<p>        这种方式让类型定义在整个程序中可用并且避免了链接过程中重复定义的错误。在这种方便方式的前提下，很多初学模版的程序员会对将定义声明在头文件中的方式感到抱怨。如果我们将模版函数的声明和定义分开：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef MYFIRST_HPP
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MYFIRST_HPP
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">printTypeof</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// MYFIRST_HPP
</span></span></span></code></pre></div><hr>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;myfirst.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">printTypeof</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><hr>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;myfirst.cpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">ice</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">printTypeof</span><span class="p">(</span><span class="n">ice</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        <code>C++</code>编译器很可能会编译这个程序，但是链接器会产生错误，错误为没有 $printTypeof$ 函数的定义。这个错误的原因是函数模版的定义无法被实例化。要实例化一个模版，编译器必须知道应该实例化哪些定义以及哪些模版参数应该被实例化。不幸的是，在上面的例子中，这两个信息都被单独编译了。因此，当我们的编译器想实例化 $printTypeof$ 的调用但是没有看到定义时，它只能假设这个定义在别处被提供了并且创建了一个引用 ( 给链接器解析 )。另一方面，当编译器处理 $myfirst.cpp$ 文件时，并没有任何提示说明它应该实例化出特定类型参数的模版定义，从而链接器无法解析出先前创建的引用。</p>
<h3 id="12-头文件中的模版">1.2 头文件中的模版</h3>
<p>        之前问题的通用解决方案是采用与宏和内联函数相同的方式：在头文件中定义声明的模版。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#ifndef MYFIRST_HPP
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MYFIRST_HPP
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">printTypeof</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">printTypeof</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#endif </span><span class="c1">// MYFIRST_HPP
</span></span></span></code></pre></div><p>        这种组织模版的方式称为包含模式。通过这种方式，程序现在可以正常编译、链接和执行了。<br>
        这里有几点我们要注意下。最重要的一点是这种方式使得包含头文件的开销变得相当大。在这个例子中，开销主要不是来源于模版定义的代码体积，而是我们在定义模版的过程中使用的其他两个头文件—— $iostream$ 和 $typeinfo$ 。你会发现这两个头文件中有着一大堆代码，因为它们本身也有着很多模版定义。<br>
        在实践中，这个问题很重要，因为它会导致一些重要程序的编译时间增加。因此，我们将通过一些可行的方法来解决这个问题，包括预编译头和显式模版特例化。尽管存在编译时间问题，我们还是推荐使用包含模式来组织你的模版，直到有新的更好的机制推出。<strong>模块</strong> ( $modules$ ) 在<code>C++20</code>被引入，这是一种允许程序员以更加逻辑化的方式组织代码的机制，通过它，编译器可以独立编译所有声明并且之后可以在需要的时候选择性地高效地导入处理好的声明。<br>
        另一个要注意的点是包含模式下非内联模版函数和内联函数以及宏是不同的，它们不会在被调用时展开。相反，当它们被实例化时，会创建一个函数副本。因为这是自动进行的，编译器可能会在两个不同的文件中创建相同的副本。理论上，这不应该由我们来关心，这是<code>C++</code>编译系统该关心的。工程上这种方式大部分时候是可以的，我们完全不需要解决这个问题。对于大型项目，当它们创建自己的代码库，这个问题可能偶尔会出现。<br>
        最后，我们还要注意在上面的例子中，适用于普通函数模版的方式，也适用于类模版中的成员函数和静态数据成员，同样也适用于成员函数模版。</p>
<h2 id="2-模版和内联">2. 模版和内联</h2>
<p>        将函数声明为内联是一种在运行时提升程序速度的通用手段。$inline$ 关键字暗示在函数调用时，会优先将函数体内联替代调用，而不是执行函数调用机制。然而，函数实现会忽略这种暗示。因此，$inline$ 能保证的效果只有允许函数定义在一个程序内多次出现 ( 因为定义会在头文件里并且被多次包含 )。<br>
        类似于内联函数，函数模版也可以在多个翻译单元中被定义，通常通过在头文件中定义并被多个源文件包含实现。这不意味着函数模版会是默认内联的，它是完全由编译器决定的。可能会有点出人意料，通常编译器评估一个函数内联后是否能提升性能的能力比程序员更好。因此，不同编译器处理 $inline$ 关键字的方式是不同的，甚至取决于你指定的编译方式。<br>
        尽管如此，通过合适的监测工具，程序员可以比编译器知道更多的信息，因此希望覆盖编译器的决定 ( 例如在针对不同平台调优时 )。有时候只能通过编译器属性实现这个功能，例如 $noinline$ 或者 $always_-inline$ 。<br>
        完全实例化函数模版的行为与普通函数一样，它们的定义只能出现一次，除非被定义为 $inline$ 。</p>
<h2 id="3-预编译头">3. 预编译头</h2>
<p>        就算没有模版，<code>C++</code>头文件也是很大的，需要编译很久。模版增加了这种趋势，这种让程序员等到抓狂的情况，驱使了供应商实现一种称为<strong>预编译头</strong> ( $precompiled$ $headers$ ，$PCH$ ) 的方法。这个方法在标准之外，行为取决于特定的供应商。尽管我们没有提到在多种<code>C++</code>编译系统中怎么创建和使用预编译头文件，但是了解一下它们是怎么工作的是很有帮助的。<br>
        当编译器翻译一个文件，它从文件开始翻译到文件结束。当它处理文件符号时，它会修改内部状态，例如往符号表中添加表项。当做这些工作的时候，编译器也可能在对象文件中生成代码。预编译头方法是基于代码中的许多文件以相同的 $N$ 行开始这个事实的。让我们假设每个文件都是以相同的 $N$ 行开始的，我们可以编译这 $N$ 行然后在预编译头中保存编译器状态。然后，在我们程序的每个文件，我们可以重新装载之前保存的状态，然后从 $N + 1$ 行开始编译。这样我们就可以说装载之前保存的状态是一个比编译前 $N$ 行快几个数量级的操作。然而，在第一次编译时保存状态的开销比直接编译 $N$ 行的开销要大，这个开销提升可能从 $20\% \sim 200\%$ 不等。<br>
        使用预编译头的关键是尽可能保证在文件的开始使用最大数目相同的代码。在工程中，这意味着文件必须从相同的 #$include$ 指示开始，这会占用很大一部分编译时间。因此，关注头文件包含的顺序是很有用的。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span></code></pre></div><hr>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span></code></pre></div><p>        这两个文件就不能使用预编译头了，因为它们的起始状态不同。<br>
        一些程序员觉得可以通过包含一些不必要的头文件从而让编译器使用预编译头来加速编译，这个想法可以很大程度上简化包含策略的管理。例如，直接创建一个包含所有标准头文件的头文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/* std.hpp */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;deque&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span></code></pre></div><p>        这个文件可以被预编译，并且每个使用标准库的程序文件都可以直接简单地包含这个头文件。通常，这个文件需要一段时间来编译，但是如果系统有着足够的内存，预编译头方法就可以让它的处理速度比大部分不使用预编译的单独处理每个标准库的方法快很多。标准头文件适合在这种方法中使用，因为它们几乎不改变，因此我们定义的 $std.hpp$ 预编译头只需要编译一次。否则，预编译头通常会是项目依赖配置的一部分 ( 例如，通过 $make$ 或者<code>IDE</code>来按需更新 )。<br>
        一个管理预编译头的方式是创建预编译头文件<strong>层</strong> ( $layers$ )，涵盖最常用、最稳定的头文件到大部分时间不会改变的头文件。然而，如果头文件会被频繁修改，那么为它们创建预编译头花费的时间会比使用预编译头节省的时间要多。这种方式的一个重要用法是使用一个更稳定的预编译头文件层提升相对来讲更不稳定的头文件的预编译速度。例如，假设除了 $std.hpp$ ，我们还定义了一个 $core.hpp$ 头文件，包含了我们项目需要的额外的工具，具有一定程度的稳定性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;std.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;core_data.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;core_algos.hpp&#34;</span><span class="cp">
</span></span></span></code></pre></div><p>        因为这个文件先包含了 $std.hpp$ ，编译器可以装载相关联的预编译头，就不需要重新编译整个标准头文件了。当这个文件处理完成后，会生成一个新的预处理头文件。应用之后在使用 $core.hpp$ 时候，就可以快速访问其中定义的功能了。</p>
<h2 id="4-可调用实体">4. 可调用实体</h2>
<p>        许多库包含了用于客户端代码传递调用实体的接口，例如需要在其他线程执行的某个操作、哈希函数、用于集合排序的对象或者提供一些默认参数值的泛型封装。标准库定义了许多可以携带可调用实体的组件。用于这种情况的术语是<strong>回调</strong> ( $callback$ )，通常它指代作为参数传递给函数调用的实体。例如，一个排序函数可能包含一个回调参数作为排序标准，当判断哪个元素在前时会调用。<br>
        <code>C++</code>有许多作为回调的有用的类型，因为它们既可以作为函数调用参数，也可以直接被调用。这些类型有：</p>
<ul>
<li>函数指针；</li>
<li>重载了 $operator(\ )$ 函数的类；</li>
<li>可以转为函数指针或者函数引用的类。</li>
</ul>
<p>        总的来说，这些类型被称为<strong>函数对象类型</strong> ( $function$ $ojbect$ $types$ )，这种类型的值称为<strong>函数对象</strong> ( $function$ $object$ )。<code>C++</code>标准库稍微扩展了<strong>可调用类型</strong> ( $callable$ $type$ ) 的概念，使得它既可以是一个函数对象类型也可以是一个成员指针。可调用类型值称为<strong>可调用对象</strong> ( $callable$ $object$ )。<br>
        通过模版，泛型代码通常可以接收任意类型的可调用对象。</p>
<h3 id="41-函数对象支持">4.1 函数对象支持</h3>
<p>        让我们看看标准库 $for_-each$ 算法是怎么实现的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Callable</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">foreach</span><span class="p">(</span><span class="n">Iter</span> <span class="n">current</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">,</span> <span class="n">Callable</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">current</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">current</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        我们可以这样使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;foreach.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;func() called for: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FuncObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;FuncObj::op() called for: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">primes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">foreach</span><span class="p">(</span><span class="n">primes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">primes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">func</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">foreach</span><span class="p">(</span><span class="n">primes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">primes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">func</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">foreach</span><span class="p">(</span><span class="n">primes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">primes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">FuncObj</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">foreach</span><span class="p">(</span><span class="n">primes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">primes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;lambda called for: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>当传递函数名作为函数参数时，我们不会真的把函数传递过去，而是传递函数指针或者引用。与数组相同，以值方式传递的函数参数会退化为指针，如果对应的参数是模版参数，那么会推导为函数指针；以引用方式传递的函数参数不会退化。然而，函数类型不能使用 $const$ 限定符。如果我们使用 $const$ 声明 $foreach$ 的最后一个参数，$const$ 会被忽略；</li>
<li>我们第二个调用显式指定了函数指针，这与第一个调用等价，不过可能更容易理解；</li>
<li>传递一个函数结构体即传递一个类对象作为可调用对象，调用这种类型通常相当于调用它的 $operator(\ )$ 函数。注意你应该将 $operator(\ )$ 定义为常量成员函数，否则，当框架或库想要调用不改变传递对象的状态时，就会产生一个错误。一个类类型对象也可以隐式转为一个<strong>代理调用函数</strong> ( $surrogate$ $call$ $function$ )，通过这种方式，它们也可以被调用；</li>
<li><code>Lambda</code>表达式生成一个函数结构体 ( 称为闭包，$closure$ )，因此这种方式与上面一样。</li>
</ul>
<h3 id="42-成员函数和额外参数">4.2 成员函数和额外参数</h3>
<p>        一种调用实体并没有在先前的例子中提起：成员函数。因为调用一个非静态成员函数通常会涉及确定一个被调用对象，语法类似于 $object.memfunc(\dots)$ 或者 $ptr-&gt;memfun(\dots)$ ，而不是 $function(\dots)$ 。幸运的是，<code>C++17</code>开始，标准库提供了 $std::invoke$ 函数，允许我们统一普通函数调用语法和成员函数调用语法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Callable</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">foreach</span><span class="p">(</span><span class="n">Iter</span> <span class="n">current</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">,</span> <span class="n">Callable</span> <span class="n">op</span><span class="p">,</span> <span class="n">Args</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">args</span><span class="p">...,</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">current</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        这里除了可调用对象参数之外，我们还接收一个可选的额外的变长参数。$foreach$ 函数使用给定的可调用对象和额外的参数调用 $std::invoke$ ，后者的调用逻辑为：</p>
<ul>
<li>如果可调用对象是成员指针，它使用第一个额外参数作为被调用对象，其余额外参数作为调用参数；</li>
<li>否则，所有额外参数都作为调用参数。</li>
</ul>
<p>        注意我们这里不能使用完美转发，因为第一个调用可能会移动，从而导致之后的调用产生未定义行为。<br>
        通过这种实现方式，我们可以调用成员函数了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;foreachinvoke.hpp&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">memfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;MyClass::memfunc() called for: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">primes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">foreach</span><span class="p">(</span><span class="n">primes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">primes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">          <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">prefix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">prefix</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">},</span>
</span></span><span class="line"><span class="cl">          <span class="s">&#34;- value: &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">MyClass</span> <span class="n">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">foreach</span><span class="p">(</span><span class="n">primes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">primes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">          <span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">memfunc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">obj</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="43-包装函数调用">4.3 包装函数调用</h3>
<p>        $std::invoke$ 的一个应用是包装函数调用，这种方式下我们也可以使用完美转发来传递可调用对象和参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Callable</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">call</span><span class="p">(</span><span class="n">Callable</span><span class="o">&amp;&amp;</span> <span class="n">op</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                     <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        另一个有趣的事是调用者如何处理被调用者使用完美转发返回的返回值。为了支持返回引用 ( 比如 $std::ostream$&amp; )，你必须使用 $decltype(auto)$ 。如果你想要存储 $std::invoke$ 的返回值，你也可以使用 $decltype(auto)$ 。但是，使用 $decltype(auto)$ 有一个问题：如果调用对象返回 $void$ ，那么就无法使用 $decltype(auto)$ ，因为 $void$ 是一个不完全类型。你可以这样解决：</p>
<ul>
<li>在调用前声明一个对象，该对象的析构函数执行你想要对 $std::invoke$ 返回值所进行的操作：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">cleanup</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">cleanup</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">dummy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                   <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span></span></code></pre></div><ul>
<li>分开实现 $void$ 和非 $void$ 情况：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Callable</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">call</span><span class="p">(</span><span class="n">Callable</span><span class="o">&amp;&amp;</span> <span class="n">op</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                  <span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="kt">void</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">ret</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Callable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...)};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="5-其他泛型工具">5. 其他泛型工具</h2>
<h3 id="51-type-traits">5.1 <code>Type</code> <code>Traits</code></h3>
<p>        标准库提供了一系列实用工具，称为 $type$ $traits$ ，允许我们检查和修改类型。这种泛型代码可以适配其实例化所用的类型，并依据不同类型进行不同的操作。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_cv_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;invalid instantiation of class C for void type&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">V</span><span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_reference_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_convertible_v</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">has_virtual_destructor_v</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        就像这个例子展示的，检查不同模版实现之间的不同特定条件。这里我们使用了编译时 $if$ 特性，也可以通过 $std::enable_-if$ 、部分特例化或者<code>SFINAE</code>来启用和禁用帮助类模版实现。<br>
        注意 $type$ $traits$ 可能会产生一些出乎你意料的行为，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">remove_const_t</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span><span class="o">&amp;&gt;</span>  <span class="c1">// int const&amp;
</span></span></span></code></pre></div><p>        因为引用不是 $const$ ，所以调用不会产生任何效果，而是返回传入类型。因此，如果你想要移除 $const$ ，你必须先移除引用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">remove_const_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span><span class="o">&amp;&gt;&gt;</span>  <span class="c1">// int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_const_t</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span><span class="o">&amp;&gt;&gt;</span>  <span class="c1">// int const
</span></span></span></code></pre></div><p>        或者，你也可以直接：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span><span class="o">&amp;&gt;</span>  <span class="c1">// int
</span></span></span></code></pre></div><p>        但是上面这种也会把原始数组和函数转换为指针。<br>
        有些 $type$ $traits$ 对传入类型也有要求，不满足这些要求可能会产生未定义行为，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="c1">// unsigned int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span><span class="o">&amp;&gt;</span>  <span class="c1">// 未定义行为
</span></span></span></code></pre></div><p>        有时候也会产生出乎意料的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">add_rvalue_reference_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="c1">// int&amp;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">add_rvalue_reference_t</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span><span class="o">&gt;</span>  <span class="c1">// int const&amp;&amp;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">add_rvalue_reference_t</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span><span class="o">&amp;&gt;</span>  <span class="c1">// int const&amp;
</span></span></span></code></pre></div><p>        我们可能认为通过 $add_-rvalue_-reference_-t$ 可以获得右值，但是因为引用折叠，最终会返回一个左值。另一个例子是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">is_copy_assignable_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">is_assignable_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span>  <span class="c1">// false
</span></span></span></code></pre></div><p>        $is_-copy_-assignable$ 检查类型是否可以拷贝赋值，而 $is_-assignable_-v$ 则会考虑值类型，因为你无法将一个右值赋给右值，所以会返回 $false$ 。从这个角度来看，第一个表达式其实等价于：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">is_assignable_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;&gt;</span>  <span class="c1">// true
</span></span></span></code></pre></div><p>        同样的道理，有：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">is_swappable_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">is_swappable_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;&gt;</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">is_swappable_with_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span>  <span class="c1">// false
</span></span></span></code></pre></div><h3 id="52-stdaddressof">5.2 <code>std::addressof</code></h3>
<p>        $std::addressof$ 函数模版生成一个对象或者函数的确切地址。即使对象类型重载了 &amp; 运算符，它也能工作。所以，我们推荐使用 $addressof$ 来获取对象或者一个任意类型的地址：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>  <span class="c1">// 如果T重载了&amp;，可能会失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="53-stddeclval">5.3 <code>std::declval</code></h3>
<p>        $std::declval$ 函数模版可以作为一个确切类型对象引用的占位符，这个函数没有定义，因此无法被调用 ( 也不会创建一个对象 )。因此，它只能被用于不进行计算的操作 ( 例如 $decltype$ 和 $sizeof$ )。所以，这个模版用于你不想创建一个对象，而是假设你有一个对应类型的对象的时候。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">typename</span> <span class="n">RT</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                        <span class="k">decltype</span><span class="p">(</span><span class="nb">true</span> <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">())</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">RT</span> <span class="n">max</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">,</span> <span class="n">T2</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></div><p>        为了避免调用 $T1$ 和 $T2$ 的默认构造函数，我们使用 $std::declval$ 来假设这里有一个这种类型的对象。不要忘了使用 $std::decay$ 来保证返回类型可以被引用，因为 $std::declval$ 本身产生的是一个右值引用。</p>
<h2 id="6-完美转发临时变量">6. 完美转发临时变量</h2>
<p>        我们可以通过转发引用和 $std::forward$ 来完美转发泛型参数。然而，有时候我们需要在泛型代码中完美地转发并非参数的数据。这种情况下，我们可以使用 $auto$&amp;&amp; 来创建一个可以被转发的变量。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">set</span><span class="p">(</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="p">}</span>
</span></span></code></pre></div><p>        如果我们要对上面的函数应用完美转发，可以这样做：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        这样就避免了没有必要的中间值拷贝了。</p>
<h2 id="6-模版引用参数">6. 模版引用参数</h2>
<p>        虽然不常见，模版类型参数可以成为引用类型。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">tmplParamIsReference</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;T is reference: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_reference_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span><span class="o">&amp;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">tmplParamIsReference</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tmplParamIsReference</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>  <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tmplParamIsReference</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tmplParamIsReference</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>  <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        即使引用变量被传给了 $tmplParamIsReference$ ，模版参数 $T$ 还是被推导为非引用类型 ( 因为对于一个引用变量 $v$ ，表达式 $v$ 具有引用类型，但是表达式 $v$ 的类型永远都不会是一个引用 )。然而，我们可以通过显式指定的方式来强制使用引用。这样可以改变一个模版的行为，但是最好不要这样做，一个模版可能没有被设计为这样使用，从而导致错误或者未定义行为。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">T</span><span class="p">{}</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RefMem</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">zero</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">RefMem</span><span class="p">()</span> <span class="o">:</span> <span class="n">zero</span><span class="p">{</span><span class="n">Z</span><span class="p">}</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">null</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RefMem</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rm1</span><span class="p">,</span> <span class="n">rm2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rm1</span> <span class="o">=</span> <span class="n">rm2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RefMem</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span> <span class="n">rm3</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">RefMem</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">rm4</span><span class="p">;</span>  <span class="c1">// 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">extern</span> <span class="kt">int</span> <span class="n">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">RefMem</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">null</span><span class="o">&gt;</span> <span class="n">rm5</span><span class="p">,</span> <span class="n">rm6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rm5</span> <span class="o">=</span> <span class="n">rm6</span><span class="p">;</span>  <span class="c1">// 错误，引用成员没有赋值运算符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        我们使用 $int$ 来实例化类型时，这个类模版可以正常工作。但是当我们使用引用来实例化时，就有点棘手了：</p>
<ul>
<li>默认实例化机制无法运行；</li>
<li>不能再传入 $0$ 作为初始值；</li>
<li>最出乎意料的是，赋值运算符也不能使用，因为具有非静态引用类型成员的类没有默认的赋值运算符。</li>
</ul>
<p>        并且，使用引用类型作为非类模版参数是很麻烦且危险的。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">SZ</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Arr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">Arr</span><span class="p">()</span> <span class="o">:</span> <span class="n">elems</span><span class="p">(</span><span class="n">SZ</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SZ</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Arr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// 编译时错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">Arr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">size</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>  <span class="c1">// 运行时错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        这里我们尝试使用引用类型实例化，但是因为 $vector$ 不能接收引用类型，所以会产生一个编译错误。比编译错误更糟糕的是运行错误，我们将 $SZ$ 参数变为一个引用，从而导致它可以在容器未察觉的情况下随意修改，因此导致了未定义行为。注意，就算我们将 $SZ$ 的模版参数声明改为 $int$ $const$&amp; 也无济于事，因为通过 $size$ ，引用值还是可以被修改。<br>
        这个例子有些牵强，然而，在更复杂的情况下，我们并不能排除类似问题发生的可能。而且，在<code>C++17</code>中，非类型参数也可以被推导，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">SZ</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Arr</span><span class="p">;</span>
</span></span></code></pre></div><p>        这样会产生引用类型，因此我们会避免这种情况 ( 默认情况下使用 $auto$ )。<br>
        因为这个，<code>C++</code>标准库有时候会进行出乎意料的特例化和约束，例如：</p>
<ul>
<li>为了在接收引用对象时仍然保持赋值运算符，类模版 $std::pair$ 和 $std::tuple$ 显式实现赋值运算符而非使用默认版本。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">pair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">T1</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">T2</span> <span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pair</span><span class="p">(</span><span class="n">pair</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pair</span><span class="p">(</span><span class="n">pair</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pair</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">pair</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pair</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">pair</span><span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>因为解决可能副作用的方案的复杂性，<code>C++17</code>标准库类模版 $std::optional$ 和 $std::variant$ 使用引用类型来实例化会产生错误：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">optional</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;Invalid instantiation of optional&lt;T&gt; for references&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        引用类型总体上与其他类型有着很大区别，它遵循一个独一无二的语言规则。</p>
<h2 id="7-推迟计算">7. 推迟计算</h2>
<p>        在模版实现中，模版代码是否能处理未完成类型有时会成为一个问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cont</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">*</span> <span class="n">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        这时，这个类可以使用未完成类型，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Cont</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        然而，如果使用一些 $traits$ ，那么类模版就会失去这种可以使用未完成类型的能力：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cont</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">*</span> <span class="n">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_move_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&gt;::</span><span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        这里我们使用 $traits$ 来判断根据 $T$ 是否可以移动构造来决定 $foo$ 的返回值是 $T$&amp;&amp; 还是 $T$&amp; 。这样做的问题是 $is_-move_-constructible$ 要求其模版参数是一个完成类型 ( 并且非 $void$ 和未知长度数组 )。因此，如果我们继续使用 $Cont$ 声明 $Node$ ，就会产生一个错误。<br>
        我们可以使用一个成员模版来代替原本的 $foo$ ，这样就把 $is_-move_-constructible$ 的计算推迟到实例化 $foo$ 的时候了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Cont</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">*</span> <span class="n">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">D</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_move_constructible</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&gt;::</span><span class="n">type</span>
</span></span><span class="line"><span class="cl">  <span class="n">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="7-编写泛型库时的注意事项">7. 编写泛型库时的注意事项</h2>
<ul>
<li>在模版中使用转发引用来转发。如果值并不依赖于模版参数，使用 $auto$&amp;&amp; ；</li>
<li>当参数被声明为转发引用时，注意在传递左值时模版参数具有引用类型；</li>
<li>当你需要一个依赖于模版参数的对象的地址的时候，使用 $std::addressof$ ，这样就可以避免类型重载 $operator$&amp; 带来的错误了；</li>
<li>对于成员函数模版，确保它们不会比预定义的拷贝/移动构造函数和运算符有着更优的匹配；</li>
<li>当模版参数可能是字符串常量并且以非值方式传递时，考虑使用 $std::decay$ ；</li>
<li>如果你有一个依赖于模版参数的作为返回值或者同时作为传入值和返回值的参数时，注意模版参数类型可能会推导为 $const$ ；</li>
<li>注意模版引用参数带来的副作用，尤其是，你可能想要让返回值不是一个引用的时候；</li>
<li>注意对未完成类型的支持，例如用于递归数据结构时；</li>
<li>对所有可能的数组类型进行重载，不要只有 $T[SZ]$ 这种情况。</li>
</ul>

            </div>
            <div class="meta post-footer">
                <span>2022 Mar 14 15:57</span>
                <a href="https://z217blog.cn/post/cpptemplates6/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:zihan.zhouchn@outlook.com">zihan.zhouchn@outlook.com</a>
            </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2022, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
    <script>
        InitLightSwitcher()
    </script>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
</main>
</body>

</html>