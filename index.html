<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.92.2" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B20/">Unix网络编程（20）：共享内存</a>
        
        
        <p>《Unix网络编程》读书笔记（20）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 23 13:45
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B19/">Unix网络编程（19）：信号量</a>
        
        
        <p>《Unix网络编程》读书笔记（19）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 21 16:43
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B18/">Unix网络编程（18）：锁</a>
        
        
        <p>《Unix网络编程》读书笔记（18）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 21 14:36
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B17/">Unix网络编程（17）：消息队列</a>
        
        
        <p>《Unix网络编程》读书笔记（17）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 20 14:01
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B16/">Unix网络编程（16）：管道和FIFO</a>
        
        
        <p>《Unix网络编程》读书笔记（16）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 19 14:31
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B20/">Unix网络编程（20）：共享内存</a></h1>
            <div class="post-content">
                <p>        共享内存是可用<code>IPC</code>形式中最快的。因为将内存区映射到进程的地址空间之后，进程间的数据传递就不用通过内核。</p>
<h2 id="1-共享内存操作">1. 共享内存操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回映射内存区的地址，出错返回MAP_FAILED
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">mmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">offset</span><span class="p">);</span>
</code></pre></div><p>        $mmap$ 函数把一个文件或一个<code>POSIX</code>共享内存区对象映射到调用进程的地址空间。使用该函数有三个目的：</p>
<ul>
<li>对普通文件使用内存映射<code>I/O</code>；</li>
<li>对特殊文件进行匿名内存映射；</li>
<li>使用 $shm_-open$ 提供无亲缘关系的进程间的<code>POSIX</code>共享内存区。</li>
</ul>
<p>        $addr$ 可以指定描述符 $fd$ 应该被映射到的进程内存空间的地址，也可以指定为 $NULL$ ，从而让内核自己选择。$len$ 是映射到调用进程地址空间中的字节数，从被映射字节开头第 $offset$ 个字节开始，$offset$ 可以为 $0$ 。内存映射区的保护由 $prot$ 参数提供，可选值有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">$prot$</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$PROT_-READ$</td>
<td style="text-align:left">数据可读</td>
</tr>
<tr>
<td style="text-align:left">$PROT_-WRITE$</td>
<td style="text-align:left">数据可写</td>
</tr>
<tr>
<td style="text-align:left">$PROT_-EXEC$</td>
<td style="text-align:left">数据可执行</td>
</tr>
<tr>
<td style="text-align:left">$PROT_-NONE$</td>
<td style="text-align:left">数据不可访问</td>
</tr>
</tbody>
</table>
<p>        $prot$ 参数的常见值为 $PROT_-READ$ | $PROT_-WRITE$ 。$flags$ 指定共享内存属性，可选值有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">$flag$</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$MAP_-SHARED$</td>
<td style="text-align:left">变动是共享的</td>
</tr>
<tr>
<td style="text-align:left">$MAP_-PRIVATE$</td>
<td style="text-align:left">变动是私有的</td>
</tr>
<tr>
<td style="text-align:left">$MAP_-FIXED$</td>
<td style="text-align:left">准确地解释 $addr$</td>
</tr>
</tbody>
</table>
<p>        其中 $MAP_-SHARED$ 和 $MAP_-PRIVATE$ 必须选择其中一个。如果选择 $MAP_-SHARED$ ，那么调用进程对映射区内所做的修改对其他进程可见，并且也会修改底层对象；如果选择 $MAP_-PRIVATE$ ，那么调用进程对映射区所做的修改只有当前进程可见，而且不会修改底层对象；从移植性上考虑，不应该指定 $MAP_-FIXED$ ，如果没有指定该标志并且 $addr$ 非空，则具体行为取决于实现。可移植的代码应该把 $addr$ 设置为 $NULL$ 并不指定 $MAP_-FIXED$ 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">munmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">msync</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div><p>        $munmap$ 从进程空间中删除映射区，删除之后再次访问先前映射区地址会产生 $SIGSEGV$ 信号。$msync$ 算法用于主动将映射区中的数据同步到硬盘，可选的 $flags$ 参数有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">$flag$</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$MS_-ASYNC$</td>
<td style="text-align:left">异步写</td>
</tr>
<tr>
<td style="text-align:left">$MS_-SYNC$</td>
<td style="text-align:left">同步写</td>
</tr>
<tr>
<td style="text-align:left">$MS_-INVALIDATE$</td>
<td style="text-align:left">使高速缓存中的数据失效</td>
</tr>
</tbody>
</table>
<p>        其中 $MS_-ASYNC$ 和 $MS_-SYNC$ 必须指定其中一个。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">shared</span> <span class="p">{</span>
  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">;</span>  <span class="c1">// the mutex: a Posix memory-based semaphore
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>  <span class="c1">// the counter
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nloop</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">shared</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: incr2 &lt;pathname&gt; &lt;#loops&gt;&#34;</span><span class="p">);</span>
  <span class="n">nloop</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

  <span class="c1">// open file, initalize to 0, map into memory
</span><span class="c1"></span>  <span class="n">fd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">);</span>
  <span class="n">Write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shared</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared</span><span class="p">));</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
             <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

  <span class="c1">// initialize semaphore that is shared between processes
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">setbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// stdout is unbuffered
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// child
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nloop</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;child: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">);</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// parent
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nloop</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;parent: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="2-匿名内存映射">2. 匿名内存映射</h2>
<p>        匿名内存映射可以让我们在不用创建文件的前提下使用内存映射。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nloop</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="n">sem_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: incr_map_anon &lt;#loops&gt;&#34;</span><span class="p">);</span>
  <span class="n">nloop</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// map into memory
</span><span class="c1"></span>  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
             <span class="n">MAP_SHARED</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">// 后略...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>        $/dev/zero$ 设备文件会不断产生空字符，也可以用于实现匿名内存映射。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nloop</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="n">sem_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: incr_dev_zero &lt;#loops&gt;&#34;</span><span class="p">);</span>
  <span class="n">nloop</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// open /dev/zerp, map into memory
</span><span class="c1"></span>  <span class="n">fd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="s">&#34;/dev/zero&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

  <span class="c1">// 后略...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h2 id="3-安全访问共享内存映射区">3. 安全访问共享内存映射区</h2>
<p>        访问共享内存映射区时可能会产生两种错误：</p>
<ol>
<li>当访问的区域位于映射区以外时，返回 $SIGSEGV$ 错误；</li>
<li>当访问的区域位于映射区以内但是超出文件大小时，返回 $SIGBUS$ 错误。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define FILE &#34;test.data&#34;
</span><span class="cp">#define SIZE 32768
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

  <span class="c1">// open: create or truncate; then mmap file
</span><span class="c1"></span>  <span class="n">fd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">FILE</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">);</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">SIZE</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4096</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;setting file size to %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">Ftruncate</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;ptr[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        上述程序使用了让文件持续增长的技巧。它指定了一个大于文件大小的内存映射区，同时不断跟踪文件大小，并让文件大小随着写入增长。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">ftruncate</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div><p>        处理 $mmap$ 的时候，普通文件或共享内存区的大小都可以通过 $ftruncate$ 修改。但是对于普通文件和共享内存区对象文件，<code>POSIX</code>对它们的处理逻辑不同：</p>
<ul>
<li>对于普通文件，如果文件大小大于 $length$ ，那么文件会被缩小并且丢弃额外的数据；如果文件大小小于 $length$ ，那么文件怎么修改和大小怎么改变是未定义的。实际上，对于一个普通文件，一种可移植的增加大小的方法是先使用 $lseek$ 定位到 $length - 1$ ，然后写入 $1$ 字节数据。所幸的是，几乎所有<code>Unix</code>实现都支持使用 $ftruncate$ 扩展一个文件；</li>
<li>对于共享内存区对象文件，$ftruncate$ 会把大小设置为 $length$ 字节。</li>
</ul>
<p>        普通文件指通过 $open$ 打开的文件，共享内存区对象文件则指通过 $shm_-open$ 打开的文件，稍后我们会看到 $shm_-open$ 的调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">fstat</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</code></pre></div><p>        当打开一个已存在的共享内存区对象文件时，我们可以通过 $fstat$ 获取该文件信息。$stat$ 结构有 $12$ 或以上的成员，然而当 $fd$ 指代一个共享内存区对象时，只有四个成员有效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">stat</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="n">mode_t</span> <span class="n">st_mode</span><span class="p">;</span>  <span class="c1">// mode: S_I{RW}{USR,GRP,OTH}
</span><span class="c1"></span>  <span class="n">uid_t</span> <span class="n">st_uid</span><span class="p">;</span>  <span class="c1">// user ID of owner
</span><span class="c1"></span>  <span class="n">gid_t</span> <span class="n">st_gid</span><span class="p">;</span>  <span class="c1">// group ID of owner
</span><span class="c1"></span>  <span class="n">off_t</span> <span class="n">st_size</span><span class="p">;</span>  <span class="c1">// size in bytes
</span><span class="c1"></span>  <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><h2 id="4-posix共享内存区操作">4. <code>POSIX</code>共享内存区操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回非负描述符，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">shm_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>

<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">shm_unlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</code></pre></div><p>        <code>POSIX</code>共享内存区涉及以下两个步骤要求：</p>
<ol>
<li>调用 $shm_-open$ 并指定文件名，创建或打开一个共享内存区对象文件；</li>
<li>调用 $mmap$ 把这个共享内存区对象文件映射到调用进程的地址空间。</li>
</ol>
<p>        $oflag$ 参数必须含有 $ORDONLY$ 和 $O_-RDWR$ 的其中一个，还可以指定 $O_-CREAT$ 、$O_-EXCL$ 和 $O_-TRUNC$ 。$mode$ 指定权限位，在指定了 $O_-CREAT$ 的前提下使用，如果没有指定 $O_-CREAT$ ，可以设置为 $0$ 。$shm_-unlink$ 则负责删除一个共享内存区对象文件，跟其他 $unlink$ 一样，已打开的文件不会影响删除。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd1</span><span class="p">,</span> <span class="n">fd2</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr2</span><span class="p">;</span>
  <span class="n">pid_t</span> <span class="n">childpid</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">stat</span> <span class="n">stat</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: test3 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="n">shm_unlink</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">fd1</span> <span class="o">=</span> <span class="n">Shm_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">);</span>
  <span class="n">Ftruncate</span><span class="p">(</span><span class="n">fd1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="n">fd2</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="s">&#34;/etc/hostname&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
  <span class="n">Fstat</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">childpid</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// child
</span><span class="c1"></span>    <span class="n">ptr2</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">ptr1</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
                <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;child: shm ptr = %p, hostname ptr = %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">);</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;shared memory integer = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// parent: mmap in reverse order from child
</span><span class="c1"></span>  <span class="n">ptr1</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">ptr2</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;parent: shm ptr = %p, hostname ptr = %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr1</span><span class="p">,</span> <span class="n">ptr2</span><span class="p">);</span>
  <span class="o">*</span><span class="n">ptr1</span> <span class="o">=</span> <span class="mi">777</span><span class="p">;</span>
  <span class="n">Waitpid</span><span class="p">(</span><span class="n">childpid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        上面的程序演示了父子进程可以把同一个共享内存区对象映射到不同的进程地址，并且通过这不同的进程地址读出相同的值。</p>
<h2 id="5-生产者-消费者模型">5. 生产者-消费者模型</h2>
<p>        我们可以通过共享内存技术实现生产者-消费者模型，通过共享内存区来容纳消息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define MESGSIZE 256  </span><span class="c1">// max #bytes per message, incl. null at end
</span><span class="c1"></span><span class="cp">#define NMESG 16  </span><span class="c1">// max #messages
</span><span class="c1"></span>
<span class="k">struct</span> <span class="n">shmstruct</span> <span class="p">{</span>  <span class="c1">// struct stored in shared memory
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">;</span>  <span class="c1">// three POSIX memory-based semaphores
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">nempty</span><span class="p">;</span>
  <span class="n">sem_t</span> <span class="n">nstored</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nput</span><span class="p">;</span>  <span class="c1">// index into msgoff[] for next put
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">noverflow</span><span class="p">;</span>  <span class="c1">// #overflows by senders
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">noverflowmutex</span><span class="p">;</span>  <span class="c1">// mutex for noverflow counter
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">msgoff</span><span class="p">[</span><span class="n">NMESG</span><span class="p">];</span>  <span class="c1">// offset in shared memory of each message
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">msgdata</span><span class="p">[</span><span class="n">NMESG</span> <span class="o">*</span> <span class="n">MESGSIZE</span><span class="p">];</span>  <span class="c1">// the actual messages
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><p>        当生产者想发送消息但是没有空间时，我们不会阻塞生产者，而是递增 $noverflow$ 计数。$msgoff$ 指出每个消息的偏移，其中 $msgoff[0] = 0$ 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;cliserv2.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">lastnoverflow</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">shmstruct</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: server2 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// create shm, set its size, map it, close descriptor
</span><span class="c1"></span>  <span class="n">shm_unlink</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">// OK if this fails
</span><span class="c1"></span>  <span class="n">fd</span> <span class="o">=</span> <span class="n">Shm_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">);</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmstruct</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
             <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Ftruncate</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmstruct</span><span class="p">));</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

  <span class="c1">// initialize the array of offsetss
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">NMESG</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">msgoff</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="n">MESGSIZE</span><span class="p">;</span>

  <span class="c1">// initialize the semaphores in shared memory
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NMESG</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflowmutex</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// this program is the consumer
</span><span class="c1"></span>  <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">lastnoverflow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nstored</span><span class="p">);</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">msgoff</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;index = %d: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">msgdata</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">NMESG</span><span class="p">)</span>
      <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// circular buffer
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nempty</span><span class="p">);</span>

    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflowmutex</span><span class="p">);</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflow</span><span class="p">;</span>  <span class="c1">// don&#39;t printf while mutex held
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflowmutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="n">lastnoverflow</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;noverflow = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
      <span class="n">lastnoverflow</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        消费者程序会先删除可能存在的共享内存区对象文件，然后重新创建。接着会初始化每个消息的偏移。最后，在每次循环的末尾都会检查 $noverflow$ ，如果改变了，就输出它的最新值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;cliserv2.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nloop</span><span class="p">,</span> <span class="n">nusec</span><span class="p">;</span>
  <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">mesg</span><span class="p">[</span><span class="n">MESGSIZE</span><span class="p">];</span>
  <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">shmstruct</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: client2 &lt;name&gt; &lt;#loops&gt; &lt;#usec&gt;&#34;</span><span class="p">);</span>
  <span class="n">nloop</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="n">nusec</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

  <span class="c1">// open and map shared memory that server must create
</span><span class="c1"></span>  <span class="n">fd</span> <span class="o">=</span> <span class="n">Shm_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDWR</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">);</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmstruct</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
             <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

  <span class="n">pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nloop</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sleep_us</span><span class="p">(</span><span class="n">nusec</span><span class="p">);</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">mesg</span><span class="p">,</span> <span class="n">MESGSIZE</span><span class="p">,</span> <span class="s">&#34;pid %ld: message %d&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">pid</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sem_trywait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nempty</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflowmutex</span><span class="p">);</span>
        <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflow</span><span class="o">++</span><span class="p">;</span>
        <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflowmutex</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;sem_trywait error&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">msgoff</span><span class="p">[</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nput</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nput</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">NMESG</span><span class="p">)</span>
      <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nput</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// circular buffer
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">msgdata</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="n">mesg</span><span class="p">,</span> <span class="n">MESGSIZE</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nstored</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        生产者程序使用不会阻塞 $sem_-trywait$ 调用，如果调用失败 ( 即 $nempty$ 信号量不大于 $0$ )，说明映射区中没有空间，递增 $noverflow$ 。</p>

            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 23 13:45</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B20/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B19/">Unix网络编程（19）：信号量</a></h1>
            <div class="post-content">
                <p>        <strong>信号量</strong> ( $semaphore$ ) 是一种用于不同进程间或一个进程内的不同线程间同步的原语。<code>POSIX</code>信号量不必在内核中维护，可能使用文件系统中的某个文件来标识。</p>
<h2 id="1-有名信号量操作">1. 有名信号量操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回信号量指针，出错返回SEM_FAILED
</span><span class="c1"></span><span class="n">sem_t</span> <span class="o">*</span><span class="nf">sem_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="p">...</span>
  <span class="cm">/* mode_t mode, unsigned int value */</span> <span class="p">);</span>
</code></pre></div><p>        $sem_-open$ 创建一个有名信号量或者打开一个有名信号量。有名信号量既可以用于线程间同步，又可以用于进程间同步。$oflag$ 参数可以是 $0$ 、$O_-CREAT$ 或 $O_-CREAT$ | $O_-EXCL$ 。如果指定了 $O_-CREAT$ ，那么也要指定权限位 $mode$ 和信号量初始值 $value$ 。信号量初始值不能超过 $SEM_-VALUE_-MAX$ ( 这个常值至少为 $32767$ )。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">sem_close</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_unlink</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div><p>        当进程终止时，内核会对仍然打开着的有名信号量执行关闭操作。关闭一个信号量只是减少其引用计数，并不会删除。如果想要删除一个信号量，需要调用 $sem_-unlink$ 函数。类似于 $unlink$ ，如果在调用 $sem_-unlink$ 时该信号量引用计数不为 $0$ ，依然会进行删除，但是析构会等到引用计数为 $0$ 时才会发生。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_trywait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_getvalue</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">valp</span><span class="p">);</span>
</code></pre></div><p>        $sem_-wait$ 测试指定信号量的值，如果大于 $0$ ，就将其减 $1$ 并返回；如果不大于 $0$ ，就会阻塞直到该值大于 $0$ ，然后减 $1$ 并返回。如果在阻塞的过程中被中断，$sem_-wait$ 会返回并设置 $EINTR$ 错误。考虑到可能使用同一信号量的其他线程的存在，测试并减 $1$ 这个过程是原子的。$sem_-trywait$ 是 $sem_-wait$ 的非阻塞版本，如果值不大于 $0$ ，它会返回并设置 $EAGAIN$ 错误。<br>
        当一个线程使用完信号量后，应该调用 $sem_-post$ 函数将信号值加 $1$ 。$sem_-getvalue$ 会在 $valp$ 中返回信号量的当前值。如果信号量非正值，那么返回值可能是 $0$ ，也可能是一个负数，其绝对值为阻塞在该信号量上的线程数。</p>
<h2 id="2-生产者-消费者问题">2. 生产者-消费者问题</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp">#define SEM_MUTEX &#34;mutex&#34;
</span><span class="cp">#define SEM_NEMPTY &#34;nempty&#34;
</span><span class="cp">#define SEM_NSTORED &#34;nstored&#34;
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">;</span>  <span class="c1">// read-only by producer and consumer
</span><span class="c1"></span><span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producer and consumer
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="n">sem_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="o">*</span><span class="n">nempty</span><span class="p">,</span> <span class="o">*</span><span class="n">nstored</span><span class="p">;</span>
<span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">,</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons1 &lt;#items&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// create three semaphores
</span><span class="c1"></span>  <span class="n">shared</span><span class="p">.</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Sem_open</span><span class="p">(</span><span class="n">SEM_MUTEX</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span>
                          <span class="n">FILE_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">shared</span><span class="p">.</span><span class="n">nempty</span> <span class="o">=</span> <span class="n">Sem_open</span><span class="p">(</span><span class="n">SEM_NEMPTY</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span>
                           <span class="n">FILE_MODE</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">shared</span><span class="p">.</span><span class="n">nstored</span> <span class="o">=</span> <span class="n">Sem_open</span><span class="p">(</span><span class="n">SEM_NSTORED</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span>
                            <span class="n">FILE_MODE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// create one producer thread and one consumer thread
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// wait for the two threads
</span><span class="c1"></span>  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// remove the semaphores
</span><span class="c1"></span>  <span class="n">Sem_unlink</span><span class="p">(</span><span class="n">SEM_MUTEX</span><span class="p">);</span>
  <span class="n">Sem_unlink</span><span class="p">(</span><span class="n">SEM_NEMPTY</span><span class="p">);</span>
  <span class="n">Sem_unlink</span><span class="p">(</span><span class="n">SEM_NSTORED</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// store i into circular buffer
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">[</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        上述程序声明 $3$ 个信号量。$mutex$ 保护共享缓冲区；$nempty$ 统计共享缓冲区中的空槽数；$nstored$ 统计共享缓冲区中的元素数。</p>
<h2 id="3-匿名信号量操作">3. 匿名信号量操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shared</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_destroy</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div><p>        匿名信号量是存储在内存中的信号量。匿名信号量通过 $sem_-init$ 初始化，如果 $shared$ 为 $0$ ，那么待初始化的信号量是在同一进程的各个线程间共享的，否则该信号量是在进程间共享的。当 $shared$ 为非零值时，信号量必须存放在某种类型的共享内存区中，从而能让多个进程访问。与 $sem_-open$ 一样，$value$ 指定信号量初始值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">;</span>  <span class="c1">// read-only by producer and consumer
</span><span class="c1"></span><span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores, not pointers
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">,</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons2 &lt;#items&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// initialize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">Set_concurrency</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="4-生产者-消费者问题多生产者和单个消费者">4. 生产者-消费者问题：多生产者和单个消费者</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp">#define MAXNTHREADS 100
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">,</span> <span class="n">nproducers</span><span class="p">;</span>  <span class="c1">// read-only by producer and consumer
</span><span class="c1"></span>
<span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producers and consumer
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">nput</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nputval</span><span class="p">;</span>
  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores, not pointers
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">];</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">],</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons3 &lt;#items&gt; &lt;#producers&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">nproducers</span> <span class="o">=</span> <span class="n">mi</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">MAXNTHREADS</span><span class="p">);</span>

  <span class="c1">// initialize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// create all producers and one consumer
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="n">nproducers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// wait for all producers and the consumer
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;count[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">&gt;=</span> <span class="n">nitems</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// all done
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nput</span><span class="o">++</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="p">;</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>    <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error: buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]);</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        相较于单生产者单消费者的情况，生产者的循环会在放置了 $nitems$ 个值后终止。</p>
<h2 id="5-生产者-消费者问题多生产者和多消费者">5. 生产者-消费者问题：多生产者和多消费者</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp">#define MAXNTHREADS 100
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">,</span> <span class="n">nproducers</span><span class="p">,</span> <span class="n">nconsumers</span><span class="p">;</span>  <span class="c1">// read-only
</span><span class="c1"></span>
<span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producers and consumers
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">nput</span><span class="p">;</span>  <span class="c1">// item number
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">nputval</span><span class="p">;</span>  <span class="c1">// value to store in buff[]
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">nget</span><span class="p">;</span>  <span class="c1">// item number
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">ngetval</span><span class="p">;</span>  <span class="c1">// value fetched from buff[]
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">prodcount</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">],</span> <span class="n">conscount</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">];</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">],</span> <span class="n">tid_consume</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons4 &lt;#items&gt; &lt;#producers&gt; &lt;#consumers&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">nproducers</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">MAXNTHREADS</span><span class="p">);</span>
  <span class="n">nconsumers</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">MAXNTHREADS</span><span class="p">);</span>

  <span class="c1">// initalize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// create all producers and all consumers
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="n">nproducers</span> <span class="o">+</span> <span class="n">nconsumers</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">prodcount</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prodcount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nconsumers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">conscount</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conscont</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="c1">// wait for all producers and all consumers
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;producer count[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">prodcount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nconsumers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;consumer count[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">conscount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">&gt;=</span> <span class="n">nitems</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// let consumers terminate
</span><span class="c1"></span>      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// all done
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nput</span><span class="o">++</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="o">++</span><span class="p">;</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>    <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shard</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nget</span> <span class="o">&gt;=</span> <span class="n">nitems</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// all done
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">nget</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">shared</span><span class="p">.</span><span class="n">ngetval</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error: buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nget</span><span class="o">++</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">ngetval</span><span class="o">++</span><span class="p">;</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>    <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        这里的生产者函数增添了一行，在检测到已经生产了 $nitems$ 个数据后，为了唤醒阻塞在 $nstored$ 上的线程，会在线程终止前递增 $nstored$ 信号值。同时我们修改消费者函数，每次消费前比较 $nget$ 和 $nitems$ ，确定是否完成所有消费。</p>
<h2 id="6-多缓冲区">6. 多缓冲区</h2>
<p>        在一些处理数据的程序中，我们可能会用到以下形式的循环：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fdin</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* process the data */</span>
  <span class="n">write</span><span class="p">(</span><span class="n">fdout</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        以上循环读入一行文件，并对其处理，然后写回一行输出。我们可以考虑将这个操作分为两个线程，一个线程负责读，另一个负责写。表面上看这可以改善程序的运行，其实不然，因为我们使用的还是同一个缓冲区，写线程还是要等待读线程完成。为了解决这个问题，我们可以使用两个缓冲区。同时，要注意大多数<code>Unix</code>内核检测出对一个文件的顺序读之后，不仅会读出我们需要的磁盘块的内容，还会顺便读取下一个磁盘块的内容，从而可以改善下次读取的操作时间。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 8
</span><span class="cp"></span>
<span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producer and consumer
</span><span class="c1"></span>  <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">BUFFSIZE</span><span class="p">];</span>  <span class="c1">// a buffer
</span><span class="c1"></span>    <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">// count of #bytes in the buffer
</span><span class="c1"></span>  <span class="p">}</span> <span class="n">buff</span> <span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>  <span class="c1">// NBUFF of these buffers/counts
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>  <span class="c1">// input file to copy to stdout
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">,</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mycat2 &lt;pathname&gt;&#34;</span><span class="p">);</span>

  <span class="n">fd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>

  <span class="c1">// initalize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// one producer thread, one consumer thread
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// reader thread
</span><span class="c1"></span>  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// writer thread
</span><span class="c1"></span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">.</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="c1">// critical region
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span> <span class="o">=</span> <span class="n">Read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">NBUFF</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// circular buffer
</span><span class="c1"></span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="c1">// critical region
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">NBUFF</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// circular buffer
</span><span class="c1"></span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        本例子中由 $mutex$ 锁住的临界区是空的，如果我们的数据以链表形式而不是数组形式存储，那么这块区域可用于操作链表。</p>
<h2 id="7-信号量限制">7. 信号量限制</h2>
<p>        <code>POSIX</code>定义了两个信号量限制：</p>
<ul>
<li>$SEM_-NSEMS_-MAX$ ：一个进程可同时打开着的最大信号量 ( <code>POSIX</code>要求至少为 $256$ )；</li>
<li>$SEM_-VALUE_-MAX$ ：一个信号量的最大值 ( <code>POSIX</code>要求至少为 $32767$ )。</li>
</ul>
<p>        这两个常值通常定义在 &lt;$unistd.h$&gt; 头文件中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;SEM_NSEMS_MAX = %ld, SEM_VALUE_MAX = %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
    <span class="n">Sysconf</span><span class="p">(</span><span class="n">_SC_SEM_NSEMS_MAX</span><span class="p">),</span> <span class="n">Sysconf</span><span class="p">(</span><span class="n">_SC_SEM_VALUE_MAX</span><span class="p">));</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 21 16:43</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B19/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B18/">Unix网络编程（18）：锁</a></h1>
            <div class="post-content">
                <h2 id="1-互斥锁上锁和解锁">1. 互斥锁上锁和解锁</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回非负错误码 */</span>

<span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_mutex_trylock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mptr</span><span class="p">);</span>
</code></pre></div><p>        <code>POSIX</code>互斥锁被声明为 $pthread_-mutex_-t$ 类型的变量。如果是静态分配的，需要初始化为常值 $PTHREAD_-MUTEX_-INITIALIZER$ ；如果是动态分配的，或者分配在共享内存区中，需要通过 $pthread_-mutex_-init$ 函数初始化。$pthread_-mutex_-lock$ 是阻塞版本的上锁，会一直阻塞直到该互斥锁解锁；$pthread_-mutex_-trylock$ 是非阻塞版本的上锁，如果该互斥锁已经上锁，会返回 $EBUSY$ 错误。</p>
<h2 id="2-生产者消费者问题">2. 生产者消费者问题</h2>
<p>        <strong>生产者-消费者</strong> ( $producer-consumer$ ) 问题，也称为<strong>有界缓冲区</strong> ( $bounded$ $buffer$ ) 问题。一个或多个生产者创建一个个数据条目，这些条目由一个或多个消费者处理。数据条目在生产者和消费者之间使用某种方式的<code>IPC</code>传递。对于使用管道或消息队列进行通信的生产者和消费者，内核会进行隐式同步。然而对于使用共享内存区进行通信的生产者和消费者，需要进行显式同步。我们使用互斥锁进行显式同步。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define MAXNITEMS 1000000
</span><span class="cp">#define MAXNTHREADS 100
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">;</span>  <span class="c1">// read-only by producer and consumer
</span><span class="c1"></span><span class="k">struct</span> <span class="p">{</span>
  <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">MAXNITEMS</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">nput</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nval</span><span class="p">;</span>
<span class="p">}</span> <span class="n">shared</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">PTHREAD_MUTEX_INITIALIZER</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">];</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">],</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons2 &lt;#items&gt; &lt;#threads&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">MAXNITEMS</span><span class="p">);</span>
  <span class="n">nthreads</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">MAXNTHREADS</span><span class="p">);</span>

  <span class="n">Set_concurrency</span><span class="p">(</span><span class="n">nthreads</span><span class="p">);</span>
  <span class="c1">// start all the producer threads
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="c1">// wait for all the producer threads
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;count[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="c1">// start, then wait for the consumer thread
</span><span class="c1"></span>  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        $set_-concurrency$ 告知系统我们希望并发运行的线程数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">&gt;=</span> <span class="n">nitems</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// array is full, we&#39;re done
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span><span class="p">]</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">nval</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nput</span><span class="o">++</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nval</span><span class="o">++</span><span class="p">;</span>
    <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="3-上锁与等待">3. 上锁与等待</h2>
<p>        我们修改程序，让消费者线程在所有生产者启动后启动。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">];</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">],</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons3 &lt;#item&gt; &lt;#nthreads&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">MAXNITEMS</span><span class="p">);</span>
  <span class="n">nthreads</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">MAXNTHREADS</span><span class="p">);</span>

  <span class="c1">// create all producers and one consumer
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="n">nthreads</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// wait for all producers and the consumer
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;count[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consume_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">shared</span><span class="p">.</span><span class="n">nput</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>  <span class="c1">// an item is ready
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">consume_wait</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        当数组中对应的位置缺少数据，从而消费者不能消费时，我们采用了轮询的方式等待生产者生产。</p>
<h2 id="4-条件变量的唤醒和等待">4. 条件变量的唤醒和等待</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回非负错误码 */</span>

<span class="kt">int</span> <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cptr</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cptr</span><span class="p">);</span>
</code></pre></div><p>        条件变量是类型为 $pthread_-cond_-t$ 的变量。每个条件变量总是与一个互斥锁关联。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define MAXNITEMS 1000000
</span><span class="cp">#define MAXNTHREADS 100
</span><span class="cp"></span>
<span class="c1">// globals shared by threads
</span><span class="c1"></span><span class="kt">int</span> <span class="n">nitems</span><span class="p">;</span>  <span class="c1">// read-only by producer and consumer
</span><span class="c1"></span><span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">MAXNITEMS</span><span class="p">];</span>
<span class="k">struct</span> <span class="p">{</span>
  <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nput</span><span class="p">;</span>  <span class="c1">// next index to store
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">nval</span><span class="p">;</span>  <span class="c1">// next value to store
</span><span class="c1"></span><span class="p">}</span> <span class="n">put</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">PTHREAD_MUTEX_INITIALIZER</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="p">{</span>
  <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
  <span class="n">pthread_cond_t</span> <span class="n">cond</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nready</span><span class="p">;</span>  <span class="c1">// number ready for consumer
</span><span class="c1"></span><span class="p">}</span> <span class="n">nready</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">,</span>
  <span class="n">PTHREAD_COND_INITIALIZER</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">put</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">put</span><span class="p">.</span><span class="n">nput</span> <span class="o">&gt;=</span> <span class="n">nitems</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">put</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// array is full, we&#39;re done
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">buff</span><span class="p">[</span><span class="n">put</span><span class="p">.</span><span class="n">nput</span><span class="p">]</span> <span class="o">=</span> <span class="n">put</span><span class="p">.</span><span class="n">nval</span><span class="p">;</span>
    <span class="n">put</span><span class="p">.</span><span class="n">nput</span><span class="o">++</span><span class="p">;</span>
    <span class="n">put</span><span class="p">.</span><span class="n">nval</span><span class="o">++</span><span class="p">;</span>
    <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">put</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nready</span><span class="p">.</span><span class="n">nready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">cond</span><span class="p">);</span>
    <span class="n">nready</span><span class="p">.</span><span class="n">nready</span><span class="o">++</span><span class="p">;</span>
    <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">nready</span><span class="p">.</span><span class="n">nready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">nready</span><span class="p">.</span><span class="n">nready</span><span class="o">--</span><span class="p">;</span>
    <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        以上程序可能存在上锁冲突：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">nready</span><span class="p">.</span><span class="n">nready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="n">nready</span><span class="p">.</span><span class="n">nready</span><span class="o">--</span><span class="p">;</span>
<span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div><p>        在等待和唤醒的时候都需要先获取互斥锁。然而由于其他线程唤醒的时候也持有锁，所以可能会让被唤醒的线程因为唤醒后无法获取锁，从而重新进入阻塞状态。为了避免这种冲突，可以修改代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">dosignal</span><span class="p">;</span>

<span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="n">dosignal</span> <span class="o">=</span> <span class="p">(</span><span class="n">nready</span><span class="p">.</span><span class="n">nready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">nready</span><span class="p">.</span><span class="n">nready</span><span class="o">++</span><span class="p">;</span>
<span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">dosignal</span><span class="p">)</span>
  <span class="n">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nready</span><span class="p">.</span><span class="n">cond</span><span class="p">);</span>
</code></pre></div><p>        <code>POSIX</code>允许线程在没有持有与该条件变量相关联的互斥锁的前提下调用 $pthread_-cond_-signal$ ，但是对于需要可预见的调度行为，在调用前必须获取互斥锁。</p>
<h2 id="5-条件变量的定时等待和广播">5. 条件变量的定时等待和广播</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回非负错误码 */</span>

<span class="kt">int</span> <span class="nf">pthread_cond_broadcast</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_cond_timedwait</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cptr</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mptr</span><span class="p">,</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">abstime</span><span class="p">);</span>
</code></pre></div><p>        $pthread_-cond_-broadcast$ 唤醒在条件变量上等待的所有线程。 $pthread_-cond_-timedwait$ 允许线程设置一个阻塞时间上限，$abstime$ 是绝对时间而不是时间差。</p>
<h2 id="6-互斥锁和条件变量属性">6. 互斥锁和条件变量属性</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回非负错误码 */</span>

<span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_mutex_destroy</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_cond_init</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_condattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_cond_destroy</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cptr</span><span class="p">);</span>
</code></pre></div><p>        静态分配时通常使用 $PTHREAD_-MUTEX_-INITIALIZER$ 和 $PTHREAD_-COND_-INITIALIZER$ 初始化，这种方式初始化的互斥锁和条件变量具有默认属性。动态分配或者在共享内存区中的需要使用以上函数进行初始化和销毁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回非负错误码 */</span>

<span class="kt">int</span> <span class="nf">pthread_mutexattr_init</span><span class="p">(</span><span class="n">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_mutexattr_destroy</span><span class="p">(</span><span class="n">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_condattr_init</span><span class="p">(</span><span class="n">pthread_condattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_mutexattr_destroy</span><span class="p">(</span><span class="n">pthread_condattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>
</code></pre></div><p>        互斥锁和条件变量的属性类型分别为 $pthread_-mutexattr_-t$ 和 $pthread_-condattr_-t$ ，由以上函数初始化和销毁。一旦某个互斥锁或条件变量的属性对象已经被初始化，就可以通过调用不同函数启用或禁止特定属性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回非负错误码 */</span>

<span class="kt">int</span> <span class="nf">pthread_mutexattr_getpshared</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">valptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_mutexattr_setpshared</span><span class="p">(</span><span class="n">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_condattr_getpshared</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_condattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">valptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_condattr_setpshared</span><span class="p">(</span><span class="n">pthread_condattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</code></pre></div><p>        两个 $get$ 函数的 $valptr$ 返回属性当前值，$set$ 函数则根据 $value$ 设置该值。$value$ 可以是 $PTHREAD_-PROCESS_-PRIVATE$ 或 $PTHREAD_-PROCESS_-SHARED$ ，后者也称为进程间共享属性。当在多个进程间共享互斥锁时，进程终止时系统是不会释放所有持有的锁的。而对于线程，如果在持有互斥锁时被其他线程取消，可以通过安装取消时调用的函数来清理。</p>
<h2 id="7-读写锁">7. 读写锁</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回非负错误码 */</span>

<span class="kt">int</span> <span class="nf">pthread_rwlock_rdlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_rwlock_wrlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_rwlock_tryrdlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_rwlock_trywrlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_rwlock_unlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwptr</span><span class="p">);</span>
</code></pre></div><p>        $pthread_-rwlock_-tryrdlock$ 和 $pthread_-rwlock_-trywrlock$ 尝试以非阻塞方式获取锁，如果失败，返回 $EBUSY$ 错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回非负错误码 */</span>

<span class="kt">int</span> <span class="nf">pthread_rwlock_init</span><span class="p">(</span><span class="n">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwptr</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">pthread_rwlockattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_rwlock_destroy</span><span class="p">(</span><span class="n">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwptr</span><span class="p">);</span>
</code></pre></div><p>        如果某个读写锁是静态分配的，可以通过 $PTHREAD_-RWLOCK_-INITIALIZER$ 初始化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回非负错误码 */</span>

<span class="kt">int</span> <span class="nf">pthread_rwlockattr_init</span><span class="p">(</span><span class="n">pthread_rwlockattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_rwlockattr_destroy</span><span class="p">(</span><span class="n">pthread_rwlockattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_rwlockattr_getpshared</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_rwlockattr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">valptr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_rwlockattr_setpshared</span><span class="p">(</span><span class="n">pthread_rwlockattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</code></pre></div><p>        $value$ 的值为 $PTHREAD_-PROCESS_-PRIVATE$ 或者 $PTHREAD_-PROCESS_-SHARED$ 。</p>
<h2 id="8-线程取消">8. 线程取消</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回非负错误码
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">pthread_cancel</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">pid</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">pthread_cleanup_push</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">pthread_cleanup_pop</span><span class="p">(</span><span class="kt">int</span> <span class="n">execute</span><span class="p">);</span>
</code></pre></div><p>        通过 $pthread_-cancel$ ，可以取消一个持有锁的线程。线程可以通过 $pthread_-cleanup_-push$ 和 $pthread_-cleanup_-pop$ 安装和删除清理处理函数。清理处理函数会在线程被取消或者线程自愿终止时被调用。$pthread_-cleanup_-pop$ 总是删除栈顶的函数，并且当 $execute$ 不为 $0$ 时执行该函数。</p>
<h2 id="9-记录上锁">9. 记录上锁</h2>
<p>        <code>POSIX</code>记录上锁定义了一个特殊的字节范围以指定整个文件。它的起始偏移为 $0$ ，长度也为 $0$ 。<strong>粒度</strong> ( $granularity$ ) 标识能够被锁住的对象的大小。对记录上锁来说，粒度就是单个字节。通常情况下，粒度越小，意味着允许同时使用的用户数量就越多。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 返回值取决于cmd，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">fcntl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* struct flock *arg */</span> <span class="p">);</span>

<span class="k">struct</span> <span class="n">flock</span> <span class="p">{</span>
  <span class="kt">short</span> <span class="n">l_type</span><span class="p">;</span>  <span class="c1">// F_RDLCK, F_WRLCK, F_UNLCK
</span><span class="c1"></span>  <span class="kt">short</span> <span class="n">l_whence</span><span class="p">;</span>  <span class="c1">// SEEK_SET, SEEK_CUR, SEEK_END
</span><span class="c1"></span>  <span class="n">off_t</span> <span class="n">l_start</span><span class="p">;</span>  <span class="c1">// relative starting offset in bytes
</span><span class="c1"></span>  <span class="n">off_t</span> <span class="n">l_len</span><span class="p">;</span>  <span class="c1">// #bytes; 0 means until end-of-file
</span><span class="c1"></span>  <span class="n">pid_t</span> <span class="n">l_pid</span><span class="p">;</span>  <span class="c1">// PID returned by F_GETLK
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><ul>
<li>$F_-SETLK$ ：获取 ( $l_-type$ 为 $F_-RDLCK$ 或 $F_-WRLCK$ ) 或释放 ( $l_-type$ 为 $F_-UNLCK$ ) 由 $arg$ 指向的 $flock$ 结构的锁。如果当前进程无法获取锁，返回 $EACCES$ 或 $EAGAIN$ 错误；</li>
<li>$F_-SETLKW$ ：与上个命令类似，但是如果无法获取锁不会立即返回，而是阻塞直到获取成功；</li>
<li>$F_-GETLK$ ：检查由 $arg$ 指向的锁是否已有其他进程持有，如果没有就将 $l_-type$ 置为 $F_-UNLCK$ ；否则，这个锁的信息将由 $arg$ 返回，其中包括持有锁的进程的<code>PID</code>。</li>
</ul>
<p>        一个进程可以对某个文件的特定字节范围多次发出 $F_-SETLK$ 或 $F_-SETLKW$ ，每次成功与否取决于其他进程是否锁住该字节范围和锁的类型。对于同一个进程，后执行的 $F_-SETLK$ 或 $F_-SETLKW$ 会覆盖先执行的针对统一字节范围的同样两个命令。一个进程对文件上锁不会影响其他进程访问这个文件，也就是说，一个进程锁住一个字节范围，另一个进程还是能访问对应范围内的数据。如果同一个进程对于一个已持有锁的字节范围调用 $F_-GETLK$ ，会返回 $F_-UNLCK$ ，因为当前进程已经上锁。<br>
        字节偏移是作为一个相对偏移成员 ( $l_-start$ 和 $l_-len$ ) 伴随其解释 ( $l_-whence$ ) 指定的。$l_-whence$ 可以是：</p>
<ul>
<li>$SEEK_-SET$ ：$l_-start$ 相对于文件开头；</li>
<li>$SEEK_-CUR$ ：$l_-start$ 相对于当前字节偏移；</li>
<li>$SEEK_-END$ ：$l_-start$ 相对于文件结束。</li>
</ul>
<p>        锁住整个文件的方式有两种：</p>
<ol>
<li>指定 $l_-whence$ 为 $SEEK_-SET$ ，$l_-start$ 和 $l_-len$ 为 $0$ ；</li>
<li>使用 $lseek$ 把读写指针定位到文件开始，然后指定 $l_-whence$ 为 $SEEK_-CUR$ ，$l_-start$ 和 $l_-len$ 为 $0$ 。</li>
</ol>
<p>        $fcntl$ 记录上锁既可以用于读也可以用于写。对于一个字节，它只能存在一种锁。一个字节可以有多个读锁，但只能有一个写锁。当一个描述符没有以写的模式打开时不能上写锁，同样的，没有以读模式打开的描述符也不能上读锁。对于一个打开着某个文件的给定进程来说，当它关闭该文件的所有描述符或它本身终止时，与该文件关联的锁都会被删除。记录锁与进程<code>ID</code>相关，不能通过 $fork$ 继承。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">my_lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">flock</span> <span class="n">lock</span><span class="p">;</span>

  <span class="n">lock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">F_WRLCK</span><span class="p">;</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">SEEK_SET</span><span class="p">;</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// write lock entire file
</span><span class="c1"></span>
  <span class="n">Fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETLKW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">flock</span> <span class="n">lock</span><span class="p">;</span>

  <span class="n">lock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">;</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">SEEK_SET</span><span class="p">;</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// unlock entire file
</span><span class="c1"></span>
  <span class="n">Fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETLK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        上锁和解锁的过程有些复杂，可以通过宏简化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define read_lock(fd, offset, whence, len) \
</span><span class="cp">  lock_reg(fd, F_SETLK, F_RDLCK, offset, whence, len)
</span><span class="cp">#define readw_lock(fd, offset, whence, len) \
</span><span class="cp">  lock_reg(fd, F_SETLKW, F_RDLCK, offset, whence, len)
</span><span class="cp">#define write_lock(fd, offset, whence, len) \
</span><span class="cp">  lock_reg(fd, F_SETLK, F_WRLCK, offset, whence, len)
</span><span class="cp">#define writew_lock(fd, offset, whence, len) \
</span><span class="cp">  lock_reg(fd, F_SETLKW, F_WRLCK, offset, whence, len)
</span><span class="cp">#define un_lock(fd, offset, whence, len) \
</span><span class="cp">  lock_reg(fd, F_SETLK, F_UNLCK, offset, whence, len)
</span><span class="cp">#define is_read_lockable(fd, offset, whence, len) \
</span><span class="cp">  !lock_test(fd, F_RDLCK, offset, whence, len)
</span><span class="cp">#define is_write_lockable(fd, offset, whence, len) \
</span><span class="cp">  !lock_test(fd, F_WRLCK, offset, whence, len)
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">lock_reg</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">flock</span> <span class="n">lock</span><span class="p">;</span>

  <span class="n">lock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>  <span class="c1">// F_RDLCK, F_WRLCK, F_UNLCK
</span><span class="c1"></span>  <span class="n">lock</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>  <span class="c1">// byte offset, relative to l_whence
</span><span class="c1"></span>  <span class="n">lock</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">whence</span><span class="p">;</span>  <span class="c1">// SEEK_SET, SEEK_CUR, SEEK_END
</span><span class="c1"></span>  <span class="n">lock</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>  <span class="c1">// #bytes (0 means to EOF)
</span><span class="c1"></span>
  <span class="k">return</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>  <span class="c1">// -1 upon error
</span><span class="c1"></span><span class="p">}</span>

<span class="n">pid_t</span> <span class="nf">lock_test</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">flock</span> <span class="n">lock</span><span class="p">;</span>

  <span class="n">lock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>  <span class="c1">// F_RDLCK or F_WRLCK
</span><span class="c1"></span>  <span class="n">lock</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>  <span class="c1">// byte offset, relative to l_whence
</span><span class="c1"></span>  <span class="n">lock</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">whence</span><span class="p">;</span>  <span class="c1">// SEEK_SET, SEEK_CUR, SEEK_END
</span><span class="c1"></span>  <span class="n">lock</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>  <span class="c1">// #bytes (0 means to EOF)
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETLK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// unexpected error
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">==</span> <span class="n">F_UNLCK</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// false, region not locked by another proc
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">lock</span><span class="p">.</span><span class="n">l_pid</span><span class="p">;</span>  <span class="c1">// true, return positive PID of lock owner
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>        记录上锁的一个常见用途是确保某个程序 ( 例如守护进程 ) 在任何时刻只有一个副本在运行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define PATH_PIDFILE &#34;pidfile&#34;
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">pidfd</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

  <span class="c1">// open the PID file, create if nonexistent
</span><span class="c1"></span>  <span class="n">pidfd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">PATH_PIDFILE</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">);</span>

  <span class="c1">// try to write lock the entire file
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">write_lock</span><span class="p">(</span><span class="n">pidfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">=</span> <span class="n">EACCES</span> <span class="o">||</span> <span class="n">errno</span> <span class="o">=</span> <span class="n">EAGAIN</span><span class="p">)</span>
      <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;unable to lock %s, is %s already running?&#34;</span><span class="p">,</span>
        <span class="n">PATH_PIDFILE</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">else</span>
      <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;unable to lock %s&#34;</span><span class="p">,</span> <span class="n">PATH_PIDFILE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// write my PID, leave file open to hold the write lock
</span><span class="c1"></span>  <span class="n">snprintf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="s">&#34;%ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">getpid</span><span class="p">());</span>
  <span class="n">Ftruncate</span><span class="p">(</span><span class="n">pidfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Write</span><span class="p">(</span><span class="n">pidfd</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">line</span><span class="p">));</span>

  <span class="c1">// then do whatever the daemon does
</span><span class="c1"></span>
  <span class="n">pause</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><h2 id="10-文件锁">10. 文件锁</h2>
<p>        <code>POSIX</code>保证如果以 $O_-CREAT$ 和 $O_-EXCL$ 标志调用 $open$ 函数，那么一旦该文件存在，函数就返回错误。而且考虑到其他进程的存在，检查该文件是否存在和创建文件必须是原子的。从而，我们可以把这种文件当锁使用。释放这样的锁只需要调用 $unlink$ 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define LOCKFILE &#34;/tmp/seqno.lock&#34;
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">my_lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">tempfd</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">((</span><span class="n">tempfd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">LOCKFILE</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EEXIST</span><span class="p">)</span>
      <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;open error for lock file&#34;</span><span class="p">);</span>
    <span class="c1">// someone else has the lock, loop around adn try again
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">tempfd</span><span class="p">);</span>  <span class="c1">// opened the file, we have the lock
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Unlink</span><span class="p">(</span><span class="n">LOCKFILE</span><span class="p">);</span>  <span class="c1">// release lock by removing file
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>        这种技巧存在三个问题：</p>
<ol>
<li>如果当前持有锁的进程没有释放就终止，那么文件不会被删除。对于这个问题，可以通过检查文件最近访问时间，如果超过一定时间没访问就认为锁已经释放，但是这种方法不完美。另一种方法是在文件内写入进程<code>ID</code>，然后检查该进程<code>ID</code>是否在运行。这个方法同样存在问题，因为进程<code>ID</code>在经过一段时间后会重用；</li>
<li>如果另外某个进程已经上锁，那么当前进程只能不断轮询；</li>
<li>调用 $open$ 和 $unlink$ 会涉及文件系统的访问，增加开销。</li>
</ol>
<p>        <code>Unix</code>文件系统的另外两个技巧也可以用于上锁：</p>
<ol>
<li>如果新链接的文件名存在，那么 $link$ 会失败。可以先创建一个临时文件，路径名包括当前进程<code>ID</code>信息，然后将该临时文件 $link$ 到待建立锁的文件上。如果创建成功，说明获取了锁，只需要在不使用时 $unlink$ 锁文件即可。如果返回 $EEXIST$ 错误，说明锁已经被占用。这种技巧要求临时文件路径名和锁文件路径名必须位于同一个文件系统中，因为大多版本的<code>Unix</code>不允许不同文件系统之间的硬链接；</li>
<li>如果以 $O_-TRUNC$ 模式打开的文件存在，但是当前进程没有写权限，$open$ 会返回错误。我们可以指定 $O_-CREAT$ 、 $O_-WRONLY$ 和 $O_-TRUNC$ 并设置 $mode$ 为 $0$ ( 即新文件不打开任何权限位 ) 的前提下调用 $open$ 。如果成功，我们就拥有了锁，只需要在不使用时 $unlink$ 锁文件即可。如果返回 $EACCES$ ，那么线程必须重新尝试。这种技巧要求当前进程不具备超级用户权限。</li>
</ol>
<p>        不管是哪种方式的文件上锁，都存在着一些问题。所以最好的方式还是使用 $fcntl$ 的记录上锁。</p>

            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 21 14:36</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B18/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B17/">Unix网络编程（17）：消息队列</a></h1>
            <div class="post-content">
                <p>        消息队列可认为是一个消息链表，有足够写权限的线程可往队列中放置消息，有足够读权限的线程可从队列中取走消息。每个消息都是一个记录，它由发送者赋予一个优先级。与管道和<code>FIFO</code>不同，在某个进程往一个队列写入消息前，并不需要另外某个进程在该队列上等待消息到达。</p>
<h2 id="1-mq_openmq_close和mq_unlink函数">1. <code>mq_open</code>、<code>mq_close</code>和<code>mq_unlink</code>函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回消息队列描述符，出错返回-1
</span><span class="c1"></span><span class="n">mqd_t</span> <span class="nf">mq_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="p">...</span>
  <span class="cm">/* mode_t mode, struct aq_attr *attr */</span> <span class="p">);</span>

<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_close</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">);</span>

<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_unlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</code></pre></div><p>        $oflag$ 参数是 $O_-RDONLY$ 、$O_-WRONLY$ 或 $O_-RDWR$ 之一，并且可以按位或 $O_-CREAT$ 、$O_-EXCL$ 或 $O_-NONBLOCK$ 。当实际操作是创建一个新队列时 ( 指定 $O_-CREAT$ 且请求的消息队列不存在 )，需要 $mode$ 和 $attr$ 参数。$mq_-close$ 调用类似于 $close$ 调用，调用之后消息队列不会从系统中删除。当一个进程终止时，它的所有打开着的消息队列会被关闭。如果要从系统中删除一个消息队列，则需要调用 $mq_-unlink$ ，类似于 $unlink$ ，当一个消息队列的打开计数大于 $0$ 时，不会立即删除，而是直到该消息队列真正被关闭时才会删除。<code>POSIX</code>消息队列至少具备随内核的持续性，这意味着即使当前没有进程打开着消息队列，其中的消息也将一直存在，直到被删除。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
  <span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>

  <span class="n">flags</span> <span class="o">=</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">Getopt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&#34;e&#34;</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;e&#39;</span><span class="o">:</span>
      <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_EXCL</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">optind</span> <span class="o">!=</span> <span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqcreate [ -e ] &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="n">mql</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">optind</span><span class="p">],</span> <span class="n">flags</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Mq_close</span><span class="p">(</span><span class="n">mqd</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        允许有一个排他选项 $-e$ 创建消息队列。通过 $getopt$ 获取这个选项，$getopt$ 会在 $optind$ 中存放待处理的下一个参数的下标。</p>
<h2 id="2-mq_getattr和mq_setattr函数">2. <code>mq_getattr</code>和<code>mq_setattr</code>函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_getattr</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_setattr</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">oattr</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">mq_attr</span> <span class="p">{</span>
  <span class="kt">long</span> <span class="n">mq_flags</span><span class="p">;</span>  <span class="c1">// message queue flag: 0, O_NONBLOCK
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">mq_maxmsg</span><span class="p">;</span>  <span class="c1">// max number of messages allowed on queue
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">mq_msgsize</span><span class="p">;</span>  <span class="c1">// max size of a message (in bytes)
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">mq_curmsgs</span><span class="p">;</span>  <span class="c1">// number of messages currently on queue
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><p>        $mq_-attr$ 结构指针可以作为 $mq_-open$ 的第四个参数传递，从而允许我们在该函数的实际操作是创建一个新队列时，为它指定 $mq_-maxmsg$ 和 $mq_-msgsize$ 属性，其他两个属性会被忽略。$mq_-setattr$ 为所指队列设置属性，但是只使用 $mq_-flags$ ，用于设置或清除非阻塞标志。另外，如果 $oattr$ 非空，当前队列的先前属性会返回到 $oattr$ 中。</p>
<h2 id="3-mq_send和mq_receive函数">3. <code>mq_send</code>和<code>mq_receive</code>函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_send</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">);</span>

<span class="c1">// 成功返回消息字节数，出错返回-1
</span><span class="c1"></span><span class="n">ssize_t</span> <span class="nf">mq_receive</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">priop</span><span class="p">);</span>
</code></pre></div><p>        这两个函数分别用于往消息队列放置一个消息和从消息队列中取出一个消息。每个消息都对应一个优先级 $prio$ ，它是一个小于 $MQ_-PRIO_-MAX$ 的无符号整数，<code>POSIX</code>要求这个上限最小为 $32$ 。$mq_-receive$ 总是会取出队列中优先级最高的最早发送的消息，并且该优先级会和消息长度一起返回。$mq_-receive$ 的 $len$ 不能小于消息队列中的消息最大大小，如果小于，会返回 $EMSGSIZE$ 错误。如果应用不必使用优先级不同的消息，可以统一将优先级指定为 $0$ ，并将 $mq_-receive$ 的最后一个参数指定为 $NULL$ 。</p>
<h2 id="4-消息队列限制">4. 消息队列限制</h2>
<p>        消息队列存在两个限制，都是在创建队列时指定的：</p>
<ul>
<li>$mq_-mqxmsg$ ：队列中的最大消息数；</li>
<li>$mq_-msgsize$ ：给定消息的最大字节数。</li>
</ul>
<p>        消息队列的实现定义了另外两个限制：</p>
<ul>
<li>$MQ_-OPEN_-MAX$ ：一个进程能够同时拥有的打开着的消息队列的最大数目 ( <code>POSIX</code>要求至少为 $8$ )；</li>
<li>$MQ_-PRIO_-MAX$ ：任意消息的最大优先级加 $1$ ( <code>POSIX</code>要求至少为 $32$ )。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;MQ_OPEN_MAX = %ld, MQ_PRIO_MAX = %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
    <span class="n">Sysconf</span><span class="p">(</span><span class="n">_SC_MQ_OPEN_MAX</span><span class="p">),</span> <span class="n">Sysconf</span><span class="p">(</span><span class="n">_SC_MQ_PRIO_MAX</span><span class="p">));</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="5-mq_notify函数">5. <code>mq_notify</code>函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_notify</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sigevent</span> <span class="o">*</span><span class="n">notification</span><span class="p">);</span>
</code></pre></div><p>        <code>POSIX</code>消息队列允许<strong>异步事件通知</strong> ( $asynchronous$ $event$ $notification$ )，用于告知何时有一个消息被放置到空的消息队列中。这种通知有两种方式可以选择：</p>
<ul>
<li>产生一个信号；</li>
<li>创建一个线程来执行一个指定的函数。</li>
</ul>
<p>        $mq_-notify$ 为指定的消息队列建立或删除异步事件通知。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">union</span> <span class="n">sigval</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sival_int</span><span class="p">;</span>  <span class="c1">// integer value
</span><span class="c1"></span>  <span class="kt">void</span> <span class="o">*</span><span class="n">sival_ptr</span><span class="p">;</span>  <span class="c1">// pointer value
</span><span class="c1"></span><span class="p">};</span>

<span class="k">struct</span> <span class="n">sigevent</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sigev_notify</span><span class="p">;</span>  <span class="c1">// SIGEV_{NONE, SIGNAL, THREAD}
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">sigev_signo</span><span class="p">;</span>  <span class="c1">// signal number if SIGEV_SIGNAL
</span><span class="c1"></span>  <span class="k">union</span> <span class="n">sigval</span> <span class="n">sigev_value</span><span class="p">;</span>  <span class="cm">/* passed to signal handler or thread
</span><span class="cm">                                following two if SIGEV_THREAD */</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sigev_notifiy_function</span><span class="p">)(</span><span class="k">union</span> <span class="n">sigval</span><span class="p">);</span>
  <span class="n">pthread_attr_t</span> <span class="o">*</span><span class="n">sigev_notify_attributes</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><ol>
<li>如果 $notification$ 非空，那么当前进程希望在有一个消息到达前得到通知；</li>
<li>如果 $notification$ 为空，而且当前进程已被注册接收指定队列的通知，那么撤销先前的注册；</li>
<li>任意时刻只有一个进程可以被注册接收某个指定队列的通知；</li>
<li>当有一个消息到达某个先前为空的队列，而且已有一个进程被注册为接收该队列的通知时，只有在没有任何线程阻塞在该队列的 $mq_-receive$ 调用的前提下，通知才会发出。即，$mq_-receive$ 优于注册通知；</li>
<li>当通知被发送给注册进程时，注册即被撤销。如果想要再次接收通知，需要再次注册。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifysig1 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// open queue, get attributes, allocate read buffer
</span><span class="c1"></span>  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

  <span class="c1">// establish signal handler, enable notification
</span><span class="c1"></span>  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr1</span><span class="p">);</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">SIGUSR1</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span>
    <span class="n">pause</span><span class="p">();</span>  <span class="c1">// signal hadler does everything
</span><span class="c1"></span>  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">vodi</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>

  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister first
</span><span class="c1"></span>  <span class="n">n</span> <span class="o">=</span> <span class="n">Mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;SIGUSR1 received, read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="51-异步信号安全函数">5.1 异步信号安全函数</h3>
<p>        上述程序的问题是它在信号处理程序中调用 $mq_-notify$ 、$mq_-receive$ 和 $printf$ 。这些函数实际上都不可以在信号处理程序中调用。<code>POSIX</code>使用<strong>异步信号安全</strong> ( $async-signal-safe$ ) 这个术语描述可以在信号处理函数中调用的函数。</p>
<p>$$
\begin{array}{|c|c|c|c|}
\hline
access &amp; fpathconf &amp; rename &amp; sysconf\\
aio_-return &amp; fstat &amp; rmdir &amp; tcdrian \\
aio_-suspend &amp; fsync &amp; sem_-post &amp; tcflow \\
alarm &amp; getegid &amp; setgit &amp; tcflush \\
cfgetispeed &amp; geteuid &amp; setpgid &amp; tcgetattr \\
cfgetospeed &amp; getpgrp &amp; sigaction &amp; tcsetattr \\
chdir &amp; getpid &amp; sigaddset &amp; tcsetpgrp \\
chmod &amp; getppid &amp; sigdelset &amp; time \\
chown &amp; getuid &amp; sigemptyset &amp; timer_-getoverrun \\
clock_-gettime &amp; kill &amp; sigfillset &amp; timer_-gettime \\
close &amp; link &amp; sigismember &amp; timer_-settime \\
creat &amp; lseek &amp; signal &amp; times \\
dup &amp; mkdir &amp; sigpause &amp; umask \\
dup2 &amp; mkfifo &amp; sigpending &amp; uname \\
execle &amp; open &amp; sigprocmask &amp; unlink \\
execve &amp; pathconf &amp; sigqueue &amp; utim \\
_-exit &amp; pause &amp; sigset &amp; wait \\
fcntl &amp; pipe &amp; sigsuspend &amp; waitpid \\
fdatasync &amp; raise &amp; sleep &amp; write \\
fork &amp; read &amp; stat \\
\hline
\end{array}
$$</p>
<p>        没有列在上表中的函数不能在信号处理函数中调用。注意所有标准<code>I/O</code>函数和 $pthread_-XXX$ 函数都没有列在其中。<code>IPC</code>相关函数只有 $sem_-post$ 、$read$ 和 $write$ 在其中。<br>
        避免从信号处理程序中掉哟该任何函数的办法之一是让处理函数仅仅设置一个全局标志，再由某个线程检查该标志以确定何时收到消息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">volatile</span> <span class="n">sig_atomic_t</span> <span class="n">mqflag</span><span class="p">;</span> <span class="c1">// set nonzero by signal handler
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">sigset_t</span> <span class="n">zeromask</span><span class="p">,</span> <span class="n">newmask</span><span class="p">,</span> <span class="n">oldmask</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifysig2 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// open queue, get attributes, allocate read buffer
</span><span class="c1"></span>  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>  <span class="c1">// no signals block
</span><span class="c1"></span>  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmask</span><span class="p">);</span>
  <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

  <span class="c1">// establish signal handler, enable notification
</span><span class="c1"></span>  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr1</span><span class="p">);</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">SIGUSR1</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">);</span>  <span class="c1">// block SIGUSR1
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">mqflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>
    <span class="n">mqflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// reset flag
</span><span class="c1"></span>
    <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister first
</span><span class="c1"></span>    <span class="n">n</span> <span class="o">=</span> <span class="n">Mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// unblock SIGUSR1
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">mqflag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="52-非阻塞的信号通知">5.2 非阻塞的信号通知</h3>
<p>        上面的程序还存在一个问题，那就是<code>Unix</code>的信号是不排队的，如果有两个消息到达，我们的程序只会处理一个。解决办法是使用非阻塞模式读取消息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">sigset_t</span> <span class="n">zeromask</span><span class="p">,</span> <span class="n">newmask</span><span class="p">,</span> <span class="n">oldmask</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifysig3 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// open queue, get attributes, allocate read buffer
</span><span class="c1"></span>  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>  <span class="c1">// no signals blocked
</span><span class="c1"></span>  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmask</span><span class="p">);</span>
  <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

  <span class="c1">// establish signal handler, enable notification
</span><span class="c1"></span>  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr1</span><span class="p">);</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">SIGUSR1</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">);</span>  <span class="c1">// block SIGUSR1
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">mqflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>
    <span class="n">mqflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// reset flag
</span><span class="c1"></span>
    <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister first
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span>
      <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;mq_receive error&#34;</span><span class="p">);</span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// unblock SIGUSR1
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="53-sigwait函数">5.3 <code>sigwait</code>函数</h3>
<p>        上述程序尽管正确，但是效率还可以更高。因为我们的程序是通过 $sigsuspend$ 阻塞的，直到 $mqflag$ 非零，更高效的办法是只等待 $SIGUSR1$ 而不是任意一个信号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回非负错误码
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">sigwait</span><span class="p">(</span><span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
</code></pre></div><p>        $sigwait$ 会阻塞等待信号集 $set$ 中的某个信号返回，返回时设置 $sig$ ，标识产生的信号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">signo</span><span class="p">;</span>
  <span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">sigset_t</span> <span class="n">newmask</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifysig4 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// open queue, get attributes, allocate read buffer
</span><span class="c1"></span>  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
  <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>
  <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// block SIGUSR1
</span><span class="c1"></span>
  <span class="c1">// establish signal handler, enable notification
</span><span class="c1"></span>  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">SIGUSR1</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sigwait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">signo</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGUSR1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister first
</span><span class="c1"></span>      <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;mq_receive error&#34;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="54-select函数">5.4 <code>select</code>函数</h3>
<p>        消息队列描述符 $mqd_-t$ 不能用于 $select$ 或 $poll$ 。然而我们可以通过管道结合 $mq_-notify$ 使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">nfds</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">fd_set</span> <span class="n">rset</span><span class="p">;</span>
  <span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifysig5 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// open queue, get attributes, allocate read buffer
</span><span class="c1"></span>  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

  <span class="n">Pipe</span><span class="p">(</span><span class="n">pipefd</span><span class="p">);</span>

  <span class="c1">// establish signal handler, enable notification
</span><span class="c1"></span>  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr1</span><span class="p">);</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">SIGUSR1</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rset</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">FD_SET</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">);</span>
    <span class="n">nfds</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">Read</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister first
</span><span class="c1"></span>      <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;mq_receive error&#34;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Write</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// one byte of 0
</span><span class="c1"></span>  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="55-线程">5.5 线程</h3>
<p>        异步事件通知的另一种方式是把 $sigev_-notify$ 指定为 $SIGEV_-THREAD$ ，这会创建一个新线程。线程属性由 $sigev_-notify_-attributes$ 指定，调用 $sigev_-notify_-function$ 函数，参数为 $sigev_-value$ 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">notify_thread</span><span class="p">(</span><span class="k">union</span> <span class="n">sigval</span><span class="p">);</span>  <span class="c1">// our thread function
</span><span class="c1"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifythread1 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_THREAD</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">.</span><span class="n">sival_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify_function</span> <span class="o">=</span> <span class="n">notify_thread</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify_attributes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span>
    <span class="n">pause</span><span class="p">();</span>  <span class="c1">// each new thread does everything
</span><span class="c1"></span>  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">notify_thread</span><span class="p">(</span><span class="k">union</span> <span class="n">sigval</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;notify_thread started</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister
</span><span class="c1"></span>
  <span class="k">while</span> <span class="p">((</span><span class="n">m</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span>
    <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;mq_receive error&#34;</span><span class="p">);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="6-posix实时信号">6. <code>POSIX</code>实时信号</h2>
<p>        信号可划分为两组：</p>
<ol>
<li>值在 $SIGRTMIN$ 和 $SIGTRMAX$ 之间 ( 包括两者 ) 的实时信号，<code>POSIX</code>要求至少提供 $RTSIG_-MAX$ 种实时信号，最小为 $8$ ；</li>
<li>其他信号，比如 $SIGALRM$ 、$SIGINT$ 和 $SIGKILL$ 等。</li>
</ol>
<p>        接收某个信号的进程的 $sigaction$ 调用中是否制定了新的 $SA_-SIGINFO$ 标志会带来差异。</p>
<table>
  <thead>
    <tr>
      <th rowspan="2" style="text-align: center;">信号</th>
      <th colspan="2" style="text-align: center;">$sigaction$ 调用</th>
    </tr>
    <tr>
      <th style="text-align: center;">指定 $SA_-SIGINFO$</th>
      <th style="text-align: center;">未指定 $SA_-SIGINFO$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center;">$SIGRTMIN$ $\sim$ $SIGRTMAX$</td>
      <td style="text-align: center;">已指定实时行为</td>
      <td style="text-align: center;">未指定实时行为</td>
    </tr>
    <tr>
      <td style="text-align: center;">其他信号</td>
      <td style="text-align: center;">未指定实时行为</td>
      <td style="text-align: center;">未指定实时行为</td>
    </tr>
  </tbody>
</table>
<p>        未指定实时行为意味着有些实现可能提供实时行为，有些不提供。如果需要实时行为，我们必须使用 $SIGRTMIN$ $\sim$ $SIGRTMAX$ 之间的信号，并且在调用 $sigaction$ 时指定 $SA_-SIGINFO$ 。实时行为意味着：</p>
<ul>
<li>信号是排队的；</li>
<li>当有多个解阻塞信号排队时，值较小的信号优于值较大信号递交；</li>
<li>某个非实时信号递交时，传递给它的信号处理程序的唯一参数是信号值。而实时信号可以传递更多信息。</li>
<li>一些新信号定义成使用实时信号工作。例如，$sigqueue$ 函数代替 $kill$ 函数向某个进程发送信号，该新函数允许发送者随所发送信号传递一个 $sigval$ 。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">si_signo</span><span class="p">;</span>  <span class="c1">// same value as signo argument
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">si_code</span><span class="p">;</span>  <span class="c1">// SI_{USER, QUEUE, TIMER, ASYNCIO, MEGEQ}
</span><span class="c1"></span>  <span class="k">union</span> <span class="n">sigval</span> <span class="n">si_value</span><span class="p">;</span>  <span class="c1">// integer or pointer value from sender
</span><span class="c1"></span><span class="p">}</span> <span class="n">siginfo_t</span><span class="p">;</span>
</code></pre></div><p>        $context$ 参数所指的内容依赖于具体实现。</p>
<ul>
<li>$SI_-ASYNCIO$ ：信号由某个异步<code>I/O</code>请求产生，即<code>POSIX</code>的 $aio_-XXX$ 函数；</li>
<li>$SI_-MESGQ$ ：信号在有一个消息被放置到某个空消息队列时产生；</li>
<li>$SI_-QUEUE$ ：信号由 $timer_-settime$ 函数设置的定时器产生；</li>
<li>$SI_-USER$ ：信号由 $kill$ 函数产生。</li>
</ul>
<p>        如果信号由其他事件产生，$si_-code$ 的值就会被设置成不同于上述的值。而 $siginfo_-t$ 结构的 $si_-value$ 成员只有 $si_-code$ 是上述所列的值之一时才启用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="k">volatile</span> <span class="n">siginfo_t</span> <span class="n">arrival</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">nsig</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_rt</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
  <span class="n">sigset_t</span> <span class="n">newset</span><span class="p">;</span>
  <span class="k">union</span> <span class="n">sigval</span> <span class="n">val</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;SIGRTMIN = %d, SIGRTMAX = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">SIGRTMIN</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">SIGRTMAX</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// child: block three realtime signals
</span><span class="c1"></span>    <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>
    <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="n">SIGRTMAX</span><span class="p">);</span>
    <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="n">SIGRTMAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="n">SIGRTMAX</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// establish signal handler with SA_SIGINFO set
</span><span class="c1"></span>    <span class="n">Signal_rt</span><span class="p">(</span><span class="n">SIGRTMAX</span><span class="p">,</span> <span class="n">sig_rt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>
    <span class="n">Signal_rt</span><span class="p">(</span><span class="n">SIGRTMAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sig_rt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>
    <span class="n">Signal_rt</span><span class="p">(</span><span class="n">SIGRTMAX</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sig_rt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>  <span class="c1">// let parent send all the signals
</span><span class="c1"></span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// unblock
</span><span class="c1"></span>    <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  <span class="c1">// let all queued signals be delivered
</span><span class="c1"></span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsig</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;received signal #%d, code = %d, ival = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
        <span class="n">arrival</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">si_signo</span><span class="p">,</span> <span class="n">arrival</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">si_code</span><span class="p">,</span>
        <span class="n">arrival</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">si_value</span><span class="p">.</span><span class="n">sival_int</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// parent sends nine signals to child
</span><span class="c1"></span>  <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  <span class="c1">// let child block add signals
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">SIGRTMAX</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">SIGRTMAX</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">val</span><span class="p">.</span><span class="n">sival_int</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
      <span class="n">Sigqueue</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;sent signal %d, val = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_rt</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">arrival</span><span class="p">[</span><span class="n">nsig</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>  <span class="c1">// save info for child to print
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>        首先输出最小和最大实时信号值，查看系统支持的实时信号数量。然后派生一个子进程，阻塞我们需要的实时信号。接着子进程调用 $signal_-rt$ 函数建立信号处理程序，父进程则等待 $6$ 秒后发送信号，最后子进程输出接收到的所有信号。</p>
<h3 id="61-sinal_rt函数">6.1 <code>sinal_rt</code>函数</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="nf">Sigfunc_rt</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="n">Sigfunc_rt</span> <span class="o">*</span><span class="nf">signal_rt</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">Sigfunc_rt</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">act</span><span class="p">,</span> <span class="n">oact</span><span class="p">;</span>

  <span class="n">act</span><span class="p">.</span><span class="n">sa_sigaction</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>  <span class="c1">// must store function addr here
</span><span class="c1"></span>  <span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span> <span class="o">=</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>  <span class="c1">// signals to block
</span><span class="c1"></span>  <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_SIGINFO</span><span class="p">;</span>  <span class="c1">// must specify this for realtime
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGALRM</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef SA_INTERRUPT
</span><span class="cp"></span>    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_INTERRUPT</span><span class="p">;</span>  <span class="c1">// SunOS 4.x
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef SA_RESTART
</span><span class="cp"></span>    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_RESTART</span><span class="p">;</span>  <span class="c1">// SVR4, 44BSD
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oact</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Sigfunc_rt</span> <span class="o">*</span><span class="p">)</span> <span class="n">SIG_ERR</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">oact</span><span class="p">.</span><span class="n">sa_sigaction</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        加入实时信号支持后，$sigaction$ 发生了变化，添加了 $sa_-sigaction$ 成员。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">sigaction</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sa_handler</span><span class="p">)();</span>  <span class="c1">// SIG_DFL, SIG_IGN or add of signal handler
</span><span class="c1"></span>  <span class="n">sigset_t</span> <span class="n">sa_mask</span><span class="p">;</span>  <span class="c1">// additional signals to block
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">sa_flags</span><span class="p">;</span>  <span class="c1">// signal options: SA_xxx
</span><span class="c1"></span>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sa_sigaction</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="n">siginfo_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>  <span class="c1">// addr of signal handler if SA_SIGINFO set
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><ul>
<li>如果 $sa_-flags$ 成员设置了 $SA_-SIGINFO$ 标志，那么 $sa_-sigaction$ 成员会指定信号处理函数地址；</li>
<li>如果 $sa_-flags$ 成员没有设置 $SA_-SIGINFO$ 标志，那么 $sa_-handler$ 成员会指定信号处理函数地址；</li>
<li>给某个信号指定默认行为或忽略信号，应该把 $sa_-handler$ 设置为 $SIG_-DFL$ 或 $SIG_-IGN$ 并不设置 $SA_-SIGINFO$ 标志。</li>
</ul>

            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 20 14:01</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B17/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2022, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>