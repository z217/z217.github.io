<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.74.3" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
        
        <a href="http://123.57.12.189"  target="_blank" >
            <i class="fas fa-link fa-sm"></i>
            <span>二站</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/java-8%E5%AE%9E%E6%88%98%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api/">Java 8实战：日期和时间API</a>
        
        
        <p>Java 8日期和时间API简介</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Feb 18 18:39
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/java-8%E5%AE%9E%E6%88%98%E6%B5%81%E5%A4%84%E7%90%86/">Java 8实战：流处理</a>
        
        
        <p>Java 8流处理介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Feb 17 18:00
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm10%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">JVM（10）：线程安全与锁优化</a>
        
        
        <p>深入理解Java虚拟机（10）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Jan 13 21:17
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm9%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">JVM（9）：内存模型与线程</a>
        
        
        <p>深入理解Java虚拟机（9）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Jan 12 21:13
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm8%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/">JVM（8）：后端编译与优化</a>
        
        
        <p>深入理解Java虚拟机（8）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Jan 09 20:58
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/java-8%E5%AE%9E%E6%88%98%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api/">Java 8实战：日期和时间API</a></h1>
            </center>
            <div class="post-content">
                <p>        在<code>Java 1.0</code>中，对日期和时间的支持只能依赖 $java.util.Date$ 类。这个类无法表示日期，只能以毫秒的精度表示时间。而且由于某些原因未知的设计决策，这个类的易用性也不高。例如一个表示 $2014$ 年 $3$ 月 $18$ 日的 $Date$ 需要用以下方式创建：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Date</span> <span class="n">date</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Date</span><span class="o">(</span><span class="n">114</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
</code></pre></div><p>        此外，$Date.toString$ 方法的返回值中虽然包含时区，但 $Date$ 并不支持时区。所以，在<code>Java 1.1</code>中，$Date$ 的许多方法被废弃，取而代之的是 $java.util.Calendar$ 类，但是这个类同样也存在着很多问题。比如月份依旧是从 $0$ 开始，而且没有提供 $DateFormat$ 方法。如果使用 $DateFormat$ 方法，那么又会带来并发问题，因为它不是线程安全的。为了解决上述问题，<code>Java 8</code>中新增的 $java.time$ 包中添加了新的日期和时间<code>API</code>。<br/>
        $java.time$ 包中提供了一些新类：$LocalDate$ 、$LocalTime$ 、$Instant$ 、$Duration$ 和 $Period$ 。<br/></p>
<h2 id="1-localdatelocaltimelocaldatetime">1. <code>LocalDate</code>/<code>LocalTime</code>/<code>LocalDateTime</code></h2>
<p>        $LocalDate$ 的实例是一个不可变对象，它只提供了简单的日期，并不包含当天的时间信息。另外，它也不附带任何与时区相关的信息。可以通过静态工厂方法 $of$ 创建一个 $LocalDate$ 实例，或者通过 $now$ 方法从系统时钟中获取当前日期，并通过 $getYear$ 、$getMonth$ 、$getDayOfMonth$ 等方法读取常用值。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span><span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getYear</span><span class="o">();</span> <span class="c1">// 2014
</span><span class="c1"></span><span class="n">Month</span> <span class="n">month</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getMonth</span><span class="o">();</span> <span class="c1">// MARCH
</span><span class="c1"></span><span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getDayOfMonth</span><span class="o">();</span> <span class="c1">// 18
</span><span class="c1"></span><span class="n">DayOfWeek</span> <span class="n">dow</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getDayOfWeek</span><span class="o">();</span> <span class="c1">// TUESDAY
</span><span class="c1"></span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">lengthOfMonth</span><span class="o">();</span> <span class="c1">// 31
</span><span class="c1"></span><span class="kt">boolean</span> <span class="n">leap</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">isLeapYear</span><span class="o">();</span> <span class="c1">// false
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">today</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
</code></pre></div><p>        $TemporalField$ 是一个接口，定义了如何访问 $temporal$ 对象某个字段的值。$ChronoField$ 枚举实现了这一接口，通过 $get$ 方法可以获取对应字段的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">YEAR</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTH_OF_YEAR</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">DAY_OF_MONTH</span><span class="o">);</span>
</code></pre></div><p>        类似的，一天中的时间可以使用 $LocalTime$ 表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalTime</span> <span class="n">time</span> <span class="o">=</span> <span class="n">LocalTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">,</span> <span class="n">20</span><span class="o">);</span> <span class="c1">// 13:45:20
</span><span class="c1"></span><span class="kt">int</span> <span class="n">hour</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">getHour</span><span class="o">();</span> <span class="c1">// 13
</span><span class="c1"></span><span class="kt">int</span> <span class="n">minute</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">getMinute</span><span class="o">();</span> <span class="c1">// 45
</span><span class="c1"></span><span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">getSecond</span><span class="o">();</span> <span class="c1">// 20
</span></code></pre></div><p>        $LocalDate$ 和 $LocalTime$ 都可以通过解析字符串的形式创建。一旦传递的字符串参数无法被解析为合法的对象时就会抛出一个 $DateTimeParseException$ 异常。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2014-03-18&#34;</span><span class="o">);</span>
<span class="n">LocalTime</span> <span class="n">time</span> <span class="o">=</span> <span class="n">LocalTime</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;13:45:20&#34;</span><span class="o">);</span>
</code></pre></div><p>        $LocalDateTime$ 是 $LocalDate$ 和 $LocalTime$ 的复合体，既可以表示日期，也可以表示时间，但不带有时区信息。通过 $atTime$ 或者 $atDate$ 方法传递一个时间或者日期对象，可以创建一个 $LocalDateTime$ 。此外，也可以通过 $toLocalDate$ 和 $toLocalTime$ 方法，从 $LocalDateTime$ 中创建 $LocalDate$ 和 $LocalTime$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDateTime</span> <span class="n">dt1</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">,</span> <span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">,</span> <span class="n">20</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt2</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">date</span><span class="o">,</span> <span class="n">time</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt3</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">atTime</span><span class="o">(</span><span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">,</span> <span class="n">20</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt4</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">atTime</span><span class="o">(</span><span class="n">time</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt5</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">atDate</span><span class="o">(</span><span class="n">date</span><span class="o">);</span>

<span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">dt1</span><span class="o">.</span><span class="na">toLocalDate</span><span class="o">();</span>
<span class="n">LocalTime</span> <span class="n">time1</span> <span class="o">=</span> <span class="n">dt1</span><span class="o">.</span><span class="na">toLocalTime</span><span class="o">();</span>
</code></pre></div><h2 id="2-instant">2. <code>Instant</code></h2>
<p>        从计算机的角度来看，建模时间最自然的格式是表示一个持续时间段某个点的单一大整形数，这也是 $Instant$ 类对时间建模的方式，基本上它是以<code>Unix</code>元年时间（传统的设定为<code>UTC</code>时区 $1970$ 年 $1$ 月 $1$ 日午夜时分）开始所经历的秒数进行计算。<br/>
        静态工厂方法 $ofEpochSecond$ 接收秒数，创建 $Instant$ 实例。此外，它还提供了一个重载版本，额外接收一个纳秒。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Instant</span><span class="o">.</span><span class="na">ofEpochSecond</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
<span class="n">Instant</span><span class="o">.</span><span class="na">ofEpochSecond</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="n">1_000_000_000</span><span class="o">);</span>
<span class="n">Instant</span><span class="o">.</span><span class="na">ofEpochSecond</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="o">-</span><span class="n">1_000_000_000</span><span class="o">);</span>
<span class="n">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
</code></pre></div><p>        虽然 $Instant$ 也支持 $now$ 方法，但是它包含的是由秒及纳秒所构成的数字，目的是方便机器使用，所以无法处理一些时间单位。但是我们可以通过 $Duration$ 和 $Period$ 类使用 $Instant$ 。<br/></p>
<h2 id="3-durationperiod">3. <code>Duration</code>/<code>Period</code></h2>
<p>        到目前为止的所有类都实现了 $Temporal$ 接口，该接口定义了如何读取和操纵为时间建模的对象的值。$Duration$ 类表示两个 $Temporal$ 对象之间的时间，提供了一个静态工厂方法 $between$ 用于创建该类型实例。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Duration</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">time1</span><span class="o">,</span> <span class="n">time2</span><span class="o">);</span>
<span class="n">Duration</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">dateTime1</span><span class="o">,</span> <span class="n">dateTime2</span><span class="o">);</span>
<span class="n">Duration</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">instant1</span><span class="o">,</span> <span class="n">instant2</span><span class="o">);</span>
</code></pre></div><p>        由于 $Duration$ 类主要用于以秒和纳秒衡量时间的长短，所以不能只接收 $LocalDate$ 作为参数。而且由于 $LocalDateTime$ 和 $Instant$ 是为不同的目的而设计的，所以也不能将二者同时作为参数传入，否则会抛出 $DateTimeException$ 异常。<br/>
        $Period$ 类与 $Duration$ 类相对，接收两个 $LocalDate$ ，表示它们之间的时长。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Period</span> <span class="n">tenDays</span> <span class="o">=</span> <span class="n">Period</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">8</span><span class="o">),</span>
                                <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">));</span>
</code></pre></div><p>        除了 $between$ 之外，$Duration$ 和 $Period$ 也提供了很多方便的工厂类，用于直接创建实例。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">是否为静态方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$between$</td>
<td align="center">是</td>
<td align="center">创建两个时间点之间的间隔</td>
</tr>
<tr>
<td align="center">$from$</td>
<td align="center">是</td>
<td align="center">由一个临时时间点创建间隔</td>
</tr>
<tr>
<td align="center">$of$</td>
<td align="center">是</td>
<td align="center">由它的组成部分创建间隔</td>
</tr>
<tr>
<td align="center">$parse$</td>
<td align="center">是</td>
<td align="center">由字符串创建间隔</td>
</tr>
<tr>
<td align="center">$addTo$</td>
<td align="center">否</td>
<td align="center">创建间隔副本并叠加到指定对象上</td>
</tr>
<tr>
<td align="center">$get$</td>
<td align="center">否</td>
<td align="center">读取间隔</td>
</tr>
<tr>
<td align="center">$isNegative$</td>
<td align="center">否</td>
<td align="center">检查间隔是否为负值</td>
</tr>
<tr>
<td align="center">$isZero$</td>
<td align="center">否</td>
<td align="center">检查间隔是否为零</td>
</tr>
<tr>
<td align="center">$minus$</td>
<td align="center">否</td>
<td align="center">减去一定时间创建间隔副本</td>
</tr>
<tr>
<td align="center">$multipliedBy$</td>
<td align="center">否</td>
<td align="center">将间隔值乘以某个标量创建副本</td>
</tr>
<tr>
<td align="center">$negated$</td>
<td align="center">否</td>
<td align="center">忽略某个时长的方式创建间隔副本</td>
</tr>
<tr>
<td align="center">$plus$</td>
<td align="center">否</td>
<td align="center">增加某个时长的方式创建间隔副本</td>
</tr>
<tr>
<td align="center">$subtractFrom$</td>
<td align="center">否</td>
<td align="center">从指定对象中减去间隔</td>
</tr>
</tbody>
</table>
<h2 id="4-操作日期">4. 操作日期</h2>
<p>        $with$ 方法允许我们创建对象的副本，并按照需要修改它的属性。此外，也可以使用类似于四则运算的方法来创建对象副本。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">withYear</span><span class="o">(</span><span class="n">2011</span><span class="o">);</span> <span class="c1">// 2011-03-18
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date3</span> <span class="o">=</span> <span class="n">date2</span><span class="o">.</span><span class="na">withDayOfMonth</span><span class="o">(</span><span class="n">25</span><span class="o">);</span> <span class="c1">// 2011-03-25
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date4</span> <span class="o">=</span> <span class="n">date3</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTH_OF_YEAR</span><span class="o">,</span> <span class="n">9</span><span class="o">);</span> <span class="c1">// 2011-09-25
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date5</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">plusWeeks</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="c1">// 2014-03-25;
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date6</span> <span class="o">=</span> <span class="n">date5</span><span class="o">.</span><span class="na">minusYear</span><span class="o">(</span><span class="n">3</span><span class="o">);</span> <span class="c1">// 2011-03-25
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date7</span> <span class="o">=</span> <span class="n">date6</span><span class="o">.</span><span class="na">plus</span><span class="o">(</span><span class="n">6</span><span class="o">,</span> <span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTHS</span><span class="o">);</span> <span class="c1">// 2011-09-25
</span></code></pre></div><p>        此外，$LocalDate$ 、$LocalTime$ 、$LocalDateTime$ 以及 $Instant$ 中都提供了大量通用方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">是否为静态方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$from$</td>
<td align="center">是</td>
<td align="center">根据对象创建实例</td>
</tr>
<tr>
<td align="center">$now$</td>
<td align="center">是</td>
<td align="center">根据系统时钟创建实例</td>
</tr>
<tr>
<td align="center">$of$</td>
<td align="center">是</td>
<td align="center">根据对象的某部分创建实例</td>
</tr>
<tr>
<td align="center">$parse$</td>
<td align="center">是</td>
<td align="center">根据字符串创建实例</td>
</tr>
<tr>
<td align="center">$atOffset$</td>
<td align="center">否</td>
<td align="center">将对象和某个时区偏移结合</td>
</tr>
<tr>
<td align="center">$atZone$</td>
<td align="center">否</td>
<td align="center">将对象和某个时区结合</td>
</tr>
<tr>
<td align="center">$format$</td>
<td align="center">否</td>
<td align="center">使用某个格式器将对象转换为字符串（$Instant$ 类不支持）</td>
</tr>
<tr>
<td align="center">$get$</td>
<td align="center">否</td>
<td align="center">读取对象某部分值</td>
</tr>
<tr>
<td align="center">$minus$</td>
<td align="center">否</td>
<td align="center">将对象减去一定时长创建副本</td>
</tr>
<tr>
<td align="center">$plus$</td>
<td align="center">否</td>
<td align="center">将对象加上一定时长创建副本</td>
</tr>
<tr>
<td align="center">$with$</td>
<td align="center">否</td>
<td align="center">对对象某些部分进行修改创建副本</td>
</tr>
</tbody>
</table>
<h2 id="5-temporaladjuster">5. <code>TemporalAdjuster</code></h2>
<p>        $with$ 方法可以接收一个 $TemporalAdjuster$ 对象，允许我们更加灵活地处理日期。对于一些常见的用例，日期和时间<code>API</code>已经提供了大量预定义的 $TemporalAdjuster$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">TemporalAdjusters</span><span class="o">.</span><span class="na">nextOrSame</span><span class="o">(</span><span class="n">DayOfWeek</span><span class="o">.</span><span class="na">SUNDAY</span><span class="o">));</span> <span class="c1">// 2014-03-23
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date3</span> <span class="o">=</span> <span class="n">date2</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">TemporalAdjusters</span><span class="o">.</span><span class="na">lastDayOfMonth</span><span class="o">());</span> <span class="c1">// 2014-03-31
</span></code></pre></div><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$dayOfWeekInMonth$</td>
<td align="center">同月份同星期中每周第几天</td>
</tr>
<tr>
<td align="center">$firstDayOfMonth$</td>
<td align="center">当月第一天</td>
</tr>
<tr>
<td align="center">$firstDayOfNextMonth$</td>
<td align="center">下月第一天</td>
</tr>
<tr>
<td align="center">$firstDayOfNextYear$</td>
<td align="center">下年第一天</td>
</tr>
<tr>
<td align="center">$firstDayInMonth$</td>
<td align="center">同月份第一个星期几</td>
</tr>
<tr>
<td align="center">$lastDayOfMonth$</td>
<td align="center">当月最后一天</td>
</tr>
<tr>
<td align="center">$lastDayOfNextMonth$</td>
<td align="center">下月最后一天</td>
</tr>
<tr>
<td align="center">$lastDayOfNextYear$</td>
<td align="center">下年最后一天</td>
</tr>
<tr>
<td align="center">$lastDayOfYear$</td>
<td align="center">今年最后一天</td>
</tr>
<tr>
<td align="center">$lastInMonth$</td>
<td align="center">同月份最后一个星期几</td>
</tr>
<tr>
<td align="center">$next$ / $previous$</td>
<td align="center">之前或之后第一个星期几</td>
</tr>
<tr>
<td align="center">$nextOrSame$ / $previousOrSame$</td>
<td align="center">之前或之后第一个星期几，包括当前日期</td>
</tr>
</tbody>
</table>
<p>        如果预定义的 $TemporalAdjuster$ 不能满足需求，我们可以定义更加复杂的操作，即创建自定义的 $TemporalAdjuster$ 。实际上，$TemporalAdjuster$ 接收是一个函数式接口，只声明了一个方法。我们可以将其视为 $UnaryOperator$&lt;$Temporal$&gt; 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TemporalAdjuster</span> <span class="o">{</span>
    <span class="n">Temporal</span> <span class="nf">adjustInto</span><span class="o">(</span><span class="n">Temporal</span> <span class="n">temporal</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>        由于该接口为函数式接口，所以我们可以通过<code>Lambda</code>表达式进行传递。实现一个计算下一个工作日的 $TemporalAdjuster$ 的例子如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">date</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">temporal</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">DayOfWeek</span> <span class="n">dow</span> <span class="o">=</span> <span class="n">DayOfWeek</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">temporal</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">DAY_OF_WEEK</span><span class="o">));</span>
    <span class="kt">int</span> <span class="n">dayToAdd</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dow</span> <span class="o">==</span> <span class="n">DayOfWeek</span><span class="o">.</span><span class="na">FRIDAY</span><span class="o">)</span> <span class="n">dayToAdd</span> <span class="o">=</span> <span class="n">3</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">dow</span> <span class="o">==</span> <span class="n">DayOfWeek</span><span class="o">.</span><span class="na">SATURDAY</span><span class="o">)</span> <span class="n">dayToAdd</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">temporal</span><span class="o">.</span><span class="na">plus</span><span class="o">(</span><span class="n">dayToAdd</span><span class="o">,</span> <span class="n">ChronoField</span><span class="o">.</span><span class="na">DAYS</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div><p>        $TemporalAdjusters.ofDateAdjuster$ 方法接收一个 $UnaryOperator$&lt;$LocalDate$&gt; 类型的参数，返回一个 $TemporalAdjuster$ 。我们也可以使用该方法利用<code>Lambda</code>表达式创建 $TemporalAdjuster$ 。</p>
<h2 id="6-datetimeformatter">6. <code>DateTimeFormatter</code></h2>
<p>        $java.time.format$ 专门用于格式化以及解析日期-时间对象，而 $DateTimeFormatter$ 类是其中最重要的类。所有的 $DateTimeFormatter$ 实例都能用于以一定的格式创建代表特定日期或时间的字符串。此外，在解析过程中也可以通过指定格式的形式使用不同的字符串创建日期。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">BASIC_ISO_DATE</span><span class="o">);</span> <span class="c1">// 20140318
</span><span class="c1"></span><span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ISO_LOCAL_DATE</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span>
<span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;20140318&#34;</span><span class="o">,</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">BASIC_ISO_DATE</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2014-03-18&#34;</span><span class="o">,</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ISO_LOCAL_DATE</span><span class="o">);</span>
</code></pre></div><p>        除了使用已经定义好的格式外，通过 $ofPattern$ 方法，我们也可以自定义格式。$ofPattern$ 还提供了一个重载版本，允许我们创建某个 $Locale$ 的格式器。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DateTimeFormatter</span> <span class="n">formatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">&#34;dd/MM/yyyy&#34;</span><span class="o">);</span>
<span class="n">DateTimeFormatter</span> <span class="n">italianFormatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">&#34;d. MMMM yyyy&#34;</span><span class="o">,</span> <span class="n">Locale</span><span class="o">.</span><span class="na">ITALIAN</span><span class="o">);</span>
</code></pre></div><p>        如果需要更加细粒度的控制，$DateTimeFormatter$ 还提供了更复杂的格式器。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DateTimeFormatter</span> <span class="n">italianFormatter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DateTimeFormatterBuilder</span><span class="o">()</span>
                                        <span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">DAY_OF_MONTH</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendLiteral</span><span class="o">(</span><span class="s">&#34;. &#34;</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTH_OF_YEAR</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendLiteral</span><span class="o">(</span><span class="s">&#34; &#34;</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">YEAR</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">parseCaseInsensitive</span><span class="o">()</span>
                                        <span class="o">.</span><span class="na">toFormatter</span><span class="o">(</span><span class="n">Locale</span><span class="o">.</span><span class="na">ITALIAN</span><span class="o">);</span>
</code></pre></div><p>        相较于 $java.util.DateFormat$ ，所有的 $DateTimeFormatter$ 都是线程安全的，所以可以以单例模式创建格式器实例，并在多个线程之间共享。</p>
<h2 id="7-时区和历法">7. 时区和历法</h2>
<p>        $java.time.ZoneId$ 类是老版的 $java.util.TimeZone$ 的替代品，与其他日期和时间类一样，它也是无法修改的。$ZoneRules$ 类中包含了 $40$ 个实例，可以通过 $ZoneId.getRules(\ )$ 可以获取指定时区的规则。每个特定的 $ZoneId$ 对象都由一个<code>ID</code>标识。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ZoneId</span> <span class="n">romeZone</span> <span class="o">=</span> <span class="n">ZoneId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;Europe/Rome&#34;</span><span class="o">);</span>
</code></pre></div><p>        <code>Java 8</code>中为 $TimeZone$ 提供了一个新方法 $toZoneId$ ，通过该方法，我们可以将一个老时区对象转换为 $ZoneId$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ZoneId</span> <span class="n">zoneId</span> <span class="o">=</span> <span class="n">TimeZone</span><span class="o">.</span><span class="na">getDefault</span><span class="o">().</span><span class="na">toZoneId</span><span class="o">();</span>
</code></pre></div><p>        一旦得到 $ZoneId$ ，我们就可以将其与 $LocalDate$ 、$LocalDateTime$ 或者是 $Instant$ 结合，构造为一个 $ZonedDateTime$ 实例。通过 $ZoneId$ ，我们还可以实现 $LocalDateTime$ 和 $Instant$ 之间的互相转换。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">ZonedDateTime</span> <span class="n">zdt1</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">atStartOfDay</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>

<span class="n">LocalDateTime</span> <span class="n">dateTime</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">,</span> <span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">);</span>
<span class="n">ZonedDateTime</span> <span class="n">zdt2</span> <span class="o">=</span> <span class="n">dateTime</span><span class="o">.</span><span class="na">atZone</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>

<span class="n">Instant</span> <span class="n">instant</span> <span class="o">=</span> <span class="n">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
<span class="n">ZonedDateTime</span> <span class="n">zdt3</span> <span class="o">=</span> <span class="n">instant</span><span class="o">.</span><span class="na">atZone</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>

<span class="n">Instant</span> <span class="n">instantFromDateTime</span> <span class="o">=</span> <span class="n">dateTime</span><span class="o">.</span><span class="na">toInstant</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">timeFromInstant</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">ofInstant</span><span class="o">(</span><span class="n">instant</span><span class="o">,</span> <span class="n">romeZone</span><span class="o">);</span>
</code></pre></div><p>        另一种比较通用的表示时区的方式是利用当前时区和<code>UTC</code>/格林尼治的固定偏差，我们可以通过 $of$ 方式创建。要注意，使用这种方式定义的 $ZoneOffset$ 并未考虑任何日光时的影响，所以在大部分情况下不推荐使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ZoneOffset</span> <span class="n">newYorkOffset</span> <span class="o">=</span> <span class="n">ZoneOffset</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;-05:00&#34;</span><span class="o">);</span>
</code></pre></div><p>        虽然<code>ISO-8601</code>日历系统是世界文明日历系统的事实标准。但是<code>Java 8</code>中另外还提供了 $4$ 种其他的日历系统，这些日历系统中的每一个都有一个对应的日志类，分别是 $ThaiBuddhistDate$ 、$MinguoDate$ 、$JapaneseDate$ 以及 $HijrahDate$ 。所有这些类以及 $LocalDate$ 都实现了 $ChronoLocalDate$ 接口，能够对公历的日期进行建模。我们可以通过 $from$ 方法从 $LocalDate$ 中创建，或者先创建一个日历系统，接着再创建该日期实例。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">JapaneseDate</span> <span class="n">japaneseDate</span> <span class="o">=</span> <span class="n">JapaneseDate</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">date</span><span class="o">);</span>

<span class="n">Chronology</span> <span class="n">japaneseChronology</span> <span class="o">=</span> <span class="n">Chronology</span><span class="o">.</span><span class="na">ofLocale</span><span class="o">(</span><span class="n">Locale</span><span class="o">.</span><span class="na">JAPAN</span><span class="o">);</span>
<span class="n">ChronoLocalDate</span> <span class="n">now</span> <span class="o">=</span> <span class="n">japaneseChronology</span><span class="o">.</span><span class="na">dateNow</span><span class="o">();</span>
</code></pre></div><p>        日期及时间<code>API</code>的设计者建议使用第一种方式进行创建，因为开发者在代码中可能会进行一些假设，但这些假设在不同的日历系统中有可能不成立，比如一个月最多有 $31$ 天，一年有 $12$ 个月等。除非需要将程序的输入或者输出本地化，否则不要使用 $ChronoLocalDate$ 类。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Feb 18 18:39</span> <a href="/post/java-8%E5%AE%9E%E6%88%98%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/java-8%E5%AE%9E%E6%88%98%E6%B5%81%E5%A4%84%E7%90%86/">Java 8实战：流处理</a></h1>
            </center>
            <div class="post-content">
                <p>        <code>流</code>是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流。基于<code>流</code>的思想，<code>Java 8</code>在 $java.util.stream$ 中添加了一个<code>Stream API</code>。 $Stream$&lt;$T$&gt; 就是一系列 $T$ 类型的项目。<br/>
        和<code>Collection API</code>相比，<code>Stream API</code>处理数据的方式非常不同。用集合的话，需要使用 $for$ 循环迭代并处理元素，我们称之为<code>外部迭代</code>。相反，<code>Stream API</code>的数据处理完全是在库内部进行的，我们称之为<code>内部迭代</code>。虽然都能访问数据项目的序列，但是相比之下，<code>Collection API</code>主要是为了存储和访问数据，而<code>Stream API</code>主要用于描述对数据的计算。这里的关键点在于，<code>Stream API</code>允许并行处理一个 $Stream$ 中的元素。筛选一个 $Collection$ 最快的方式通常是将其转换为 $Stream$ ，进行并行处理，再转换回 $List$ 。粗略地说，流与集合之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，包含数据结构中目前所有的值，集合中的元素只有经过计算后才能添加；相比之下，流是在概念上固定的数据结构，不能通过流添加或删除元素，流中的元素是按需计算的，即只从流中提取出需要的值。与迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。要想重新遍历，可以从原始数据源中重新获取一个新的流。尝试再次遍历一个已经消费的流会抛出 $IllegalStateException$ 异常。流与集合的另一个关键区别在于遍历数据的方式，正如之前所说，使用 $Collection$ 接口需要用户进行外部迭代，而 $Steams$ 库使用的是内部迭代，即库自动完成迭代，并将流值存放在某个地方。相较于显式的外部迭代，内部迭代下项目可以透明地并行处理，或者用更优化的顺序进行处理，例如同时处理多个数据，或者优先处理某些数据等。<br/></p>
<h2 id="1-流操作">1. 流操作</h2>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">类型</th>
<th align="center">返回类型</th>
<th align="center">操作参数</th>
<th align="center">函数描述符</th>
<th align="center">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$filter$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$T$&gt;</td>
<td align="center">$Predicate$&lt;$T$&gt;</td>
<td align="center">$T \rightarrow boolean$</td>
<td align="center">返回一个包含所有符合谓词的元素的流</td>
</tr>
<tr>
<td align="center">$distinct$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$T$&gt;</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回一个元素各异的流</td>
</tr>
<tr>
<td align="center">$map$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$R$&gt;</td>
<td align="center">$Function$&lt;$T, R$&gt;</td>
<td align="center">$T \rightarrow R$</td>
<td align="center">将函数应用到每个元素上，并映射成一个新元素</td>
</tr>
<tr>
<td align="center">$flatMap$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$R$&gt;</td>
<td align="center">$Function$&lt;$T,R$&gt;</td>
<td align="center">$T \rightarrow R$</td>
<td align="center">将多个生成流扁平化为单个流</td>
</tr>
<tr>
<td align="center">$limit$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$T$&gt;</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回一个不超过给定长度的流</td>
</tr>
<tr>
<td align="center">$skip$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$T$&gt;</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回一个跳过给定数量元素的流</td>
</tr>
<tr>
<td align="center">$sorted$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$T$&gt;</td>
<td align="center">$Comparator$&lt;$T$&gt;</td>
<td align="center">$(T, T) \rightarrow int$</td>
<td align="center">返回一个经过排序的流</td>
</tr>
<tr>
<td align="center">$forEach$</td>
<td align="center">终端</td>
<td align="center">$void$</td>
<td align="center">$Consumer$&lt;$T$&gt;</td>
<td align="center">$T \rightarrow void$</td>
<td align="center">消费流中的每一个元素并对其应用<code>Lambda</code>，返回类型为 $void$</td>
</tr>
<tr>
<td align="center">$count$</td>
<td align="center">终端</td>
<td align="center">$long$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回流中元素的个数，返回类型为 $long$</td>
</tr>
<tr>
<td align="center">$collect$</td>
<td align="center">终端</td>
<td align="center">$R$</td>
<td align="center">$Collector$&lt;$T, A, R$&gt;</td>
<td align="center"></td>
<td align="center">把流归约成一个集合并返回</td>
</tr>
<tr>
<td align="center">$anyMatch$</td>
<td align="center">终端</td>
<td align="center">$boolean$</td>
<td align="center">$Predicate$&lt;$T$&gt;</td>
<td align="center">$T \rightarrow boolean$</td>
<td align="center">流中是否含有一个元素能匹配给定的谓词</td>
</tr>
<tr>
<td align="center">$allMatch$</td>
<td align="center">终端</td>
<td align="center">$boolean$</td>
<td align="center">$Predicate$&lt;$T$&gt;</td>
<td align="center">$T \rightarrow boolean$</td>
<td align="center">流中的元素是否都能匹配给定的谓词</td>
</tr>
<tr>
<td align="center">$noneMatch$</td>
<td align="center">终端</td>
<td align="center">$boolean$</td>
<td align="center">$Predicate$&lt;$T$&gt;</td>
<td align="center">$T \rightarrow boolean$</td>
<td align="center">流中是否没有元素与给定的谓词匹配</td>
</tr>
<tr>
<td align="center">$findAny$</td>
<td align="center">终端</td>
<td align="center">$Optional$&lt;$T$&gt;</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回当前流中的任意元素</td>
</tr>
<tr>
<td align="center">$findFirst$</td>
<td align="center">终端</td>
<td align="center">$Optional$&lt;$T$&gt;</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回当前流中第一个元素</td>
</tr>
<tr>
<td align="center">$reduce$</td>
<td align="center">终端</td>
<td align="center">$Optional$&lt;$T$&gt;</td>
<td align="center">$BinaryOperator$&lt;$T$&gt;</td>
<td align="center">$(T, T) \rightarrow T$</td>
<td align="center">对流中元素重复应用方法</td>
</tr>
</tbody>
</table>
<p>        诸如 $filter$ 或 $Sorted$ 等操作会返回另一个流，这让多个操作可以连接起来形成一个查询，这种操作称为<code>中间操作</code>。除非流水线上触发一个终端操作，否则中间操作不会执行任何处理。<code>终端操作</code>会从流的流水线生成结果，其结果是任何不是流的值，比如 $List$ 、$Integer$ 等。总而言之，流的使用一般包括三件事：一个数据源、一个中间操作链和一个终端操作。<br/>
        诸如 $map$ 或 $filter$ 等操作会从输入流中获取每一个元素，并在输出流中得到 $0$ 或 $1$ 个结果。这些操作一般都是<code>无状态操作</code>。但诸如 $reduce$ 、$sum$ 、$max$ 等操作需要内部状态来累计结果，这些操作就是<code>有状态操作</code>。但是这些操作的内部状态很小，通常只是一些基本数据类型，不管流中有多少元素需要处理，内部状态都是有界的。而诸如 $sorted$ 或 $distinct$ 等操作，它们的内部状态可能很大，这时就要求无界的存储空间。<br/>
        $peek$ 是一个特殊的流操作，可以在流的每个元素恢复运行之前，插入执行一个动作。$peek$ 不会恢复流的运行，而是在一个元素上完成操作之后，将操作顺承到流水线中的下一个操作。<br/>
        <code>Java 8</code>引入了三个原始类型特化流接口 $IntStream$ 、$DoubleStream$ 和 $LongStream$ ，分别将流中的元素特化为 $int$ 、$long$ 和 $double$ ，从而避免了暗含的装箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的 $sum$ ，此外还可以在必要时将它们转换回对象流。将流转换为特化版本的常用方法是 $mapToInt$ 、$mapToDouble$ 和 $mapToLong$ 。这些方法和 $map$ 的工作方式一样，但是会返回特化流。如果想要将特化流转换为对象流，可以使用 $boxed$ 方法。类似的，也可以使用 $mapToObj$ 方法生成对象流。<br/>
        <code>Java 8</code>还引入了两个可以用于 $IntStream$ 和 $LongStream$ 的静态方法，帮助生成数值范围，分别是 $range$ 和 $rangeClosed$ ，前者为开区间，后者为闭区间。<br/>
        除了调用集合中的 $stream$ 方法之外，还有一些其他的构造流的方式：</p>
<ul>
<li>$Stream.of$ ：通过显式值创建一个流；</li>
<li>$Arrays.stream$ ：从数组创建一个流；</li>
<li>$Files.lines$ ：由指定文件中的各行构成的字符串流；</li>
<li>$Stream.iterate$ ：从函数创建一个无限流，接收一个初始值；</li>
<li>$Stream.generate$ ：接收一个 $Supplier$&lt;$T$&gt; 类型参数，创建一个无限流；</li>
<li>$Stream.empty$ ：创建一个空流。</li>
</ul>
<h2 id="2-optional">2. <code>Optional</code></h2>
<p>        $Optional$ 是<code>Java 8</code>中引入的一个新类。当变量存在时，$Optional$ 只是对类的简单封装。变量不存在时，缺失的值会被建模成一个空的 $Optional$ 对象，由方法 $Optional.empty(\ )$ 返回，该方法为一个静态工厂方法，返回 $Optional$ 类的特定单一实例。引入 $Optional$ 的意图并非要消除每一个 $null$ 引用，其目的是帮助设计出一个更加普适的<code>API</code>。$Optional$ 提供了几种可以迫使你显式地检查值是否存在或处理值不存在的情形的方法：</p>
<ul>
<li>$isPresent(\ )$ ：包含值时返回 $true$ ；</li>
<li>$isPresent(Consumer$&lt;$T$&gt; $block)$ ：值存在时执行给定代码块；</li>
<li>$get(\ )$ ：值存在时返回值，否则抛出 $NoSuchElement$ 异常；</li>
<li>$orElse(T\ other)$ ：值存在时返回值，否则返回默认值；</li>
<li>$orElsetGet(Supplier$&lt;$?\ extends\ T$&gt; $other)$ ：当值不存在时会调用 $Supplier$ 对象并返回；</li>
<li>$orElseThrow(Supplier$&lt;$?\ extends\ X$&gt; $exceptionSupplier)$ ：当值不存在时会抛出 $Supplier$ 指定的异常类型；</li>
<li>$ifPresent(Consumer$&lt;$?\ super\ T$&gt;$)$ ：能在变量值存在时执行一个作为参数传入的方法，否则不进行任何操作。</li>
</ul>
<p>        创建 $Optional$ 对象的方式很简单，可以通过 $Optional.empty(\ )$ 声明一个空的 $Optional$ 对象，也可以通过 $Optional.of(\ )$ 方法通过一个非空值创建对象。如果不知道传入的对象是否为空值，可以使用 $Optional.ofNullable(\ )$ 方法，使用该方法构造的对象如果参数为 $null$ ，那么会返回一个空的 $Optional$ 对象。<br/>
        一般情况下，当我们访问一个可以为空的对象值前，需要先判断其是否为空。$Optional.map(\ )$ 方法会将提供的函数应用于当前值，如果当前 $Optional$ 非空，那么将该值作为参数传递给 $map$ ，反之则什么也不做。如果在一个对象上连续多次调用 $map$ 方法，可能会出现嵌套式的 $Optional$ 对象，此时我们可以使用 $Optional.flatMap(\ )$ 方法。类似于流，该方法将嵌套式的 $Optional$ 对象合并为一个。<br/>
        当需要调用某个对象的方法，查看某些属性时，可以使用 $filter$ 方法。该方法接受一个谓词作为参数，如果对象值存在并且符合谓词条件，$filter$ 就不做任何改变，否则就返回一个空的 $Optional$ 对象。<br/>
        与 $Stream$ 一样，$Optional$ 也提供了类似的基础类型 $OptionalInt$ 、$OptionalLong$ 以及 $OptionalDouble$ 。对于 $Stream$ 而言，因为其中可能包含大量的元素，出于性能考虑，我们最好使用基础类型。但对于只有单个元素的 $Optional$ ，这个理由就不成立了。基础类型的 $Optional$ 并不支持 $map$ 、$flatMap$ 以及 $filter$ 方法，同时也不能作为方法引用传递给另一个 $flatMap$ 方法，所以并不推荐使用。</p>
<h2 id="3-collector">3. <code>Collector</code></h2>
<p>        $Collector$ 用于定义 $collect$ 方法用来生成结果集合的标准。更具体地说，对流调用 $collect$ 方法将对流中的元素触发一个归约操作。一般来说，$Collector$ 会对元素应用一个转换函数，并将结果累积在一个数据结构中。$Collector$ 接口中方法的实现决定了如何对流执行归约操作， 而 $Collectors$ 实用类中提供了很多静态工厂方法，可以方便地创建常见收集器的实例：</p>
<ul>
<li>$toList$ ：把流中的所有项目收集到一个 $List$ ；</li>
<li>$toSet$ ：把流中的所有项目收集到一个 $Set$ ，删除重复项；</li>
<li>$toCollection$ ：把流中所有项目收集到给定的供应源创建的集合，需要额外指定一个集合创建方法；</li>
<li>$counting$ ：返回流中元素个数，更直接地，也可以使用 $Stream.count$ 方法；</li>
<li>$maxBy$ ：接收一个 $Comparator$ ，返回流中最大值；</li>
<li>$minBy$ ：接收一个 $Comparator$ ，返回流中最小值；</li>
<li>$summingInt$ / $summingLong$ / $summingDouble$ ：接收一个把对象映射为 $int$ / $long$ / $double$ 的函数，并返回总和；</li>
<li>$averagingInt$ / $averagingLong$ / $averagingDouble$ ：接收一个把对象映射为 $int$ / $long$ / $double$ 的函数，并返回平均值；</li>
<li>$summarizingInt$ / $summarizingLong$ / $summarizingDouble$ ：接收一个把对象映射为 $int$ / $long$ / $double$ 的函数，并返回一个 $IntSummaryStatistics$ / $LongSummaryStatistics$ / $DoubleSummaryStatistics$ 对象，包含流中元素个数、最大值、最小值、总和和平均值信息；</li>
<li>$joining$ ：对流中的每一个对象应用 $toString$ 方法，并将结果串连成一个字符串，允许接收一个分界符；</li>
<li>$groupingBy$ ：接收两个函数，前者为键值分类函数，后者为收集器类型的收集函数，并返回一个 $Map$ ，其中第二个参数可以省略，默认为 $groupingBy(f,\ toList(\ ))$ ；</li>
<li>$partitionBy$ ：接收一个 $Predicate$&lt;$T$&gt; 类型参数和一个转换函数，返回一个键值为 $Boolean$ 的 $Map$ ，其中第二个参数可以省略，默认为 $partitionBy(f,\ toList(\ ))$ ；</li>
</ul>
<p>        $reducing$ 方法允许定义一个更一般化的归约过程，它接收三个参数：初始值、转换函数和一个 $BinaryOperator$ ，用于将两个项目累积成一个同类型的值。此外还有一个单参数类型的重载版本，只接收一个 $BinaryOperator$ ，以第一个项目作为起点，把恒等函数作为转换函数。<br/>
        在收集的时候，由于调用的方法的原因，可能会返回 $Optional$ 类型的参数，而这往往不是我们想要的，这时候就可以使用 $collectingAndThen$ 方法，可以额外接收一个转换函数，将 $Optional$ 类型进行转换。<br/>
        如果要自定义收集器，需要使用 $Collector$ 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">supplier</span><span class="o">();</span>
    <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nf">accumulator</span><span class="o">();</span>
    <span class="n">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="nf">finisher</span><span class="o">();</span>
    <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">combiner</span><span class="o">();</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="nf">characteristics</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>        其中 $T$ 是流要收集的项目的泛型，$A$ 是累加器的类型，$R$ 是收集操作得到的对象的类型。$supplier$ 方法返回一个结果为空的 $Supplier$ ，创建一个空的累加器实例；$accumulator$ 方法返回执行归约操作的函数；$finisher$ 方法返回在累积过程的最后调用的函数，以便将累加器对象转换为整个集合操作的最终结果；$combiner$ 方法返回一个供归约操作使用的函数，定义了对流的各个子部分进行并行处理时如何合并累加器结果；$characteristics$ 方法会返回一个不可变的 $Characteristics$ 集合，定义了收集器的行为，是一个包含了三个项目的枚举：$UNORDERED$ ( 结果不受流中项目的遍历和累计顺序的影响 )、$CONCURRENT$ ( $accumulator$ 可以多线程调用 )、$IDENTITY_-FINISH$ ( $finisher$ 返回恒等函数，可以跳过 )。以下为 $ToListCollector$ 类型实例，它将流转换为 $List$ ：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ToListCollector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">supplier</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">ArrayList</span><span class="o">::</span><span class="k">new</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nf">accumulator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">List</span><span class="o">::</span><span class="n">add</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">finisher</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">();</span> <span class="c1">// 恒等函数
</span><span class="c1"></span>    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">combiner</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">list1</span><span class="o">,</span> <span class="n">list2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">list1</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">list2</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">list1</span><span class="o">;</span>
        <span class="o">};</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="nf">characteristics</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span>
            <span class="n">EnumSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Characteristics</span><span class="o">.</span><span class="na">IDENTITY_FINISH</span><span class="o">,</span> <span class="n">Characteristics</span><span class="o">.</span><span class="na">CONCURRENT</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        除了实现 $Collector$ 之外，自定义收集操作也可以通过调用一个重载版本的 $collect$ 方法完成。该方法接收 $supplier$ 、$accumulator$ 和 $combiner$ 三个函数，并且永远都是一个 $IDENTITY_-FINISH$ 和 $CONCURRENT$ 但非 $UNORDERED$ 的收集器。</p>
<h2 id="4-并行流">4. 并行流</h2>
<p>        <code>并行流</code>就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。通过对收集源调用 $parallelStream$ 方法，可以把集合转换为并行流。也可以通过在顺序流上调用 $parallel$ 方法来转换为并行流，调用该方法后流本身并不会有任何实际的变化，在内部实际上只设置了一个 $boolean$ 标志位。类似的，也可以在并行流上调用 $sequential$ 方法来将它转换为顺序流。<br/>
        并行化的过程本身需要对流做递归划分，把每个子流的归纳操作分配到不同的线程，然后把这些操作的结果合并成一个值。但在多个内核之间移动数据的代价也可能很大，所以很重要的一点是要保证在内核中并行执行工作的时间比在内核之间传输数据的时间长。总而言之，很多情况下不可能或不方便并行化。一般而言，想给出任何关于什么时候该用并行流的定量建议都是不可能也毫无意义的。</p>
<ul>
<li>在将顺序流转换为并行流时，对于存在疑问的转换，可以先测试；</li>
<li>自动装箱和拆箱操作会大大降低性能，对于存在大量这种操作的流，应该尽可能地使用原始类型特化流；</li>
<li>有些操作例如 $limit$ 和 $findFirst$ 等依赖于元素顺序的操作，在并行流上的性能就比顺序流差；</li>
<li>对于处理成本较高的操作，使用并行流时性能更好的可能性较大；</li>
<li>避免使用并行流处理数据量较小的集合；</li>
<li>考虑流背后的数据结构是否易于分解，例如 $ArrayList$ 、$range$ 、$HashSet$ 的拆分效率较好，而 $LinkedList$ 、$iterate$ 的拆分效率则很差；</li>
<li>考虑流自身的特点和流水线中间操作修改流的方式，例如筛选操作丢弃的元素个数无法预测，因而难以将流划分为大小近似的部分；</li>
<li>考虑终端操作中合并代价，避免合并代价大于使用并行流带来的性能提升。</li>
</ul>
<p>        并行流的背后使用的是<code>Java 7</code>中引入的<code>分支/合并框架</code>，目的是以递归方式将可以并行的任务拆分成更小的任务，然后把每个子任务的结果合并起来生成整体结果。它是 $ExecutorService$ 接口的一个实现，它把子任务分配给线程池 ( 称为 $ForJoinPool$ ) 中的工作线程。<br/>
        要把任务提交到该线程池，必须创建 $RecursiveTask$&lt;$R$&gt;的一个子类，其中 $R$ 是并行化任务产生的结果，如果任务不返回结果，则是 $RecursiveTask$ 类型。要定义 $RecursiveTask$ ，只需要实现它唯一的抽象方法 $compute$ 。$compute$ 方法定义了将任务拆分为子任务的逻辑，以及无法再拆分或不方便再拆分时生成单个子任务结果的逻辑。一般来说并没有确切的标准决定一个任务是否应该再拆分。分支/合并框架中使用了<code>工作窃取</code> ( $work\ stealing$ ) 技术，每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列中取出下一个任务，提前完成了队列中的所有任务，则会随机选择一个其他线程的队列，从中获取任务。由于工作窃取，因此将原任务分为大量的小任务一般来说都是一个好的选择。<br/>
        $Spliterator$ 是 <code>Java 8</code>中加入的另一个新接口，用于并行遍历数据源中的元素。同时<code>Java 8</code>为集合框架中包含的所有数据结构提供了一个默认的 $Spliterator$ 实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>
    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">trySplit</span><span class="o">();</span>
    <span class="kt">long</span> <span class="nf">estimateSize</span><span class="o">();</span>
    <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>        $tryAdvance$ 的行为类似于普通的 $Iterator$ ，它会按顺序依次遍历使用 $Spliterator$ 的元素，并且如果还有其他元素需要遍历则返回 $true$ 。$trySplit$ 可以将一些元素划分给另一个 $Spliterator$ ，让它们两并行处理，将 $Stream$ 拆分为多个部分的算法是一个递归过程，即不断地调用 $trySplit$ 方法直到不可划分。$estimateSize$ 方法用于估计剩余的需要遍历的元素个数，对于已知大小的源，这个数字是准确的。<br/></p>

            </div>
            <div class="meta post-footer"> <span>2021 Feb 17 18:00</span> <a href="/post/java-8%E5%AE%9E%E6%88%98%E6%B5%81%E5%A4%84%E7%90%86/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm10%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">JVM（10）：线程安全与锁优化</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-线程安全">1. 线程安全</h2>
<p>        按照线程安全程度由强到弱，可以将<code>Java</code>语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>
<h3 id="11-不可变">1.1 不可变</h3>
<p>        在<code>Java</code>语言里，不可变 ( $Immutable$ ) 对象一定是线程安全对象，因此不需要进行任何线程安全保障措施。对于基本数据类型，只需要在定义时使用 $final$ 关键字即可保证不可变。而对于对象类型，<code>Java</code>语言目前暂时还没有提供支持，因此只能让对象自行保证行为不会影响状态，其中最简单的一种方式就是把所有带有状态的变量都声明为 $final$ 。</p>
<h3 id="12-绝对线程安全">1.2 绝对线程安全</h3>
<p>        绝对线程安全指的是当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果。而实际上，要想达到绝对线程安全可能需要付出非常高昂的代价。<code>Java API</code>中标注线程安全的类，大多数都不是绝对线程安全的。例如 $java.util.Vector$ 是一个线程安全的容器，因为它的很多方法被 $synchronized$ 修饰，但是在以下情况下还是线程不安全的：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">vector</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">&lt;&gt;();</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">vector</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>

        <span class="n">Thread</span> <span class="n">removeThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vector</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="n">vector</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">Thread</span> <span class="n">printThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vector</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">vector</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="n">removeThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">printThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        而要想做到线程安全，需要将上述代码改为如下形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Thread</span> <span class="n">removeThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">vector</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vector</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="n">vector</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">});</span>

<span class="n">Thread</span> <span class="n">printThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">vector</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vector</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">vector</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div><p>        而 $Vector$ 要想做到绝对线程安全，就需要在内部维护一组一致性的快照访问，在每次对元素进行改动的时候都要产生新的快照，因此需要付出极大的空间成本和时间成本。</p>
<h3 id="13-相对线程安全">1.3 相对线程安全</h3>
<p>        相对线程安全是我们通常意义上的线程安全，需要保证对对象单次的操作是线程安全的，即将上述绝对线程安全的定义中的“调用这个对象的行为”改为“单次调用”。<code>Java API</code>中大部分标注线程安全的类都属于相对线程安全，比如上面提到的 $java.util.Vector$ 类。</p>
<h3 id="14-线程兼容">1.4 线程兼容</h3>
<p>        线程兼容是指对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段保证对象在并发环境中安全使用，也就是我们通常所说的线程不安全类。<code>Java API</code>中大部分类都是线程兼容的。</p>
<h3 id="15-线程对立">1.5 线程对立</h3>
<p>        线程对立是指不管调用端采取了什么同步措施都不能在多线程中并发使用代码。线程对立的代码极少出现，而且通常都是有害的，应当尽量避免。</p>
<h2 id="2-线程安全的实现">2. 线程安全的实现</h2>
<h3 id="21-互斥同步">2.1 互斥同步</h3>
<p>        互斥同步 ( $Mutal\ \ Exclusion\ \ \And\ \ Synchronization$ ) 是最常见也是最主要的实现手段。同步即保证共享数据在一个时刻只能被一个线程使用，互斥则是实现同步的手段。<code>Java</code>内最基本的互斥同步手段就是 $synchronized$ 关键字，经过<code>Javac</code>编译后生成 $monitorenter$ 和 $monitorexit$ 字节码指令。这两条指令都要指定一个 $reference$ 类型的参数，如果源码中指定的是对象，那么就以对象作为参数；如果没有明确指定，则根据其修饰的方法类型决定是以对象实例作为参数还是以 $Class$ 对象作为参数。执行 $monitorenter$ 时，如果对象没有被锁定，或者已经持有对象锁，就把锁计数器值加一，并在执行 $monitorexit$ 时减一。如果对象锁计数器为零，代表锁被释放。持有的对象锁只能被当前线程所释放，另一个线程无法强制释放，只能被阻塞。<br/>
        从执行成本的角度来看，持有锁是一个重量级 ( $Heavy-Weight$ ) 操作。在采用操作系统原生内核线程的情况下，阻塞或者唤醒一个线程都需要操作系统完成，因此需要进行用户态和核心态的转换，所以应当只有在必要的情况下才使用 $synchronized$ 。虚拟机也会进行一些优化，比如在阻塞之前加入一段自旋等待过程，从而避免频繁切换到核心态。<br/>
        除了 $synchronized$ 外，我们也可以使用 $java.util.concurrent$ 包，其中的 $locks.Lock$ 接口允许用户以非块结构完成互斥同步。重入锁 ( $ReentrantLock$ ) 是最常见的一种实现，它与 $synchronized$ 一样是可重入的，而且还增加了一些高级功能：等待可中断（等待线程可以放弃等待）、公平锁（按照申请顺序获得锁，但会导致性能下降）、锁绑定多个条件（一个 $ReentrantLock$ 可以绑定多个 $Condition$ 对象）。</p>
<h3 id="22-非阻塞同步">2.2 非阻塞同步</h3>
<p>        互斥同步在线程阻塞和线程唤醒的时候会带来额外开销，因此也被称为阻塞同步 ( $Blocking\ \ Synchronization$ )，从解决方式上来看属于悲观锁。而与之相反的基于冲突检测的乐观并发策略就是允许线程进行操作，如果在操作过程中出现了冲突则进行补偿，最常见的补偿措施是不断重试。这种方式称为非阻塞同步 ( $Non-Blocking\ \ Synchronization$ )，使用这种措施的代码也被称为无锁 ( $Lock-Free$ ) 编程。乐观并发策略要求操作和冲突检测的步骤具备原子性，因此需要依赖一定的硬件指令集。</p>
<h3 id="23-无同步">2.3 无同步</h3>
<p>        保证线程安全并不一定需要进行阻塞或者非阻塞同步，同步只是一个保证数据正确的手段。如果能够让一个方法本来就不涉及共享数据，那么就不需要同步。这类型的典型例子是可重入代码 ( $Reentrant\ \ Code$ ) 和线程本地存储 ( $Thread\ \ Local\ \ Storage$ )。<br/>
        可重入代码是指可以在执行的任何时刻中断，并在控制权返回后也不会出错的代码。我们可以把可重入作为线程安全的一个条件，但并不是所有的线程安全代码都要求可重入。可重入代码具有一些共同特征，如不依赖全局变量，存储在堆上的数据和公用的系统资源、状态量由参数传入、不调用非可重入方法等。如果一个方法的返回结果是可预测的，那么就可以认为是可重入代码。<br/>
        线程本地存储是指如果一段代码中所需要的数据必须与其他代码共享，并且这些共享数据的代码可以在同一个线程中执行，那么就把共享数据的可见范围限制在同一个线程中。符合线程本地存储的典型例子就是“生产者-消费者模式”。<code>Java</code>语言中并没有方式让一个变量被某个线程独占，但是可以通过 $java.lang.ThreadLocal$ 类实现本地存储。</p>
<h2 id="3-锁优化">3. 锁优化</h2>
<h3 id="31-自旋锁与自适应自旋">3.1 自旋锁与自适应自旋</h3>
<p>        互斥同步在阻塞和唤醒的过程中需要完成用户态和核心态的转换，为了避免频繁转换，可以让线程执行一个忙等待，这就是自旋锁。自旋等待虽然避免了线程切换的开销，但是还是会占用处理器时间。所以如果锁被占用的时间很短，那么自旋等待的效果就会很好，反之会很差。因此可以给自旋等待设置一个时间限度，在限定次数内没有获得锁的线程就使用传统方式挂起，这个值默认是十次，可以通过 $-XX:PreBlockSpin$ 设置。<br/>
        <code>JDK 6</code>中引入了自适应自旋，这使得自旋等待的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。如果在同一个锁对象上，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就认为这次自旋很有可能再次成功，从而允许自旋等待更长时间。</p>
<h3 id="32-锁消除">3.2 锁消除</h3>
<p>        锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除，主要判定依据是逃逸分析。<code>Java</code>语言内部存在许多同步代码，锁消除主要是针对<code>Java</code>语言内部的锁。</p>
<h3 id="33-锁粗化">3.3 锁粗化</h3>
<p>        大多数情况下，我们应当把同步块的作用范围限制到尽量小，从而减少同步操作。但是如果一系列的连续操作都对同一个对象进行上锁和解锁，那么会带来额外的性能损耗。锁粗化就是针对这种情况，扩展同步块的作用范围，从而避免额外的性能损耗。</p>
<h3 id="34-轻量级锁">3.4 轻量级锁</h3>
<p>        轻量级锁是<code>JDK 6</code>中加入的新型锁机制，轻量是相对于使用操作系统实现的传统锁而言的。轻量级锁的目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量带来的性能损耗。<code>HotSpot</code>虚拟机的对象头分为两部分，一部分用于存储对象自身的运行时数据（如哈希码、分代年龄），另一部分用于存储指向方法区对象类型数据的指针。前者在 $32$ 位和 $64$ 位的虚拟机中分别占用 $32$ 位和 $64$ 位大小，称为 $Mark\ \ Word$ 。$Mark\ \ Word$ 被设计为非固定的动态数据结构，可以根据对象状态复用存储空间，这是轻量级锁实现的关键。在代码即将进入同步块时，如果同步对象没有被锁定，虚拟机会在当前线程的栈帧中建立一个名为锁记录 ( $Lock\ \ Record$ ) 的空间，存储锁对象目前的 $Mark\ \ Word$ 的拷贝。之后虚拟机尝试使用 $CAS$ 操作更新 $Mark Word$ 为指向 $Lock\ \ Record$ 的指针，代表线程拥有对象锁。如果更新失败，代表存在另一个线程与之竞争，虚拟机会检查对象的 $Mark\ \ Word$ ，判断当前的锁情况。如果出现两个以上的线程竞争使用同一个锁，轻量级锁就不再有效，需要改为使用重量级锁。在不存在竞争的情况下，轻量级锁因为避免了使用互斥量的开销，所以性能方面要比重量级锁高；反过来如果存在竞争，性能就会更低。</p>
<h3 id="35-偏向锁">3.5 偏向锁</h3>
<p>        偏向锁也是<code>JDK 6</code>中引入的，目的是消除数据在无竞争情况下的同步原语。与轻量级锁的不同之处在于轻量级锁是为了消除同步过程中使用的互斥量，而偏向锁是为了消除整个同步过程。偏向锁会偏向于第一个获得它的线程，并且在接下来的执行过程中，如果锁一直没有被其他线程获取，那么持有偏向锁的线程将永远不需要同步。偏向锁的实现与轻量级锁类似，不同之处在于 $Mark\ \ Word$ 中会记录获得偏向锁的线程<code>ID</code>，并在之后同一个线程进入同步块时不再进行任何同步操作。一旦出现另一个线程尝试获取锁，偏向模式立即结束，根据当前对象的锁定状态决定是否撤销偏向。偏向锁可以提高带有同步但是无竞争的程序性能，同样也并非总是有利，对于大多数总是被多个线程访问的情况，偏向模式就是多余的。<br/>
        偏向锁的实现需要占用 $Mark\ \ Word$ 中存储哈希码的区域。哈希码依赖于 $Object::hashCode(\ )$ 方法，会在第一次调用后存储在对象头中，从而保证哈希码的一致性。因此如果一个对象计算过一次哈希码之后，就不能再使用偏向锁，一个处于偏向锁状态的对象需要计算哈希码时，它的偏向锁状态会被立即撤销，并膨胀为重量级锁。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Jan 13 21:17</span> <a href="/post/jvm10%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm9%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">JVM（9）：内存模型与线程</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-内存模型">1. 内存模型</h2>
<h3 id="11-主内存与工作内存">1.1 主内存与工作内存</h3>
<p>        <code>Java</code>内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。在这里主要考虑的问题是多线程对同一块内存区域进行的操作，因此并不需要考虑一些线程私有的变量比如局部变量和方法参数。<code>Java</code>内存模型规定了所有变量都存储在主内存 ( $Main\ \ Memory$ ) 中，每条线程允许拥有自己的工作内存 ( $Working\ \ Memory$ )，保存了主内存中要使用的变量的副本。对于引用对象，工作内存中并不会包含整个对象的副本，而是对象引用以及对象中要使用的字段的副本。通过工作内存，线程的所有的对变量的操作都会在工作内存中进行，即通过工作内存间接访问主内存。</p>
<h3 id="11-内存间交互">1.1 内存间交互</h3>
<p>        主内存与工作内存之间的交互协议指的是一个变量如何从主内存拷贝到工作内存，并从工作内存同步至主内存的过程。<code>Java</code>内存模型定义了 $8$ 种原子性操作：</p>
<ol>
<li>$lock$ ：作用于主内存变量，将变量标识为线程独占状态；</li>
<li>$unlock$ ：作用于主内存变量，把释放一个处于线程独占状态的变量；</li>
<li>$read$ ：作用于主内存变量，将一个变量传输到工作内存中；</li>
<li>$load$ ：作用于工作内存变量，将一个主内存传输的变量载入工作内存的副本中；</li>
<li>$use$ ：作用于工作内存变量，每当虚拟机遇到一个需要使用变量的字节码指令时，将变量传递给执行引擎；</li>
<li>$assign$ ：作用于工作内存变量，每当虚拟机遇到一个给变量赋值的字节码指令时，从执行引擎接收值并赋给变量；</li>
<li>$store$ ：作用于工作内存变量，将一个变量传送到主内存中；</li>
<li>$write$ ：作用于主内存变量，将一个工作内存传送的变量写入主内存的变量中。</li>
</ol>
<p>        如果要把一个变量从主内存拷贝到工作内存中，就需要顺序执行 $read$ 和 $load$ 操作；反过来，如果要把一个变量从工作内存拷贝到主内存中，就需要顺序执行 $store$ 和 $write$ 操作。<code>Java</code>内存模型虽然规定了上述操作要顺序执行，但并没有要求连续执行，也就是说可以读取多个变量后再依次载入，或者存储多个变量后再依次写入。除此之外，还有其他规则：</p>
<ul>
<li>不允许 $read$ 和 $load$ 、$store$ 和 $write$ 单独出现；</li>
<li>不允许线程丢弃 $assign$ 操作；</li>
<li>不允许线程在没有进行 $assign$ 操作时同步内存；</li>
<li>不允许在工作内存中直接 $use$ 一个未被初始化的变量；</li>
<li>一个变量在一个时刻只能被一个线程 $lock$ ，一个线程可以多次执行 $lock$ 操作，后续需要执行相应次数的 $unlock$ 才能解锁；</li>
<li>对一个变量执行 $lock$ 操作会清除变量值，需要重新执行 $load$ 或者 $assign$ 进行赋值；</li>
<li>不允许对一个没有被锁定的变量 $unlock$ ，也不允许 $unlock$ 其他线程独占的变量；</li>
<li>$unlock$ 变量前需要先对其进行 $store$ 和 $write$ 。</li>
</ul>
<h3 id="12-volatile">1.2 <code>volatile</code></h3>
<p>        $volatile$ 具有一些特殊的访问规则。当一个变量被定义为 $volatile$ 之后，它将具有两条性质：一是保证变量是所有线程可见的，即一个线程的修改可以在之后被另一个线程所发现；二是指令重排序优化会被禁止，以保证语句之间的相对执行顺序。虽然可见性使得线程间变量值的传递不再需要经过对主内存的读取和写入，但这并不意味读取到的变量值是正确的。因为 $volatile$ 允许多线程同时对变量进行写操作，这就意味着对于一些非原子性的操作，譬如<code>Java</code>中的运算操作符（需要先将值读取到操作栈之后才能进行运算），$volatile$ 只能保证值被读取的时候是正确的，并不能保证在之后进行运算的过程中值不会发生改变。因此对于第一条性质，要保证运算结果并不依赖变量的当前值，或者只有一个线程会修改变量值。<br/>
        保证 $volatile$ 可见性的关键在于 $lock$ 操作，它会清空变量值，并在之后对变量进行 $store$ 和 $write$ 操作，从而保证了对变量的修改可以被其他线程发现。同时，$lock$ 操作也充当着内存屏障的功能，即执行 $lock$ 操作代表之前的操作已经执行完毕，从而可以利用 $lock$ 操作保证指令之间的相对执行顺序。也因此，$volatile$ 相比于 $synchronized$ 或者 $java.util.concurrent$ ，读操作速度没有什么差别，但是写操作会慢上一些，因为需要插入许多内存屏障以保证执行顺序，当然总体上来讲还是要快于后两者的。<br/>
        <code>Java</code>内存模型也对 $volatile$ 变量定义了特殊规则，设 $V$ 和 $W$ 代表两个 $volatile$ 变量，则有：</p>
<ul>
<li>只有前一条指令是 $load$ 时才能 $use$ ；只有后一条指令是 $use$ 时才能 $load$ ，即 $load$ 和 $use$ 必须连续一起出现；</li>
<li>只有前一条指令是 $assign$ 时才能 $store$ ；只有后一条指令是 $store$ 时才能 $assign$ ，即 $assign$ 和 $store$ 必须连续一起出现；</li>
<li>在一个线程中，如果对 $V$ 执行 $use$ 或者 $assign$ 操作优先于对 $W$ 执行 $use$ 或者 $assign$ 操作，那么对 $V$ 执行的 $read$ 或者 $write$ 操作必须优先于对 $W$ 执行的 $read$ 或者 $write$ 操作。</li>
</ul>
<h3 id="13-long和double">1.3 <code>long</code>和<code>double</code></h3>
<p>        $long$ 和 $double$ 是 $64$ 位的数据类型。对于 $64$ 位的数据类型，<code>Java</code>内存模型定义了一条特殊的规则：允许将其划分为两次 $32$ 位的操作进行，即 “ $long$ 和 $double$ 非原子性协定 ” ( $Non-Atomic\ \ Treatment\ \ of\ \ double\ \ and\ \ long\ \ Variables$ )。如果有多个线程共享一个未声明 $volatile$ 的 $long$ 或者 $double$ 类型的变量，并且同时对它们进行读写操作，那么某些线程可能会读取到一个修改了一半的数值。当然这种情况很罕见，因为常用的 $64$ 位虚拟机中并不会出现非原子性访问行为。</p>
<h3 id="14-原子性可见性与有序性">1.4 原子性、可见性与有序性</h3>
<h4 id="141-原子性">1.4.1 原子性</h4>
<p>        <code>Java</code>内存模型直接保证的原子性变量操作包括：$read$ 、$load$ 、$assign$ 、$use$ 、$store$ 和 $write$ 。如果需要一个更大范围的原子性保证，<code>Java</code>内存模型还提供了 $lock$ 和 $unlock$ 操作，即 $synchronized$ 块之间的操作也具备原子性。</p>
<h4 id="142-可见性">1.4.2 可见性</h4>
<p>        <code>Java</code>内存模型通过在变量修改后将新值同步回主内存，并在变量被读取时从主内存刷新变量值的方式实现可见性。除了 $volatile$ 之外，还可以使用 $synchronized$ 和 $final$ 保证可见性。</p>
<h4 id="143-有序性">1.4.3 有序性</h4>
<p>        有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在另一个线程中观察，所有的操作都是无序的。</p>
<h3 id="15-先行发生原则">1.5 先行发生原则</h3>
<p>        先行发生是<code>Java</code>内存模型中定义的两项操作之间的偏序关系。如果操作 $A$ 先行发生于操作 $B$ ，指的就是操作 $B$ 能够观测到操作 $A$ 产生的影响，影响指的是修改变量值、发送消息、调用方法等。<code>Java</code>内存模型之中存在一些天然的先行发生关系：</p>
<ul>
<li><strong>程序次序规则</strong> ( $Program\ \ Order\ \ Rule$ )：线程内按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li><strong>管程锁定规则</strong> ( $Monitor\ \ Lock\ \ Rule$ )：$unlock$ 操作先行发生于后续对同一个锁的 $lock$ 操作；</li>
<li>$volatile$ <strong>变量规则</strong> ( $Volatile\ \ Variable\ \ Rule$ )：对一个 $volatile$ 变量的写操作先行发生于读操作；</li>
<li><strong>线程启动规则</strong> ( $Thread\ \ Start\ \ Rule$ )：$Thread$ 的 $start(\ )$ 方法先行发生于所有动作；</li>
<li><strong>线程终止规则</strong> ( $Thread\ \ Termination\ \ Rule$ )：$Thread$ 的所有操作都先行发生于对其的终止检测 ( $join(\ )$ 和 $isAlive(\ )$ 等 )；</li>
<li><strong>线程中断规则</strong> ( $Thread\ \ Interruption\ \ Rule$ )：$Thread$ 的 $interrupt(\ )$ 方法先行发生于对其的中断事件检测 ( $interrupted(\ )$ )；</li>
<li><strong>对象终结规则</strong> ( $Finalizer\ \ Rule$ )：对象的初始化先行发生于其 $finalize(\ )$ 方法的开始；</li>
<li><strong>传递性</strong> ( $Transitivity$ )：如果操作 $A$ 先行发生于操作 $B$ ，操作 $B$ 先行发生于操作 $C$ ，那么操作 $A$ 先行发生于操作 $C$ 。</li>
</ul>
<p>        对于没有出现在上述列表里的操作关系，或者不能由上述列表关系推导出来的操作关系，虚拟机可以随意对它们进行重排。</p>
<h2 id="2-线程">2. 线程</h2>
<h3 id="21-线程实现">2.1 线程实现</h3>
<p>        虽然并发并不一定依赖于线程，但在<code>Java</code>中基本都离不开线程。线程允许在共享进程资源的同时又可以分离资源分配和执行调度，是<code>Java</code>里面进行处理器资源调度的最基本单位。</p>
<h4 id="211-内核线程实现">2.1.1 内核线程实现</h4>
<p>        内核线程 ( $Kernel-Level\ \ Thread$ ，$KLT$ ) 就是直接由操作系统内核支持的线程，即内核负责线程切换，通过操纵调度器 ( $Scheduler$ ) 对线程进行调度，并将线程处理的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，支持多线程的内核就称为多线程内核 ( $Multi-Threads\ \ Kernel$ )。程序一般不会直接使用内核线程，而是使用其高级接口轻量级进程 ( $Light\ \ Weight\ \ Process$ ，$LWP$ )，也就是我们通常讲的线程。一个系统能支持的轻量级进程的数量是有限的，取决于内核线程的数量。基于内核线程实现的线程的各种操作都是系统调用，而系统调用需要在用户态和内核态之间不断切换，从而会带来较高的代价。内核线程实现也称为 $1:1$ 实现。</p>
<h4 id="212-用户线程实现">2.1.2 用户线程实现</h4>
<p>        广义上来讲，一个线程只要不是内核线程，都可以称为用户线程 ( $User\ \ Thread$ ，$UT$ )。而狭义上的用户线程指的是完全建立在用户空间的线程库上，从而系统内核无法感知到的线程。用户线程的建立、调度和销毁完全可以在用户态下完成，而且如果建立得当，所有操作都可以在用户态下完成，从而拥有更高的效率。但是反过来，缺少了系统内核的支持，线程的创建、销毁、切换和调度就交给了用户，从而带来了一些更加复杂的问题。用户线程实现也称为 $1:N$ 实现。</p>
<h4 id="213-混合实现">2.1.3 混合实现</h4>
<p>        混合实现指的是同时使用内核线程和用户线程的方式，也称为 $N:M$ 实现。在这种方式下，用户线程还是建立在用户空间中，而 $LWP$ 充当了用户线程和内核线程之间的桥梁，一个 $LWP$ 可以对应多个用户线程。这样可以使用内核提供的线程调度功能和处理器映射功能，用户线程的系统调用也要通过 $LWP$ 完成，降低了阻塞风险。</p>
<h4 id="214-java实现">2.1.4 <code>Java</code>实现</h4>
<p>        从<code>JDK 1.3</code>起，主流<code>JVM</code>的线程模型普遍替换为基于操作系统原生线程模型的方式实现，即 $1:1$ 线程模型。<code>HotSpot</code>虚拟机中，每个<code>Java</code>线程都直接映射到一个操作系统的原生线程上，中间没有额外的间接结构，即把线程调度完全交给操作系统。</p>
<h3 id="22-线程调度">2.2 线程调度</h3>
<p>        线程调度主要有两种方式：协同式 ( $Cooperative\ \ Threads-Scheduling$ ) 和抢占式 ( $Preemptive\ \ Threads-Scheduling$ )。在协同式线程调度下，线程的执行时间由线程本身控制，线程在执行完成后会通知另一个线程；在抢占式线程调度下，线程的执行时间和切换由系统决定。虽然<code>Java</code>的线程调度由系统完成，但是可以通过设置线程优先级的方式，建议系统优先执行某些线程。</p>
<h3 id="23-状态转换">2.3 状态转换</h3>
<p>        线程具有 $6$ 种状态：新建、运行、无限期等待、限期等待、阻塞和结束。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Jan 12 21:13</span> <a href="/post/jvm9%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
        if (tocFlag) tocInit();
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>