<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.82.1" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/leetcode%E9%A2%98%E8%A7%A37%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/">Leetcode题解（7）：股票问题</a>
        
        
        <p>LeetCode股票问题合集</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Apr 24 19:11
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Algorithm
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/stampedlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">StampedLock源码解读</a>
        
        
        <p>StampedLock源码解读</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 30 14:05
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/leetcode%E9%A2%98%E8%A7%A36%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/">Leetcode题解（6）：用Rand7实现Rand10</a>
        
        
        <p>LeetCode用Rand7()实现Rand10()题目解法</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 26 20:08
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Algorithm
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/">Redis底层数据结构实现</a>
        
        
        <p>Redis常见的数据结构的底层实现方式</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 25 23:02
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Other
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/reentranlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">ReentranLock源码解读</a>
        
        
        <p>ReentrantLock源码解读</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 20 22:27
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/leetcode%E9%A2%98%E8%A7%A37%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/">Leetcode题解（7）：股票问题</a></h1>
            </center>
            <div class="post-content">
                <h2 id="i">I</h2>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">LeetCode121.买卖股票的最佳时机</a></p>
<p>        题目很简单，所以直接写了。思路就是遍历数组，维护一个最小值，以及一个最大差值。在遍历过程中不断计算差值，如果当前值比最小值小则更新最小值，如果当前差值比最大差值大则更新差值。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">min</span><span class="p">,</span> <span class="nx">res</span> <span class="o">:=</span> <span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">prices</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="nx">min</span> <span class="p">{</span>
            <span class="nx">min</span> <span class="p">=</span> <span class="nx">v</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">res</span> <span class="p">&lt;</span> <span class="nx">v</span> <span class="o">-</span> <span class="nx">min</span> <span class="p">{</span>
            <span class="nx">res</span> <span class="p">=</span> <span class="nx">v</span> <span class="o">-</span> <span class="nx">min</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></div><h2 id="ii">II</h2>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode122.买卖股票的最佳时机II</a></p>
<p>        与上一题不同的是这次可以多次购买，但是同样很简单，只要差值是正数就可以直接加在结果上。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">min</span><span class="p">,</span> <span class="nx">res</span> <span class="o">:=</span> <span class="nx">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">prices</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="nx">min</span> <span class="p">{</span>
            <span class="nx">min</span> <span class="p">=</span> <span class="nx">v</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">res</span> <span class="o">+=</span> <span class="nx">v</span><span class="o">-</span><span class="nx">min</span>
            <span class="nx">min</span> <span class="p">=</span> <span class="nx">v</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></div><p>        我们可以把第二题看成维护两个状态，买入 $buy$ 和卖出 $sell$ ，从而第二题可以这样实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">buy</span><span class="p">,</span> <span class="nx">sell</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">prices</span> <span class="p">{</span>
        <span class="nx">buy</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">buy</span><span class="p">,</span> <span class="nx">sell</span><span class="o">-</span><span class="nx">v</span><span class="p">)</span>
        <span class="nx">sell</span> <span class="p">=</span> <span class="nx">buy</span> <span class="o">+</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sell</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></div><p>        $buy$ 表示买入股票，更新规则可以这样理解：</p>
<ul>
<li>如果当前买入的股票比现在的股票便宜，也即 $buy &gt; sell-v$ ，则不更新</li>
<li>如果当前买入的股票比现在的股票贵，也即 $buy &lt; sell-v$ ，则更新</li>
</ul>
<p>        而 $sell$ 表示卖出股票，可以发现我们只是简单的为其赋值 $buy+v$ 。如果不在 $buy$ 更新后再更新，就代表着没有考虑今天的股票价格，如果今天的股票价格要小于上次买入的价格，那么就会带来亏损，从而达不到最大的收益。当然，第二题也可以采用下面这种更新方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">buy</span><span class="p">,</span> <span class="nx">sell</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">buy</span><span class="p">,</span> <span class="nx">sell</span><span class="o">-</span><span class="nx">v</span><span class="p">),</span> <span class="nf">max</span><span class="p">(</span><span class="nx">sell</span><span class="p">,</span> <span class="nx">buy</span><span class="o">+</span><span class="nx">v</span><span class="p">)</span>
</code></pre></div><p>        采用上面这种更新方式，当发现在当前卖出之前买入的股票会导致亏损，也就是 $sell &gt; buy+v$ 时，就选择不更新。</p>
<h3 id="iii">III</h3>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">LeetCode123.买卖股票的最佳时机III</a></p>
<p>        难度突然骤升，但是还是一样的解法。遍历数组，维护四个变量：第一次买入、第一次卖出、第二次买入和第二次卖出，在遍历的过程中尝试将每个数分别作为第一次买入、第一次卖出、第二次买入和第二次卖出的结果，然后取最大值。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">buy1</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span>
	<span class="kd">var</span> <span class="nx">buy2</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span>
	<span class="kd">var</span> <span class="nx">sell1</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="kd">var</span> <span class="nx">sell2</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">prices</span> <span class="p">{</span>
		<span class="nx">buy1</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">buy1</span><span class="p">,</span> <span class="o">-</span><span class="nx">v</span><span class="p">)</span>
		<span class="nx">sell1</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">sell1</span><span class="p">,</span> <span class="nx">buy1</span><span class="o">+</span><span class="nx">v</span><span class="p">)</span>
		<span class="nx">buy2</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">buy2</span><span class="p">,</span> <span class="nx">sell1</span><span class="o">-</span><span class="nx">v</span><span class="p">)</span>
		<span class="nx">sell2</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">sell2</span><span class="p">,</span> <span class="nx">buy2</span><span class="o">+</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">sell2</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></div><h2 id="iv">IV</h2>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">LeetCode188.买卖股票的最佳时机IV</a></p>
<p>        其实跟上面一道题一样，只是这次可以多次交易而已，还有注意下对 $0$ 值的处理就行了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="nx">k</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="nx">buy</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
    <span class="nx">sell</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">buy</span> <span class="p">{</span>
        <span class="nx">buy</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">prices</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">buy</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">buy</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">buy</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="o">-</span><span class="nx">v</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">buy</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">buy</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">sell</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="nx">v</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">sell</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">sell</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">buy</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="nx">v</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sell</span><span class="p">[</span><span class="nx">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></div><h2 id="v">V</h2>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">LeetCode309.最佳买卖股票时机含冷冻期</a></p>
<p>        而这道题其实就是在第二题的基础上多加了个冷冻期的状态，我们可以把之前的 $sell$ 拆为两个状态，从而实现方式为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">buy</span><span class="p">,</span> <span class="nx">sell1</span><span class="p">,</span> <span class="nx">sell2</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">prices</span> <span class="p">{</span>
		<span class="nx">buy</span><span class="p">,</span> <span class="nx">sell1</span><span class="p">,</span> <span class="nx">sell2</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">buy</span><span class="p">,</span> <span class="nx">sell2</span><span class="o">-</span><span class="nx">v</span><span class="p">),</span> <span class="nx">buy</span><span class="o">+</span><span class="nx">v</span><span class="p">,</span> <span class="nf">max</span><span class="p">(</span><span class="nx">sell1</span><span class="p">,</span> <span class="nx">sell2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="nx">sell1</span><span class="p">,</span> <span class="nx">sell2</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></div><p>        比较疑惑的一点就是为什么第二题的 $sell$ 要在 $buy$ 更新后才更新而这一题却不用，而这个问题的关键在于新增的变量 $sell2$ 。 这一道题我们采用了三个变量，其中 $buy$ 依旧是买入的意思，而 $sell1$ 表示卖出当前持有的股票并进入冷冻期，$sell2$ 表示冷冻期结束。$sell2$ 采用的更新方式是与 $sell1$ 进行比较，如果 $sell1$ 产生了亏损，则不会出售。<br>
        当然也可以采用下面的更新方式，依旧是正确的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">buy</span><span class="p">,</span> <span class="nx">sell1</span><span class="p">,</span> <span class="nx">sell2</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">prices</span> <span class="p">{</span>
		<span class="nx">buy</span><span class="p">,</span> <span class="nx">sell1</span><span class="p">,</span> <span class="nx">sell2</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">buy</span><span class="p">,</span> <span class="nx">sell2</span><span class="o">-</span><span class="nx">v</span><span class="p">),</span> <span class="nf">max</span><span class="p">(</span><span class="nx">sell1</span><span class="p">,</span> <span class="nx">buy</span><span class="o">+</span><span class="nx">v</span><span class="p">),</span> <span class="nx">sell1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">sell1</span>
<span class="p">}</span>
</code></pre></div><p>        可能这种方式比上面的更好理解，但是本质还是一样的。</p>
<h2 id="vi">VI</h2>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">LeetCode714.买卖股票的最佳时机含手续费</a></p>
<p>        有了之前题目作准备，这道题肯定已经没啥难度了，直接秒了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="nx">prices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">fee</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">buy</span><span class="p">,</span> <span class="nx">sell</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MinInt32</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">prices</span> <span class="p">{</span>
        <span class="nx">buy</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">buy</span><span class="p">,</span> <span class="nx">sell</span><span class="o">-</span><span class="nx">v</span><span class="o">-</span><span class="nx">fee</span><span class="p">)</span>
        <span class="nx">sell</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">sell</span><span class="p">,</span> <span class="nx">buy</span><span class="o">+</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sell</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2021 Apr 24 19:11</span> <a href="/post/leetcode%E9%A2%98%E8%A7%A37%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/stampedlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">StampedLock源码解读</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-字段">1. 字段</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 处理器数量
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NCPU</span> <span class="o">=</span> <span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">();</span>
<span class="c1">// 入队前的最大重试次数
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SPINS</span> <span class="o">=</span> <span class="o">(</span><span class="n">NCPU</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">?</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">6</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span>
<span class="c1">// 作为首节点阻塞前的最大重试次数
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">HEAD_SPINS</span> <span class="o">=</span> <span class="o">(</span><span class="n">NCPU</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">?</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">10</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span>
<span class="c1">// 再次阻塞前的最大重试次数
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_HEAD_SPINS</span> <span class="o">=</span> <span class="o">(</span><span class="n">NCPU</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">?</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">16</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span>
<span class="c1">// 等待自旋上溢的闲置时期，必须为2的幂次-1
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">OVERFLOW_YIELD_RATE</span> <span class="o">=</span> <span class="n">7</span><span class="o">;</span>
<span class="c1">// 在上溢前记录读锁的位数，占据低位
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">LG_READERS</span> <span class="o">=</span> <span class="n">7</span><span class="o">;</span>
<span class="c1">// 每次读增加的单位
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">RUNIT</span> <span class="o">=</span> <span class="n">1L</span><span class="o">;</span>
<span class="c1">// 写锁所在位数
</span><span class="c1">// 1000 0000
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">WBIT</span> <span class="o">=</span> <span class="n">1L</span> <span class="o">&lt;&lt;</span> <span class="n">LG_READERS</span><span class="o">;</span>
<span class="c1">// 读锁所在位数
</span><span class="c1">// 0111 1111
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">RBITS</span> <span class="o">=</span> <span class="n">WBIT</span> <span class="o">-</span> <span class="n">1L</span><span class="o">;</span>
<span class="c1">// 读锁上限
</span><span class="c1">// 0111 1110
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">RFULL</span> <span class="o">=</span> <span class="n">RBITS</span> <span class="o">-</span> <span class="n">1L</span><span class="o">;</span>
<span class="c1">// 掩码
</span><span class="c1">// 1111 1111
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">ABTIS</span> <span class="o">=</span> <span class="n">RBITS</span> <span class="o">|</span> <span class="n">WBITS</span><span class="o">;</span>
<span class="c1">// 读锁反数
</span><span class="c1">// 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1000 0000
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">SBITS</span> <span class="o">=</span> <span class="o">~</span><span class="n">RBITS</span><span class="o">;</span>
<span class="c1">// 锁状态初始值
</span><span class="c1">// 0001 0000 0000
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">ORIGIN</span> <span class="o">=</span> <span class="n">WBIT</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">;</span>
<span class="c1">// 取消获取锁时的特殊状态，表示中断
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">INTERRUPTED</span> <span class="o">=</span> <span class="n">1L</span><span class="o">;</span>
<span class="c1">// 等待状态
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">WAITING</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
<span class="c1">// 取消状态
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CANCELLED</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
<span class="c1">// 节点读模式
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">RMODE</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="c1">// 节点写模式
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">WMODE</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
<span class="c1">// CLH队列首节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">WNode</span> <span class="n">whead</span><span class="o">;</span>
<span class="c1">// CLH队列尾节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">WNode</span> <span class="n">wtail</span><span class="o">;</span>
<span class="c1">// 视图
</span><span class="c1"></span><span class="kd">transient</span> <span class="n">ReadLockView</span> <span class="n">readLockView</span><span class="o">;</span>
<span class="kd">transient</span> <span class="n">WriteLockView</span> <span class="n">writeLockView</span><span class="o">;</span>
<span class="kd">transient</span> <span class="n">ReadWriteLockView</span> <span class="n">readWriteLockView</span><span class="o">;</span>
<span class="c1">// 锁队列状态
</span><span class="c1">// 高24位为版本号，每次获取和释放写锁都会+1，25位为写锁标志，剩余7位为读锁计数，记录当前读锁数量
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="kt">long</span> <span class="n">state</span><span class="o">;</span>
<span class="c1">// 额外的读锁计数
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="kt">int</span> <span class="n">readerOverflow</span><span class="o">;</span>
</code></pre></div><h2 id="2-内部类">2. 内部类</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 节点在队列中排列，连续的写节点会在队列中，连续的读节点会在cowait中
</span><span class="c1">// 等待节点
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">WNode</span> <span class="o">{</span>
    <span class="kd">volatile</span> <span class="n">WNode</span> <span class="n">prev</span><span class="o">;</span>
    <span class="kd">volatile</span> <span class="n">WNode</span> <span class="n">next</span><span class="o">;</span>
    <span class="kd">volatile</span> <span class="n">WNode</span> <span class="n">cowait</span><span class="o">;</span> <span class="c1">// 读线程所在链表
</span><span class="c1"></span>    <span class="kd">volatile</span> <span class="n">Thread</span> <span class="n">thread</span><span class="o">;</span> <span class="c1">// 当前节点阻塞的线程
</span><span class="c1"></span>    <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">status</span><span class="o">;</span> <span class="c1">// 0、WAITING或者CANCELLED
</span><span class="c1"></span>    <span class="kd">final</span> <span class="kt">int</span> <span class="n">mode</span><span class="o">;</span> <span class="c1">// RMODE或者WMODE
</span><span class="c1"></span>    <span class="n">WNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="n">WNode</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="3-构造函数">3. 构造函数</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">StampedLock</span><span class="o">()</span> <span class="o">{</span> <span class="n">state</span> <span class="o">=</span> <span class="n">ORIGIN</span><span class="o">;</span> <span class="o">}</span>
</code></pre></div><h2 id="4-写锁">4. 写锁</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 尝试获取独占写锁，阻塞直到成功获取
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">long</span> <span class="nf">writeLock</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">s</span><span class="o">,</span> <span class="n">next</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">((((</span><span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">ABITS</span><span class="o">)</span> <span class="o">==</span> <span class="n">0L</span> <span class="o">&amp;&amp;</span> <span class="c1">// 写锁未被获取
</span><span class="c1"></span>             <span class="c1">// 尝试更新状态，增加一个写计数
</span><span class="c1"></span>             <span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">STATE</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">next</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">WBIT</span><span class="o">))</span> <span class="o">?</span>
             <span class="n">next</span> <span class="o">:</span> <span class="n">acquireWrite</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">0L</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">long</span> <span class="nf">acquireWrite</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">interruptible</span><span class="o">,</span> <span class="kt">long</span> <span class="n">deadline</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">WNode</span> <span class="n">node</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">p</span><span class="o">;</span>
    <span class="c1">// 第一次自旋
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">spins</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;;)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">m</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">ns</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">ABITS</span><span class="o">)</span> <span class="o">==</span> <span class="n">0L</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 再次尝试获取写锁
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">STATE</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">ns</span> <span class="o">+</span> <span class="n">WBIT</span><span class="o">))</span>
                <span class="k">return</span> <span class="n">ns</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">spins</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
            <span class="c1">// 存在独占写锁并且队列为空，自旋
</span><span class="c1"></span>            <span class="n">spins</span> <span class="o">=</span> <span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">WBITS</span> <span class="o">&amp;&amp;</span> <span class="n">wtail</span> <span class="o">==</span> <span class="n">whead</span><span class="o">)</span> <span class="o">?</span> <span class="n">SPINS</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">spins</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 随机减少一次自旋次数
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">LockSupport</span><span class="o">.</span><span class="na">nextSecondarySeed</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span>
                <span class="o">--</span><span class="n">spins</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">wtail</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 队列为空
</span><span class="c1"></span>            <span class="c1">// 创建哑节点作为首节点
</span><span class="c1"></span>            <span class="n">WNode</span> <span class="n">hd</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WNode</span><span class="o">(</span><span class="n">WMODE</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">WHEAD</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hd</span><span class="o">))</span>
                <span class="n">wtail</span> <span class="o">=</span> <span class="n">hd</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 队列非空，创建节点
</span><span class="c1"></span>            <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WNode</span><span class="o">(</span><span class="n">WMODE</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">!=</span> <span class="n">p</span><span class="o">)</span> <span class="c1">// 尾节点改变，更新尾节点
</span><span class="c1"></span>            <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">WTAIL</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 尝试将当前节点设为尾节点，退出循环
</span><span class="c1"></span>            <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 第二次自旋
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">spins</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;;)</span> <span class="o">{</span>
        <span class="n">WNode</span> <span class="n">h</span><span class="o">,</span> <span class="n">np</span><span class="o">,</span> <span class="n">pp</span><span class="o">;</span> <span class="kt">int</span> <span class="n">ps</span><span class="o">;</span>
        <span class="c1">// 前驱节点为首节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">((</span><span class="n">h</span> <span class="o">=</span> <span class="n">whead</span><span class="o">)</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">spins</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 设置自旋次数
</span><span class="c1"></span>                <span class="n">spins</span> <span class="o">=</span> <span class="n">HEAD_SPINS</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">spins</span> <span class="o">&lt;</span> <span class="n">MAX_HEAD_SPINS</span><span class="o">)</span> <span class="c1">// 增加自旋次数
</span><span class="c1"></span>                <span class="n">spins</span> <span class="o">&lt;&lt;=</span> <span class="n">1</span><span class="o">;</span>
            <span class="c1">// 第三次自旋
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">spins</span><span class="o">;;)</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">s</span><span class="o">,</span> <span class="n">ns</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(((</span><span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">ABITS</span><span class="o">)</span> <span class="o">==</span> <span class="n">0L</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 尝试获取写锁
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">STATE</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span>
                                             <span class="n">ns</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">WBIT</span><span class="o">))</span> <span class="o">{</span>
                        <span class="c1">// 获取成功，设置当前节点为首节点
</span><span class="c1"></span>                        <span class="n">whead</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="k">return</span> <span class="n">ns</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">LockSupport</span><span class="o">.</span><span class="na">nextSecondarySeed</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
                           <span class="o">--</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 随机减少自旋次数
</span><span class="c1"></span>                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 前驱节点非空
</span><span class="c1"></span>            <span class="n">WNode</span> <span class="n">c</span><span class="o">;</span> <span class="n">Thread</span> <span class="n">w</span><span class="o">;</span>
            <span class="c1">// 首节点相连的读线程链表非空
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">cowait</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 唤醒读线程节点
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">WCOWAIT</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="na">cowait</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">w</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">thread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">U</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 首节点未改变
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">whead</span> <span class="o">==</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 前驱节点改变，更新前驱节点
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">((</span><span class="n">np</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="o">!=</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">np</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">).</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">ps</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">status</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
                <span class="c1">// 设置前驱节点为WAITING状态
</span><span class="c1"></span>                <span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">WSTATUS</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">WAITING</span><span class="o">);</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ps</span> <span class="o">==</span> <span class="n">CANCELLED</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 前驱节点被取消
</span><span class="c1"></span>                <span class="c1">// 删除前驱节点
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">((</span><span class="n">pp</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pp</span><span class="o">;</span>
                    <span class="n">pp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">time</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">deadline</span> <span class="o">=</span> <span class="n">0L</span><span class="o">)</span> <span class="c1">// 未设置超时时间
</span><span class="c1"></span>                    <span class="n">time</span> <span class="o">=</span> <span class="n">0L</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">time</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">())</span> <span class="o">&lt;=</span> <span class="n">0L</span><span class="o">)</span>
                    <span class="c1">// 超时，取消当前节点
</span><span class="c1"></span>                    <span class="k">return</span> <span class="n">cancelWaiter</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">node</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
                <span class="n">Thread</span> <span class="n">wt</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
                <span class="c1">// 记录节点阻塞的锁
</span><span class="c1"></span>                <span class="n">U</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="n">wt</span><span class="o">,</span> <span class="n">PARKLOCKER</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
                <span class="c1">// 设置当前节点线程为当前线程
</span><span class="c1"></span>                <span class="n">node</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">wt</span><span class="o">;</span>
                <span class="c1">// 前驱节点被阻塞、前驱节点非首节点或者写锁已经被获取、首节点未改变、前驱节点未改变
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">status</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">h</span> <span class="o">||</span> <span class="o">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">ABITS</span><span class="o">)</span> <span class="o">!=</span> <span class="n">0L</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                    <span class="n">whead</span> <span class="o">==</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span>
                    <span class="c1">// 阻塞当前线程
</span><span class="c1"></span>                    <span class="n">U</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">time</span><span class="o">);</span>
                <span class="c1">// 当前节点被唤醒，清除线程
</span><span class="c1"></span>                <span class="n">node</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">U</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="n">wt</span><span class="o">,</span> <span class="n">PARKLOCKER</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                <span class="c1">// 是否检查中断，如果中断，取消当前节点
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">interruptible</span> <span class="o">&amp;&amp;</span> <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
                    <span class="k">return</span> <span class="n">cancelWaiter</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">node</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>       总结：</p>
<ol>
<li>判断写锁是否被获取，没有则尝试获取；</li>
<li>前驱节点为首节点，自旋，自旋次数为0则入队</li>
<li>前驱节点为首节点，自旋获取锁</li>
<li>否则尝试唤醒头节点中阻塞的读线程</li>
<li>没有获取写锁，阻塞当前线程</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlockWrite</span><span class="o">(</span><span class="kt">long</span> <span class="n">stamp</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">WNode</span> <span class="n">h</span><span class="o">;</span>
    <span class="c1">// 检查版本号
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">stamp</span> <span class="o">||</span> <span class="o">(</span><span class="n">stamp</span> <span class="o">&amp;</span> <span class="n">WBIT</span><span class="o">)</span> <span class="o">==</span> <span class="n">0L</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
    <span class="c1">// 更新版本号
</span><span class="c1"></span>    <span class="n">state</span> <span class="o">=</span> <span class="o">(</span><span class="n">stamp</span> <span class="o">+=</span> <span class="n">WBIT</span><span class="o">)</span> <span class="o">==</span> <span class="n">0L</span> <span class="o">?</span> <span class="n">ORIGIN</span> <span class="o">:</span> <span class="n">stamp</span><span class="o">;</span>
    <span class="c1">// 队列非空，状态非0，唤醒下一个节点
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">h</span> <span class="o">=</span> <span class="n">whead</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="na">status</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
        <span class="n">release</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">release</span><span class="o">(</span><span class="n">WNode</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">WNode</span> <span class="n">q</span><span class="o">;</span> <span class="n">Thread</span> <span class="n">w</span><span class="o">;</span>
        <span class="c1">// 状态设为0
</span><span class="c1"></span>        <span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">WSTATUS</span><span class="o">,</span> <span class="n">WAITING</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
        <span class="c1">// 首节点的下一个节点为空或者被取消
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">q</span><span class="o">.</span><span class="na">status</span> <span class="o">==</span> <span class="n">CANCELLED</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 尾遍历查找阻塞节点
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="n">WNode</span> <span class="n">t</span> <span class="o">=</span> <span class="n">wtail</span><span class="o">;</span> <span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">h</span><span class="o">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">status</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 唤醒节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">q</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">w</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">thread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">U</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="5-读锁">5. 读锁</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">long</span> <span class="nf">readLock</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="o">,</span> <span class="n">next</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">((</span><span class="n">whead</span> <span class="o">==</span> <span class="n">wtail</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">ABITS</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">RFULL</span> <span class="o">&amp;&amp;</span> <span class="c1">// 没有写锁并且读锁未达上限
</span><span class="c1"></span>             <span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">STATE</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">next</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">RUNIT</span><span class="o">))</span> <span class="o">?</span> <span class="c1">// 增加读锁计数
</span><span class="c1"></span>             <span class="n">next</span> <span class="o">:</span> <span class="n">acquireRead</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">0L</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">long</span> <span class="nf">acquireRead</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">interruptible</span><span class="o">,</span> <span class="kt">long</span> <span class="n">deadline</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">WNode</span> <span class="n">node</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">p</span><span class="o">;</span>
    <span class="c1">// 第一次自旋
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">spins</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;;)</span> <span class="o">{</span>
        <span class="n">WNode</span> <span class="n">h</span><span class="o">;</span>
        <span class="c1">// 队列为空
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">((</span><span class="n">h</span> <span class="o">=</span> <span class="n">whead</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">wtail</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 第二次自旋
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">m</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">ns</span><span class="o">;;)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">ABITS</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">RFULL</span> <span class="o">?</span> <span class="c1">// 读锁未达上限
</span><span class="c1"></span>                    <span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">STATE</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">RUNIT</span><span class="o">)</span> <span class="o">:</span> <span class="c1">// 增加读锁计数
</span><span class="c1"></span>                    <span class="o">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">WBIT</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">ns</span> <span class="o">=</span> <span class="n">tryIncReaderOverflow</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">!=</span> <span class="n">0L</span><span class="o">))</span> <span class="c1">// 读锁达上限，溢出处理
</span><span class="c1"></span>                    <span class="k">return</span> <span class="n">ns</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">WBIT</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 写锁被获取
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">spins</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 随机减少自旋次数
</span><span class="c1"></span>                        <span class="k">if</span> <span class="o">(</span><span class="n">LockSupport</span><span class="o">.</span><span class="na">nextSecondarySeed</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span>
                            <span class="o">--</span><span class="n">spins</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">spins</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">WNode</span> <span class="n">nh</span> <span class="o">=</span> <span class="n">whead</span><span class="o">,</span> <span class="n">np</span> <span class="o">=</span> <span class="n">wtail</span><span class="o">;</span>
                            <span class="c1">// 头尾节点未改变或者队列非空
</span><span class="c1"></span>                            <span class="k">if</span> <span class="o">((</span><span class="n">nh</span> <span class="o">==</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">np</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">nh</span><span class="o">)</span> <span class="o">!=</span> <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">))</span>
                                <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="c1">// 重置自旋次数
</span><span class="c1"></span>                        <span class="n">spins</span> <span class="o">=</span> <span class="n">SPINS</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 尾节点为空，初始化
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">WNode</span> <span class="n">hd</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WNode</span><span class="o">(</span><span class="n">WMODE</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">WHEAD</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hd</span><span class="o">))</span>
                <span class="n">wtail</span> <span class="o">=</span> <span class="n">hd</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 当前节点为空，初始化
</span><span class="c1"></span>            <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WNode</span><span class="o">(</span><span class="n">RMODE</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">mode</span> <span class="o">!=</span> <span class="n">RMODE</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 队列为空或者尾节点不是读模式
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">!=</span> <span class="n">p</span><span class="o">)</span> <span class="c1">// 入队
</span><span class="c1"></span>                <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">WTAIL</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 更新尾节点，进入第五次自旋
</span><span class="c1"></span>                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">WCOWAIT</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">cowait</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">cowait</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="c1">// 尾节点为读模式，设置当前节点cowait字段
</span><span class="c1"></span>            <span class="n">node</span><span class="o">.</span><span class="na">cowait</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 第三次自旋
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                <span class="n">WNode</span> <span class="n">pp</span><span class="o">,</span> <span class="n">c</span><span class="o">;</span> <span class="n">Thread</span> <span class="n">w</span><span class="o">;</span>
                <span class="c1">// 头节点非空、头节点cowait非空、唤醒cowait节点中的线程
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">((</span><span class="n">h</span> <span class="o">=</span> <span class="n">whead</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">cowait</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                    <span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">WCOWAIT</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="na">cowait</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">w</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">thread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">U</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                <span class="c1">// 前驱节点的前驱节点为头节点或者前驱节点为头节点
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="o">(</span><span class="n">pp</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="o">||</span> <span class="n">h</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">pp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">long</span> <span class="n">m</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">ns</span><span class="o">;</span>
                    <span class="c1">// 第四次自旋
</span><span class="c1"></span>                    <span class="k">do</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">ABITS</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">RFULL</span> <span class="o">?</span> <span class="c1">// 读锁未达上限
</span><span class="c1"></span>                            <span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">STATE</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="c1">// 增加读锁计数
</span><span class="c1"></span>                                                 <span class="n">ns</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">RUNIT</span><span class="o">)</span> <span class="o">:</span>
                            <span class="o">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">WBIT</span> <span class="o">&amp;&amp;</span> <span class="c1">// 写锁未被获取
</span><span class="c1"></span>                             <span class="o">(</span><span class="n">ns</span> <span class="o">=</span> <span class="n">tryIncReaderOverflow</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">!=</span> <span class="n">0L</span><span class="o">))</span> <span class="c1">// 溢出处理
</span><span class="c1"></span>                    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">WBIT</span><span class="o">);</span> <span class="c1">// 写锁未被获取
</span><span class="c1"></span>                <span class="o">}</span>
                <span class="c1">// 头节点和前置节点未被改变
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">whead</span> <span class="o">==</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">prev</span> <span class="o">==</span> <span class="n">pp</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">long</span> <span class="n">time</span><span class="o">;</span>
                    <span class="c1">// 前前驱节点为空或者前驱节点为头节点或者前驱节点被取消
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">h</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">status</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// 跳出循环，进入第一次自旋
</span><span class="c1"></span>                        <span class="n">node</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="c1">// 超时处理，没有设置则不处理
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">deadline</span> <span class="o">==</span> <span class="n">0L</span><span class="o">)</span>
                        <span class="n">time</span> <span class="o">=</span> <span class="n">0L</span><span class="o">;</span>
                    <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">time</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">())</span> <span class="o">&lt;=</span> <span class="n">0L</span><span class="o">)</span>
                        <span class="k">return</span> <span class="n">cancelWaiter</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
                    <span class="n">Thread</span> <span class="n">wt</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
                    <span class="n">U</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="n">wt</span><span class="o">,</span> <span class="n">PARKLOCKER</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
                    <span class="n">node</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">wt</span><span class="o">;</span>
                    <span class="c1">// 前前驱节点非头节点、写锁被获取并且头节点尾节点未改变
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">((</span><span class="n">h</span> <span class="o">!=</span> <span class="n">pp</span> <span class="o">||</span> <span class="o">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">ABITS</span><span class="o">)</span> <span class="o">==</span> <span class="n">WBIT</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                         <span class="n">whead</span> <span class="o">==</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">prev</span> <span class="o">==</span> <span class="n">pp</span><span class="o">)</span>
                        <span class="c1">// 阻塞当前线程
</span><span class="c1"></span>                        <span class="n">U</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">time</span><span class="o">);</span>
                    <span class="n">node</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="n">U</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="n">wt</span><span class="o">,</span> <span class="n">PARKLOCKER</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                    <span class="c1">// 如果设置中断标志，判断是否中断
</span><span class="c1"></span>                    <span class="k">if</span> <span class="o">(</span><span class="n">interruptible</span> <span class="o">&amp;&amp;</span> <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
                        <span class="k">return</span> <span class="n">cancelWaiter</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 第五次自旋
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">spins</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;;)</span> <span class="o">{</span>
        <span class="n">WNode</span> <span class="n">h</span><span class="o">,</span> <span class="n">np</span><span class="o">,</span> <span class="n">pp</span><span class="o">;</span> <span class="kt">int</span> <span class="n">ps</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">h</span> <span class="o">=</span> <span class="n">whead</span><span class="o">)</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 队列为空
</span><span class="c1"></span>            <span class="c1">// 设置自旋次数
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">spins</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
                <span class="n">spins</span> <span class="o">=</span> <span class="n">HEAD_SPINS</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">spins</span> <span class="o">&lt;</span> <span class="n">MAX_HEAD_SPINS</span><span class="o">)</span>
                <span class="n">spins</span> <span class="o">&lt;&lt;=</span> <span class="n">1</span><span class="o">;</span>
            <span class="c1">// 第六次自旋
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">spins</span><span class="o">;;)</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">m</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">ns</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">ABTIS</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">RFULL</span> <span class="o">?</span> <span class="c1">// 读锁未达上限
</span><span class="c1"></span>                    <span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">STATE</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">RUNIT</span><span class="o">)</span> <span class="o">:</span> <span class="c1">// 增加读锁计数
</span><span class="c1"></span>                    <span class="o">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">WBIT</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">ns</span> <span class="o">=</span> <span class="n">tryIncReaderOverflow</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">!=</span> <span class="n">0L</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 写锁未被获取，溢出处理
</span><span class="c1"></span>                    <span class="n">WNode</span> <span class="n">c</span><span class="o">;</span> <span class="n">Thread</span> <span class="n">w</span><span class="o">;</span>
                    <span class="n">whead</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                    <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="c1">// 唤醒等待线程
</span><span class="c1"></span>                    <span class="k">while</span> <span class="o">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">cowait</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">WCOWAIT</span><span class="o">,</span>
                                                   <span class="n">c</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="na">cowait</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                            <span class="o">(</span><span class="n">w</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">thread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                            <span class="n">U</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="k">return</span> <span class="n">ns</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">WBIT</span> <span class="o">&amp;&amp;</span> <span class="c1">// 写锁被获取
</span><span class="c1"></span>                           <span class="n">LockSupport</span><span class="o">.</span><span class="na">nextSecondarySeed</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 自旋次数达到上限
</span><span class="c1"></span>                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 头节点非空
</span><span class="c1"></span>            <span class="n">WNode</span> <span class="n">c</span><span class="o">;</span> <span class="n">Thread</span> <span class="n">w</span><span class="o">;</span>
            <span class="c1">// 唤醒等待线程
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">cowait</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">WCOWAIT</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="na">cowait</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">w</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">thread</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">U</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">whead</span> <span class="o">==</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 头节点未改变
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">((</span><span class="n">np</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="o">!=</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 前驱节点改变
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">np</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 更新前驱节点
</span><span class="c1"></span>                    <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">).</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">ps</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">status</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 前驱节点状态为0
</span><span class="c1"></span>                <span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">WSTATUS</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">WAITING</span><span class="o">);</span> <span class="c1">// 设置阻塞状态
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ps</span> <span class="o">==</span> <span class="n">CANCELLED</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 前驱节点被取消
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">((</span><span class="n">pp</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 移除前驱节点
</span><span class="c1"></span>                    <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pp</span><span class="o">;</span>
                    <span class="n">pp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">time</span><span class="o">;</span>
                <span class="c1">// 超时处理，未设置则不处理
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">deadline</span> <span class="o">==</span> <span class="n">0L</span><span class="o">)</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">0L</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">time</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">())</span> <span class="o">&lt;=</span> <span class="n">0L</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">cancelWaiter</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">node</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
                <span class="n">Thread</span> <span class="n">wt</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
                <span class="n">U</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="n">wt</span><span class="o">,</span> <span class="n">PARKLOCKER</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
                <span class="n">node</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">wt</span><span class="o">;</span>
                <span class="c1">// 阻塞当前线程
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">status</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">h</span> <span class="o">||</span> <span class="o">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">ABITS</span><span class="o">)</span> <span class="o">==</span> <span class="n">WBIT</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                    <span class="n">whead</span> <span class="o">==</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span>
                    <span class="n">U</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">time</span><span class="o">);</span>
                <span class="n">node</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">U</span><span class="o">.</span><span class="na">putObject</span><span class="o">(</span><span class="n">wt</span><span class="o">,</span> <span class="n">PARKLOCKER</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                <span class="c1">// 中断处理
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">interruptible</span> <span class="o">&amp;&amp;</span> <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
                    <span class="k">return</span> <span class="n">cancelWaiter</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">node</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        总结：</p>
<ol>
<li>如果首尾节点相同，自旋获取锁；</li>
<li>如果首尾节点不同，入队</li>
<li>如果当前节点之前的节点为写节点，进入第五次自旋；</li>
<li>如果当前节点之前的节点为读节点，进入之前读节点的cowait中；</li>
<li>再次检测首尾节点是否相同，如果相同，自旋获取锁；</li>
<li>如果不相同，阻塞当前线程。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlockRead</span><span class="o">(</span><span class="kt">long</span> <span class="n">stamp</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">s</span><span class="o">,</span> <span class="n">m</span><span class="o">;</span> <span class="n">WNode</span> <span class="n">h</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="c1">// 检查版本号是否一致
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(((</span><span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">SBITS</span><span class="o">)</span> <span class="o">!=</span> <span class="o">(</span><span class="n">stamp</span> <span class="o">&amp;</span> <span class="n">SBITS</span><span class="o">)</span> <span class="o">||</span>
            <span class="o">(</span><span class="n">stamp</span> <span class="o">&amp;</span> <span class="n">ABITS</span><span class="o">)</span> <span class="o">==</span> <span class="n">0L</span> <span class="o">||</span> <span class="o">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">s</span> <span class="o">&amp;</span> <span class="n">ABITS</span><span class="o">)</span> <span class="o">==</span> <span class="n">0L</span> <span class="o">||</span> <span class="n">m</span> <span class="o">==</span> <span class="n">WBIT</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
        <span class="c1">// 读锁未达上限
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">RFULL</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 释放读锁，减少读锁计数
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="na">compareAndSwapLong</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">STATE</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span> <span class="o">-</span> <span class="n">RUNIT</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">RUNIT</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">whead</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="na">status</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
                    <span class="n">release</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">tryDecReaderOverflow</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">!=</span> <span class="n">0L</span><span class="o">)</span> <span class="c1">// 溢出处理
</span><span class="c1"></span>            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="6-乐观锁">6. 乐观锁</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">long</span> <span class="nf">tryOptimisticRead</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">s</span><span class="o">;</span>
    <span class="c1">// 写锁未被获取，返回高25位
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">(((</span><span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">WBIT</span><span class="o">)</span> <span class="o">==</span> <span class="n">0L</span><span class="o">)</span> <span class="o">?</span> <span class="o">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">SBITS</span><span class="o">)</span> <span class="o">:</span> <span class="n">0L</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">validate</span><span class="o">(</span><span class="kt">long</span> <span class="n">stamp</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 加入内存屏障，刷新数据
</span><span class="c1"></span>    <span class="n">U</span><span class="o">.</span><span class="na">loadFence</span><span class="o">();</span>
    <span class="c1">// 检查版本号是否一致
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">(</span><span class="n">stamp</span> <span class="o">&amp;</span> <span class="n">SBITS</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SBITS</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2021 Mar 30 14:05</span> <a href="/post/stampedlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/leetcode%E9%A2%98%E8%A7%A36%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/">Leetcode题解（6）：用Rand7实现Rand10</a></h1>
            </center>
            <div class="post-content">
                <p><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">LeetCode470</a></p>
<p>        在解决这道题之前，我们可以先查看一个反过来的情况——用 $Rand10()$ 实现 $Rand7()$ ，可以直接发现实现方式就是不断用 $Rand10()$ 生成随机数，直到生成的数字处于 $1 \sim 7$ 之间即可。也就是说，如果可以生成的数字范围要大于待生成的数字范围，可以通过不断循环直到获取落在生成范围里面的数字的方式实现。<br/>
        利用上述思想，我们可以很容易的想出这道题的解法——利用 $Rand7()$ 构造一个生成的数字范围大于 $1 \sim 10$ 的随机数生成器即可。要想构造这样的生成器，我们可以再观察下 $Rand10()$ 。如果我们想要用 $Rand10()$ 构造一个生成数字范围在 $1 \sim 99$ 之间的随机数生成器，可以使用如下算法 $(Rand10() - 1) * 10 + Rand10()$ ，也就是生成两次，一个作为十位一个作为个位。可以很容易发现这种算法生成的数字是随机均匀分布的。<br/>
        使用 $Rand10()$ 的例子生成的是 $10$ 进制二位数，利用同样的思想我们也可以生成 $7$ 进制二位数，即 $(Rand7() - 1) * 7 + Rand7()$ ，使用这种方式生成的数字也是随机均匀分布的。将其转为 $10$ 进制后，数字范围落在 $1 \sim 49$ 之间，如果直接抛弃 $11 \sim 49$ 之间的数字，那么可能需要重复调用很多次。因此我们可以只抛弃 $41 \sim 49$ 之间的数字，对剩余的数字采用取模运算，实现方式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="kd">extends</span> <span class="n">SolBase</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rand10</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>
        <span class="k">do</span> <span class="o">{</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">(</span><span class="n">rand7</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">7</span> <span class="o">+</span> <span class="n">rand7</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="n">40</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">%</span> <span class="n">10</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        上述的实现方式是抛弃了 $41 \sim 49$ 之间的数字，抛弃了 $9$ 个数字的实现方式还是有点多的。从我们之前的讲解来看，可以不局限于生成两位数，三位数、四位数也是可以的，因此我们也可以这样实现：首先生成 $7$ 进制两位数，如果不大于 $40$ ，返回，否则利用两位数再次生成 $3$ 位数、$4$ 位数。对于 $Rand7()$ ，我们只需要生成到 $7$ 进制 $4$ 位数就行了，因为 $7^3=243$ ，$7^4=1701$ ，也就是 $4$ 位数最多只需要抛弃 $1$ 个数字，而如果是 $5$ 位数，则又要抛弃 $7$ 个数字才行。<br/>
        我们也可以利用取模 $10$ 这个点来进一步简化算法。如果生成的数字在 $41 \sim 49$ 之间，没有必要直接用该数字进行计算，因为 $40$ 在取模这一步会被消掉，无论乘以哪个数字，所以我们可以将生成的数字减去 $40$ 再进行计算。减去 $40$ 后生成的数字范围在 $1 \sim 63$ 之间，同样的，如果生成了 $61 \sim 63$ 之间的数字，也可以减去 $60$ 后再计算。实现方式如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="kd">extends</span> <span class="n">SolBase</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rand10</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">(</span><span class="n">rand7</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">7</span> <span class="o">+</span> <span class="n">rand7</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="n">40</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">(</span><span class="n">num</span> <span class="o">-</span> <span class="n">40</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">7</span> <span class="o">+</span> <span class="n">rand7</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="n">60</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">(</span><span class="n">num</span> <span class="o">-</span> <span class="n">60</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">7</span> <span class="o">+</span> <span class="n">rand7</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="n">20</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">%</span> <span class="n">10</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2021 Mar 26 20:08</span> <a href="/post/leetcode%E9%A2%98%E8%A7%A36%E7%94%A8rand7%E5%AE%9E%E7%8E%B0rand10/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/">Redis底层数据结构实现</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-对象">1. 对象</h2>
<p>        <code>Redis</code>中的每个键值对都是由两个对象结构表示，定义在 $server.h$ 文件中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 对象类型
</span><span class="c1"></span><span class="cp">#define OBJ_STRING 0
</span><span class="cp">#define OBJ_LIST 1
</span><span class="cp">#define OBJ_SET 2
</span><span class="cp">#define OBJ_ZSET 3
</span><span class="cp">#define OBJ_HASH 4
</span><span class="cp">#define OBJ_MODULE 5
</span><span class="cp">#define OBJ_STREAM 6
</span><span class="cp"></span><span class="c1">// 对象编码
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_RAW 0 </span><span class="c1">// SDS
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_INT 1 </span><span class="c1">// 长整型
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_HT 2 </span><span class="c1">// 字典
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_ZIPMAP 3
</span><span class="cp">#define OBJ_ENCODING_LINKEDLIST 4
</span><span class="cp">#define OBJ_ENCODING_ZIPLIST 5 </span><span class="c1">// 压缩列表
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_INTSET 6 </span><span class="c1">// 整数集合
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_SKIPLIST 7 </span><span class="c1">// 跳表
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_EMBSTR 8 </span><span class="c1">// embstr编码的SDS
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_QUICKLIST 9
</span><span class="cp">#define OBJ_ENCODING_STREAM 10
</span><span class="cp"></span><span class="c1">// 对象结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="nl">type</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span> <span class="c1">// 类型
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">encoding</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span> <span class="c1">// 编码
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">lru</span><span class="p">:</span><span class="n">LRU_BITS</span><span class="p">;</span> <span class="c1">// 最后一次访问时间
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span> <span class="c1">// 引用计数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="c1">// 底层指针
</span><span class="c1"></span><span class="p">}</span> <span class="n">robj</span><span class="p">;</span>
</code></pre></div><h2 id="1-sds">1. <code>SDS</code></h2>
<p>        <strong>简单动态字符串</strong> ( $simple\ \ dynamic\ \ string$, $SDS$ ) 是<code>Redis</code>中字符串的数据结构，定义在 $sds.h$ 头文件中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sds</span><span class="p">;</span>

<span class="c1">// 不使用该结构，而是直接访问flag
</span><span class="c1"></span><span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr5</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr8</span> <span class="p">{</span>
    <span class="n">uint8_t</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 已使用的字节数，不包括&#39;\0&#39;
</span><span class="c1"></span>    <span class="n">uint8_t</span> <span class="n">alloc</span><span class="p">;</span> <span class="c1">// 总共分配的字节数，不包括&#39;\0&#39;
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="c1">// 类型
</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span> <span class="c1">// 字节数组，包括&#39;\0&#39;
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr16</span> <span class="p">{</span>
    <span class="n">uint16_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">uint16_t</span> <span class="n">alloc</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr32</span> <span class="p">{</span>
    <span class="n">uint32_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">uint32_t</span> <span class="n">alloc</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr64</span> <span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">uint64_t</span> <span class="n">alloc</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cp">#define SDS_TYPE_5 0
</span><span class="cp">#define SDS_TYPE_8 1
</span><span class="cp">#define SDS_TYPE_16 2
</span><span class="cp">#define SDS_TYPE_32 3
</span><span class="cp">#define SDS_TYPE_64 4
</span><span class="cp">#define SDS_TYPE_MASK 7
</span><span class="cp">#define SDS_TYPE_BITS 3
</span></code></pre></div><p>        __ $attribute$ __ $(($ __ $packed$ __ $))$ 作用是取消字节对齐，从而允许通过传入 $buf$ 的方式访问 $flags$ ，即 $buf[-1]$ 。<br/>
        <code>Redis</code>会根据字符串长度选择对应的数据结构。在 $sds.c$ 文件中定义了如下函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="nf">sdsReqType</span><span class="p">(</span><span class="n">size_t</span> <span class="n">string_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">string_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// 32
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">SDS_TYPE_5</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">string_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">// 256
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">SDS_TYPE_8</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">string_size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="c1">// 65536
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">SDS_TYPE_16</span><span class="p">;</span>
<span class="cp">#if (LONG_MAX == LLONG_MAX)
</span><span class="cp"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">string_size</span> <span class="o">&lt;</span> <span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="c1">// 2^32
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">SDS_TYPE_32</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">SDS_TYPE_64</span><span class="p">;</span> <span class="c1">// 2^64
</span><span class="c1"></span><span class="cp">#else
</span><span class="cp"></span>    <span class="k">return</span> <span class="n">SDS_TYPE_32</span><span class="p">;</span>
<span class="cp">#endif;
</span><span class="cp"></span><span class="p">}</span>
</code></pre></div><p>        与普通的字符数组相比，$SDS$ 可以直接获取长度，并且在添加字节时不用每次都重新创建。由于底层用的也是字符数组，因此 $SDS$ 也兼容<code>C</code>库函数中的字符串操作。</p>
<h2 id="2-链表">2. 链表</h2>
<p>        链表定义在 $adlist.h$ 文件中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 节点
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">listNode</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">listNode</span><span class="p">;</span>

<span class="c1">// 迭代器
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">listIter</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">direction</span><span class="p">;</span>
<span class="p">}</span> <span class="n">listIter</span><span class="p">;</span>

<span class="c1">// 链表
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">list</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">dup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">// 节点复制
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">// 节点删除
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">// 节点查找
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 长度
</span><span class="c1"></span><span class="p">}</span> <span class="n">list</span><span class="p">;</span>
</code></pre></div><h2 id="3-整数集合">3. 整数集合</h2>
<p>        如果一个 $set$ 只包含整数，那么就会使用整数集合存储。整数集合定义在 $intset.h$ 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">intset</span> <span class="p">{</span>
    <span class="n">uint32_t</span> <span class="n">encoding</span><span class="p">;</span> <span class="c1">// 集合类型
</span><span class="c1"></span>    <span class="n">uint32_t</span> <span class="n">length</span><span class="p">;</span> <span class="c1">// 长度
</span><span class="c1"></span>    <span class="n">int8_t</span> <span class="n">contents</span><span class="p">[];</span> <span class="c1">// 以不包含重复项的形式升序排序的数组
</span><span class="c1"></span><span class="p">}</span> <span class="n">intset</span><span class="p">;</span>
</code></pre></div><p>        整数集合中保存的整数类型取决于 $encoding$ 。如果存入的整数不符合编码格式，就需要升级，升级要根据新元素的类型扩展数组并重新分配空间。</p>
<h2 id="4-hash">4. <code>Hash</code></h2>
<p>        $Hash$ 定义在 $dict.h$ 文件中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dicEntry</span> <span class="p">{</span> <span class="c1">// 节点
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span> <span class="c1">// 键
</span><span class="c1"></span>    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
        <span class="n">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
        <span class="n">int64_t</span> <span class="n">s64</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 值
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">dicEntry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="c1">// 链表结构解决冲突
</span><span class="c1"></span><span class="p">}</span> <span class="n">dictEntry</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictType</span> <span class="p">{</span> <span class="c1">// 字典类型
</span><span class="c1"></span>    <span class="n">uint64_t</span> <span class="p">(</span><span class="o">*</span><span class="n">hashFunction</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">// 计算哈希值行数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">keyDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">// 复制键
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">valDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span> <span class="c1">// 复制值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">keyCompare</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span> <span class="c1">// 查找键
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">keyDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">// 删除键
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">valDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span> <span class="c1">// 删除值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">expandAllowed</span><span class="p">)(</span><span class="n">size_t</span> <span class="n">moreMem</span><span class="p">,</span> <span class="kt">double</span> <span class="n">usedRatio</span><span class="p">);</span> <span class="c1">// 扩容
</span><span class="c1"></span><span class="p">}</span> <span class="n">dictType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictht</span> <span class="p">{</span> <span class="c1">// 哈希表
</span><span class="c1"></span>    <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span> <span class="c1">// 哈希数组
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span> <span class="c1">// 表大小，2的幂次
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizemask</span><span class="p">;</span> <span class="c1">// 计算索引，即表大小-1
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span> <span class="c1">// 已使用节点数
</span><span class="c1"></span><span class="p">}</span> <span class="n">dictht</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dict</span> <span class="p">{</span> <span class="c1">// 字典
</span><span class="c1"></span>    <span class="n">dictType</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span> <span class="c1">// 类型
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">;</span> <span class="c1">// 私有数据
</span><span class="c1"></span>    <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 两个哈希表
</span><span class="c1"></span>    <span class="kt">long</span> <span class="n">rehashidx</span><span class="p">;</span> <span class="c1">// rehash索引，不进行rehash时为-1
</span><span class="c1"></span>    <span class="n">int16_t</span> <span class="n">pauserhash</span><span class="p">;</span> <span class="c1">// 如果&gt;0说明rehash暂停，&lt;0说明发生错误
</span><span class="c1"></span><span class="p">}</span> <span class="n">dict</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictIterator</span> <span class="p">{</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">table</span><span class="p">,</span> <span class="n">safe</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">nextEntry</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">fingerprint</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictIterator</span><span class="p">;</span>
</code></pre></div><p>        <code>Redis</code>的字典使用链地址法解决哈希冲突，采用头插法。<code>Redis</code>中的字典不仅可以进行扩容操作，也可以进行收缩操作，大小固定为不小于当前使用空间的最小的 $2$ 的整数次幂。在每次执行 $CRUD$ 操作之后都会进行 $rehash$ 操作，将保存在 $ht[0]$ 中的键值对迁移到 $ht[1]$ 中，直到 $ht[0]$ 为空，然后交换 $ht[0]$ 和 $ht[1]$ ，并在 $ht[1]$ 上重建一个新表。$rehashidx$ 的作用是记录每次操作过程中应该进行迁移的键值对的索引，如果迁移完成，会重新设为 $-1$ 。</p>
<h2 id="5-压缩列表">5. 压缩列表</h2>
<p>        压缩列表是 $list$ 和 $hash$ 的底层实现之一，对于只包含少量数据的项，会使用压缩列表存储。压缩列表定义在 $ziplist.c$ 文件中，结构如下：</p>
<ol>
<li>$zlbytes$ ：$4$ 字节压缩列表长度；</li>
<li>$zltail$ ：$4$ 字节尾元素相对于压缩列表起始地址偏移量；</li>
<li>$zllen$ ：$2$ 字节压缩列表元素数目，长度超过 $2^{16}-1$ ，需要遍历压缩列表才能获取元素数目</li>
<li>$entry$ ：元素节点；</li>
<li>$zlend$ ：$1$ 字节表示压缩列表结尾，恒为 $0xFF$。</li>
</ol>
<p>        其中元素节点的编码如下：</p>
<ol>
<li>$previous_-entry_-length$ ：前一个节点的字节长度；</li>
<li>$encoding$ ：当前元素编码；</li>
<li>$content$ ：存储的数据，可以是字节数组或者整数。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// zl为char*类型，指向压缩列表首地址
</span><span class="c1"></span><span class="cp">#define ZIPLIST_BYTES(zl) (*((uint32_t*)(zl)))
</span><span class="cp"></span><span class="c1">// zl+4指向zltail字段
</span><span class="c1"></span><span class="cp">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t)((zl)+sizeof(uint32_t))))
</span><span class="cp"></span><span class="c1">// zl+zltail指向为元素首地址
</span><span class="c1"></span><span class="cp">#define ZIPLIST_ENTRY_TAIL(zl) ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))
</span><span class="cp"></span><span class="c1">// zl+8指向zllen字段
</span><span class="c1"></span><span class="cp">#define ZIPLIST_LENGTH(zl) (*((uint16_t)((zl)+sizeof(uint32_T)*2)))
</span><span class="cp"></span><span class="c1">// 最后一个字段为zlend
</span><span class="c1"></span><span class="cp">#define ZIPLIST_ENTRY_END(zl) ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)
</span><span class="cp"></span><span class="c1">// 存储经过解码后的节点
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zlentry</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prevrawlensize</span><span class="p">;</span> <span class="c1">// 前驱节点长度的字节长度
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prevrawlen</span><span class="p">;</span> <span class="c1">// 前驱节点长度
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lensize</span><span class="p">;</span> <span class="c1">// encoding字段的字节长度
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 数据字节长度
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">headersize</span><span class="p">;</span> <span class="c1">// prevrawlensize + lensize，即previous_entry_length+encoding长度
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span><span class="p">;</span> <span class="c1">// ZIP_STR_* 或者 ZIP_INT_*
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// 存储数据的首地址
</span><span class="c1"></span><span class="p">}</span> <span class="n">zlentry</span><span class="p">;</span>
</code></pre></div><h2 id="6-跳表">6. 跳表</h2>
<p>        跳表定义在 $server.h$ 文件中。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="p">{</span> <span class="c1">// 跳表节点
</span><span class="c1"></span>    <span class="n">sds</span> <span class="n">ele</span><span class="p">;</span> <span class="c1">// 元素
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span> <span class="c1">// 分值
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span> <span class="n">backward</span><span class="p">;</span> <span class="c1">// 后向指针
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">zskiplistLevel</span> <span class="p">{</span> <span class="c1">// 层
</span><span class="c1"></span>        <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">forward</span><span class="p">;</span> <span class="c1">// 前向指针
</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">span</span><span class="p">;</span> <span class="c1">// 跨度，即同层相邻节点之间最底层节点的数量
</span><span class="c1"></span>    <span class="p">}</span> <span class="n">level</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">zskiplistNode</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplist</span> <span class="p">{</span> <span class="c1">// 跳表
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span> <span class="c1">// 长度
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span> <span class="c1">// 最大层数
</span><span class="c1"></span><span class="p">}</span> <span class="n">zskiplist</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">zset</span> <span class="p">{</span> <span class="c1">// 有序集合
</span><span class="c1"></span>    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span> <span class="c1">// 字典
</span><span class="c1"></span>    <span class="n">zskiplist</span> <span class="o">*</span><span class="n">zsl</span><span class="p">;</span> <span class="c1">// 跳表
</span><span class="c1"></span><span class="p">}</span> <span class="n">zset</span><span class="p">;</span>
</code></pre></div><p>        $ZSKIPLIST_-P$ 为 $0.25$ ，代表每次插入的节点都有 $25\%$ 的概率上升一层。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Mar 25 23:02</span> <a href="/post/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
        if (tocFlag) tocInit();
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>