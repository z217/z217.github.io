<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.74.3" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
        
        <a href="http://123.57.12.189"  target="_blank" >
            <i class="fas fa-link fa-sm"></i>
            <span>二站</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/">MySQL索引介绍</a>
        
        
        <p>MySQL索引简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 04 22:16
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: DBS
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/mysql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/">MySQL架构介绍</a>
        
        
        <p>MySQL架构简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 04 22:16
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: DBS
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/java-8%E5%AE%9E%E6%88%98%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api/">Java 8实战：日期和时间API</a>
        
        
        <p>Java 8日期和时间API简介</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Feb 18 18:39
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/java-8%E5%AE%9E%E6%88%98%E6%B5%81%E5%A4%84%E7%90%86/">Java 8实战：流处理</a>
        
        
        <p>Java 8流处理介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Feb 17 18:00
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm10%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">JVM（10）：线程安全与锁优化</a>
        
        
        <p>深入理解Java虚拟机（10）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Jan 13 21:17
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/">MySQL索引介绍</a></h1>
            </center>
            <div class="post-content">
                <p>        索引 ( 在<code>MySQL</code>中也叫做<strong>键</strong> ( $key$ )) 是存储引擎用于快速找到记录的一种数据结构。索引优化是查询性能优化最有效的手段。</p>
<h2 id="1-基础">1. 基础</h2>
<p>        <code>MySQL</code>中，索引引擎首先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为<code>MySQL</code>只能高效地使用索引的最左前缀列。<br/></p>
<h3 id="11-类型">1.1 类型</h3>
<p>        索引有很多类型。在<code>MySQL</code>中，索引是在存储引擎层而不是服务层实现的，所以并没有统一的索引标准。</p>
<h4 id="111-b-tree">1.1.1 <code>B-Tree</code></h4>
<p>        如果没有特别指明类型，那么通常所说的索引都是<code>B-Tree</code>索引，顾名思义，即使用<code>B-Tree</code>数据结构来存储数据。大多数<code>MySQL</code>引擎都支持这种索引。不过，底层的存储引擎也可能使用不同的存储结构，例如<code>InnoDB</code>使用的是<code>B+Tree</code>。存储引擎以不同的方式使用<code>B-Tree</code>索引，性能也各有不同，各有优劣。例如，<code>MyISAM</code>使用前缀压缩技术使得索引更小，但<code>InnoDB</code>则按照原数据格式进行存储。再如<code>MyISAM</code>索引通过数据的物理位置引用被索引的行，而<code>InnoDB</code>则根据主键引用被索引的行。<br/>
        <code>B-Tree</code>通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。<code>B-Tree</code>索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。<br/>
        <code>B-Tree</code>索引适用于全键值、键值范围或键值前缀查找。其中键值前缀查找只适用于根据最左前缀的查找。上述的索引对如下类型的查询有效：</p>
<ul>
<li>全值匹配</li>
<li>匹配最左前缀</li>
<li>匹配列前缀</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>只访问索引的查询</li>
</ul>
<p>        因为索引树的节点是有序的，所以除了按值查找外，索引还可以用于查询中的 $ORDER\ \ BY$ 操作。一般来说，如果<code>B-Tree</code>可以按照某种方式查找到值，那么也可以按照这种方式用于排序。</p>
<h4 id="12-哈希索引">1.2 哈希索引</h4>
<p>        <strong>哈希索引</strong> ( $hash\ \ index$ ) 基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，并存储在索引中，同时在哈希表中保存指向每个数据行的指针。在<code>MySQL</code>中，只有<code>Memory</code>引擎显式支持哈希索引，同时也是默认索引类型。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。<br/>
        <code>InnoDB</code>引擎有一个特殊的功能叫做<strong>自适应哈希索引</strong> ( $adaptive\ \ hash\ \ index$ )。当<code>InnoDB</code>注意到某些索引值被使用得非常频繁时，它会在内存中基于<code>B-Tree</code>索引之上再创建一个哈希索引。<br/>
        如果存储引擎不支持哈希索引，可以模拟创建哈希索引，即增加一列，存储哈希值。<code>MySQL</code>提供了 $CRC32$ 函数用于计算哈希值，通过设置触发器，可以在每次插入时自动插入索引。不要使用 $SHA1$ 和 $MD5$ 作为哈希函数，因为这两个函数计算出来的哈希值是非常长的字符串。如果数据表非常大，$CRC32$ 会出现大量哈希冲突，这时也可以考虑自己实现哈希函数。</p>
<h2 id="2-优点">2. 优点</h2>
<p>        索引可以让服务器快速地定位到表的指定位置，但并非唯一作用。最常见的<code>B-Tree</code>索引，按照顺序存储数据，可以用于 $ORDER\ \ BY$ 和 $GROUP\ \ BY$ 操作。利用数据有序的特点，索引有如下三个优点：</p>
<ul>
<li>减少了服务器需要扫描的数据量；</li>
<li>帮助服务器避免排序和临时表；</li>
<li>将随机<code>I/O</code>变为顺序<code>I/O</code>。</li>
</ul>
<p>        但是索引并不总是最好的工具。对于非常小的表，大部分情况下简单的全表扫描更加高效。而对于中大型表，索引就非常有效。但对于特大型表，建立和使用索引的代价将随之增长，这时候就需要一种可以直接区分出查询需要的数据的技术，例如分区技术。</p>
<h2 id="3-索引策略">3. 索引策略</h2>
<h3 id="31-独立的列">3.1 独立的列</h3>
<p>        如果查询中的列不是独立的，<code>MySQL</code>就不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">actor_id</span> <span class="k">FROM</span> <span class="n">sakila</span><span class="p">.</span><span class="n">actor</span> <span class="k">WHERE</span> <span class="n">actor_id</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</code></pre></div><h3 id="32-前缀索引和索引选择性">3.2 前缀索引和索引选择性</h3>
<p>        有时候需要索引很长的字符列，这会让索引变得大且慢。除了之前提到的模拟哈希索引外，也可以索引开始的部分字符，这样可以大大节约索引空间，但是也会降低选择性。选择性指的是不重复的值和记录总数的比值，越高代表查询效率越高。一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于 $BLOB$ 、$TEXT$ 或者很长的 $VARCHAR$ 类型的列，必须使用前缀索引，因为<code>MySQL</code>不允许索引这些列的完整长度。<br/>
        前缀索引是一种能使索引更小、更快的有效方法，但另一方面也有其缺点：<code>MySQL</code>无法使用前缀索引做 $ORDER\ \ BY$ 和 $GROUP\ \ BY$ ，也无法使用前缀索引做覆盖扫描。<br/>
        除了前缀索引外，有时候后缀索引也有用途。<code>MySQL</code>原生不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。</p>
<h3 id="33-多列索引">3.3 多列索引</h3>
<p>        在创建索引的过程中一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。在多个列上建立独立的单列索引大部分情况下并不能提高<code>MySQL</code>的查询性能。<code>MySQL 5.0</code>引入了一种叫<strong>索引合并</strong> ( $index\ \ merge$ ) 的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕：</p>
<ul>
<li>当出现服务器对多个索引做相交操作时，通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引；</li>
<li>当服务器需要对多个索引做联合操作时，通常需要耗费大量<code>CPU</code>和内存资源在算法的缓存、排序和合并操作上；</li>
<li>优化器不会把这些计算到查询成本中，优化器只关心随即页面读取，从而导致查询成本被低估。</li>
</ul>
<h3 id="34-索引列顺序">3.4 索引列顺序</h3>
<p>        索引列的正确顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。在一个多列<code>B-Tree</code>索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以多列索引的列顺序至关重要。当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的，这时候索引的作用只是优化 $WHERE$ 条件的查找。</p>
<h3 id="35-聚簇索引">3.5 聚簇索引</h3>
<p>        聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但<code>InnoDB</code>的聚簇索引实际上在同一个结构中保存了<code>B-Tree</code>索引和数据行。当表有聚簇索引时，它的数据行实际上存放在索引的<strong>叶子页</strong> ( $leaf\ \ page$ ) 中。聚簇表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。<br/>
        <code>InnoDB</code>通过主键聚集数据，也就是选择主键列作为聚簇索引。如果没有定义主键，则会选择一个唯一的非空索引替代。如果没有这样的索引，则会隐式定义一个主键作为聚簇索引。<code>InnoDB</code>只聚集在同一个页面中的记录，包含相邻键值的页面可能会相距甚远。<br/>
        聚集的数据有一些重要的优点：</p>
<ul>
<li>可以把相关的数据保存在一起；</li>
<li>数据访问更快；</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>        同时也带了一些缺点：</p>
<ul>
<li>聚簇数据最大限度地提高了<code>I/O</code>密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了；</li>
<li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到<code>InnoDB</code>表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 $OPTIMIZE\ \ TABLE$ 命令重新组织一下表；</li>
<li>更新聚簇索引列的代价很高，因为会强制<code>InnoDB</code>将每个被更新的行移动到新的位置；</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临<strong>页分裂</strong> ( $page\ \ split$ ) 问题。页分裂会导致表占用更多的磁盘空间；</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候；</li>
<li>二级索引 ( 非聚簇索引 ) 可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列；</li>
<li>二级索引访问需要两次索引查找。因为<code>InnoDB</code>二级索引叶子节点保存的是行的主键值，所以需要再次查找聚簇索引。</li>
</ul>
<p>        如果正在使用的<code>InnoDB</code>表没有什么数据需要聚集，那么可以定义一个<strong>代理键</strong> ( $surrogate\ \ key$ ) 作为主键，这种主键的数据应该和应用无关，最简单的方法是使用 $AUTO_-INCREMENT$ 自增列。这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也会更好。<br/>
        最好避免随机的 ( 不连续且值的分布范围非常大 ) 的聚簇索引，特别是对于<code>I/O</code>密集型的应用，例如使用<code>UUID</code>作为聚簇索引会很糟糕，因为它使得索引的插入变得随机。在把随机值插入聚簇索引后，也许还需要做一次 $OPTIMIZE\ \ TABLE$ 来重建表并优化页的填充。</p>
<h3 id="36-覆盖索引">3.6 覆盖索引</h3>
<p>        通常都会根据 $WHERE$ 条件来创建合适的索引，不过这只是索引优化的一个方面。<code>MySQL</code>也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。如果一个索引包含 ( 或者说覆盖 ) 所有需要查询的字段的值，我们就称之为”覆盖索引“。并非所有类型的索引都能称为覆盖索引，覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值。</p>
<h3 id="37-排序">3.7 排序</h3>
<p>        <code>MySQL</code>有两种方式可以生成有序的结果：通过排序操作；或者按索引顺序扫描；如果 $EXPLAIN$ 出来的 $type$ 列的值为 $index$ ，说明使用了索引扫描来做排序。如果索引不能覆盖查询所需的全部列，就不得不每扫描一条索引记录就回表查询依次对应的行，这基本上都是随机<code>I/O</code>。所以，如果可能的话，设计索引时应该尽可能地同时满足这两种任务。<br/>
        只有当索引的列顺序和 $ORDER\ \ BY$ 子句的顺序完全一致，并且所有列的排序方向都一样时，<code>MySQL</code>才能使用索引来对结果做排序。如果查询需要关联多张表，则只有当 $ORDER\ \ BY$ 子句引用的字段全部为第一个表时，才能使用索引做排序。</p>
<h3 id="38-压缩索引">3.8 压缩索引</h3>
<p>        <code>MyISAM</code>使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能。默认只压缩字符串，但通过参数设置也可以对整数进行压缩。具体的压缩方法是：先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。例如索引块第一个值为 $perform$ ，第二个值为 $performance$ ，那么第二个值得前缀压缩后会被存储为类似于 $7,ance$ 的形式。指针也是采用类似的压缩方式。<br/>
        压缩快使用更少的空间，代价是某些操作可能更慢，因为压缩值要依赖于之前的值，所以不能简单的使用二分查找等算法。对于<code>CPU</code>密集型应用，因为扫描需要随机查找，压缩索引会使得查找变慢。</p>
<h3 id="39-冗余和重复索引">3.9 冗余和重复索引</h3>
<p>        <code>MySQL</code>允许在相同列上创建多个索引，无论是有意的还是无意的。<code>MySQL</code>需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样的重复索引，发现以后也应该立即移除。冗余索引和重复索引有些不同，例如创建了索引 $(A,B)$ ，再创建索引 $(A)$ 就是冗余索引；但是如果再创建索引 $(B,A)$ ，就不是冗余索引。大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。但也有时候出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。</p>
<h3 id="310-索引和锁">3.10 索引和锁</h3>
<p>        索引可以让查询锁定更少的行。如果查询从不访问那些不需要的行，那么就会锁定更少的行。虽然<code>InnoDB</code>的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁竞争并减少并发性。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Mar 4 22:16</span> <a href="/post/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/mysql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/">MySQL架构介绍</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-mysql逻辑架构">1. <code>MySQL</code>逻辑架构</h2>
<p><img src="/image/2021-03-04-01.png" alt="MySQL服务器逻辑架构图"></p>
<ul>
<li>最上层服务并不是<code>MySQL</code>独有，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构，比如连接处理、授权认证、安全等；</li>
<li>第二层架构是<code>MySQL</code>比较有意思的部分。大多数<code>MySQL</code>的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等；</li>
<li>第三层包含了存储引擎。存储引擎负责<code>MySQL</code>中数据的存储和提取。存储引擎多种多样，服务器通过<code>API</code>与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎<code>API</code>包含了几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析<code>SQL</code> ( <code>InnoDB</code>会解析外键定义 ) ，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。</li>
</ul>
<h3 id="11-连接管理与安全性">1.1 连接管理与安全性</h3>
<p>        每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个<code>CPU</code>核心或者<code>CPU</code>中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。在连接建立后，服务器会验证客户端是否具有执行某个特定查询的权限。</p>
<h3 id="12-优化与执行">1.2 优化与执行</h3>
<p>        <code>MySQL</code>会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准。<br/>
        对于 $SELECT$ 语句，在解析查询之前，服务器会先检查查询缓存 ( $Query\ \ Cache$ )，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。</p>
<h2 id="2-并发控制">2. 并发控制</h2>
<p>        在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，<code>MySQL</code>会通过锁定防止其他用户读取统一数据。大多数时候，<code>MySQL</code>的内部管理都是透明的。<br/>
        所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。大多数商业数据库系统没有提供更多的选择，一般都是在表上施加<strong>行级锁</strong> ( $row-level\ \ lock$ )，并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能地提供更好的性能。而<code>MySQL</code>则提供了多种选择。每种<code>MySQL</code>存储引擎都可以实现自己的锁策略和锁粒度。在存储引擎的设计中，锁管理是个非常重要的决定。将锁粒度固定在某个级别，可以为某些特定的应用场景提供更好的性能，但同时却会失去对另外一些应用场景的良好支持。好在<code>MySQL</code>支持多个存储引擎的架构，所以不需要单一的通用解决方案。</p>
<ul>
<li><strong>表锁</strong> ( $table\ \ lock$ )：表锁是<code>MySQL</code>中最基本的锁策略，并且是开销最小的策略，它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他的读取的用户才能获得读锁，读锁之间是不相互阻塞的。尽管存储引擎可以管理自己的锁，但<code>MySQL</code>本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如 $ALTER\ \ TABLE$ 之类的语句使用表锁，而忽略存储引擎锁机制；</li>
<li><strong>行级锁</strong> ( $row\ \ lock$ )：行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。众所周知，在<code>InnoDB</code>和<code>XtraDB</code>，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而<code>MySQL</code>服务器层没有实现。</li>
</ul>
<h2 id="3-事务">3. 事务</h2>
<p>        事务就是一组原子性的<code>SQL</code>查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。</p>
<ul>
<li><strong>原子性</strong> ( $atomicity$ )：一个事务必须被视为一个不可分割的最小工作单元；</li>
<li><strong>一致性</strong> ( $consistency$ )：数据库总是从一个一致性的状态转换到另外一个一致性的状态；</li>
<li><strong>隔离性</strong> ( $isolation$ )：一个事务所做的修改在最终提交以前，对其他事务是不可见的；</li>
<li><strong>持久性</strong> ( $durability$ )：一旦事务提交，其所做的修改就会永久保存到数据库中。</li>
</ul>
<p>        一个运行良好的事务处理系统，必须满足<code>ACID</code>特性。但在应用逻辑中，要想实现这一点很困难，甚至可以说是不可能完成的任务。一个兼容<code>ACID</code>的数据库系统，需要做很多复杂但可能用户并没有觉察到的工作。</p>
<h3 id="31-隔离级别">3.1 隔离级别</h3>
<ul>
<li><code>READ UNCOMMITTED</code> ( <strong>未提交读</strong> )：事务中的修改，即使没有提交，对其他事务也都是可见的。事务读取未提交的数据称为<strong>脏读</strong> ( $Dirty\ \ Read$ )；</li>
<li><code>READ COMMITTED</code> ( <strong>提交读</strong> )：大多数数据库系统的默认隔离级别都是提交读，但<code>MySQL</code>不是。一个事务开始时，只能看到已经提交的事务所做的修改。这个级别有时候也叫做<em><strong>不可重复读</strong></em> ( $nonrepeatable\ \ read$ )，因为两次执行同样的查询，可能会得到不一样的结果；</li>
<li><code>REPEATABLE READ</code> ( <strong>可重复读</strong> )：该级别解决了脏读问题，保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，还是无法解决<strong>幻读</strong> ( $Phantom\ \ Read$ ) 问题。幻读指的是当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录。可重复读是<code>MySQL</code>的默认事务隔离级别；</li>
<li><code>SERIALIZABLE</code> ( <strong>可串行化</strong> )：通过强制事务串行执行，可以避免幻读问题。但是由于会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁竞争问题。</li>
</ul>
<h3 id="32-死锁">3.2 死锁</h3>
<p>        为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如<code>InnoDB</code>存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。还有一种解决方式，就是当查询的时间达到等待超时的设定后放弃锁请求，这种方式通常来说不太好。<code>InnoDB</code>目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。<br/>
        锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，但有些完全是由于存储引擎的实现方式导致的。</p>
<h3 id="33-事务日志">3.3 事务日志</h3>
<p>        使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到硬盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序<code>I/O</code>，而不像随机<code>I/O</code>需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志</strong> ( $Write-Ahead\ \ Logging$ )，修改数据需要写两次磁盘。</p>
<h3 id="34-mysql中的事务">3.4 <code>MySQL</code>中的事务</h3>
<p>        <code>MySQL</code>提供了两种事务型的存储引擎：<code>InnoDB</code>和<code>NDB Cluster</code>。另外还有一些第三方存储引擎也支持事务，比较知名的包括<code>XtraDB</code>和<code>PBXT</code>。<br/>
        <code>MySQL</code>默认采用<strong>自动提交</strong> ( $AUTOCOMMIT$ ) 模式，如果不是显式开始一个事务，则每个查询都被当做一个事务执行提交操作。通过$SET\ \ AUTOCOMMIT$ ，可以启用或者禁用自动提交模式。禁用之后，只有显式地执行提交或者回滚操作，当前事务才会结束。但对于非事务型的表，比如<code>MyISAM</code>或者内存表，不会有任何影响。另外还有一些命令，在执行之前会强制执行<code>COMMIT</code>提交当前的活动事务，比如 $ALTER\ \ TABLE$ 。<br/>
        <code>MySQL</code>可以通过执行 $SET\ \ TRANSACTION\ \ ISOLATION\ \ LEVEL$ 命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。<code>MySQL</code>能够识别所有的 $4$ 个<code>ANSI</code>隔离级别，<code>InnoDB</code>引擎也支持所有的隔离级别。<br/>
        <code>MySQL</code>服务器层部管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中使用多种存储引擎是不可靠的。在事务中混合使用事务型和非事务型的表，在正常提交的情况下不会有什么问题。但是当事务需要回滚时，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复。<br/>
        <code>InnoDB</code>采用的是<strong>两阶段锁定协议</strong> ( $two-phase\ \ locking\ \ protocol$ )。在事务执行过程中，随时都可以执行锁定，锁只有在执行<code>COMMIT</code>或者<code>ROLLBACK</code>的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，<code>InnoDB</code>会根据隔离级别在需要的时候自动加锁。</p>
<h2 id="4-多版本并发控制">4. 多版本并发控制</h2>
<p>        <code>MySQL</code>的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了<strong>多版本并发控制</strong> ( <code>MVCC</code> )。可以认为<code>MVCC</code>是行级锁的一个变种，但是它在很多情况下都避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。<br/>
        <code>MVCC</code>的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。不同引擎的<code>MVCC</code>实现是不同的，典型的有乐观并发控制和悲观并发控制。<br/>
        <code>InnoDB</code>的<code>MVCC</code>是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间。当然存储的不是实际时间，而是系统版本号。每开始一个新事务，系统版本号都会自动递增。在<code>REPEATABLE READ</code>隔离级别下，<code>MVCC</code>的操作方式如下：</p>
<ul>
<li>$SELECT$ ：<code>InnoDB</code>会根据以下两个条件检查每行记录：查找版本早于当前事务版本的数据行，并保证行的删除版本要么未定义，要么大于当前事务版本号。只有符合上述条件的记录，才能返回作为查询结果；</li>
<li>$INSERT$ ：为新插入的每一行保存当前系统版本号作为行版本号；</li>
<li>$DELETE$ ：为删除的每一行保存当前系统版本号作为行删除标识；</li>
<li>$UPDATE$ ：插入一行新纪录，为插入的新行保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</li>
</ul>
<p>        <code>MVCC</code>只在<code>REPEATABLE READ</code>和<code>READ COMMITTED</code>两个隔离级别下工作。</p>
<h2 id="5-mysql的存储引擎">5. <code>MySQL</code>的存储引擎</h2>
<p>        在文件系统中，<code>MySQL</code>将每个数据库（也可以称之为<code>schema</code>）保存为数据目录下的一个子目录。创建表时，<code>MySQL</code>会在数据库子目录下创建一个和表同名的 $.frm$ 文件保存表的定义。可以使用 $SHOW\ \ TABLE\ \ STATUS$ 命令显示表的相关信息。</p>
<h3 id="51-innodb">5.1 <code>InnoDB</code></h3>
<p>        <code>InnoDB</code>是<code>MySQL</code>的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的<strong>短期</strong> ( $short-lived$ ) 事务，短期事务大部分情况是正常提交的，很少会被回滚。<code>InnoDB</code>的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑<code>InnoDB</code>引擎。<br/>
        <code>InnoDB</code>的数据存储在<strong>表空间</strong> ( $tablespace$ ) 中，表空间是由<code>InnoDB</code>管理的一个黑盒子，由一系列的数据文件组成。在<code>MySQL 4.1</code>以后的版本中，<code>InnoDB</code>可以将每个表的数据和索引存放在单独的文件中。<code>InnoDB</code>也可以使用裸设备作为表空间的存储介质，但现代的文件系统使得裸设备不再是必要的选择。存在如下几种表空间：</p>
<ul>
<li><strong>系统表空间</strong>：在安装数据库的时候默认会初始化一个以 $ibdata1$ 命名的系统表空间，存储所有数据的信息以及回滚段信息，默认大小为 $10MB$ ，在高并发情况下会有性能影响，建议调整大小为 $1GB$ ；</li>
<li><strong>独立表空间</strong>：设置参数 $innodb_-file_-per_-table=1$ ，目前<code>MySQL</code>默认都是独立表空间，即每个表都有自己的表空间文件，存储对应的<code>B+Tree</code>、索引和插入缓冲等信息，其余信息会存储在共享表空间；</li>
<li><strong>撤销表空间</strong>：包含撤销日志，初始化的时候会创建两个默认的插销表空间；</li>
<li><strong>通用表空间</strong>：可以存储多个表的数据，相比独立表空间更节约元数据的内存开销；</li>
<li><strong>临时表空间</strong>：分会话临时表空间和全局临时表空间。会话临时表空间会在第一个请求中从临时表空间分配，当会话断开时，临时表空间将被释放进入临时表空间池中；全局临时表空间用于存储用户创建的临时表的更改数据，用于回滚，在正常关闭或初始化中止时被删除，并在每次启动服务器时重新创建；</li>
</ul>
<p>        <code>InnoDB</code>使用<code>MVVC</code>来支持高并发，并且实现了四个标准的隔离级别。其默认级别是<code>REPEATABLE READ</code>，并且通过<strong>间隙锁</strong> ( $next-key\ \ locking$ ) 策略防止幻读的出现。间隙锁使得<code>InnoDB</code>不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。<br/>
        <code>InnoDB</code>表是基于聚簇索引建立的，和<code>MySQL</code>的其他存储引擎有很大的不同，对主键查询有很高的性能。不过它的<strong>二级索引</strong> ( $secondary\ \ index$ ，非主键索引 ) 中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。<br/>
        <code>InnoDB</code>内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建<code>hash</code>索引以加速读操作的<strong>自适应哈希索引</strong> ( $adaptive\ \ hash\ \ index$ )，以及能够加速插入操作的<strong>插入缓冲区</strong> ( $insert\ \ buffer$ ) 等。</p>
<h3 id="52-myisam">5.2 <code>MyISAM</code></h3>
<p>        在<code>MySQL 5.1</code>及之前的版本，<code>MyISAM</code>是默认的存储引擎，提供了大量的特性，包括全文索引、压缩、空间函数等，但不支持事务和行级锁，以及崩溃后的安全恢复。虽然不支持事务和崩溃后的安全恢复，但对于只读的数据，或者表比较小，可以忍受修复操作，依然可以使用<code>MyISAM</code>。<br/>
        <code>MyISAM</code>将表存储在两个文件中：数据文件和索引文件，分别以 $.MYD$ 和 $.MYI$ 为扩展名。<code>MyISAM</code>表可以包含动态或者静态（长度固定）行。在<code>MySQL 5.0</code>中，如果是变长行，则默认配置只能处理 $256TB$ 的数据，这个配置可以通过修改指针长度实现。<br/>
        作为<code>MySQL</code>最早的存储引擎之一，<code>MyISAM</code>有一些已经开发出来很多年的特性：</p>
<ul>
<li><em><strong>加锁与并发</strong></em>：读取时对表加共享锁，写入时对表加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录；</li>
<li><em><strong>修复</strong></em>：可以手工或者自动执行检查和修复操作，但这里说的修复和事务恢复以及崩溃恢复是不同的概念。执行表的修复可能导致一些数据丢失，而且修复操作是非常慢的；</li>
<li><em><strong>索引特性</strong></em>：对于<code>MyISAM</code>表，即使是 $BLOB$ 和 $TEXT$ 等长字段，也可以基于前 $500$ 个字符创建索引。<code>MyISAM</code>也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询；</li>
<li><em><strong>延迟更新索引键</strong></em>：创建时如果指定 $DELAY_-KEY_-WRITE$ 选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的<b>键缓冲区</b> ( $in-memory\ \ key\ \ buffer$ )，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。</li>
</ul>
<p>        如果表在创建并导入数据后，不会再进行修改操作，那么这样的表或许适合采用<code>MyISAM</code>压缩表，可以使用 $myisampack$ 对<code>MyISAM</code>表进行压缩。压缩表是不能进行修改的，可以极大地减少空间占用，因此也可以减少磁盘<code>I/O</code>，从而提升查询性能。压缩表也支持索引，但索引也是只读。</p>
<h3 id="53-转换表的引擎">5.3 转换表的引擎</h3>
<ul>
<li>$ALTER\ \ TABLE$ ：将表从一个引擎修改为另一个引擎最简单的办法是使用 $ALTER\ \ TABLE\ \ xxx\ \ ENGINE$ 语句，上述语法可以适用任何存储引擎，但是需要执行很长时间，因为需要将表项复制到新表。在复制的过程中，原表上会加读锁；</li>
<li>导出与导入：可以使用 $mysqldump$ 工具将数据导出到文件，然后修改文件中的 $CREATE\ \ TABLE$ 语句的存储引擎选项，同时修改表名；</li>
<li>创建与查询：先创建一个新的存储引擎的表，然后利用 $INSERT\ \ \cdots\ \ SELECT$ 语句来导入数据。对于数据量较大的情况，可以考虑做分批处理。</li>
</ul>

            </div>
            <div class="meta post-footer"> <span>2021 Mar 4 22:16</span> <a href="/post/mysql%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/java-8%E5%AE%9E%E6%88%98%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api/">Java 8实战：日期和时间API</a></h1>
            </center>
            <div class="post-content">
                <p>        在<code>Java 1.0</code>中，对日期和时间的支持只能依赖 $java.util.Date$ 类。这个类无法表示日期，只能以毫秒的精度表示时间。而且由于某些原因未知的设计决策，这个类的易用性也不高。例如一个表示 $2014$ 年 $3$ 月 $18$ 日的 $Date$ 需要用以下方式创建：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Date</span> <span class="n">date</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Date</span><span class="o">(</span><span class="n">114</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
</code></pre></div><p>        此外，$Date.toString$ 方法的返回值中虽然包含时区，但 $Date$ 并不支持时区。所以，在<code>Java 1.1</code>中，$Date$ 的许多方法被废弃，取而代之的是 $java.util.Calendar$ 类，但是这个类同样也存在着很多问题。比如月份依旧是从 $0$ 开始，而且没有提供 $DateFormat$ 方法。如果使用 $DateFormat$ 方法，那么又会带来并发问题，因为它不是线程安全的。为了解决上述问题，<code>Java 8</code>中新增的 $java.time$ 包中添加了新的日期和时间<code>API</code>。<br/>
        $java.time$ 包中提供了一些新类：$LocalDate$ 、$LocalTime$ 、$Instant$ 、$Duration$ 和 $Period$ 。<br/></p>
<h2 id="1-localdatelocaltimelocaldatetime">1. <code>LocalDate</code>/<code>LocalTime</code>/<code>LocalDateTime</code></h2>
<p>        $LocalDate$ 的实例是一个不可变对象，它只提供了简单的日期，并不包含当天的时间信息。另外，它也不附带任何与时区相关的信息。可以通过静态工厂方法 $of$ 创建一个 $LocalDate$ 实例，或者通过 $now$ 方法从系统时钟中获取当前日期，并通过 $getYear$ 、$getMonth$ 、$getDayOfMonth$ 等方法读取常用值。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span><span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getYear</span><span class="o">();</span> <span class="c1">// 2014
</span><span class="c1"></span><span class="n">Month</span> <span class="n">month</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getMonth</span><span class="o">();</span> <span class="c1">// MARCH
</span><span class="c1"></span><span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getDayOfMonth</span><span class="o">();</span> <span class="c1">// 18
</span><span class="c1"></span><span class="n">DayOfWeek</span> <span class="n">dow</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">getDayOfWeek</span><span class="o">();</span> <span class="c1">// TUESDAY
</span><span class="c1"></span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">lengthOfMonth</span><span class="o">();</span> <span class="c1">// 31
</span><span class="c1"></span><span class="kt">boolean</span> <span class="n">leap</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">isLeapYear</span><span class="o">();</span> <span class="c1">// false
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">today</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
</code></pre></div><p>        $TemporalField$ 是一个接口，定义了如何访问 $temporal$ 对象某个字段的值。$ChronoField$ 枚举实现了这一接口，通过 $get$ 方法可以获取对应字段的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">year</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">YEAR</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">month</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTH_OF_YEAR</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">DAY_OF_MONTH</span><span class="o">);</span>
</code></pre></div><p>        类似的，一天中的时间可以使用 $LocalTime$ 表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalTime</span> <span class="n">time</span> <span class="o">=</span> <span class="n">LocalTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">,</span> <span class="n">20</span><span class="o">);</span> <span class="c1">// 13:45:20
</span><span class="c1"></span><span class="kt">int</span> <span class="n">hour</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">getHour</span><span class="o">();</span> <span class="c1">// 13
</span><span class="c1"></span><span class="kt">int</span> <span class="n">minute</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">getMinute</span><span class="o">();</span> <span class="c1">// 45
</span><span class="c1"></span><span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">getSecond</span><span class="o">();</span> <span class="c1">// 20
</span></code></pre></div><p>        $LocalDate$ 和 $LocalTime$ 都可以通过解析字符串的形式创建。一旦传递的字符串参数无法被解析为合法的对象时就会抛出一个 $DateTimeParseException$ 异常。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2014-03-18&#34;</span><span class="o">);</span>
<span class="n">LocalTime</span> <span class="n">time</span> <span class="o">=</span> <span class="n">LocalTime</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;13:45:20&#34;</span><span class="o">);</span>
</code></pre></div><p>        $LocalDateTime$ 是 $LocalDate$ 和 $LocalTime$ 的复合体，既可以表示日期，也可以表示时间，但不带有时区信息。通过 $atTime$ 或者 $atDate$ 方法传递一个时间或者日期对象，可以创建一个 $LocalDateTime$ 。此外，也可以通过 $toLocalDate$ 和 $toLocalTime$ 方法，从 $LocalDateTime$ 中创建 $LocalDate$ 和 $LocalTime$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDateTime</span> <span class="n">dt1</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">,</span> <span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">,</span> <span class="n">20</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt2</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">date</span><span class="o">,</span> <span class="n">time</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt3</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">atTime</span><span class="o">(</span><span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">,</span> <span class="n">20</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt4</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">atTime</span><span class="o">(</span><span class="n">time</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">dt5</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">atDate</span><span class="o">(</span><span class="n">date</span><span class="o">);</span>

<span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">dt1</span><span class="o">.</span><span class="na">toLocalDate</span><span class="o">();</span>
<span class="n">LocalTime</span> <span class="n">time1</span> <span class="o">=</span> <span class="n">dt1</span><span class="o">.</span><span class="na">toLocalTime</span><span class="o">();</span>
</code></pre></div><h2 id="2-instant">2. <code>Instant</code></h2>
<p>        从计算机的角度来看，建模时间最自然的格式是表示一个持续时间段某个点的单一大整形数，这也是 $Instant$ 类对时间建模的方式，基本上它是以<code>Unix</code>元年时间（传统的设定为<code>UTC</code>时区 $1970$ 年 $1$ 月 $1$ 日午夜时分）开始所经历的秒数进行计算。<br/>
        静态工厂方法 $ofEpochSecond$ 接收秒数，创建 $Instant$ 实例。此外，它还提供了一个重载版本，额外接收一个纳秒。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Instant</span><span class="o">.</span><span class="na">ofEpochSecond</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
<span class="n">Instant</span><span class="o">.</span><span class="na">ofEpochSecond</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="n">1_000_000_000</span><span class="o">);</span>
<span class="n">Instant</span><span class="o">.</span><span class="na">ofEpochSecond</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="o">-</span><span class="n">1_000_000_000</span><span class="o">);</span>
<span class="n">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
</code></pre></div><p>        虽然 $Instant$ 也支持 $now$ 方法，但是它包含的是由秒及纳秒所构成的数字，目的是方便机器使用，所以无法处理一些时间单位。但是我们可以通过 $Duration$ 和 $Period$ 类使用 $Instant$ 。<br/></p>
<h2 id="3-durationperiod">3. <code>Duration</code>/<code>Period</code></h2>
<p>        到目前为止的所有类都实现了 $Temporal$ 接口，该接口定义了如何读取和操纵为时间建模的对象的值。$Duration$ 类表示两个 $Temporal$ 对象之间的时间，提供了一个静态工厂方法 $between$ 用于创建该类型实例。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Duration</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">time1</span><span class="o">,</span> <span class="n">time2</span><span class="o">);</span>
<span class="n">Duration</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">dateTime1</span><span class="o">,</span> <span class="n">dateTime2</span><span class="o">);</span>
<span class="n">Duration</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">Duration</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">instant1</span><span class="o">,</span> <span class="n">instant2</span><span class="o">);</span>
</code></pre></div><p>        由于 $Duration$ 类主要用于以秒和纳秒衡量时间的长短，所以不能只接收 $LocalDate$ 作为参数。而且由于 $LocalDateTime$ 和 $Instant$ 是为不同的目的而设计的，所以也不能将二者同时作为参数传入，否则会抛出 $DateTimeException$ 异常。<br/>
        $Period$ 类与 $Duration$ 类相对，接收两个 $LocalDate$ ，表示它们之间的时长。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Period</span> <span class="n">tenDays</span> <span class="o">=</span> <span class="n">Period</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">8</span><span class="o">),</span>
                                <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">));</span>
</code></pre></div><p>        除了 $between$ 之外，$Duration$ 和 $Period$ 也提供了很多方便的工厂类，用于直接创建实例。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">是否为静态方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$between$</td>
<td align="center">是</td>
<td align="center">创建两个时间点之间的间隔</td>
</tr>
<tr>
<td align="center">$from$</td>
<td align="center">是</td>
<td align="center">由一个临时时间点创建间隔</td>
</tr>
<tr>
<td align="center">$of$</td>
<td align="center">是</td>
<td align="center">由它的组成部分创建间隔</td>
</tr>
<tr>
<td align="center">$parse$</td>
<td align="center">是</td>
<td align="center">由字符串创建间隔</td>
</tr>
<tr>
<td align="center">$addTo$</td>
<td align="center">否</td>
<td align="center">创建间隔副本并叠加到指定对象上</td>
</tr>
<tr>
<td align="center">$get$</td>
<td align="center">否</td>
<td align="center">读取间隔</td>
</tr>
<tr>
<td align="center">$isNegative$</td>
<td align="center">否</td>
<td align="center">检查间隔是否为负值</td>
</tr>
<tr>
<td align="center">$isZero$</td>
<td align="center">否</td>
<td align="center">检查间隔是否为零</td>
</tr>
<tr>
<td align="center">$minus$</td>
<td align="center">否</td>
<td align="center">减去一定时间创建间隔副本</td>
</tr>
<tr>
<td align="center">$multipliedBy$</td>
<td align="center">否</td>
<td align="center">将间隔值乘以某个标量创建副本</td>
</tr>
<tr>
<td align="center">$negated$</td>
<td align="center">否</td>
<td align="center">忽略某个时长的方式创建间隔副本</td>
</tr>
<tr>
<td align="center">$plus$</td>
<td align="center">否</td>
<td align="center">增加某个时长的方式创建间隔副本</td>
</tr>
<tr>
<td align="center">$subtractFrom$</td>
<td align="center">否</td>
<td align="center">从指定对象中减去间隔</td>
</tr>
</tbody>
</table>
<h2 id="4-操作日期">4. 操作日期</h2>
<p>        $with$ 方法允许我们创建对象的副本，并按照需要修改它的属性。此外，也可以使用类似于四则运算的方法来创建对象副本。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">withYear</span><span class="o">(</span><span class="n">2011</span><span class="o">);</span> <span class="c1">// 2011-03-18
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date3</span> <span class="o">=</span> <span class="n">date2</span><span class="o">.</span><span class="na">withDayOfMonth</span><span class="o">(</span><span class="n">25</span><span class="o">);</span> <span class="c1">// 2011-03-25
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date4</span> <span class="o">=</span> <span class="n">date3</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTH_OF_YEAR</span><span class="o">,</span> <span class="n">9</span><span class="o">);</span> <span class="c1">// 2011-09-25
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date5</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">plusWeeks</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="c1">// 2014-03-25;
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date6</span> <span class="o">=</span> <span class="n">date5</span><span class="o">.</span><span class="na">minusYear</span><span class="o">(</span><span class="n">3</span><span class="o">);</span> <span class="c1">// 2011-03-25
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date7</span> <span class="o">=</span> <span class="n">date6</span><span class="o">.</span><span class="na">plus</span><span class="o">(</span><span class="n">6</span><span class="o">,</span> <span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTHS</span><span class="o">);</span> <span class="c1">// 2011-09-25
</span></code></pre></div><p>        此外，$LocalDate$ 、$LocalTime$ 、$LocalDateTime$ 以及 $Instant$ 中都提供了大量通用方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">是否为静态方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$from$</td>
<td align="center">是</td>
<td align="center">根据对象创建实例</td>
</tr>
<tr>
<td align="center">$now$</td>
<td align="center">是</td>
<td align="center">根据系统时钟创建实例</td>
</tr>
<tr>
<td align="center">$of$</td>
<td align="center">是</td>
<td align="center">根据对象的某部分创建实例</td>
</tr>
<tr>
<td align="center">$parse$</td>
<td align="center">是</td>
<td align="center">根据字符串创建实例</td>
</tr>
<tr>
<td align="center">$atOffset$</td>
<td align="center">否</td>
<td align="center">将对象和某个时区偏移结合</td>
</tr>
<tr>
<td align="center">$atZone$</td>
<td align="center">否</td>
<td align="center">将对象和某个时区结合</td>
</tr>
<tr>
<td align="center">$format$</td>
<td align="center">否</td>
<td align="center">使用某个格式器将对象转换为字符串（$Instant$ 类不支持）</td>
</tr>
<tr>
<td align="center">$get$</td>
<td align="center">否</td>
<td align="center">读取对象某部分值</td>
</tr>
<tr>
<td align="center">$minus$</td>
<td align="center">否</td>
<td align="center">将对象减去一定时长创建副本</td>
</tr>
<tr>
<td align="center">$plus$</td>
<td align="center">否</td>
<td align="center">将对象加上一定时长创建副本</td>
</tr>
<tr>
<td align="center">$with$</td>
<td align="center">否</td>
<td align="center">对对象某些部分进行修改创建副本</td>
</tr>
</tbody>
</table>
<h2 id="5-temporaladjuster">5. <code>TemporalAdjuster</code></h2>
<p>        $with$ 方法可以接收一个 $TemporalAdjuster$ 对象，允许我们更加灵活地处理日期。对于一些常见的用例，日期和时间<code>API</code>已经提供了大量预定义的 $TemporalAdjuster$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">date1</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">TemporalAdjusters</span><span class="o">.</span><span class="na">nextOrSame</span><span class="o">(</span><span class="n">DayOfWeek</span><span class="o">.</span><span class="na">SUNDAY</span><span class="o">));</span> <span class="c1">// 2014-03-23
</span><span class="c1"></span><span class="n">LocalDate</span> <span class="n">date3</span> <span class="o">=</span> <span class="n">date2</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">TemporalAdjusters</span><span class="o">.</span><span class="na">lastDayOfMonth</span><span class="o">());</span> <span class="c1">// 2014-03-31
</span></code></pre></div><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$dayOfWeekInMonth$</td>
<td align="center">同月份同星期中每周第几天</td>
</tr>
<tr>
<td align="center">$firstDayOfMonth$</td>
<td align="center">当月第一天</td>
</tr>
<tr>
<td align="center">$firstDayOfNextMonth$</td>
<td align="center">下月第一天</td>
</tr>
<tr>
<td align="center">$firstDayOfNextYear$</td>
<td align="center">下年第一天</td>
</tr>
<tr>
<td align="center">$firstDayInMonth$</td>
<td align="center">同月份第一个星期几</td>
</tr>
<tr>
<td align="center">$lastDayOfMonth$</td>
<td align="center">当月最后一天</td>
</tr>
<tr>
<td align="center">$lastDayOfNextMonth$</td>
<td align="center">下月最后一天</td>
</tr>
<tr>
<td align="center">$lastDayOfNextYear$</td>
<td align="center">下年最后一天</td>
</tr>
<tr>
<td align="center">$lastDayOfYear$</td>
<td align="center">今年最后一天</td>
</tr>
<tr>
<td align="center">$lastInMonth$</td>
<td align="center">同月份最后一个星期几</td>
</tr>
<tr>
<td align="center">$next$ / $previous$</td>
<td align="center">之前或之后第一个星期几</td>
</tr>
<tr>
<td align="center">$nextOrSame$ / $previousOrSame$</td>
<td align="center">之前或之后第一个星期几，包括当前日期</td>
</tr>
</tbody>
</table>
<p>        如果预定义的 $TemporalAdjuster$ 不能满足需求，我们可以定义更加复杂的操作，即创建自定义的 $TemporalAdjuster$ 。实际上，$TemporalAdjuster$ 接收是一个函数式接口，只声明了一个方法。我们可以将其视为 $UnaryOperator$&lt;$Temporal$&gt; 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TemporalAdjuster</span> <span class="o">{</span>
    <span class="n">Temporal</span> <span class="nf">adjustInto</span><span class="o">(</span><span class="n">Temporal</span> <span class="n">temporal</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>        由于该接口为函数式接口，所以我们可以通过<code>Lambda</code>表达式进行传递。实现一个计算下一个工作日的 $TemporalAdjuster$ 的例子如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">date</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">temporal</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">DayOfWeek</span> <span class="n">dow</span> <span class="o">=</span> <span class="n">DayOfWeek</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">temporal</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">DAY_OF_WEEK</span><span class="o">));</span>
    <span class="kt">int</span> <span class="n">dayToAdd</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dow</span> <span class="o">==</span> <span class="n">DayOfWeek</span><span class="o">.</span><span class="na">FRIDAY</span><span class="o">)</span> <span class="n">dayToAdd</span> <span class="o">=</span> <span class="n">3</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">dow</span> <span class="o">==</span> <span class="n">DayOfWeek</span><span class="o">.</span><span class="na">SATURDAY</span><span class="o">)</span> <span class="n">dayToAdd</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">temporal</span><span class="o">.</span><span class="na">plus</span><span class="o">(</span><span class="n">dayToAdd</span><span class="o">,</span> <span class="n">ChronoField</span><span class="o">.</span><span class="na">DAYS</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div><p>        $TemporalAdjusters.ofDateAdjuster$ 方法接收一个 $UnaryOperator$&lt;$LocalDate$&gt; 类型的参数，返回一个 $TemporalAdjuster$ 。我们也可以使用该方法利用<code>Lambda</code>表达式创建 $TemporalAdjuster$ 。</p>
<h2 id="6-datetimeformatter">6. <code>DateTimeFormatter</code></h2>
<p>        $java.time.format$ 专门用于格式化以及解析日期-时间对象，而 $DateTimeFormatter$ 类是其中最重要的类。所有的 $DateTimeFormatter$ 实例都能用于以一定的格式创建代表特定日期或时间的字符串。此外，在解析过程中也可以通过指定格式的形式使用不同的字符串创建日期。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">BASIC_ISO_DATE</span><span class="o">);</span> <span class="c1">// 20140318
</span><span class="c1"></span><span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ISO_LOCAL_DATE</span><span class="o">);</span> <span class="c1">// 2014-03-18
</span><span class="c1"></span>
<span class="n">LocalDate</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;20140318&#34;</span><span class="o">,</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">BASIC_ISO_DATE</span><span class="o">);</span>
<span class="n">LocalDate</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">&#34;2014-03-18&#34;</span><span class="o">,</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ISO_LOCAL_DATE</span><span class="o">);</span>
</code></pre></div><p>        除了使用已经定义好的格式外，通过 $ofPattern$ 方法，我们也可以自定义格式。$ofPattern$ 还提供了一个重载版本，允许我们创建某个 $Locale$ 的格式器。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DateTimeFormatter</span> <span class="n">formatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">&#34;dd/MM/yyyy&#34;</span><span class="o">);</span>
<span class="n">DateTimeFormatter</span> <span class="n">italianFormatter</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">&#34;d. MMMM yyyy&#34;</span><span class="o">,</span> <span class="n">Locale</span><span class="o">.</span><span class="na">ITALIAN</span><span class="o">);</span>
</code></pre></div><p>        如果需要更加细粒度的控制，$DateTimeFormatter$ 还提供了更复杂的格式器。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DateTimeFormatter</span> <span class="n">italianFormatter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DateTimeFormatterBuilder</span><span class="o">()</span>
                                        <span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">DAY_OF_MONTH</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendLiteral</span><span class="o">(</span><span class="s">&#34;. &#34;</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">MONTH_OF_YEAR</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendLiteral</span><span class="o">(</span><span class="s">&#34; &#34;</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">appendText</span><span class="o">(</span><span class="n">ChronoField</span><span class="o">.</span><span class="na">YEAR</span><span class="o">)</span>
                                        <span class="o">.</span><span class="na">parseCaseInsensitive</span><span class="o">()</span>
                                        <span class="o">.</span><span class="na">toFormatter</span><span class="o">(</span><span class="n">Locale</span><span class="o">.</span><span class="na">ITALIAN</span><span class="o">);</span>
</code></pre></div><p>        相较于 $java.util.DateFormat$ ，所有的 $DateTimeFormatter$ 都是线程安全的，所以可以以单例模式创建格式器实例，并在多个线程之间共享。</p>
<h2 id="7-时区和历法">7. 时区和历法</h2>
<p>        $java.time.ZoneId$ 类是老版的 $java.util.TimeZone$ 的替代品，与其他日期和时间类一样，它也是无法修改的。$ZoneRules$ 类中包含了 $40$ 个实例，可以通过 $ZoneId.getRules(\ )$ 可以获取指定时区的规则。每个特定的 $ZoneId$ 对象都由一个<code>ID</code>标识。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ZoneId</span> <span class="n">romeZone</span> <span class="o">=</span> <span class="n">ZoneId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;Europe/Rome&#34;</span><span class="o">);</span>
</code></pre></div><p>        <code>Java 8</code>中为 $TimeZone$ 提供了一个新方法 $toZoneId$ ，通过该方法，我们可以将一个老时区对象转换为 $ZoneId$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ZoneId</span> <span class="n">zoneId</span> <span class="o">=</span> <span class="n">TimeZone</span><span class="o">.</span><span class="na">getDefault</span><span class="o">().</span><span class="na">toZoneId</span><span class="o">();</span>
</code></pre></div><p>        一旦得到 $ZoneId$ ，我们就可以将其与 $LocalDate$ 、$LocalDateTime$ 或者是 $Instant$ 结合，构造为一个 $ZonedDateTime$ 实例。通过 $ZoneId$ ，我们还可以实现 $LocalDateTime$ 和 $Instant$ 之间的互相转换。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">ZonedDateTime</span> <span class="n">zdt1</span> <span class="o">=</span> <span class="n">date</span><span class="o">.</span><span class="na">atStartOfDay</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>

<span class="n">LocalDateTime</span> <span class="n">dateTime</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">,</span> <span class="n">13</span><span class="o">,</span> <span class="n">45</span><span class="o">);</span>
<span class="n">ZonedDateTime</span> <span class="n">zdt2</span> <span class="o">=</span> <span class="n">dateTime</span><span class="o">.</span><span class="na">atZone</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>

<span class="n">Instant</span> <span class="n">instant</span> <span class="o">=</span> <span class="n">Instant</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
<span class="n">ZonedDateTime</span> <span class="n">zdt3</span> <span class="o">=</span> <span class="n">instant</span><span class="o">.</span><span class="na">atZone</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>

<span class="n">Instant</span> <span class="n">instantFromDateTime</span> <span class="o">=</span> <span class="n">dateTime</span><span class="o">.</span><span class="na">toInstant</span><span class="o">(</span><span class="n">romeZone</span><span class="o">);</span>
<span class="n">LocalDateTime</span> <span class="n">timeFromInstant</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">ofInstant</span><span class="o">(</span><span class="n">instant</span><span class="o">,</span> <span class="n">romeZone</span><span class="o">);</span>
</code></pre></div><p>        另一种比较通用的表示时区的方式是利用当前时区和<code>UTC</code>/格林尼治的固定偏差，我们可以通过 $of$ 方式创建。要注意，使用这种方式定义的 $ZoneOffset$ 并未考虑任何日光时的影响，所以在大部分情况下不推荐使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ZoneOffset</span> <span class="n">newYorkOffset</span> <span class="o">=</span> <span class="n">ZoneOffset</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;-05:00&#34;</span><span class="o">);</span>
</code></pre></div><p>        虽然<code>ISO-8601</code>日历系统是世界文明日历系统的事实标准。但是<code>Java 8</code>中另外还提供了 $4$ 种其他的日历系统，这些日历系统中的每一个都有一个对应的日志类，分别是 $ThaiBuddhistDate$ 、$MinguoDate$ 、$JapaneseDate$ 以及 $HijrahDate$ 。所有这些类以及 $LocalDate$ 都实现了 $ChronoLocalDate$ 接口，能够对公历的日期进行建模。我们可以通过 $from$ 方法从 $LocalDate$ 中创建，或者先创建一个日历系统，接着再创建该日期实例。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="n">LocalDate</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">2014</span><span class="o">,</span> <span class="n">Month</span><span class="o">.</span><span class="na">MARCH</span><span class="o">,</span> <span class="n">18</span><span class="o">);</span>
<span class="n">JapaneseDate</span> <span class="n">japaneseDate</span> <span class="o">=</span> <span class="n">JapaneseDate</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">date</span><span class="o">);</span>

<span class="n">Chronology</span> <span class="n">japaneseChronology</span> <span class="o">=</span> <span class="n">Chronology</span><span class="o">.</span><span class="na">ofLocale</span><span class="o">(</span><span class="n">Locale</span><span class="o">.</span><span class="na">JAPAN</span><span class="o">);</span>
<span class="n">ChronoLocalDate</span> <span class="n">now</span> <span class="o">=</span> <span class="n">japaneseChronology</span><span class="o">.</span><span class="na">dateNow</span><span class="o">();</span>
</code></pre></div><p>        日期及时间<code>API</code>的设计者建议使用第一种方式进行创建，因为开发者在代码中可能会进行一些假设，但这些假设在不同的日历系统中有可能不成立，比如一个月最多有 $31$ 天，一年有 $12$ 个月等。除非需要将程序的输入或者输出本地化，否则不要使用 $ChronoLocalDate$ 类。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Feb 18 18:39</span> <a href="/post/java-8%E5%AE%9E%E6%88%98%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4api/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/java-8%E5%AE%9E%E6%88%98%E6%B5%81%E5%A4%84%E7%90%86/">Java 8实战：流处理</a></h1>
            </center>
            <div class="post-content">
                <p>        <code>流</code>是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流。基于<code>流</code>的思想，<code>Java 8</code>在 $java.util.stream$ 中添加了一个<code>Stream API</code>。 $Stream$&lt;$T$&gt; 就是一系列 $T$ 类型的项目。<br/>
        和<code>Collection API</code>相比，<code>Stream API</code>处理数据的方式非常不同。用集合的话，需要使用 $for$ 循环迭代并处理元素，我们称之为<code>外部迭代</code>。相反，<code>Stream API</code>的数据处理完全是在库内部进行的，我们称之为<code>内部迭代</code>。虽然都能访问数据项目的序列，但是相比之下，<code>Collection API</code>主要是为了存储和访问数据，而<code>Stream API</code>主要用于描述对数据的计算。这里的关键点在于，<code>Stream API</code>允许并行处理一个 $Stream$ 中的元素。筛选一个 $Collection$ 最快的方式通常是将其转换为 $Stream$ ，进行并行处理，再转换回 $List$ 。粗略地说，流与集合之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，包含数据结构中目前所有的值，集合中的元素只有经过计算后才能添加；相比之下，流是在概念上固定的数据结构，不能通过流添加或删除元素，流中的元素是按需计算的，即只从流中提取出需要的值。与迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。要想重新遍历，可以从原始数据源中重新获取一个新的流。尝试再次遍历一个已经消费的流会抛出 $IllegalStateException$ 异常。流与集合的另一个关键区别在于遍历数据的方式，正如之前所说，使用 $Collection$ 接口需要用户进行外部迭代，而 $Steams$ 库使用的是内部迭代，即库自动完成迭代，并将流值存放在某个地方。相较于显式的外部迭代，内部迭代下项目可以透明地并行处理，或者用更优化的顺序进行处理，例如同时处理多个数据，或者优先处理某些数据等。<br/></p>
<h2 id="1-流操作">1. 流操作</h2>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">类型</th>
<th align="center">返回类型</th>
<th align="center">操作参数</th>
<th align="center">函数描述符</th>
<th align="center">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$filter$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$T$&gt;</td>
<td align="center">$Predicate$&lt;$T$&gt;</td>
<td align="center">$T \rightarrow boolean$</td>
<td align="center">返回一个包含所有符合谓词的元素的流</td>
</tr>
<tr>
<td align="center">$distinct$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$T$&gt;</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回一个元素各异的流</td>
</tr>
<tr>
<td align="center">$map$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$R$&gt;</td>
<td align="center">$Function$&lt;$T, R$&gt;</td>
<td align="center">$T \rightarrow R$</td>
<td align="center">将函数应用到每个元素上，并映射成一个新元素</td>
</tr>
<tr>
<td align="center">$flatMap$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$R$&gt;</td>
<td align="center">$Function$&lt;$T,R$&gt;</td>
<td align="center">$T \rightarrow R$</td>
<td align="center">将多个生成流扁平化为单个流</td>
</tr>
<tr>
<td align="center">$limit$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$T$&gt;</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回一个不超过给定长度的流</td>
</tr>
<tr>
<td align="center">$skip$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$T$&gt;</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回一个跳过给定数量元素的流</td>
</tr>
<tr>
<td align="center">$sorted$</td>
<td align="center">中间</td>
<td align="center">$Stream$&lt;$T$&gt;</td>
<td align="center">$Comparator$&lt;$T$&gt;</td>
<td align="center">$(T, T) \rightarrow int$</td>
<td align="center">返回一个经过排序的流</td>
</tr>
<tr>
<td align="center">$forEach$</td>
<td align="center">终端</td>
<td align="center">$void$</td>
<td align="center">$Consumer$&lt;$T$&gt;</td>
<td align="center">$T \rightarrow void$</td>
<td align="center">消费流中的每一个元素并对其应用<code>Lambda</code>，返回类型为 $void$</td>
</tr>
<tr>
<td align="center">$count$</td>
<td align="center">终端</td>
<td align="center">$long$</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回流中元素的个数，返回类型为 $long$</td>
</tr>
<tr>
<td align="center">$collect$</td>
<td align="center">终端</td>
<td align="center">$R$</td>
<td align="center">$Collector$&lt;$T, A, R$&gt;</td>
<td align="center"></td>
<td align="center">把流归约成一个集合并返回</td>
</tr>
<tr>
<td align="center">$anyMatch$</td>
<td align="center">终端</td>
<td align="center">$boolean$</td>
<td align="center">$Predicate$&lt;$T$&gt;</td>
<td align="center">$T \rightarrow boolean$</td>
<td align="center">流中是否含有一个元素能匹配给定的谓词</td>
</tr>
<tr>
<td align="center">$allMatch$</td>
<td align="center">终端</td>
<td align="center">$boolean$</td>
<td align="center">$Predicate$&lt;$T$&gt;</td>
<td align="center">$T \rightarrow boolean$</td>
<td align="center">流中的元素是否都能匹配给定的谓词</td>
</tr>
<tr>
<td align="center">$noneMatch$</td>
<td align="center">终端</td>
<td align="center">$boolean$</td>
<td align="center">$Predicate$&lt;$T$&gt;</td>
<td align="center">$T \rightarrow boolean$</td>
<td align="center">流中是否没有元素与给定的谓词匹配</td>
</tr>
<tr>
<td align="center">$findAny$</td>
<td align="center">终端</td>
<td align="center">$Optional$&lt;$T$&gt;</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回当前流中的任意元素</td>
</tr>
<tr>
<td align="center">$findFirst$</td>
<td align="center">终端</td>
<td align="center">$Optional$&lt;$T$&gt;</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">返回当前流中第一个元素</td>
</tr>
<tr>
<td align="center">$reduce$</td>
<td align="center">终端</td>
<td align="center">$Optional$&lt;$T$&gt;</td>
<td align="center">$BinaryOperator$&lt;$T$&gt;</td>
<td align="center">$(T, T) \rightarrow T$</td>
<td align="center">对流中元素重复应用方法</td>
</tr>
</tbody>
</table>
<p>        诸如 $filter$ 或 $Sorted$ 等操作会返回另一个流，这让多个操作可以连接起来形成一个查询，这种操作称为<code>中间操作</code>。除非流水线上触发一个终端操作，否则中间操作不会执行任何处理。<code>终端操作</code>会从流的流水线生成结果，其结果是任何不是流的值，比如 $List$ 、$Integer$ 等。总而言之，流的使用一般包括三件事：一个数据源、一个中间操作链和一个终端操作。<br/>
        诸如 $map$ 或 $filter$ 等操作会从输入流中获取每一个元素，并在输出流中得到 $0$ 或 $1$ 个结果。这些操作一般都是<code>无状态操作</code>。但诸如 $reduce$ 、$sum$ 、$max$ 等操作需要内部状态来累计结果，这些操作就是<code>有状态操作</code>。但是这些操作的内部状态很小，通常只是一些基本数据类型，不管流中有多少元素需要处理，内部状态都是有界的。而诸如 $sorted$ 或 $distinct$ 等操作，它们的内部状态可能很大，这时就要求无界的存储空间。<br/>
        $peek$ 是一个特殊的流操作，可以在流的每个元素恢复运行之前，插入执行一个动作。$peek$ 不会恢复流的运行，而是在一个元素上完成操作之后，将操作顺承到流水线中的下一个操作。<br/>
        <code>Java 8</code>引入了三个原始类型特化流接口 $IntStream$ 、$DoubleStream$ 和 $LongStream$ ，分别将流中的元素特化为 $int$ 、$long$ 和 $double$ ，从而避免了暗含的装箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的 $sum$ ，此外还可以在必要时将它们转换回对象流。将流转换为特化版本的常用方法是 $mapToInt$ 、$mapToDouble$ 和 $mapToLong$ 。这些方法和 $map$ 的工作方式一样，但是会返回特化流。如果想要将特化流转换为对象流，可以使用 $boxed$ 方法。类似的，也可以使用 $mapToObj$ 方法生成对象流。<br/>
        <code>Java 8</code>还引入了两个可以用于 $IntStream$ 和 $LongStream$ 的静态方法，帮助生成数值范围，分别是 $range$ 和 $rangeClosed$ ，前者为开区间，后者为闭区间。<br/>
        除了调用集合中的 $stream$ 方法之外，还有一些其他的构造流的方式：</p>
<ul>
<li>$Stream.of$ ：通过显式值创建一个流；</li>
<li>$Arrays.stream$ ：从数组创建一个流；</li>
<li>$Files.lines$ ：由指定文件中的各行构成的字符串流；</li>
<li>$Stream.iterate$ ：从函数创建一个无限流，接收一个初始值；</li>
<li>$Stream.generate$ ：接收一个 $Supplier$&lt;$T$&gt; 类型参数，创建一个无限流；</li>
<li>$Stream.empty$ ：创建一个空流。</li>
</ul>
<h2 id="2-optional">2. <code>Optional</code></h2>
<p>        $Optional$ 是<code>Java 8</code>中引入的一个新类。当变量存在时，$Optional$ 只是对类的简单封装。变量不存在时，缺失的值会被建模成一个空的 $Optional$ 对象，由方法 $Optional.empty(\ )$ 返回，该方法为一个静态工厂方法，返回 $Optional$ 类的特定单一实例。引入 $Optional$ 的意图并非要消除每一个 $null$ 引用，其目的是帮助设计出一个更加普适的<code>API</code>。$Optional$ 提供了几种可以迫使你显式地检查值是否存在或处理值不存在的情形的方法：</p>
<ul>
<li>$isPresent(\ )$ ：包含值时返回 $true$ ；</li>
<li>$isPresent(Consumer$&lt;$T$&gt; $block)$ ：值存在时执行给定代码块；</li>
<li>$get(\ )$ ：值存在时返回值，否则抛出 $NoSuchElement$ 异常；</li>
<li>$orElse(T\ other)$ ：值存在时返回值，否则返回默认值；</li>
<li>$orElsetGet(Supplier$&lt;$?\ extends\ T$&gt; $other)$ ：当值不存在时会调用 $Supplier$ 对象并返回；</li>
<li>$orElseThrow(Supplier$&lt;$?\ extends\ X$&gt; $exceptionSupplier)$ ：当值不存在时会抛出 $Supplier$ 指定的异常类型；</li>
<li>$ifPresent(Consumer$&lt;$?\ super\ T$&gt;$)$ ：能在变量值存在时执行一个作为参数传入的方法，否则不进行任何操作。</li>
</ul>
<p>        创建 $Optional$ 对象的方式很简单，可以通过 $Optional.empty(\ )$ 声明一个空的 $Optional$ 对象，也可以通过 $Optional.of(\ )$ 方法通过一个非空值创建对象。如果不知道传入的对象是否为空值，可以使用 $Optional.ofNullable(\ )$ 方法，使用该方法构造的对象如果参数为 $null$ ，那么会返回一个空的 $Optional$ 对象。<br/>
        一般情况下，当我们访问一个可以为空的对象值前，需要先判断其是否为空。$Optional.map(\ )$ 方法会将提供的函数应用于当前值，如果当前 $Optional$ 非空，那么将该值作为参数传递给 $map$ ，反之则什么也不做。如果在一个对象上连续多次调用 $map$ 方法，可能会出现嵌套式的 $Optional$ 对象，此时我们可以使用 $Optional.flatMap(\ )$ 方法。类似于流，该方法将嵌套式的 $Optional$ 对象合并为一个。<br/>
        当需要调用某个对象的方法，查看某些属性时，可以使用 $filter$ 方法。该方法接受一个谓词作为参数，如果对象值存在并且符合谓词条件，$filter$ 就不做任何改变，否则就返回一个空的 $Optional$ 对象。<br/>
        与 $Stream$ 一样，$Optional$ 也提供了类似的基础类型 $OptionalInt$ 、$OptionalLong$ 以及 $OptionalDouble$ 。对于 $Stream$ 而言，因为其中可能包含大量的元素，出于性能考虑，我们最好使用基础类型。但对于只有单个元素的 $Optional$ ，这个理由就不成立了。基础类型的 $Optional$ 并不支持 $map$ 、$flatMap$ 以及 $filter$ 方法，同时也不能作为方法引用传递给另一个 $flatMap$ 方法，所以并不推荐使用。</p>
<h2 id="3-collector">3. <code>Collector</code></h2>
<p>        $Collector$ 用于定义 $collect$ 方法用来生成结果集合的标准。更具体地说，对流调用 $collect$ 方法将对流中的元素触发一个归约操作。一般来说，$Collector$ 会对元素应用一个转换函数，并将结果累积在一个数据结构中。$Collector$ 接口中方法的实现决定了如何对流执行归约操作， 而 $Collectors$ 实用类中提供了很多静态工厂方法，可以方便地创建常见收集器的实例：</p>
<ul>
<li>$toList$ ：把流中的所有项目收集到一个 $List$ ；</li>
<li>$toSet$ ：把流中的所有项目收集到一个 $Set$ ，删除重复项；</li>
<li>$toCollection$ ：把流中所有项目收集到给定的供应源创建的集合，需要额外指定一个集合创建方法；</li>
<li>$counting$ ：返回流中元素个数，更直接地，也可以使用 $Stream.count$ 方法；</li>
<li>$maxBy$ ：接收一个 $Comparator$ ，返回流中最大值；</li>
<li>$minBy$ ：接收一个 $Comparator$ ，返回流中最小值；</li>
<li>$summingInt$ / $summingLong$ / $summingDouble$ ：接收一个把对象映射为 $int$ / $long$ / $double$ 的函数，并返回总和；</li>
<li>$averagingInt$ / $averagingLong$ / $averagingDouble$ ：接收一个把对象映射为 $int$ / $long$ / $double$ 的函数，并返回平均值；</li>
<li>$summarizingInt$ / $summarizingLong$ / $summarizingDouble$ ：接收一个把对象映射为 $int$ / $long$ / $double$ 的函数，并返回一个 $IntSummaryStatistics$ / $LongSummaryStatistics$ / $DoubleSummaryStatistics$ 对象，包含流中元素个数、最大值、最小值、总和和平均值信息；</li>
<li>$joining$ ：对流中的每一个对象应用 $toString$ 方法，并将结果串连成一个字符串，允许接收一个分界符；</li>
<li>$groupingBy$ ：接收两个函数，前者为键值分类函数，后者为收集器类型的收集函数，并返回一个 $Map$ ，其中第二个参数可以省略，默认为 $groupingBy(f,\ toList(\ ))$ ；</li>
<li>$partitionBy$ ：接收一个 $Predicate$&lt;$T$&gt; 类型参数和一个转换函数，返回一个键值为 $Boolean$ 的 $Map$ ，其中第二个参数可以省略，默认为 $partitionBy(f,\ toList(\ ))$ ；</li>
</ul>
<p>        $reducing$ 方法允许定义一个更一般化的归约过程，它接收三个参数：初始值、转换函数和一个 $BinaryOperator$ ，用于将两个项目累积成一个同类型的值。此外还有一个单参数类型的重载版本，只接收一个 $BinaryOperator$ ，以第一个项目作为起点，把恒等函数作为转换函数。<br/>
        在收集的时候，由于调用的方法的原因，可能会返回 $Optional$ 类型的参数，而这往往不是我们想要的，这时候就可以使用 $collectingAndThen$ 方法，可以额外接收一个转换函数，将 $Optional$ 类型进行转换。<br/>
        如果要自定义收集器，需要使用 $Collector$ 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">supplier</span><span class="o">();</span>
    <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nf">accumulator</span><span class="o">();</span>
    <span class="n">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="nf">finisher</span><span class="o">();</span>
    <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">combiner</span><span class="o">();</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="nf">characteristics</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>        其中 $T$ 是流要收集的项目的泛型，$A$ 是累加器的类型，$R$ 是收集操作得到的对象的类型。$supplier$ 方法返回一个结果为空的 $Supplier$ ，创建一个空的累加器实例；$accumulator$ 方法返回执行归约操作的函数；$finisher$ 方法返回在累积过程的最后调用的函数，以便将累加器对象转换为整个集合操作的最终结果；$combiner$ 方法返回一个供归约操作使用的函数，定义了对流的各个子部分进行并行处理时如何合并累加器结果；$characteristics$ 方法会返回一个不可变的 $Characteristics$ 集合，定义了收集器的行为，是一个包含了三个项目的枚举：$UNORDERED$ ( 结果不受流中项目的遍历和累计顺序的影响 )、$CONCURRENT$ ( $accumulator$ 可以多线程调用 )、$IDENTITY_-FINISH$ ( $finisher$ 返回恒等函数，可以跳过 )。以下为 $ToListCollector$ 类型实例，它将流转换为 $List$ ：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ToListCollector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">supplier</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">ArrayList</span><span class="o">::</span><span class="k">new</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nf">accumulator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">List</span><span class="o">::</span><span class="n">add</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">finisher</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">();</span> <span class="c1">// 恒等函数
</span><span class="c1"></span>    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">combiner</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">list1</span><span class="o">,</span> <span class="n">list2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">list1</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">list2</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">list1</span><span class="o">;</span>
        <span class="o">};</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="nf">characteristics</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span>
            <span class="n">EnumSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Characteristics</span><span class="o">.</span><span class="na">IDENTITY_FINISH</span><span class="o">,</span> <span class="n">Characteristics</span><span class="o">.</span><span class="na">CONCURRENT</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        除了实现 $Collector$ 之外，自定义收集操作也可以通过调用一个重载版本的 $collect$ 方法完成。该方法接收 $supplier$ 、$accumulator$ 和 $combiner$ 三个函数，并且永远都是一个 $IDENTITY_-FINISH$ 和 $CONCURRENT$ 但非 $UNORDERED$ 的收集器。</p>
<h2 id="4-并行流">4. 并行流</h2>
<p>        <code>并行流</code>就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。通过对收集源调用 $parallelStream$ 方法，可以把集合转换为并行流。也可以通过在顺序流上调用 $parallel$ 方法来转换为并行流，调用该方法后流本身并不会有任何实际的变化，在内部实际上只设置了一个 $boolean$ 标志位。类似的，也可以在并行流上调用 $sequential$ 方法来将它转换为顺序流。<br/>
        并行化的过程本身需要对流做递归划分，把每个子流的归纳操作分配到不同的线程，然后把这些操作的结果合并成一个值。但在多个内核之间移动数据的代价也可能很大，所以很重要的一点是要保证在内核中并行执行工作的时间比在内核之间传输数据的时间长。总而言之，很多情况下不可能或不方便并行化。一般而言，想给出任何关于什么时候该用并行流的定量建议都是不可能也毫无意义的。</p>
<ul>
<li>在将顺序流转换为并行流时，对于存在疑问的转换，可以先测试；</li>
<li>自动装箱和拆箱操作会大大降低性能，对于存在大量这种操作的流，应该尽可能地使用原始类型特化流；</li>
<li>有些操作例如 $limit$ 和 $findFirst$ 等依赖于元素顺序的操作，在并行流上的性能就比顺序流差；</li>
<li>对于处理成本较高的操作，使用并行流时性能更好的可能性较大；</li>
<li>避免使用并行流处理数据量较小的集合；</li>
<li>考虑流背后的数据结构是否易于分解，例如 $ArrayList$ 、$range$ 、$HashSet$ 的拆分效率较好，而 $LinkedList$ 、$iterate$ 的拆分效率则很差；</li>
<li>考虑流自身的特点和流水线中间操作修改流的方式，例如筛选操作丢弃的元素个数无法预测，因而难以将流划分为大小近似的部分；</li>
<li>考虑终端操作中合并代价，避免合并代价大于使用并行流带来的性能提升。</li>
</ul>
<p>        并行流的背后使用的是<code>Java 7</code>中引入的<code>分支/合并框架</code>，目的是以递归方式将可以并行的任务拆分成更小的任务，然后把每个子任务的结果合并起来生成整体结果。它是 $ExecutorService$ 接口的一个实现，它把子任务分配给线程池 ( 称为 $ForJoinPool$ ) 中的工作线程。<br/>
        要把任务提交到该线程池，必须创建 $RecursiveTask$&lt;$R$&gt;的一个子类，其中 $R$ 是并行化任务产生的结果，如果任务不返回结果，则是 $RecursiveTask$ 类型。要定义 $RecursiveTask$ ，只需要实现它唯一的抽象方法 $compute$ 。$compute$ 方法定义了将任务拆分为子任务的逻辑，以及无法再拆分或不方便再拆分时生成单个子任务结果的逻辑。一般来说并没有确切的标准决定一个任务是否应该再拆分。分支/合并框架中使用了<code>工作窃取</code> ( $work\ stealing$ ) 技术，每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列中取出下一个任务，提前完成了队列中的所有任务，则会随机选择一个其他线程的队列，从中获取任务。由于工作窃取，因此将原任务分为大量的小任务一般来说都是一个好的选择。<br/>
        $Spliterator$ 是 <code>Java 8</code>中加入的另一个新接口，用于并行遍历数据源中的元素。同时<code>Java 8</code>为集合框架中包含的所有数据结构提供了一个默认的 $Spliterator$ 实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>
    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">trySplit</span><span class="o">();</span>
    <span class="kt">long</span> <span class="nf">estimateSize</span><span class="o">();</span>
    <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>        $tryAdvance$ 的行为类似于普通的 $Iterator$ ，它会按顺序依次遍历使用 $Spliterator$ 的元素，并且如果还有其他元素需要遍历则返回 $true$ 。$trySplit$ 可以将一些元素划分给另一个 $Spliterator$ ，让它们两并行处理，将 $Stream$ 拆分为多个部分的算法是一个递归过程，即不断地调用 $trySplit$ 方法直到不可划分。$estimateSize$ 方法用于估计剩余的需要遍历的元素个数，对于已知大小的源，这个数字是准确的。<br/></p>

            </div>
            <div class="meta post-footer"> <span>2021 Feb 17 18:00</span> <a href="/post/java-8%E5%AE%9E%E6%88%98%E6%B5%81%E5%A4%84%E7%90%86/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
        if (tocFlag) tocInit();
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>