<!DOCTYPE html>
<html lang="zh-CN"><head>
	<meta name="generator" content="Hugo 0.121.2">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="z217&#39;s blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/jquery.floatingscroll.css>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  <script src=https://z217blog.cn/js/jquery.floatingscroll.min.js></script>
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/navbutton.js></script>
<script src=https://z217blog.cn/js/lightswitcher.js></script>
<script src=https://z217blog.cn/js/toc.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>
        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a><br/>
        <a href="javascript:void(0)" id="scroll-top" onclick="scrollToTop()">回到顶部</a>
        <a href="javascript:void(0)" id="light-switcher">暗色模式</a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/">C&#43;&#43;协程（2）：理解co_await</a>
        
        
        <p>无栈协程介绍，翻译自 https://lewissbaker.github.io/</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2024 Jan 25 00:00
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&amp;C&#43;&#43;
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/">C&#43;&#43;协程（1）：协程理论</a>
        
        
        <p>无栈协程介绍，翻译自 https://lewissbaker.github.io/</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2024 Jan 23 23:59
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&amp;C&#43;&#43;
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">分布式数据系统：共识算法</a>
        
        
        <p>数据密集型应用系统设计：分布式事务与共识</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Nov 13 16:18
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Arch
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9/">分布式数据系统：主从节点</a>
        
        
        <p>数据密集型应用系统设计：分布式数据系统</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Nov 06 15:24
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Arch
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/cpptemplates6/">C&#43;&#43; Templates（6）：模版实践与泛型库</a>
        
        
        <p>《C&#43;&#43; Templates》读书笔记（6），个人翻译</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Mar 14 15:57
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&amp;C&#43;&#43;
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/">C&#43;&#43;协程（2）：理解co_await</a></h1>
            <div class="post-content">
                
                
                <p>        在之前的文章中，我介绍了函数和协程在高级表现的区别，但还没有讲到到<code>C++</code>协程标准的语法和语义。<br>
        <code>C++</code>协程标准提供的一个关键能力是暂停协程，并在之后恢复。这个机制是通过 $co_-await$ 提供的。<br>
        在揭开协程的神秘面纱前，我们需要理解 $co_-await$ 的工作方式，了解它是如何暂停和恢复协程的。在这篇文章中，我会解释 $co_-await$ 的机制，并介绍<strong>Awaitable</strong>与<strong>Awaiter</strong>的概念。<br>
        在这之前，作为背景，我想先简单回顾下协程标准。</p>
<h2 id="协程标准带来了什么">协程标准带来了什么？</h2>
<ul>
<li>三个关键字 $co_-await$ ，$co_-yield$ 和 $co_-return$</li>
<li>一些 $std$::$experimental$ 命名空间的新类型：
<ul>
<li>$coroutine_-handle$&lt;$P$&gt;</li>
<li>$coroutine_-traits$&lt;$Ts$&hellip;&gt;</li>
<li>$suspend_-always$</li>
<li>$suspend_-never$</li>
</ul>
</li>
<li>一种允许库开发者与协程交互、客制化行为的机制</li>
<li>一个让异步代码更容易编写的语言能力</li>
</ul>
<p>        <code>C++</code>协程标准可以认为在语言层面提供了一个低级汇编语言协程。这些功能很难以一种安全的方式直接使用，主要是提供给库开发者来实现高级抽象，从而应用开发者可以安全使用。<br>
        之后的语言标准 ( 希望是<code>C++20</code> ) 计划加入这些低级功能，同时让标准库提供一些包装了这些功能的高级类型，让应用开发者以更方便安全的方式使用。</p>
<h2 id="编译器-lt-gt-库交互">编译器 &lt;-&gt; 库交互</h2>
<p>        有趣的是，协程标准并没有明确定义协程语义，包括协程如何把值返回给主调，$co_-return$ 如何处理返回值，如何处理传播到协程之外的异常，以及协程应该在哪个线程恢复。<br>
        相反的，它指定了一种可以让库代码客制化协程行为的机制，通过实现特定的接口类型。编译器使用库代码生成对应的调用。这种方式很像<code>range</code>模式，后者可以让库开发者通过定义 $begin\left(\right)$ / $end\left(\right)$ 和 $iterator$ 类型，来客制化代码。<br>
        协程的这种没有给机制定义特殊语义的方式，让它变成了一个强大的工具，允许库开发者实现各种类型的协程，以各种方式，出于各种目的。<br>
        例如，你可以实现一个异步生成单个值的协程，或者一个 $Lazy$ 生成值序列的协程，或者一个遇到 $nullopt$ 就提前退出的，简化 $optional$&lt;$T$&gt; 值的协程。<br>
        协程标准定义了两个接口：$Promise$ 和 $Awaitable$ 。<br>
        $Promise$ 接口指定了协程客制化行为的方法。库开发者可以通过该接口，实现当协程被调用时的行为，协程返回时的行为 ( 包括正常返回和抛出未处理异常 )，协程内使用 $co_-await$ 或者 $co_-yield$ 的行为。<br>
        $Awaitable$ 接口指定控制 $co_-await$ 语义的方法。当一个值是可以 $co_-await$ 的，代码就会被翻译成一系列的对 $awaitable$ 对象方法的调用。这个对象可以决定是否暂停当前协程，在暂停前执行一些逻辑用于后续的恢复，以及在恢复后生成 $co_-await$ 表达式的值。<br>
        我会在之后的文章再介绍 $Promise$ ，现在先来看看 $Awaitable$ 接口。</p>
<h2 id="awaiter和-awatiable解释co_await">Awaiter和 Awatiable：解释<code>co_await</code></h2>
<p>        $co_-await$ 运算符是一个新的一元运算符，接收一个值，比如：$co_-await$ $someValue$ 。<br>
        $co_-await$ 运算符只能在协程上下文中使用。这有一点重言了，因为根据定义，包含 $co_-await$ 操作符的函数都应该被编译成协程。<br>
        支持 $co_-await$ 运算符的类型被叫做 $Awaitable$ 类型。<br>
        注意，$co_-await$ 运算符能否对一个类型使用，取决于 $co_-await$ 出现的协程上下文。协程使用的 $promise$ 类型可以通过 $await_-transform$ 方法 ( 之后介绍 )，决定 $co_-await$ 的语义。<br>
        为了更精确，我喜欢使用术语<strong>一般 Awaitable</strong> ( $Normally$ $Awaitable$ ) 来描述一个协程上下文的 $promise$ 类型没有 $await_-transform$ 方法且支持 $co_-await$ 的协程。使用术语<strong>上下文 Awaitable</strong>来描述一个协程上下文的 $promise$ 类型存在 $await_-transform$ 方法的协程，这种类型仅在某些特别的上下文中才支持 $co_-await$ 运算符。<br>
        一个<strong>Awaiter</strong>类型实现了 $co_-await$ 调用会时使用到的三个方法：$await_-ready$ ，$await_-suspend$ 和 $await_-resume$ 。<br>
        注意我不要脸地从<code>C#</code> <code>asnyc</code>关键字中“借了” $Awaiter$ 这个术语。<code>C#</code>中这个术语指代可以通过 $GetAwaiter\left(\right)$ 方法返回类似于<code>C++</code> $Awaiter$ 对象的类型，而<code>C#</code>的 $Awaiter$ 也与<code>C++</code>有着诡异的相似，具体可以看<a href="https://weblogs.asp.net/dixin/understanding-c-sharp-async-await-2-awaitable-awaiter-pattern">这篇文章</a>。<br>
        注意一个类型既可以是 $Awaitable$ 类型，也可以是 $Awaiter$ 类型。<br>
        当编译器看到 $co_-awaiter$&lt;$expr$&gt; 表达式时，根据类型的不同，可能会有多种行为。</p>
<h3 id="获取-awaiter">获取 Awaiter</h3>
<p>        编译器要做的第一件事就是生成从挂起对象上获取 $Awaiter$ 对象的代码。$N4680$ 在 $5.3.8\left(3\right)$ 小节中列出了一系列的获取 $awaiter$ 的步骤。<br>
        假设挂起协程的 $promise$ 类型是 $P$ ，并且 $promise$ 在当前协程中是一个左值引用。<br>
        如果 $promise$ 类型 $P$ ，存在 $await_-transform$ 方法，&lt;$expr$&gt; 会被传入 $promise$.$await_-transform$(&lt;$expr$&gt;) 调用来获取 $Awaitable$ 值，记为 $awaitable$ 。相反，如果 $promise$ 类型没有 $await_-transform$ 成员，我们会直接使用 &lt;$expr$&gt; 来作为 $Awaitable$ 对象，同样记为 $awaitable$ 。<br>
        然后，如果 $Awaitable$ 对象 $awaitable$ 重载了 $operator$ $co_-awaiter\left(\right)$ ，那么这个函数就会被调用，来获取 $Awaiter$ 对象。否则，$awaitable$ 会被直接作为 $awaiter$ 对象使用。<br>
        如果我们把这些规则使用函数 $get_-awaitable\left(\right)$ 和 $get_-awaiter\left(\right)$ 来编码，看起来就是这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">P</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get_awaitable</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">expr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">has_any_await_transform_member_v</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">promise</span><span class="p">.</span><span class="n">await_transform</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Awaitable</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get_awaiter</span><span class="p">(</span><span class="n">Awaitable</span><span class="o">&amp;&amp;</span> <span class="n">awaitable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">has_member_operator_co_await_v</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">has_non_member_operator_co_await_v</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">operator</span> <span class="k">co_await</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="挂起-awaiter">挂起 Awaiter</h3>
<p>        假设我们把逻辑封装成上面那种获取 $Awaiter$ 对象的函数，那么 $co_-await$&lt;$expr$&gt; 可以简单翻译成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">awaitable</span> <span class="o">=</span> <span class="n">get_awaitable</span><span class="p">(</span><span class="n">promise</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">awaiter</span> <span class="o">=</span> <span class="n">get_awaiter</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">awaitable</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)(</span><span class="n">awaitable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">awaiter</span><span class="p">.</span><span class="n">await_ready</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">handle_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">await_suspend_result_t</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="k">decltype</span><span class="p">(</span><span class="n">awaiter</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">handle_t</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">p</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">suspend</span><span class="o">-</span><span class="n">coroutine</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_void_v</span><span class="o">&lt;</span><span class="n">await_suspend_result_t</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">awaiter</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">handle_t</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="k">return</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">caller</span><span class="o">-</span><span class="n">or</span><span class="o">-</span><span class="n">resumer</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">static_assert</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">await_suspend_result_t</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="s">&#34;await_suspend() must reutrn &#39;void&#39; or &#39;bool&#39;.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">awaiter</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">handle_t</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">&lt;</span><span class="k">return</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">caller</span><span class="o">-</span><span class="n">or</span><span class="o">-</span><span class="n">resumer</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">resume</span><span class="o">-</span><span class="n">point</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">awaiter</span><span class="p">.</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        <code>void</code>版本的 $await_-suspend\left(\right)$ 无条件地在调用返回后交还控制权，而<code>bool</code>版本的则允许 $awaiter$ 对象有条件地在返回后恢复协程执行。<br>
        <code>bool</code>版本的 $await_-suspend\left(\right)$ 在 $awaiter$ 发起一个需要异步完成的操作时十分有用。在这种情况下，当任务异步完成后，$await_-suspend$ 可以返回<code>false</code>，表示协程应该立即恢复并继续执行。<br>
        在 &lt;$suspend$-$coroutine$&gt; ( 暂停协程 ) 处，编译器会生成一些代码来保存协程状态，并准备好被恢复。这些状态包括存储恢复点的位置，以及将一些寄存器值保存到当前协程帧内存中。<br>
        当前协程在 &lt;$suspend$-$coroutine\left(\right)$&gt; 操作完成后，就被认为已暂停。协程是在 $await_-suspend$ 调用内部被暂停的，一旦被暂停，就可以在之后被恢复或者销毁。<br>
        一旦 $await_-suspend\left(\right)$ 操作完成，就要在之后对这个协程进行恢复 ( 或者销毁 )。注意 $await_-suspend\left(\right)$ 返回<code>false</code>相当于在当前线程中立即恢复协程。<br>
        $await_-ready\left(\right)$ 方法可以让你避免 &lt;$suspend$-$coroutine$&gt; 带来的开销，因为它可以返回操作是否可以在不需要暂停的前提下同步完成。<br>
        在 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点，控制权会返还给主调或者恢复者，并弹出协程调用栈帧，保留协程栈帧。<br>
        当 ( 或者 ) 执行到 &lt;$resume$-$point$&gt; ( 恢复点 )，暂停的协程将被恢复。例如，在通过 $await_-resume\left(\right)$ 方法获取结果之前。<br>
        $await_-resume\left(\right)$ 方法的返回值会作为 $co_-await$ 表达式的结果。$await_-resume\left(\right)$ 方法也可以抛出一个异常，并将其传播到 $co_-await$ 表达式之外。<br>
        注意如果一个异常传播到 $await_-suspend\left(\right)$ 调用之外，协程将在没有 $await_-resume\left(\right)$ 调用的情况下被自动恢复，并将异常传播到 $co_-await$ 表达式之外。</p>
<h2 id="协程句柄">协程句柄</h2>
<p>        你可能注意到了，$coroutine_-handle$&lt;$P$&gt; 类型会被作为参数，在 $co_-await$ 表达式中传给 $await_-suspend\left(\right)$ 调用。 <br>
        这个类型代表一个无主的协程帧句柄，可以用来恢复协程执行，或者销毁协程帧。它可以用来获取协程的 $promise$ 对象。<br>
        $coroutine_-handle$ 类型有着如下 (省略了的) 接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span> <span class="o">:</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_promise</span><span class="p">(</span><span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        实现一个 $Awaitable$ 类型的时候，与 $coroutine_-handle$ 相关的关键方法是 $.resume\left(\right)$，它会在在操作完成并且想要恢复挂起中的协程执行的时候被调用。对 $coroutine_-handle$ 调用 $.resume\left(\right)$ 会在 &lt;$resume$-$point$&gt; 重新激活一个暂停的协程，在到达下一个 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点处返回。<br>
        $.destroy\left(\right)$ 方法摧毁协程帧，调用作用域内的变量析构器，释放协程帧使用的内存空间。一般情况下，你不需要主动 (  事实上真的需要避免 ) 调用 $.destroy\left(\right)$，除非你是一个正在实现协程 $promise$ 类型的库开发者。通常，协程帧会被某些协程返回的<code>RAII</code>类型所持有。所以再调用 $.destroy\left(\right)$ 可能导致一个双重析构的bug。<br>
        $.promise\left(\right)$ 方法返回一个协程 $promise$ 对象的引用。然后，就像 $.destroy\left(\right)$，一般只会在需要编写 $promise$ 类型时有用。你应该把 $promise$ 对象视为协程的一个内部细节实现。对于大部分一般 $Awaitable$ 类型，你应该使用 $coroutine_-handle$&lt;$void$&gt; 而不是 $coroutine_-handle$&lt;$Promise$&gt; 作为 $await_-suspend\left(\right)$ 方法的参数。<br>
        $coroutine_-handle$&lt;$P$&gt;::$from_-promise$($P$&amp; $promise$) 函数允许从协程 $promise$ 对象引用中重新构造协程。注意你必须保证类型 $P$ 与某个正在使用的协程帧匹配，如果 $P$ 的类型继承了 $promise$ 类型，并用于构造 $coroutine_-handle$&lt;$Base$&gt; ，会导致一些未定义行为。<br>
        $.address\left(\right)$ / $from_-address\left(\right)$ 函数允许把一个协程句柄转换成 $void*$ 指针，或者从一个 $void*$ 指针转换协程句柄。</p>
<h2 id="不需要同步的异步代码">不需要同步的异步代码</h2>
<p>        $co_-await$ 的一个十分有用的设计是协程可以在被暂停后，把控制权移交给主调 / 恢复者前执行代码。<br>
        这可以让 $Awaiter$ 对象在被暂停后发起一个异步操作，把被暂停协程的 $coroutine_-handle$ 传给该操作，并在不需要任何额外同步的前提下安全地恢复操作 ( 可能在其他线程上 )。<br>
        例如，在 $await_-suspend\left(\right)$ 调用中，发起一个异步读操作，当协程被暂停，意味着我们可以在读操作完成后，恢复协程的执行。这一步不需要任何线程同步操作，不需要协调发起线程和执行线程的关系。</p>
<pre tabindex="0"><code>Time     Thread 1                           Thread 2
  |      --------                           --------
  |      ....                               Call OS - Wait for I/O event
  |      Call await_ready()                    |
  |      &lt;supend-point&gt;                        |
  |      Call await_suspend(handle)            |
  |        Store handle in operation           |
  V        Start AsyncFileRead ---+            V
                                  +-----&gt;   &lt;AsyncFileRead Completion Event&gt;
                                            Load coroutine_handle from operation
                                            Call handle.resume()
                                              &lt;resume-point&gt;
                                              Call to await_resume()
                                              execution continues....
           Call to AsyncFileRead returns
         Call to await_suspend() returns
         &lt;return-to-caller/resumer&gt;
</code></pre><p>        当使用这种方便的方式时，你需要小心的一点是，当把协程句柄发给其他线程时，其他线程可能在 $await_-suspend\left(\right)$ 调用返回前就尝试恢复协程执行，导致在 $await_-suspend\left(\right)$ 未完成时，协程继续执行了。<br>
        当协程恢复后，做的第一件事是调用 $await_-resume\left(\right)$ 获取结果，然后通常立马析构 $Awaiter$ 对象 ( 例如，$await_-suspend\left(\right)$ 调用的<code>this</code>指针 )。然后协程可能执行直到完成，在 $await_-suspend\left(\right)$ 返回前销毁协程和 $promise$ 对象。<br>
        所以在 $await_-suspend\left(\right)$ 方法，一旦协程有可能被另一个线程并行地恢复，你就需要避免访问<code>this</code>或者协程的 $.promise\left(\right)$ 对象，因为两者都可能被摧毁。总的来说，当暂停操作从发起到完成期间，只有局部变量是安全的。</p>
<h3 id="与有栈协程相比">与有栈协程相比</h3>
<p>        我想换个话题，快速地与现有的其他有栈协程比较下无栈协程在暂停后执行逻辑的能力，比如<code>Win32 fibers</code>或者<code>boost::context</code>。<br>
        对于许多有栈协程来说，暂停和恢复操作被合并成了“上下文切换”操作。通过“上下文切换”操作，当前协程在暂停后没有机会去执行逻辑，只是单纯地将控制权移交给其他协程。<br>
        这意味着，如果我们想要基于有栈协程实现一个类似于异步文件读取操作，我们需要在暂停协程之前发起操作。因此有可能操作会在线程被暂停之前就在其他线程上完成了，并等待恢复。这种潜在的其他线程完成操作和协程暂停之间的竞态，需要一些线程同步机制来选择并决定胜者。<br>
        一种可选的方式是使用内嵌上下文 ( $tranpoline$ $context$ )，它可以通过暂停发起操作的上下文来表示发起某个操作。然而，这可能需要额外的架构，和另外的上下文切换来保证正常使用，并且成本可能大于它试图避免的同步操作的成本。</p>
<h2 id="减少内存分配">减少内存分配</h2>
<p>        异步操作经常需要给每个操作分配状态，用于跟踪操作执行阶段。这些状态需要在操作执行过程中保留，直到操作完成才会被释放。<br>
        例如，调用异步<code>Win32 I/O</code>函数需要你分配并传递一个 $OVERLAPPED$ 结构指针。主调需要保证指针在操作完成前都是有效的。<br>
        典型的基于回调的<code>API</code>要求这些状态分配在堆上，并保证它们有着合适的生命周期。如果你正在执行很多操作，你可能需要给每个操作都分配和释放状态。如果这导致性能问题，你可能需要通过内存池来分配这些状态。<br>
        然而，当使用协程时，利用局部变量在协程帧内的特性，我们可以避免堆分配存储，因为协程帧内的变量在协程被暂停时也是存活的。<br>
        通过把 $co_-await$ 表达式中每个操作状态放到 $Awaiter$ 对象中，我们可以有效的从协程帧中“借用”内存。一旦操作完成，协程被恢复，$Awaiter$ 对象被摧毁，释放协程帧中其他局部变量使用的内存。<br>
        最终，协程帧还是分配在堆上。然而，只需要一次堆分配，协程帧就可以被用来执行许多异步操作。<br>
        你想一想，协程帧其实就是<code>arena</code>内存分配器的一种高级表现。编译器计算出所有局部变量需要的<code>arena</code>大小，然后零成本地分配所有局部变量！试着用传统的分配器来战胜它;)</p>
<h2 id="例子实现一个单线程同步原语">例子：实现一个单线程同步原语</h2>
<p>        现在我们已经讲了许多 $co_-await$ 运算符的机制，我想实现一个基本的 $awaitable$ 同步原语：一个异步手动重置 $event$，来把这些知识运用到实践上。<br>
        这个 $event$ 的基本需求是对许多并行执行的协程来说是 $Awaitble$ 的，挂起操作会等暂停挂起协程，直到一个线程调用 $.set\left(\right)$ 方法，此时恢复所有挂起的协程。如果一个线程已经调用了 $.set\left(\right)$，协程应该在不暂停的前提下继续执行。<br>
        理想情况下，我想要让方法<code>noexcept</code>，这需要避免堆分配，以及无锁实现。<br>
        <strong>2017/11/23 编辑：增加 async_manual_reset_event 的用例</strong><br>
        用例看起来像是这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">T</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// A single call to produce a value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">value</span> <span class="o">=</span> <span class="n">some_long_running_computation</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Publish the value by setting the event.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">event</span><span class="p">.</span><span class="n">set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Supports multiple concurrent consumers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">consumer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Wait until the event is signalled by call to event.set()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// in the producer() function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">co_await</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Now it&#39;s safe to consume &#39;value&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This is guaranteed to &#39;happen after&#39; assignment to &#39;value&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        让我们先想想这个 $event$ 可能的状态：$not$ $set$ 和 $set$ 。<br>
        当处于 $not$ $set$ 状态，存在一个等待 $set$ 状态挂起协程的列表 ( 可能为空 )。<br>
        当设置 $set$ 状态，就不应该存在挂起的协程，因为正在 $co_-await$ 这个 $event$ 的协程可以不暂停地继续执行。<br>
        这个状态可以通过一个 $std$::$atomic$&lt;$void*$&gt; 表示：</p>
<ul>
<li>保存一个特殊指针，指向 $set$ 状态。我们使用 $event$ 的<code>this</code>指针来表示，因为它不可能跟列表中其他对象的地址相同。</li>
<li>否则，$event$ 处于 $not$ $set$ 状态，指针值是一个单独的挂起协程的链表头。</li>
</ul>
<p>        我们可以通过把状态存储在协程帧的 $awaiter$ 对象的方式，避免在堆上对节点进行额外分配。<br>
        让我们实现一个类似如下的类接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">async_manual_reset_event</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="kt">bool</span> <span class="n">initiallySet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// No copying/moving
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="k">const</span> <span class="n">asnyc_manual_reset_event</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="n">async_manual_reset_event</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">asnyc_manual_reset_event</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">async_manual_reset_event</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">is_set</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">awaiter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span> <span class="k">operator</span> <span class="nf">co_awaiter</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">set</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">struct</span> <span class="nc">awaiter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// - &#39;this&#39; =&gt; set state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// - otherwise =&gt; not set, head of linked list of awaiter*.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span> <span class="n">m_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        这里我们给出了一个相当简单直接的接口。主要要注意的点是 $operator$ $co_-await\left(\right)$ 返回一个未定义的 $awaiter$ 类型。<br>
        让我们先实现 $awaiter$ 。</p>
<h3 id="实现-awaiter">实现 Awaiter</h3>
<p>        首先，需要知道正在等待哪个 $async_-manual_-reset_-event$ ，所以需要一个 $event$ 引用和一个初始化它的构造器。<br>
        它同样需要作为 $awaiter$ 链表的节点，所以也需要保存下一个 $awaiter$ 对象的指针。<br>
        它还需要保存正在执行 $co_-await$ 的挂起协程的 $coroutine_-handle$ ，用来在 $event$ 被 $set$ 之后恢复协程。我们不关心协程的 $promise$ 类型，所以只需要使用 $coroutine_-handle$&lt;&gt; ( $coroutine_-handle$&lt;$void$&gt; 的缩写 )。<br>
        最后，它需要实现 $Awaiter$ 接口，所以需要三个特殊方法 $await_-ready$ ，$await_-suspend$ 和 $await_-resume$ 。我们不需要 $co_-await$ 返回值，所以 $await_-resume$ 可以返回 $void$ 。<br>
        一旦我们把所有东西放到一起，基本的 $awaiter$ 接口看起来就像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">async_manual_reset_event</span><span class="o">::</span><span class="n">awaiter</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span><span class="p">(</span><span class="k">const</span> <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">m_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaitinigCoroutine</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">async_manual_reset_event</span><span class="o">&amp;&amp;</span> <span class="n">m_event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">m_awaitingCoroutine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span><span class="o">*</span> <span class="n">m_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        当 $co_-await$ 一个 $event$ 时，我们不想让挂起协程在 $event$ 被 $set$ 的时候暂停。所以我们让 $await_-ready\left(\right)$ 在 $event$ 已经 $set$ 的时候返回<code>true</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">awaiter</span><span class="o">::</span><span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">m_event</span><span class="p">.</span><span class="n">is_set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        接下来，让我们看看 $await_-suspend\left(\right)$ 方法，许多 $awaitable$ 类型的有趣行为都发生在这里。<br>
        首先它需要在 $m_-awaitingCoroutine$ 成员中保存协程句柄，用于后续调用 $.resume\left(\right)$ 。<br>
        保存句柄之后，需要把 $awaiter$ 自动地加入链表中。成功入队之后，如果 $event$ 还没有被设置成 $set$ 状态，返回<code>true</code>表示我们不希望立即恢复协程，否则返回<code>false</code>，表示协程应该立马恢复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="nl">awaiter</span><span class="p">:</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaitingCoroutine</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Special m_state value that indicates the event is in the &#39;set&#39; state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="k">const</span> <span class="n">setState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Remember the handle of the awaiting coroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">m_awaitingCoroutine</span> <span class="o">=</span> <span class="n">awaitingCoroutine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Try to atomically push this awaiter onto the front of the list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span><span class="o">*</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">m_event</span><span class="p">.</span><span class="n">m_state</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Resume immediately if already in &#39;set&#39; state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">oldValue</span> <span class="o">==</span> <span class="n">setState</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Upload linked list to point at current head.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">m_next</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">awaiter</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">oldValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Finally, try to swap the old list head, inserting this awaiter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// as the new list head.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">m_event</span><span class="p">.</span><span class="n">m_state</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">oldValue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// Successfully enqueued. Remain suspend.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        注意我们使用 $acquire$ 内存序读取旧状态，这样我们就可以看到所有发生在 $set\left(\right)$ 调用之前的写操作了。<br>
        我们需要用 $release$ 内存序调用 $compare$-$exchange$ ，这样之后的 $set\left(\right)$ 就可以看到我们写入的 $m_-awaitingCoroutine$ 和更早写入的协程状态。</p>
<h3 id="完成-event-类的剩余实现">完成 event 类的剩余实现</h3>
<p>        我们已经定义好了 $awaiter$ 类型，再看回来 $async_-manual_-reset_-event$ 的方法。<br>
        首先是构造函数，它需要使用空的链表 ( 比如<code>nullptr</code>) 初始化为 $not$ $set$ 状态，或者初始化为 $set$ 状态 ( 比如<code>this</code> )。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">async_manual_reset_event</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">initiallySet</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="n">m_state</span><span class="p">(</span><span class="n">initiallySet</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span></code></pre></div><p>        接下来，$is_-set\left(\right)$ 方法更直接，如果持有<code>this</code>指针，那么就是 $set$ 状态。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">is_set</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">m_state</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">==</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        接着是 $reset\left(\right)$ 方法，如果当前是 $set$ 状态，我们需要重置为空链表的 $not$ $set$ 状态，否则不做任何事：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">reset</span><span class="p">()</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span><span class="o">*</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">m_state</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">oldValue</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        通过 $set\left(\right)$ 方法，我们可以用特殊的<code>this</code>指针与当前值交换，从而设置状态为 $set$。如果存在挂起的协程，我们需要在返回前依次恢复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">set</span><span class="p">()</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Needs to be &#39;release&#39; so that subsequent &#39;co_await&#39; has
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// visibility of our prior writes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Needs to be &#39;acquire&#39; so that we have visibility of prior
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// writes by awaiting coroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span><span class="o">*</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">m_state</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">oldValue</span> <span class="o">!=</span> <span class="k">this</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Wasn&#39;t already in &#39;set&#39; state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Treat old value as head of a linked-list of waiters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// which we have now acquired and need to resume.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span><span class="o">*</span> <span class="n">waiters</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">awaiter</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">oldValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">waiters</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Read m_next before resuming the coroutines as resuming
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the coroutine will likely destroy the awaiter object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">auto</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">waiters</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">waiters</span><span class="o">-&gt;</span><span class="n">m_awaitingCoroutine</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">waiters</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        最后我们需要实现 $operator$ $co_-await\left(\right)$ 方法，只需要构造一个 $awaiter$ 对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">awaiter</span>
</span></span><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span><span class="o">::</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">awaiter</span><span class="p">{</span> <span class="o">*</span><span class="k">this</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        这样我们就完成了一个无锁，无额外内存分配，<code>noexcept</code>实现的 $awaitable$ 的异步手动-重置 $event$ 。<br>
        如果你想要试试这段代码，看看它在<code>MSVC</code>和<code>Clang</code>下的编译结果，可以看一下<a href="https://godbolt.org/g/Ad47tH">godbolt上的源码</a>。<br>
        你也可以在<a href="https://github.com/lewissbaker/cppcoro">cppcoro库</a> 上看到这段实现，以及更多的其他的有用的 $awaitable$ 类型，例如 $async_-mutex$ 和 $async_-auto_-reset_-event$ 。</p>
<h2 id="写在结尾">写在结尾</h2>
<p>        这篇文章介绍了 $operator$ $co_-await$ 是怎么通过 $Awaitable$ 和 $Awaiter$ 这两个<code>concept</code>实现的。<br>
        同样也讲了怎么实现一个 $awaitable$ 的异步线程同步原语，使用了 $awaiter$ 对象在协程帧上分配的优点，避免了额外的堆分配。<br>
        我希望这篇文章可以帮助你理解新的 $co_-await$ 运算符。<br>
        在下一篇文章中，我将介绍 $Promise$ <code>concept</code>，以及一个协程类型的开发者可以怎样设计协程的行为。</p>
<h2 id="致谢">致谢</h2>
<p>        这段就不翻了吧~</p>

            </div>
            <div class="meta post-footer">
                <span>2024 Jan 25 00:00</span>
                <a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/">C&#43;&#43;协程（1）：协程理论</a></h1>
            <div class="post-content">
                
                
                <p>        这是<code>C++</code> <code>Coroutines</code>标准 ( <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf">C++ Coroutines TS</a> ) 系列的第一篇文章，协程作为新技术被引入<code>C++20</code>标准。<br>
        在这个系列里我会介绍<code>C++</code>协程的底层机制，以及如何使用它们实现一些更高级的抽象，就像 <a href="https://github.com/lewissbaker/cppcoro">cppcoro</a> 库一样。<br>
        在这篇文章，我会介绍函数和协程的区别，以及相应的一些他们所支持的行为的理论。文章的目标是介绍一些基础概念，帮助你理解<code>C++</code>协程。</p>
<h2 id="协程是函数函数是协程">协程是函数，函数是协程</h2>
<p>        协程是一种允许<strong>暂停</strong> ( $suspend$ ) 和<strong>恢复</strong> ( $resume$ ) 的函数的统称。<br>
        在解释这个含义之前，我们先复习一下一个“普通”<code>C++</code>函数的行为是什么。</p>
<h2 id="普通函数">“普通”函数</h2>
<p>        一个普通函数具有两种行为：<strong>调用</strong> ( $call$ ) 和<strong>返回</strong> ( $return$ , 注意这里返回涵盖了抛出异常 )。<br>
        <strong>调用</strong>创建一个<strong>调用栈</strong> ( $activation$ $frame$ )，暂停主调函数，执行被调函数的第一条命令。<br>
        <strong>返回</strong>会把返回值传回给主调，销毁调用栈，然后在主调函数的调用点处，恢复主调函数的执行。<br>
        让我们再分析一下这些语义&hellip;&hellip;</p>
<h3 id="调用栈">调用栈</h3>
<p>        什么是“调用栈”？<br>
        你可以认为调用栈是一块存储着当前函数调用的内存。这些状态包括了入参和局部变量。<br>
        对于“普通”函数，调用栈也包含返回地址——函数返回时将跳转到的指令，和主调函数的调用栈地址。你可以认为这些信息是用来保持函数继续调用的，比如，它们描述了函数调用结束后，该继续执行哪个函数。<br>
        对于“普通”函数，所有的调用栈都有着严格嵌套的生命周期。严格嵌套可以更有效的分配和释放每个函数调用的内存。这种数据结构也被称为“栈”。<br>
        调用栈分配在栈上，也被称为“栈帧”。<br>
        栈是一种十分常见的数据结构，大部分<code>CPU</code>架构都有个专门的寄存器来保存栈顶地址 ( 例如，<code>X64</code>的<code>rsp</code>寄存器 )。<br>
        分配一个调用栈，只需要让寄存器加上栈帧大小的值。同样的，释放一个调用栈，也只需要让寄存器减去栈帧大小。</p>
<h3 id="调用">调用</h3>
<p>        当一个函数调用另一个函数，主调必须暂停自己。<br>
        “暂停”一般指保存当前<code>CPU</code>寄存器中的值，并在之后恢复的时候重新设置这些值。保存寄存器这一步，可以是主调执行，也可以是被调执行，取决于不同的调用方式，但你可以认为它们都是调用的其中一部分。<br>
        调用也会把入参在新的调用栈里保存一份，让被调可以访问。<br>
        最后，主调在新调用栈里面写入恢复点的地址，并把执行权让出给被调函数。<br>
        在<code>X86/X64</code>架构，最后一步有单独对应的 $call$ 指令，会把当前指令的下一条指令地址写入栈，递增栈寄存器，然后跳转到指令操作地址。</p>
<h3 id="返回">返回</h3>
<p>        当一个函数通过 $return$ 返回，函数会先把返回值保存到主调可以访问的地方，可以在主调调用栈，也可以在当前调用栈 ( 对于跨越两个调用栈的参数和返回值，这种概念可能没有明确的区别 )。<br>
        然后函数通过以下步骤销毁调用栈：</p>
<ul>
<li>在返回点销毁所有局部变量</li>
<li>销毁所有入参对象</li>
<li>释放调用占内存</li>
</ul>
<p>        最后，通过以下步骤恢复主调执行：</p>
<ul>
<li>栈寄存器指向当前调用存储的主调调用栈地址，恢复所有当前函数可能修改的<code>CPU</code>寄存器</li>
<li>跳转到之前“调用”操作存储的恢复点</li>
</ul>
<p>        注意，与“调用”操作一样，一些“返回”操作中主调和被调的细分职责可能不一样。</p>
<h2 id="协程">协程</h2>
<p>        协程是一种在函数的<strong>调用</strong>和<strong>返回</strong>操作的基础上细分出<strong>暂停</strong>、<strong>恢复</strong>和<strong>销毁</strong>三种额外操作的操作行为统称。<br>
        <strong>暂停</strong> ( $Suspend$ ) 操作让协程在当前函数的执行点处暂停，在不销毁调用栈的前提下，将控制权交还给主调函数的操作。协程执行过程中的所有对象在暂停之后依然存活。<br>
        注意，就像函数的<strong>返回</strong>操作一样，协程需要在预先定义好的暂停点处主动暂停。<br>
        <strong>恢复</strong>操作将在先前的暂停点处恢复协程的执行，这将会重新激活协程的调用栈。<br>
        <strong>销毁</strong>会在不恢复协程的前提下，销毁协程的调用栈，暂停点作用域内的所有对象也会被一并销毁。</p>
<h3 id="协程调用栈">协程调用栈</h3>
<p>        因为协程可以在不销毁调用栈的前提下被暂停，我们也就无法保证调用栈之间是严格嵌套的了。这意味着，调用栈不再能使用栈结构分配，取而代之的，是更多的堆存储。<br>
        <code>C++</code>协程标准中有些规定，允许在主调的调用栈上分配协程调用栈，只要编译器能保证协程的生命周期与主调严格嵌套。如果编译器足够智能，这种方式可以在一定程度上减少堆分配。<br>
        协程调用栈有一部分需要在协程暂停时保留，而另一个部分只会在协程执行时被用到。例如，不在协程暂停点上的变量，这些变量可以在栈上存储。<br>
        你可以认为协程调用栈由两部分组成：“协程帧”和“栈帧”。<br>
        “协程帧”指代调用栈中需要在协程暂停期间保留的部分，“栈帧”则指只需要在协程执行期间存在的部分，负责在协程暂停时将控制权移交给主调或者协程的恢复者 ( $resumer$ ) 并释放。</p>
<h3 id="暂停">暂停</h3>
<p>        <strong>暂停</strong>允许一个协程在函数执行的中间点暂停执行，并将控制权移交给主调 / 协程的恢复者。<br>
        <code>C++</code>协程标准定义协程内有几个指定暂停点，它们会使用 $co_-await$ 或者 $co_-yield$ 关键字标识。<br>
        当一个协程执行到暂停点时，会通过以下几步来暂停：</p>
<ul>
<li>确保寄存器值已写入协程帧</li>
<li>将暂停点写入协程帧，用于后续恢复操作恢复执行，或者销毁操作销毁暂停点前的变量</li>
</ul>
<p>        一旦协程准备好被恢复，就可以认为“已暂停”。<br>
        协程在把控制权交还给主调 / 恢复者之前，有机会执行一些额外的逻辑，返回当前协程帧的句柄，用于后续恢复或者销毁。<br>
        在暂停后允许执行额外逻辑的能力，让协程可以在不同步的前提下恢复。否则因为暂停和恢复的竞态，这种操作可能需要同步执行。我将在后续的文章中详细讨论。<br>
        协程可以选择立即恢复 / 继续协程执行，或者可以选择移交控制权给主调 / 恢复者。<br>
        如果控制权被移交给主调 / 恢复者，协程调用栈的栈帧部分将被释放。</p>
<h3 id="恢复">恢复</h3>
<p>        <strong>恢复</strong>可以对一个处于“暂停”状态的协程使用。<br>
        当一个函数恢复一个协程时，它需要快速地跳到对应函数执行的中间点。恢复者通过调用 $void$ $resume()$ 来在暂停返回的协程帧上，找到对应的指令。<br>
        就像普通函数调用，$resume()$ 会分配一个新的调用栈，并在移交控制权之前保存主调调用栈的返回地址。<br>
        然而，并非将移交控制权到被调函数的开始，而是从协程帧中读取最后的暂停点，并跳转到那里。<br>
        当协程下一次暂停或者完成调用，$resume()$ 调用将会返回，恢复主调执行。</p>
<h3 id="销毁">销毁</h3>
<p>        <strong>销毁</strong>操作可以在不恢复协程执行的前提下销毁协程帧。<br>
        这个操作只能对已暂停的协程使用。<br>
        销毁操作就像恢复操作那样，重新激活协程调用栈，包括分配一个新的栈帧，保存主调返回地址。<br>
        然而，并非将控制权移交到上个暂停点，而是移交到一个可选的代码路径上，调用协程暂停点之前作用域内所有局部变量的析构器，然后释放协程帧的内存。<br>
        类似于恢复操作，销毁需要对协程暂停时返回的句柄调用 $void$ $destroy()$ 函数。</p>
<h3 id="协程调用">协程调用</h3>
<p>        协程调用几乎跟普通函数调用一样，事实上，对于主调来说，它们之间毫无区别。<br>
        然而，不像函数调用必须执行完才会返回，协程调用可以在到达暂停点处返回，并且主调可以在后续恢复。<br>
        对协程执行调用，主调会分配一个新的栈帧，把入参、返回地址写入栈帧，移交控制权。这些步骤和普通函数调用一样。<br>
        协程要做的第一件事是在堆上分配一个协程帧，并把入参从栈帧拷贝到协程帧，保证它们的生命周期和协程一样。</p>
<h3 id="协程返回">协程返回</h3>
<p>        协程返回与普通函数有一点不同。<br>
        当一个协程执行 $return$ 语句 ( 标准里是 $co_-return$ 语句 ) 时，他会把返回值存储到某个地方 ( 可以被协程修改的地方 )，接着销毁作用域内的局部变量 ( 不包括入参 )。<br>
        然后协程有机会在移交控制权之前，执行一些额外的逻辑。<br>
        额外的逻辑可能会返回值，或者恢复另一个等待返回值的协程。这些逻辑时完全客制化的。<br>
        协程然后执行暂停 ( 协程帧继续存活 ) 或者销毁 ( 协程帧销毁 ) 操作。<br>
        控制权在暂停 / 销毁操作后被移交给主调 / 恢复者，最后弹出栈帧。<br>
        需要注意的是，返回操作的返回值与调用操作的返回值不一样，因为返回可能是在初始调用之后很长时间后才执行的。</p>
<h2 id="例子">例子</h2>
<p>        为了以图像形式表达这些概念，我会通过一个简单的示例来演示协程暂停，并在之后恢复过程中的情况。<br>
        假设函数 ( 或者协程 ) $f()$ 调用一个协程 $x(int\ \ a)$ 。<br>
        调用前大概是这样的：</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP

                          +------+
+---------------+ &lt;------ | rsp  |
|  f()          |         +------+
+---------------+
| ...           |
|               |
</code></pre><p>        然后调用 $x(42)$ ，创建一个栈帧，就像普通函数那样。</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
+----------------+ &lt;-+
|  x()           |   |
| a  = 42        |   |
| ret= f()+0x123 |   |    +------+
+----------------+   +--- | rsp  |
|  f()           |        +------+
+----------------+
| ...            |
|                |
</code></pre><p>        然后，一旦协程 $x()$ 在堆上分配协程帧，并且将入参拷贝到协程帧，我们就得到了下面的图。注意编译器一般使用一个单独的寄存器存储协程帧地址 ( 例如<code>MSVC</code>使用<code>rbp</code>寄存器 )。</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
+----------------+ &lt;-+
|  x()           |   |
| a  = 42        |   |                   +--&gt;  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     +-----------+
+----------------+        | rbp  | ------+
| ...            |        +------+
|                |
</code></pre><p>        如果协程 $x()$ 之后调用另一个普通函数 $g()$ ，就会像这样：</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
+----------------+ &lt;-+
|  g()           |   |
| ret= x()+0x45  |   |
+----------------+   |
|  x()           |   |
| coroframe      | --|-------------------+
| a  = 42        |   |                   +--&gt;  +-----------+
| ret= f()+0x123 |   |    +------+             |  x()      |
+----------------+   +--- | rsp  |             | a =  42   |
|  f()           |        +------+             +-----------+
+----------------+        | rbp  |
| ...            |        +------+
|                |
</code></pre><p>        当 $g()$ 返回，他会销毁自己的调用栈，然后恢复 $x()$ 的调用栈。假设 $g()$ 的返回值存储在协程帧的局部变量 $b$ 中。</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
+----------------+ &lt;-+
|  x()           |   |
| a  = 42        |   |                   +--&gt;  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     | b = 789   |
+----------------+        | rbp  | ------+     +-----------+
| ...            |        +------+
|                |
</code></pre><p>        如果 $x()$ 执行到暂停点，并暂停执行，他会把控制权返回给 $f()$ 。<br>
        这导致 $x()$ 的栈帧会弹出，但是协程帧会保留。当协程被暂停，返回值返回给主调。返回值通常是协程句柄，指向堆上已暂停的协程帧，可以用于后续的恢复。当 $x()$ 暂停后，协程帧中会存储恢复点 ( 记为 $RP$ )。</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
                                        +----&gt; +-----------+
                          +------+      |      |  x()      |
+----------------+ &lt;----- | rsp  |      |      | a =  42   |
|  f()           |        +------+      |      | b = 789   |
| handle     ----|---+    | rbp  |      |      | RP=x()+99 |
| ...            |   |    +------+      |      +-----------+
|                |   |                  |
|                |   +------------------+
</code></pre><p>        这个句柄现在可以作为一个普通值在函数间传递。在一些点之后，可能是另一个调用栈，或者另一个线程，在某个时机，例如异步<code>I/O</code>完成的时候，另一个调用 $h()$ 恢复了协程。<br>
        恢复协程的函数调用 $void$ $resume(handle)$ ，恢复了协程执行。对于主调来说，就好像调用了一个 $void$ 返回的函数。<br>
        这会创建一个新的栈帧，记录 $resume()$ 调用的返回，激活协程栈，重新设置寄存器，在上一个暂停点处恢复 $x()$ 的执行。</p>
<pre tabindex="0"><code>STACK                     REGISTERS               HEAP
+----------------+ &lt;-+
|  x()           |   |                   +--&gt;  +-----------+
| ret= h()+0x87  |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  h()           |        +------+       |     | b = 789   |
| handle         |        | rbp  | ------+     +-----------+
+----------------+        +------+
| ...            |
|                |
</code></pre><h2 id="总结">总结</h2>
<p>        这篇文章中，我把协程描述为一种不仅具有调用和返回操作，还具有暂停、恢复和销毁这三种额外操作的函数。<br>
        我希望这对你理解协程及其控制流有帮助。<br>
        下一篇文章我将介绍<code>C++</code>协程标准语言扩展的机制，以及编译器是怎么把你写的代码翻译成协程的。</p>

            </div>
            <div class="meta post-footer">
                <span>2024 Jan 23 23:59</span>
                <a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">分布式数据系统：共识算法</a></h1>
            <div class="post-content">
                
                
                <p>        分布式计算中有很多重要场景需要集群节点达成某种一致，例如：</p>
<ul>
<li>主节点选举：对于主从模式的数据库，节点间需要对谁来充当主节点达成一致。如果由于网络故障原因出现节点之间无法通信，就很容易出现争议；</li>
<li>原子事务提交：对于支持跨节点或跨分区事务的数据库，某个事务可能在一些节点上执行成功，而在另一些节点上失败。为了维护事务的原子性，所有节点必须对事务结果达成一致。</li>
</ul>
<h2 id="1-原子提交与两阶段提交">1. 原子提交与两阶段提交</h2>
<p>        对于单节点事务，原子性通常由存储引擎负责。当客户端请求数据库节点提交事务时，数据库首先使事务的写入持久化 ( 通常保存在<code>WAL</code>中 )，然后把提交记录追加到磁盘的日志文件中。如果数据库在该过程中发生了崩溃，在节点重启后，可以通过日志恢复事务。如果崩溃之前已经写入了提交记录，则认为事务已经成功，否则，回滚该事务。因此，单节点事务十分依赖于数据写入磁盘的顺序：先写入数据，再提交记录。<br>
        将单节点事务延伸到多节点，虽然大多数<code>NoSQL</code>分布式数据库都不支持这种分布式事务，但是有很多集群关系型数据库支持。向所有节点发送请求，然后各节点独立执行是不够的，这样很容易发生不一致，从而违反了原子性。一旦某个节点提交了事务，即使事后发现其他节点发生了中止，它也无法再撤销已提交的事务，所以，如果有部分节点提交了事务，所有节点也必须一起提交。<br>
        事务提交不可撤销，一旦数据被提交，就代表其他事务可见，继而客户端会依赖这些数据做出相应决策。这是事务<strong>提交读</strong>隔离级别的基础，如果事务在提交后还能撤销，就违反了提交读的原则，从而被迫产生级联式的追溯和撤销。当然，已提交事务可以被另一个新的事务覆盖，即<em><strong>补偿性事务</strong></em>。不过，在数据库的角度，它们是两个完全独立的事务，这种跨事务的正确性保证需要应用层负责。</p>
<h3 id="11-两阶段提交">1.1 两阶段提交</h3>
<p>        <strong>两阶段提交</strong> ( $two-phase\ commit$ , $2PC$ ) 是一种在多节点之间实现事务原子提交的算法，用来确保所有节点要么全部提交，要么全部中止。<code>2PC</code>在某些数据库内存使用，或者以<code>XA</code>事务的形式提供给应用程序使用。<br>
        <code>2PC</code>引入了单节点事务所没有的新组件：协调者 ( 也被称为事务管理器 )，通常实现为共享库。<code>2PC</code>事务从应用程序在多个数据库节点上执行数据读/写开始，数据库节点称为事务的参与者。当应用程序准备提交事务时，协调者发送一个准备请求到所有节点，询问它们是否可以进行事务提交：</p>
<ul>
<li>如果所有参与者回答是，表示它们已经准备好提交，协调者会发出提交请求，所有节点开始执行事务提交；</li>
<li>如果有任何参与者回答否，协调者会放弃发送提交请求。</li>
</ul>
<p>        为了理解<code>2PC</code>，我们可以分解这个过程：</p>
<ol>
<li>应用程序启动一个分布式事务，首先向协调者请求一个全局唯一的事务<code>ID</code>；</li>
<li>应用程序在每个参与节点上执行单节点事务，并将全局唯一事务<code>ID</code>附加到事务上。此时，每个节点独立执行事务，如果有任何一个节点执行失败，协调者和其他参与者都可以安全回滚事务；</li>
<li>应用程序准备提交事务，协调者向所有参与者发送准备请求，附带全局事务<code>ID</code>。如果接收到拒绝或者超时响应，协调者会通知所有节点放弃事务；</li>
<li>参与者在收到准备请求后，检查事务是否可以提交，是否存在冲突或者违反约束。一旦向协调者返回确认响应，无论发生什么情况，都不能拒绝提交事务；</li>
<li>协调者收到所有准备请求的响应后，会将决定写入磁盘中，用于崩溃后恢复决定，这个时刻称为提交点；</li>
<li>协调者将决定写入磁盘后，向所有参与者发送提交或者放弃请求。如果请求出现失败或者超时，协调者会一种重试，直到成功。所有参与者都不能拒绝该请求，即使需要很多重试，或者中间出现崩溃。</li>
</ol>
<p>        如果参与者或者网络在<code>2PC</code>期间发生故障，比如在准备请求期间，协调者就会决定回滚事务；或者在提交请求期间，协调者会不断重试。而对于协调者故障，如果协调者在准备请求之前故障，参与者可以安全地回滚；而一旦参与者收到了准备请求并回答是，参与者便无法单方面放弃，必须一直等待协调者的决定，此时如果协调者故障，参与者便处于一种不确定的状态。理论上，参与者之间可以互相通信，了解每个参与者的投票情况，并达成一致，但是这已经不是<code>2PC</code>的范畴了。<code>2PC</code>能够顺利完成的唯一办法是等待协调者恢复，因此协调者在发送提交请求之前要将决定写入磁盘的事务日志。<br>
        <code>2PC</code>也被称为阻塞式原子提交协议，因为等待协调者从故障恢复的这个过程是阻塞的。理论上，也可以改为非阻塞的，这种称为<strong>三阶段提交</strong>。<code>3PC</code>假定一个有限的网络延迟，要求节点在规定时间内响应。然而实际情况是，网络延迟可能是无限的。通常，非阻塞原子提交依赖一个完美的故障检测器，即一种十分可靠的可以判断节点是否崩溃的机制。但是，在一个网络延迟可能是无限的场景中，超时并非一种可靠的判断机制。正常情况下，请求也可能由于网络问题而超时。正是这些原因，大家更倾向于<code>2PC</code>而非<code>3PC</code>。</p>
<h2 id="2-分布式事务实践">2. 分布式事务实践</h2>
<p>        分布式事务，尤其是那些通过<code>2PC</code>实现的事务，声誉混杂。一方面，它们提供了一种其他方案难以企及的安全保证。但是另一方面，由于操作、性能上的缺陷，以及并非完全可靠，一直被人诟病。目前，许多云服务商由于运维方面的问题而决定不支持分布式事务。分布式事务的某些实现存在严重的性能问题，例如，有报告显示<code>MySQL</code>的分布式事务比单节点事务慢 $10$ 倍以上。<code>2PC</code>性能下降的主要原因是与协调者通信带来额外的网络开销，以及为了协调者崩溃恢复做的磁盘<code>I/O</code> ( $fsync$ )。<br>
        目前存在着两种不同的分布式事务概念：</p>
<ul>
<li>数据库内部的分布式事务：某些分布式事务支持的跨数据节点的内部事务，即所有参与者节点运行着相同的数据库软件；</li>
<li>异构分布式事务：存在两种或两种以上不同参与者软件的事务，例如来自不同供应商的数据库，甚至可以是非数据库。</li>
</ul>
<p>        对于数据库内部事务，由于不需要考虑不同系统之间的兼容，可以采用任何形式的协议，并进行针对性优化，这些分布式事务往往可行。但是异构分布式事务就没那么简单了。</p>
<h3 id="21-exactly-once消息处理">2.1 <code>Exactly-once</code>消息处理</h3>
<p>        异构分布式事务旨在无缝集成多种不同的系统。例如，当且仅当数据库中处理消息的事务成功提交，消息队列才会标记该消息已处理完毕。这个过程是通过自动提交消息确认和数据库写入实现的。即使消息系统和数据库运行在不同节点上，分布式事务也能实现上述目标。如果消息发送失败或者某个节点事务失败，两者都必须中止。消息队列可以在之后重传消息。因此通过自动提交和消息处理结果，可以确保消息有效处理只有一次。<br>
        需要注意，只有所有相关系统都使用相同的原子性提交协议的前提下，这种分布式事务才是可行的。例如，如果处理结果之一是发送邮件，而邮件服务器不支持<code>2PC</code>，此时某个过程出错，消息重新入队重试，邮件就可能会被发送多次。</p>
<h3 id="22-xa事务">2.2 <code>XA</code>事务</h3>
<p>        <code>X/Open XA</code> ( $eXtended\ Architecture$ , $XA$ ) 是异构环境下进行<code>2PC</code>的一个工业标准。目前，许多关系型数据库 ( <code>PostgreSQL</code>、<code>MySQL</code>、<code>Oracle</code>等 ) 和消息队列 ( <code>ActiveMQ</code>、<code>MSMQ</code>、<code>IBM MQ</code>等 ) 都支持<code>XA</code>。<code>XA</code>并不是一个网络协议，而是一个与事务协调者进行通信的<code>C API</code>。当然，它也支持与其他语言的<code>API</code>绑定，例如<code>Java</code>。<br>
        <code>XA</code>假定应用程序通过网络或客户端的库函数与参与者节点进行通信，如果驱动程序支持<code>XA</code>，意味着应用程序可以调用<code>XA API</code>确定操作是否属于异构分布式事务的一部分。如果是，则发送必要的信息给数据库服务器。它还支持回调，这样协调者可以通过回调函数通知所有参与者执行准备或者提交 ( 或者中止 )。<br>
        协调者需要实现<code>XA API</code>。虽然标准没有规定如何实现，但实际上，协调者也通常是一个<code>API</code>库，与产生事务的应用程序运行在相同进程中。这些<code>API</code>跟踪事务的参与者，收集投票，并在本地磁盘中记录决定。如果应用程序发生崩溃，或者节点故障，在重启后，协调者会通过<code>XA API</code>读取日志，恢复决定。完成这些后，协调者才能继续通过回调函数来要求参与者执行提交或者中止。数据库服务器无法直接与协调者通信，必须通过相应<code>API</code>。</p>
<h3 id="23-协调者故障">2.3 协调者故障</h3>
<p>        数据库事务通常持有待修改行的行锁，用于防止脏写。此外，如果要使用串行化的隔离级别，<code>2PC</code>还会对曾经读取的行持有读锁。在事务提交之前，这些锁都不会被释放。因此，在<code>2PC</code>中，如果出现协调者故障带来的停顿，那么这些锁在停顿期间都不会被释放。长时间持有锁是一件坏事，这意味着其他事务无法有效执行，使得许多上层应用处于不可用状态。<br>
        理论上，如果协调者崩溃后重新启动，它应该可以从日志中恢复那些停顿的事务。然而，实践中，孤立的不确定事务是可能发生的，例如由于软件 $bug$ 导致交易日志丢失或者损坏。这些事务无法自己解决，而是一直停留在那里，即使重启节点也无法解决，因为<code>2PC</code>要求重启后继续保持重启前的事务状态。<br>
        唯一的办法就是让管理员手动决定提交还是回滚。这可能会带来大量的手工操作，并且可能在关键生产环境的中断间隙，存在巨大的压力和时间限制。许多<code>XA</code>的实现都支持某种紧急避险措施，称为<strong>启发式决策</strong>：允许参与者节点在紧急情况下单方面做出决定，放弃或者继续停顿的事务。这种做法可能会破坏事务的原子性，违背了<code>2PC</code>原则。要注意，这种做法只是为了应急，不能作为常规手段使用。</p>
<h3 id="24-分布式事务的限制">2.4 分布式事务的限制</h3>
<p>        <code>XA</code>事务解决了多个参与者之间达成一直的问题，但是也引入了很多操作限制。特别是，核心的事务协调者本身就是一种数据库，因此需要和其他重要的数据库一样格外小心：</p>
<ul>
<li>如果协调者不支持数据复制，在单节点上运行，那么它就是整个系统的单点故障。实际上，许多协调者并非高可用，或者只支持最基本的复制；</li>
<li>许多服务端应用程序都倾向于无状态模式 ( 更适合<code>HTTP</code> )，将所有持久状态都保存在数据库中。这样应用服务器可以轻松地添加或者删除实例。但是当协调者本身就是服务器的一部分时，协调者的日志就成为了可靠系统的重要组成部分，与数据库本身一样重要，这样的服务器本身就不是无状态的了；</li>
<li><code>XA</code>需要与各种数据系统保持兼容，最终其实是多系统可兼容的最低标准。例如，它无法检测不同系统的死锁条件 ( 这需要其他标准化协议，多个系统需要交换锁信息 )；</li>
<li>数据库内部的分布式事务比起<code>XA</code>来说，限制要少很多。然而对于<code>2PC</code>还是存在潜在的限制，比如所有参与者必须投票赞成。所以分布式事务扩大了事务失败的可能性，与构建容错系统的目标背道而驰。</li>
</ul>
<h2 id="3-共识算法">3. 共识算法</h2>
<p>        共识是让几个节点就某项提议达成一致，通常形式化描述为：一个或多个节点可以提议某些值，由共识算法来决定最终值。共识算法必须满足以下性质：</p>
<ul>
<li><strong>协商一致性</strong> ( $Uniform\ agreement$ )：所有节点都接受相同决议；</li>
<li><strong>诚实性</strong> ( $Integrity$ )：所有节点做出决定后都不能反悔，即一个决议不能有两个结果；</li>
<li><strong>合法性</strong> ( $Validity$ )：决议的结果一定是由某个节点提议的；</li>
<li><strong>可终止性</strong> ( $Termination$ )：节点在不崩溃的前提下一定可以达成协议。</li>
</ul>
<p>        如果不关心容错，满足前三个属性很容易：可以强行指定某个节点为“独裁者”，由它做出所有决定，唯一要注意的就是该节点失败的情况。上述共识的系统模型假定当某个节点崩溃后，节点就彻底消失，永远不会回来。在这种条件下，<code>2PC</code>显然不满足可终止性。当然，如果所有节点都崩溃了，那么无论哪种算法都不能继续做出决定。因此，可终止性的前提是，发生崩溃或者不可用的节点数必须小于半数节点。<br>
        最著名的共识算法包括<code>VSR</code>、<code>Paxos</code>、<code>Raft</code>和<code>Zab</code>，这些算法存在很多相似之处，但又不完全相同。它们大部分并不是直接使用形式化模式，而是决定了一系列值，再通过全序关系广播算法。全序关系广播通常指节点之间交换消息的某种协议，下面是一个非正式定义，要求满足两个基本安全属性：</p>
<ul>
<li>可靠发送：没有消息丢失，如果某个消息发送到了一个节点，那么它也要发送给其他节点；</li>
<li>严格有序：消息总是以相同顺序发送。</li>
</ul>
<p>        即使节点或者网络出现故障，全序关系广播算法的实现也必须保证以上两条。实现全序关系广播，要求消息顺序在发送前就已确定。理解全序关系广播的另一种方式是将其视为日志，传递消息就像追加日志，所有节点都可以读取日志并看到相同的消息序列。共识算法的全序关系广播相当于持续的多轮共识：</p>
<ul>
<li>由于协商一致性，所有节点以相同顺序发送相同消息；</li>
<li>由于诚实性，消息不能重复；</li>
<li>由于合法性，消息不会被破坏；</li>
<li>由于可终止性，消息不会丢失。</li>
</ul>
<p>        <code>VSR</code>、<code>Raft</code>和<code>Zab</code>都直接采取了全序关系广播，而<code>Paxos</code>则有对应的优化版本，称为<code>Multi-Paxos</code>。</p>
<h3 id="31-epoch和quorum">3.1 <code>Epoch</code>和<code>Quorum</code></h3>
<p>        目前所讨论的素有共识协议在内部都使用了某种形式的主节点，虽然主节点并不是固定的。相反，它们都采用了一种弱保证：定义一个世代编号 ( $epoch$ $number$ )，并保证在每个世代中，主节点是唯一的。如果发现当前主节点失效，节点间就开始新一轮投票，选举新的主节点。每次选举都会被赋予一个单调递增的<code>epoch</code>，如果出现了两个不同的主节点对应于不同<code>epoch</code>好，则更高<code>epoch</code>的主节点将获胜。<br>
        主节点做出任何决定前，都必须检查是否存在更高的<code>epoch</code>，否则就会产生冲突的决定。主节点如果想要做出某个决定，需要将提议发送给其他节点，等待<code>quorum</code>节点响应。<code>quorum</code>节点通常不是由多数节点组成的，并且，只有当没有发现更高<code>epoch</code>主节点存在时，才会对当前提议 ( 带有<code>epoch</code> ) 进行投票。因此，这里其实是有两轮不同的投票：首先投票决定主节点，然后再投票决定提议。其中关键一点是，两轮投票的<code>quorum</code>必须存在重叠。<br>
        投票的过程很像<code>2PC</code>，最大区别是，<code>2PC</code>并不需要通过选举产生协调者，共识算法只需要多数节点同意即可通过。此外，共识算法还定义了恢复过程，出现故障后，通过该过程即可以选举出新的主节点，重新进入一致状态。</p>
<h3 id="32-共识的局限">3.2 共识的局限</h3>
<p>        共识算法为一切不确定系统带来了明确的安全属性，还支持容错。但是这种好处也是有代价的：</p>
<ul>
<li>达成一致之前的投票是一个同步复制过程。但是对于数据库，通常为了更好的性能，会采用异步复制；</li>
<li>共识体系需要严格多数节点；</li>
<li>多数共识算法假定一组固定参与投票的节点集，意味着不能动态添加或删除节点；</li>
<li>共识系统通常依靠超时机制来检测节点失效，在网络延迟高度不确定的环境中，特别是跨区域分布的系统，经常由于网络延迟的原因，节点会被错误地认为发生了故障。虽然这种误判不会影响安全，但是频繁的主节点选举会影响性能；</li>
<li>共识算法对网络问题特别敏感。例如，<code>Raft</code>被发现存在不合理的边界处理：如果网络中存在某一条网络连接持续不可靠，它会在两个节点之间反复切换主节点，当前主节点会被不断赶下台。其他的共识算法也会有类似问题，所以面对不可靠网络，如何设计更具鲁棒性的共识算法仍然是一个开放性的研究问题。</li>
</ul>
<h3 id="33-paxos">3.3 <code>Paxos</code></h3>
<p>        <code>Paxos</code>算法运行在允许宕机的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用多数机制，在具有 $2F + 1$ 个节点的系统中，最多允许 $F$ 个节点的故障。<code>Paxos</code>具有以下系统角色：</p>
<ul>
<li>提议者 ( $Proposer$ )：提出提议，包含提议编号 ( $Proposal$ $ID$ ) 和提议值 ( $Value$ )；</li>
<li>决策者 ( $Acceptor$ )：参与决策，回应提议者的提议；</li>
<li>学习者 ( $Learner$ )：不参与决策，从其他节点学习最终的提议值。</li>
</ul>
<p>        在多副本状态机中，每个副本都是提议者、决策者和学习者。<br>
        <code>Paxos</code>算法分为两阶段：</p>
<ol>
<li>准备阶段：提议者向决策者发出准备请求，决策者针对收到的准备请求进行承诺；</li>
<li>决策阶段：提议者在接收到多数决策者的回应 ( $Promise$ ) 之后，向决策者发出提议请求，决策者收到请求后处理；</li>
<li>学习阶段：提议者在接收到多数决策者的决策之后，标记本次决策成功，将提议值发送给所有学习者。</li>
</ol>
<p>        决策者会对提议者的准备请求做出两个承诺和一个回应：</p>
<ul>
<li>承诺不再接收<code>ID</code>小于等于当前准备请求<code>ID</code>的准备请求；</li>
<li>承诺不再接收<code>ID</code>小于当前准备请求的决策请求；</li>
<li>回应之前接收过的<code>ID</code>最大的提议的<code>ID</code>和提议值。</li>
</ul>
<p>        原始的<code>Paxos</code>算法只能对一个值进行决策，每次决策需要至少两次收发请求，在高并发场景下可能需要更多次沟通，极端情况下还会形成<strong>活锁</strong>，即两个提议者交替发起请求，不断递增 $Proposal$ $ID$ 。因此，这种<code>Paxos</code>只适合理论研究，不适合应用在实际生产环境中。<br>
        实际生产环境中往往需要连续确定多个值，而且具有更高效率。<code>Multi-Paxos</code>就是为此提出的，它作出了两点改进：</p>
<ul>
<li>针对每个提议者，生成一个 $Instance$ $ID$ ，每个提议者由一个<code>ID</code>标识；</li>
<li>在所有提议者中选举一个主节点，由主节点将提议提交给决策者进行决策。这样就可以跳过准备请求阶段，因为实际上只有一个提议者会提议。</li>
</ul>
<p>        <code>Multi-Paxos</code>首先需要选举一个主节点，选举的过程也可以通过<code>Paxos</code>算法决策，一种简单的方式如下：</p>
<ul>
<li>具有最高<code>ID</code>的服务器作为主节点，每个服务器定时向其他服务器发送心跳消息检查状态；</li>
<li>如果没有收到比它高的<code>ID</code>的节点的心跳消息，它就会尝试发起一轮选举，选举自己作为领导者；</li>
<li>非主节点只会作为决策者，提议者只有主节点一个。</li>
</ul>
<p>        <code>Multi-Paxos</code>通过改变准备阶段的作用范围，使得多个实例的提交只需要一次决策，将两阶段变为一阶段，提高了效率。即使存在多个主节点 ( 脑裂 )，也不影响安全性，这时候只是会退化为原始的<code>Paxos</code>。</p>
<h3 id="34-raft">3.4 <code>Raft</code></h3>
<p>        <code>Raft</code>实现了和<code>Paxos</code>相同的功能，将共识问题分解为多个子问题，使用了更强的假设来减少需要考虑的状态。<code>Raft</code>将系统分为以下角色：</p>
<ul>
<li>领导者 ( $Leader$ )：接收客户端请求，同步给跟随者，当同步到多数节点后提交请求；</li>
<li>跟随者 ( $Follower$ )：接收并持久化领导者的请求，在接收到领导者的提交请求后，进行提交；</li>
<li>候选人 ( $Candidate$ )：可以参与选举的节点。</li>
</ul>
<p>        <code>Raft</code>算法只允许一个领导者的存在。节点之间存在心跳检测，如果跟随者长时间没有接收到来自领导者的心跳消息，则会开启新一轮选举。收到多数投票的候选人会称为新的领导者，直到其出现故障。<code>Raft</code>通过任期 ( $term$ ) 管理选举，任期通过时间划分，每个 $term$ 的开始都是选举，选举完成后，在这个任期内领导者会负责管理集群。<br>
        <code>Raft</code>拥有两条限制，用于保证安全性：</p>
<ul>
<li>拥有最大偏移量的候选人才可以成为领导者。这要求候选人在选举中发送自己的偏移量；</li>
<li>只允许提交当前任期的请求，之前任期的无法不能再提交。这要求领导者在请求中带上任期。</li>
</ul>
<h2 id="4-成员与协调服务">4. 成员与协调服务</h2>
<p>        <code>ZooKeeper</code>或者<code>etcd</code>这样的项目通常称为“分布式键值存储”或者“协调与配置服务”。它们对外提供的<code>API</code>与数据库非常相像：读取、写入对应主键值，或者按序便利主键。应用程序开发者其实很少直接使用<code>ZooKeeper</code>，因为它并非通用数据库，绝大部分通过其他项目来间接依赖，比如<code>HBase</code>、<code>Hadoop YARN</code>、<code>Kafka</code>等。<code>ZooKeeper</code>和<code>etcd</code>主要针对保存少量、可完全载入内存的数据 ( 即使最终还是要写入磁盘 )，不适合用于保存大量数据。它们通常采用容错的全序广播算法在所有节点上复制数据从而实现高可靠。<code>ZooKeeper</code>的实现其实模仿了<code>Google</code>的<code>Chubby</code>分布式锁服务，不仅实现了全序广播，还提供了其他有趣的特性：</p>
<ul>
<li>线性化的原子操作：使用<code>CAS</code>操作，实现加锁服务。例如多个节点同时尝试执行相同操作，则确保只会有一个节点成功。共识算法满足了原子性和线性化，即使某些节点发生故障或者网络中断。分布式锁通常是一个带有过期时间的租约，保证即使某些客户端故障也可被释放；</li>
<li>操作全序：<code>fencing</code>令牌保证每次加锁的数字总是单调递增的，<code>ZooKeeper</code>会对所有操作执行全局排序，为每个操作赋予一个唯一的事务<code>ID</code>和版本号；</li>
<li>故障检测：客户端与<code>ZooKeeper</code>之间会维持一个长期会话，客户端会周期性地与<code>ZooKeeper</code>服务节点互相交换心跳信息，以检查对方是否存活。即使出现连接中断，或者某个<code>ZooKeeper</code>节点失效，会话仍处于活动状态。如果连接断开时间超过了超时时间，<code>ZooKeeper</code>会声明会话失败，此时该会话持有的所有锁资源会被自动释放 ( 即<code>ZooKeeper</code>中的临时节点 )；</li>
<li>更改通知：客户端不仅可以读取其他客户端所创建的锁和键值，还可以监视它们的变化。因此，客户端可以知道其他客户端何时加入了集群，以及客户端是否发生了故障。通过订阅机制，客户端不需要频繁轮询服务。</li>
</ul>
<h3 id="41-节点任务分配">4.1 节点任务分配</h3>
<p>        <code>ZooKeeper</code>和<code>Chubby</code>的一个非常适合的场景是，如果系统有多个流程或服务的实例，并且需要其中一个实例充当主节点，在主节点失效时由其他节点接管。显然，这是主从模型的特征。此外，它对于作业调度系统也十分有用。还有另一个场景，对于一些分区资源 ( 数据库、消息流、文件存储等 )，需要决定节点分区分配。当有新节点加入集群时，需要将某些现有分区从当前节点迁移到新节点，从而实现动态的负载均衡。<br>
        上述场景都可以借助<code>ZooKeeper</code>的原子操作 ( 临时节点和订阅机制 ) 来实现。应用程序最初可能只运行在单节点，之后扩展到数千节点。在这么多节点上进行投票是很低效的。而<code>ZooKeeper</code>通常是在固定数量的节点上运行，可以非常高效的支持大量客户端。通常，<code>ZooKeeper</code>管理的数据变化十分缓慢，更改频率往往是分钟级甚至小时级，如果需要频繁修改，应该考虑其他工具。</p>
<h3 id="42-服务发现">4.2 服务发现</h3>
<p>        <code>ZooKeeper</code>、<code>etcd</code>和<code>Consul</code>经常用于服务发现。在典型的云环境中，虚拟机可能会动态变化，这时无法提前知道服务节点的<code>IP</code>地址，因此，可以在每次节点启动时将网络端口信息向<code>ZooKeeper</code>等服务注册，其他人只需要向<code>ZooKeeper</code>的注册表请求即可。<br>
        但是，关于服务发现是否需要共识还缺乏统一认识，习惯上是通过<code>DNS</code>来将服务名称转为<code>IP</code>。从<code>DNS</code>读取肯定不满足线性化，然而现实情况是，如果<code>DNS</code>返回的是过期值也不会有什么大问题。总体来讲，<code>DNS</code>更看重网络中断时的可用性和鲁棒性。</p>
<h3 id="43-成员服务">4.3 成员服务</h3>
<p>        <code>ZooKeeper</code>还可以作为成员服务的一部分，用于确定当前哪些节点处于活动状态，并且是集群的有效成员。这里依然存在误判的可能，即使这样，系统就成员资格的认识是一致的。</p>

            </div>
            <div class="meta post-footer">
                <span>2022 Nov 13 16:18</span>
                <a href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9/">分布式数据系统：主从节点</a></h1>
            <div class="post-content">
                
                
                <h2 id="1-主从模式">1. 主从模式</h2>
<h3 id="11-同步复制">1.1 同步复制</h3>
<p>        对于关系型数据库，同步或者异步通常是一个可选项，而其他系统可能是硬性指定二选一。<br>
        同步复制的优点是：一旦向用户确认，从节点可以保证已经完成了与主节点的同步，数据已经处于最新版本。如果主节点发生故障，总是可以确保之后继续访问从节点的数据一定是最新的。缺点是：如果同步的从节点无法确认成功，整个写入就不能成功，主节点会阻塞之后的所有写操作，直到同步副本确认。由于该缺点的存在，把所有从节点都配置为同步复制有些不切实际。在实践中，如果数据库启用了同步复制，通常意味着其中某个从节点是同步的，其他从节点则是异步的。如果同步的从节点不可用或者性能下降，则将另一个从节点升级为同步。这样可以保证至少有两个节点拥有最新的数据，这种配置也被称为<strong>半同步</strong>。<br>
        在主从模式下，如果要提高读性能，需要添加更多的从节点。但是，这种方式实际上只能用于异步模式，因为随着从节点的增加，全同步模式需要同步的从节点数量也会增加，任何单节点的故障或者网络中断都会导致整个集群无法写入，节点的增加也会提高故障机率，所以全同步模式在实践中是非常不可靠的。</p>
<h3 id="12-异步复制">1.2 异步复制</h3>
<p>        主从复制通常会被配置为全异步模式。此时，如果主节点失败且不可恢复，则所有尚未同步的从节点的写请求都会丢失，即使已经向客户端确认了写操作完成，仍然无法保证数据的持久化。全异步模式的优点是，不管从节点的数据多么滞后，总是可以继续响应写请求，具有较高吞吐性。异步模式听起来很不靠谱，但是却被广泛使用，特别是那些从节点数据巨大，或者分布于广域地理环境的情况。<br>
        异步模式下节点的数据同步可能存在滞后，意味着对主节点和从节点同时发起相同的查询，返回的结果可能是不一致的。但是，这种不一致只是暂时的状态，在不写数据库的情况下，从节点最终会与主节点的数据保持一致，这种效应也被称为<strong>最终一致性</strong>。<br>
        理论上，复制的滞后并没有上限。正常情况下，这个延迟可能不到 $1s$ ，实践中通常不会有太大影响。但是，如果系统的性能抵达上限，或者存在网络问题，延迟可能会达到几秒甚至几分钟。</p>
<h4 id="121-读写一致性">1.2.1 读写一致性</h4>
<p>        许多应用让用户提交数据，并在之后查询这些数据。用户向主节点提交数据后，之后的查询可能是在从节点上，在大多数情况下，这是个很合适的方案。然而，异步模式下，同步可能存在滞后，意味着，返回的数据是旧数据，在用户看来，代表他刚刚提交的数据丢了。<br>
        这种情况，我们需要<strong>读写一致性</strong>，或者叫<em><strong>写后读一致性</strong></em>。该机制保证，如果用户重新加载页面，总是能看到最近提交的更新。有几种方式可以实现读写一致性：</p>
<ul>
<li>如果用户访问可能会被修改的内容，从主节点读取。这种方式要球一些方法在执行实际查询前，就知道内容是否改变。比如，社交网络上的用户信息通常只能由所有者编辑，因此，可以让用户总是从主节点读取自己的用户信息，从节点读其他人的用户信息；</li>
<li>如果应用的大部分内容都可以被所有用户修改，这种方式就不太有效了。此时需要其他方式来判断，比如跟踪更新时间，在更新后的一分钟内，总是从主节点读取；或者监控从节点的复制滞后程度，避免从滞后超过一分钟的从节点读取数据；</li>
<li>客户端记录最近更新的时间戳，附带在请求中，节点可以通过该时间戳确保返回该时间戳之后的更新，如果无法返回，交由另外一个节点处理。时间戳可以是逻辑时间戳 ( 比如日志序列号 ) 或者实际系统时间；</li>
<li>如果副本分布在多个数据中心，这时情况会比较复杂，应当将请求路由到主节点所在的数据中心，即使该数据中心可能离用户距离很远。</li>
</ul>
<p>        如果同一用户从多端访问 ( 比如<code>Web</code>端和移动端 )，情况就更加复杂了，不仅要提供跨设备的读写一致性，还有新问题：</p>
<ul>
<li>时间戳方式难以实现，因为一台设备并不知道另一台设备的操作，如果需要实现时间戳方式，元数据需要做到全局共享；</li>
<li>如果副本分布在多数据中心，无法保证来自不同设备的连接路由到同一个数据中心。</li>
</ul>
<h4 id="122-单调读">1.2.2 单调读</h4>
<p>        假定用户发起多次读取，读请求可能会被路由到不同节点，则可能会出现请求返回不同结果的情况。<strong>单调读</strong>一致性可以确保不会发生这种异常。单调读一致性比强一致性弱，但是比最终一致性强。读取数据时，单调读保证同一个用户一次发起的多次读取不会看到回滚 ( 数据不一致 ) 现象。一种实现单调读的方式是：确保每个用户总是固定读同一个节点，例如基于用户<code>ID</code>哈希。</p>
<h4 id="123-前缀一致读">1.2.3 前缀一致读</h4>
<p>        用户发起两个请求，后一个请求的内容依赖于前一个请求，比如用户先写入 $1$ ，再递增为 $2$ 。从用户的角度，这个顺序没有问题。但是在其他观察者的角度，可能会存在逻辑问题，比如由于网络延迟，观察者先观察到后一个请求，这时顺序就变成了用户先写入 $2$ ，再写入 $1$ 。为了防止这种异常，需要引入<strong>前缀一致性</strong>，即对于一系列按照某个顺序发起的写请求，读取的时候也应该按照这个顺序。<br>
        这个问题是存在于分区数据库的一个特殊问题。如果数据库总是以相同的顺序写入，那么读取的时候看到的会是一致的序列。但是，分区数据库的不同分区之间是独立运行的，所以没有一个全局的写入顺序，导致用户读取的时候，会读到一部分新值和一部分旧值。一种解决方案是：将所有具有因果关系的写入都交给同一个分区完成，但是会导致效率大打折扣。</p>
<h3 id="13-节点失效">1.3 节点失效</h3>
<h4 id="131-从节点失效">1.3.1 从节点失效</h4>
<p>        从节点的磁盘上保存了数据变更日志，如果从节点崩溃，或者与主节点之间发生暂时性的网络中断，可以通过该日志获取故障前处理的最后一个事务，向主节点请求该事务之后的中断期内所有数据变更，将其应用到本地即可，之后就可以像正常情况一样持续接收来自主节点的数据流变化。</p>
<h4 id="132-主节点失效">1.3.2 主节点失效</h4>
<p>        主节点失效，则需要选择某个从节点，将其提升为主节点。同时，客户端也要将之后的写请求发送给新的主节点。故障切换可以是手动的，也可以是自动的，自动切换的步骤如下：</p>
<ol>
<li>确认主节点失效。主节点可能出于多种原因失效，比如系统崩溃、停电、网络中断等，并没有什么办法可以检测出失效原因，所以大多数系统都采用了超时机制判断。节点间会持续地互相发送心跳消息，如果发现某个节点在一段时间 ( 比如 $30s$ ) 内都没有响应，就认为该节点已经失效；</li>
<li>选举新的主节点。新的主节点可以通过一种共识算法来选举，或者由控制节点指定。候选节点最好是与主节点之间数据差异最小的，从而最小化数据丢失的风险；</li>
<li>重新配置系统使得新主节点生效。客户端需要将写请求发送给新的主节点，如果原来的主节点之后重新上线，需要将其降级为从节点，并认可新的主节点。</li>
</ol>
<p>        切换过程中可能存在很多变数：</p>
<ul>
<li>如果使用异步复制，新的主节点相比原主节点的数据存在滞后，在选举完成后，原主节点又很快恢复并加入集群，接下来的写操作要怎么处理？新的主节点可能会收到冲突的写请求，因为原主节点并没有意识到发生了主节点切换，仍然会尝试同步其他从节点。一种常见的解决方案是，直接丢弃这些冲突的写请求，虽然这会违背数据更新持久化的承诺；</li>
<li>如果有其他依赖于数据库的组件在一起协同使用，丢弃数据的方案就很危险。例如，在<code>GitHub</code>的一个事故中，主节点在未完全同步的情况下失效，新主节点被选举，由于存在滞后，原主节点已经分配出去，存储在<code>Redis</code>中的自增主键，被新主节点再次使用，导致了<code>MySQL</code>与<code>Redis</code>之间的数据不一致；</li>
<li>某些情况下，可能会发生两个节点都认为自己是主节点的情况，称为<strong>脑裂</strong>。脑裂非常危险，它可能会导致两个主节点同时接收写请求，并且没有很好的解决数据冲突，导致数据被丢失或者被破坏。有些系统会通过强制关闭其中一个节点的方式，来解决脑裂问题。然而，如果设计或者实现考虑不周，也是有可能出现两个节点都被关闭的情况；</li>
<li>如果设置超时时间？超时时间越厂，确认主节点失效的时间也就越长，意味着总体的恢复时间就越长。例如，突发的负载峰值会导致节点的响应时间变长甚至超时，或者由于网络故障导致延迟增加，如果这时系统已经处于高负载情况，或者网络严重拥堵的情况，不必要的切换只会使情况更糟。</li>
</ul>
<h3 id="14-日志">1.4 日志</h3>
<h4 id="141-语句复制">1.4.1 语句复制</h4>
<p>        主节点记录执行的写请求语句，将该操作语句作为日志，发送给从节点。在关系型数据库中，意味着发送 $INSERT$ 、$UPDATE$ 等语句，从节点分析并执行这些语句，像来自客户端那样。基于语句复制存在一些不适用场景：</p>
<ul>
<li>调用非确定性函数的语句，比如 $NOW(\ )$ 或者 $RAND(\ )$ 函数，这会导致在不同副本产生不一样的值；</li>
<li>依赖于自增列，或者现有数据的语句，这意味着所有副本必须按照完全相同的顺序执行，否则会产生不同的结果。进而，如果存在多个并发事务，也会影响事务之间的执行；</li>
<li>存在副作用的语句（如触发器、存储过程、用户定义函数等），可能会在不同副本上产生不同副作用。</li>
</ul>
<p>        这些问题可以采取某些措施来解决，比如主节点记录操作语句时将非确定性函数替换为确定结果。遗憾的是，存在太多边界条件，因此基于语句的复制通常不是首选。</p>
<h4 id="142-wal">1.4.2 <code>WAL</code></h4>
<p>        通常，数据库的每个写操作，都会以追加形式写入<code>WAL</code>日志中，可以使用完全相同的日志在另一个节点上构建副本，即主节点不仅将<code>WAL</code>日志写入磁盘，还会通过网络发送给从节点。<br>
        基于<code>WAL</code>复制的缺点是日志描述的数据结果非常底层，比如关系型数据库，<code>WAL</code>会记录磁盘块的哪些字节发生改变，以及其他细节等，从而与具体的存储方案高度耦合，如果数据的存储格式发生了改变，之前的同步方式也会失效。如果复制协议允许从节点的软件版本比主节点更新，那么可以实现数据库软件的不停机升级；相反，如果要求版本严格一致，那么升级就只能以停机为代价。</p>
<h4 id="143-行复制">1.4.3 行复制</h4>
<p>        基于行的复制将复制和存储引擎分离，复制与存储引擎采用不同的日志，这时复制日志称为逻辑日志。</p>
<ul>
<li>对于行插入，日志包含所有相关列的新值；</li>
<li>对于行删除，日志应该以某种方式标识已删除的行 ( 通常是主键 )；</li>
<li>对于行更新，日志应该以某种方式标识被更新的行，以及被更新列的新值。</li>
</ul>
<p>        如果一个事务涉及多行数据修改，就会产生多条行日志，并在之后跟着一条记录，指出该事务已经提交。<code>MySQL</code>的<code>binlog</code>支持该种方式。由于逻辑日志与存储引擎解耦，因此数据库存储可以向后兼容，主从节点可以基于不同版本的软件，甚至是不同存储引擎运行。<br>
        对于外部应用，逻辑日志也更容易被解析。解析逻辑日志也被称为变更数据捕获。</p>
<h4 id="144-触发器">1.4.4 触发器</h4>
<p>        在某些时候，我们可能需要一种具有更高灵活性的复制方式，比如只复制一部分数据，或者从一个数据库复制到另一种数据库，或者指定冲突解决逻辑等，这种情况下，可以借助许多关系数据库都支持的功能：触发器和存储过程。触发器支持注册自己的应用层代码，当数据库系统发生数据改变时，自动执行这些代码。基于触发器的复制通常具有比其他方式更高的开销，也更容易出错。</p>
<h2 id="2-多主模式">2. 多主模式</h2>
<p>        目前为止，我们只考虑了单主节点的主从复制架构，这也是较为常见的方式。但是，也存在一些其他方式。主从复制的缺点很明显：只存在一个主节点，所有写入都必须经过主节点。如果存在某种原因，比如网络中断等，导致主节点无法连接，那么整个集群的写入都会受到影响。</p>
<h3 id="21-多主节点">2.1 多主节点</h3>
<p>        多主节点是一种对主从复制模型的扩展，允许配置多个主节点，每个主节点都可以接收写操作，并将数据更改转发到其他节点。这样，每个主节点既扮演主节点，也扮演其他主节点的从节点。<br>
        多主节点存在以下适用场景：</p>
<ul>
<li>多数据中心：为了容忍数据中心级别的故障，或者在地理上更接近用户，可以把数据库的副本横跨多个数据中心。在常规的主从复制模式中，主节点只能放在其中一个数据中心，而多主节点允许在每个数据中心都配置一个主节点。这样每个写操作都可以在本地数据中心内快速响应，并且，同数据中心之间的网络性能和稳定性通常会更好，意味着用户的体验也会更好。但是这种情况也要考虑用户同时修改相同数据的情况，必须解决潜在的写冲突；</li>
<li>离线客户端操作：如果应用需要在网络断开后继续工作，那么应当在设备提供一个充当主节点的本地数据库，所有设备之间采用异步方式同步副本，滞后时间可能是几小时或者数天。从架构层面来看，这基本上等同于数据中心之间的多主复制，但是数据中心的概念缩小到了某个具体设备上，并且网络连接十分不可靠；</li>
<li>协作编辑：实时协作编辑应用允许多个用户同时编辑文档，虽然这不能完全等价于数据库复制，但是在很多方面具有相似性。用户编辑文档时需要将修改立即应用到本地副本，再通过异步方式同步到服务器，以及一起编辑文档的其他用户。要确保不会发生编辑冲突，应用程序需要将文档锁定，再进行编辑。这也意味着一个用户要编译时，必须先等另一个用户提交修改并释放锁。为了加快编辑效率，锁的粒度应该很小，单个按键甚至可以是全程无锁的。</li>
</ul>
<h3 id="22-写冲突">2.2 写冲突</h3>
<p>        多主复制的最大问题是存在写冲突。</p>
<h4 id="221-同步与异步检测">2.2.1 同步与异步检测</h4>
<p>        如果是主从复制，发生冲突时，第二个写请求会被阻塞，直到第一个完成，或者被中止。在多主节点模式下，这两个写请求都会成功，并且只能在之后的异步检测时才能发现冲突。理论上，同步检测冲突也是可行的，但是需要写请求等待所有副本完成同步，反而会失去多主节点的优势。</p>
<h4 id="222-冲突避免">2.2.2 冲突避免</h4>
<p>        如果应用层可以保证对某个特定记录的写总是经过同一节点，就不会发生冲突。实践中，不少主节点复制模型锁实现的冲突解决方案存在瑕疵，因此，冲突避免通常是首选方案。比如，一个用户需要更新自己的数据，我们可以通过用户<code>ID</code>哈希的方式，保证同一个用户的写请求总是发送到同一个数据中心。从用户角度来看，等同于主从复制。有时候，可能需要改变指定的节点，比如数据中心故障，或者用户漫游到另一个位置，需要换到更近的数据中心，这时这种方案就不再有效了。</p>
<h4 id="223-一致收敛">2.2.3 一致收敛</h4>
<p>        主从模型下，数据更新符合顺序性原则，即对同一个字段的多次更新，字段最终值由最后一个更新操作决定。多主节点模型中，由于不存在这个顺序，所以最终值也是不确定的。如果每个副本都是按照其看到的顺序写入，那么数据最终可能会不一致。因此，数据库必须以一种收敛趋同的方式解决冲突，这也意味着所有更改被复制、同步之后，所有副本的最终值相同。一致收敛有如下解决方案：</p>
<ul>
<li>为写入分配一个唯一<code>ID</code>，比如时间戳、哈希或者随机数，选择<code>ID</code>最大的作为胜者，丢弃其他写入。如果基于时间戳，则称为最后写入者获胜。虽然这种方法很常见，但是容易造成数据丢失；</li>
<li>为每个副本分配一个<code>ID</code>，制定一个规则，比如<code>ID</code>较大的副本写入优于<code>ID</code>较小的副本。同样的，这种方式也会导致数据丢失；</li>
<li>通过某种方式将值合并，比如字母顺序排序等；</li>
<li>利用预定义格式记录和保留冲突信息，再通过应用层逻辑解决冲突，可能会经过用户。</li>
</ul>
<h4 id="224-自定义冲突解决逻辑">2.2.4 自定义冲突解决逻辑</h4>
<p>        解决冲突最合适的还是依赖于应用层代码，所以大多数多主模型都支持用户编写应用代码解决冲突：</p>
<ul>
<li>写入时执行：数据库系统在复制变更日志时检测到冲突，调用应用层代码解决；</li>
<li>读取时执行：写入时保留冲突值，读取时返回多个版本的数据，应用层可能自动解决冲突，或者将冲突交给用户解决，并将最终结果返回给数据库。</li>
</ul>
<p>        冲突解决通常针对某一行或者某个文档，而不是整个事务。如果有一个原子事务包含多个不同写请求，每个写请求仍然需要分开来考虑。</p>
<h3 id="23-拓扑结构">2.3 拓扑结构</h3>
<p>        多主模式下，写请求从一个节点传播到其他节点的路径，可以通过<strong>拓扑结构</strong>描述。最常见的拓扑结构是全链路拓扑：主节点将写入同步到其他所有主节点。除此之外，还存在着其他一些拓扑结构，例如，默认情况下<code>MySQL</code>只支持环形拓扑结构，即所有主节点围成一个环，每个节点只接收来自前序节点的写入，只会写后续节点。星形结构也是另一种流行的拓扑结构，一个指定的根节点会将写入转发给所有其他节点，其他节点只会写该根节点。类似的，也可以对星形结构进行推广，拓展到树形结构。<br>
        环形结构和星形结构下，写请求需要通过多个节点才能到达所有副本，中间节点需要转发从其他节点收到的数据变更。为了防止循环，每个节点需要一个唯一<code>ID</code>，并在变更日志中标识已经经过的节点<code>ID</code>。环形和星形的问题是，如果某个节点发生故障，会影响其他节点的转发。可以通过重新配置的方式排除故障节点。全链路拓扑也有自己的问题，通常发生在网络拥塞的情况下，某些网络链路可能会比其他网络链路更快，导致变更日志的互相覆盖。</p>
<h2 id="3-无主模式">3. 无主模式</h2>
<p>        目前为止讨论的所有复制方法，都要求客户端先向主节点发送写请求，再由数据库复制到其他副本。主节点决定写顺序，从节点重放。一些数据存储系统则采取了不同的思路，放弃主节点，允许任何节点接收来自客户端的写请求。最早的数据复制系统就是无主节点的，但是在后来被渐渐遗忘了，当亚马逊采用<code>Dynamo</code>系统之后，无主模式又成为了一种时髦的架构，<code>Riak</code>、<code>Cassandra</code>和<code>Voldemort</code>都是受<code>Dynamo</code>启发设计的无主节点的开源数据库系统，也被称为<code>Dynamo</code>风格数据库。<br>
        在一些无主节点实现中，客户端直接将写请求发送给多副本。而在一些其他实现中，会有一个协调者代表客户端写入。与主节点不同，协调者并不负责维护写入顺序。</p>
<h3 id="31-节点失效">3.1 节点失效</h3>
<p>        假设存在一个三副本数据库，一个副本不可用。用户向三个副本发起写请求，有两个副本成功确认，一个副本无法处理。用户在接收到两个成功确认后，认为写入成功。之后，失效节点重新上线，由于滞后数据尚未同步，客户端读取该节点数据，会得到过期数据。一种解决方式是，客户端读取时，不是只向一个副本发起请求，而是并行向多个副本发起请求，并通过版本号来确定哪些值更新。</p>
<h4 id="311-读修复和反熵">3.1.1 读修复和反熵</h4>
<p>        节点失效滞后重新上线，由于数据滞后，所以需要重新同步。<code>Dynamo</code>风格数据库通常使用以下两种机制：</p>
<ul>
<li>读修复：客户端并行读取多个副本时，可以通过版本号等方式，检测过期的返回值；</li>
<li>反熵：一些数据存储的后台进程会不断检测副本之间的数据差异，同步滞后的数据。与主从同步不同，这种方式并不保证顺序写入，并且会有明显的同步滞后。</li>
</ul>
<p>        要注意的是，并非所有的数据库都支持以上机制，例如<code>Voldemort</code>没有反熵。</p>
<h3 id="32-quorum">3.2 <code>quorum</code></h3>
<p>        如果有 $n$ 个副本，写入需要 $w$ 个节点确认，读取必须至少要查询 $r$ 个节点，则只需要 $w + r$ &gt; $n$ 就可以确保读取的节点一定会包含最新值。满足这些的 $r$ 、$w$ 值称为法定票数读 ( 或仲裁读 ) 或法定票数写 ( 或仲裁写 )。也可以认为 $r$ 和 $w$ 是用于判定读、写是否有效的最低票数。<br>
        在<code>Dynamo</code>风格数据库中，$n$ 、$r$ 和 $w$ 通常是可以配置的，常见的是配置 $n$ 为奇数，$w = r = \lceil (n + 1) / 2 \rceil$ ，也可以根据需求灵活调整。$w + r$ &gt; $n$ 定义了系统可容忍的失效节点数：</p>
<ul>
<li>$w$ &lt; $n$ ，如果一个节点不可用，仍然可以处理写入；</li>
<li>$r$ &lt; $n$ ，如果一个节点不可用，仍然可以处理读取；</li>
</ul>
<p>        如果可用节点数小于 $r$ 或者 $w$ ，写入或者读取就会返回错误。通常 $r$ 和 $w$ 会被设置为简单多数节点，但是<code>quorum</code>并不一定要求多数，只要读写节点之间存在重合节点即可。即使在 $w + r$ &gt; $n$ 的情况下，也可能存在返回旧值的边界条件：</p>
<ul>
<li>采用了 $sloppy\ quorum$ 的写操作节点和读操作节点可能完全不同，从而无法保证存在重合节点；</li>
<li>如果两个写操作同时发生，无法确定顺序，这时唯一安全的解决方案是合并写入。如果根据时间戳选择，会存在时钟不一致的问题；</li>
<li>如果读写同时发生，写操作可能只在一部分副本上进行，读取时返回的是新值还是旧值并不确定；</li>
<li>如果某些副本上写入成功，另一些副本写入失败，并且总成功副本数少于 $w$ ，已成功副本不会回滚，意味着之后的读操作可能返回已失败的新值；</li>
<li>如果具有新值的节点失效，之后重新加入集群后恢复的数据来自旧值，那么新值的副本数就会少于 $w$ ；</li>
<li><code>quorum</code>也存在一些线性化读取的问题。</li>
</ul>
<p>        <code>Dynamo</code>风格数据库是针对最终一致性场景设计的，$w$ 和 $r$ 不应该是一种绝对保证，而是一种可以灵活调配的配置。配置适当<code>quorum</code>的数据库系统可以容忍某些节点故障，也不需要执行故障切换。它还可以容忍某些节点变慢，因为请求并不需要等待所有 $n$ 个节点响应。对于一些需要高可用和低延迟的场景，还可以容忍偶尔读取旧值。<br>
        但是，<code>quorum</code>并不是总会提供高容错能力，一个网络中断可以很容易切断客户端到多数节点的连接。在断掉连接的客户端看来，相当于集群全部失效。在一个大规模集群中，客户端可能在网络中断时还可以连接到某些节点，但是这个节点数量又不能满足仲裁，数据库就面临一个选择：直接返回错误还是接收写请求并写入暂时可访问的节点？后一种方式称为<em><strong>宽松的仲裁</strong></em>：读写仍然需要 $r$ 和 $w$ 个成功的响应，但包含了那些并不在先前指定的 $n$ 个节点的响应。一旦网络问题解决，临时节点需要把接收到的所有写入发送给原始节点，即数据回传。$sloppy\ quorum$ 并非传统 $quorum$ ，更像是为了保证数据持久性设计的一个保证措施，除非回传结束，否则无法保证客户端一定能从 $r$ 个节点中读到新值。</p>
<h2 id="4-并发写">4. 并发写</h2>
<p>        <code>Dynamo</code>风格数据库允许多个客户端对相同主键发起写操作，意味着写冲突的存在。此外，读修复或者反熵也会导致写冲突。一个核心问题是，由于网络延迟或者部分节点失效，请求在不同节点上的顺序是不同的。如果节点每次收到写请求时就直接覆盖原有值，那么这些节点将永远也无法一致。</p>
<h3 id="41-最后写入者获胜">4.1 最后写入者获胜</h3>
<p>        一种实现收敛的方法是，每个副本总是保留最新的值。假定每个写请求都会最终同步到每个副本，我们需要一个明确的方法来确定哪个写入是最新的。多个客户端向节点发送请求时，一个客户端无法发现另一个客户端，也不知道哪个请求先发起。既然无法确定请求的自然排序，我们可以强制以某种方式排序，比如以时间戳排序。这种解决方法称为<strong>最后写入者获胜</strong> ( $last\ write\ wins$ , $LWW$ )。<code>LWW</code>可以实现最终收敛，代价是数据持久性。如果同一个主键有多个并发写，即使这些写都返回成功，但是最后只会有一个值获胜，其他的将被丢弃。<br>
        在一些场景，比如缓存中，覆盖写是可以接受的。如果覆盖、丢失不可接受，<code>LWW</code>就不是很好的解决方案了。确保<code>LWW</code>安全无副作用的唯一方法是，只写一次然后将写入值视为不可变。例如，<code>Cassandra</code>的一个推荐使用方法就是使用<code>UUID</code>作为主键，这样每个写操作都针对不同、系统唯一的主键。</p>
<h3 id="42-happens-before">4.2 Happens-before</h3>
<p>        如何判断两个操作是否并发，可以通过以下两个例子分辨：</p>
<ul>
<li>一个插入操作发生在增量修改操作之前，并且增量操作基于插入的行，也就是这两个操作间存在因果关系；</li>
<li>多个设备同时写入，一个设备并不知道另一个设备是否也对同一个主键进行写入，即操作间不存在因果关系。</li>
</ul>
<p>        如果操作 $B$ 知道操作 $A$ ，或者 $B$ 依赖于 $A$ ，则称 $A$ 和 $B$ 之间存在<code>Happens-before</code> ( 先序发生 ) 关系，这就是定义并发的关键。因此，对于两个操作 $A$ 和 $B$ ，存在三种可能：$A$ 先发于 $B$ 、$B$ 先发于 $A$ 、$A$ 和 $B$ 并发。如果属于并发，就需要解决潜在的冲突问题。</p>
<h3 id="43-合并并发写的值">4.3 合并并发写的值</h3>
<p>        通过版本号，服务器可以在不依赖值的情况下判断写是否并发。流程如下：</p>
<ul>
<li>服务器为每个主键维护一个版本号，每当主键新值写入时递增版本号；</li>
<li>客户端读取时，服务器返回所有值以及最新版本号，并且在客户端写之前，要求必须先进行一次读；</li>
<li>客户端写主键，写请求必须包含之前读到的版本号、读到的值和新值合并之后的集合。写请求可以返回当前值；</li>
<li>服务收到写请求时，根据版本号，选择性地覆盖该版本号或者更低版本的所有值 ( 这些值已经被合并到更高版本集合中 )。</li>
</ul>
<p>        如果写请求带有版本号，说明它修改的是以前的状态。如果没有版本号，将会与其他操作同时进行，不会覆盖已有值。<br>
        上述算法适用于单副本的情况，但是对于多副本的情况，它们之间的版本号并不相同。为了保证一致，我们需要为每个副本和每个主键均定义一个版本号。每个副本在写入时增加自己的版本号，跟踪从其他副本看到的版本号。所有副本的版本号集合称为<strong>版本矢量</strong>。当读取数据时，版本矢量会被返回给客户端，并在随后写入时包含在请求中一起发送给数据库。</p>

            </div>
            <div class="meta post-footer">
                <span>2022 Nov 6 15:24</span>
                <a href="https://z217blog.cn/post/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%BB%E4%BB%8E%E8%8A%82%E7%82%B9/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:zihan.zhouchn@outlook.com">zihan.zhouchn@outlook.com</a>
            </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2024, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
    <script>
        InitLightSwitcher()
    </script>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
</main>
</body>

</html>