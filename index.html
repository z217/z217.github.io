<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.74.3" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
        
        <a href="http://123.57.12.189"  target="_blank" >
            <i class="fas fa-link fa-sm"></i>
            <span>二站</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/reentranlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">ReentranLock源码解读</a>
        
        
        <p>ReentrantLock源码解读</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 20 22:27
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">AQS源码解读</a>
        
        
        <p>AbstractQueuedSynchronizer源码解读</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 19 20:14
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">进程间通信</a>
        
        
        <p>进程间通信的一些概念以及几种方式介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 18 19:44
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Other
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/leetcode%E9%A2%98%E8%A7%A35lru%E4%B8%8Elinkedhashmap/">Leetcode题解（5）：LRU与LinkedHashMap</a>
        
        
        <p>LeetCodeLRU缓存机制题目解法以及和LinkedHashMap的关系</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 16 18:05
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Algorithm, Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/leetcode%E9%A2%98%E8%A7%A34%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/">Leetcode题解（4）：字符串相加</a>
        
        
        <p>LeetCode字符串相加题目解法</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Mar 16 15:50
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Algorithm
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/reentranlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">ReentranLock源码解读</a></h1>
            </center>
            <div class="post-content">
                <p>        $ReentrantLock$ 是一个可重入的独占锁，与 $synchronized$ 行为类似，但提供了额外的功能。</p>
<h2 id="1-构造函数">1. 构造函数</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 默认为非公平锁
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">()</span> <span class="o">{</span> <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span> <span class="o">}</span>

<span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span> <span class="n">sync</span> <span class="o">=</span> <span class="n">fair</span> <span class="o">?</span> <span class="k">new</span> <span class="n">FairSync</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span> <span class="o">}</span>
</code></pre></div><h2 id="2-内部类">2. 内部类</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Sync</span> <span class="kd">extends</span> <span class="n">AbstractQueuedSynchronizer</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="n">5179523762034025860L</span><span class="o">;</span>

    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">();</span>

    <span class="c1">// 非公平上锁, tryAcquire方法在子类中实现
</span><span class="c1"></span>    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">nonfairTryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 锁未被占有
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 尝试获取锁
</span><span class="c1"></span>                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span> <span class="c1">// 设置独占线程
</span><span class="c1"></span>                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 当前线程已经占有锁
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;Maximum lock count exceeded&#34;</span><span class="o">);</span>
            <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span> <span class="c1">// 添加上锁次数
</span><span class="c1"></span>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">()</span> <span class="o">-</span> <span class="n">releases</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="c1">// 当前线程非独占线程
</span><span class="c1"></span>            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
        <span class="kt">boolean</span> <span class="n">free</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 锁被释放
</span><span class="c1"></span>            <span class="n">free</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// 取消独占状态
</span><span class="c1"></span>        <span class="o">}</span>
        <span class="n">setState</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">free</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 当前实现是否持有锁
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">getExclusiveOwnerThread</span><span class="o">()</span> <span class="o">==</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="n">ConditionObject</span> <span class="nf">newCondition</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ConditionObject</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 返回持有者线程
</span><span class="c1"></span>    <span class="kd">final</span> <span class="n">Thread</span> <span class="nf">getOwner</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">getState</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">getExclusiveOwnerThread</span><span class="o">();</span> <span class="o">}</span>

    <span class="c1">// 返回当前线程上锁次数
</span><span class="c1"></span>    <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getHoldCount</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">isHeldExclusively</span><span class="o">()</span> <span class="o">?</span> <span class="n">getState</span><span class="o">()</span> <span class="o">:</span> <span class="n">0</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isLocked</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">getState</span><span class="o">()</span> <span class="o">!=</span> <span class="n">0</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">ObjectInputStream</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span> <span class="cm">/* 省略 */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 非公平锁
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">NonfairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="n">7316153563782823691L</span><span class="o">;</span>

    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">1</span><span class="o">))</span> <span class="c1">// 尝试上锁
</span><span class="c1"></span>            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
        <span class="k">else</span> <span class="c1">// 自旋获取锁
</span><span class="c1"></span>            <span class="n">acquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">nonfairTryAcquire</span><span class="o">(</span><span class="n">acquires</span><span class="o">);}</span> <span class="c1">// 调用父类方法
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 公平锁
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="n">3000897897090466540L</span><span class="o">;</span>

    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span> <span class="n">acquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="o">}</span> <span class="c1">// 公平方式获取锁，获取失败则自旋
</span><span class="c1"></span>
    <span class="c1">// 公平方式获取锁
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">hasQueuedPredecessors</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="c1">// 没有前驱节点
</span><span class="c1"></span>                <span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 尝试获取锁
</span><span class="c1"></span>                <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 当前线程为独占线程
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span> <span class="c1">// 添加获取次数
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;Maximum lock count exceeded&#34;</span><span class="o">);</span>
            <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        其中 $acquire$ 方法的实现可以在<a href="https://z217blog.cn/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#3-%E8%8E%B7%E5%8F%96%E9%94%81">这里</a>查看。</p>
<h2 id="3-上锁和解锁">3. 上锁和解锁</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 声明了一个内部类字段作为同步器
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">final</span> <span class="n">Sync</span> <span class="n">sync</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="n">lock</span> <span class="o">{</span> <span class="n">sync</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="o">}</span> <span class="c1">// 调用lock方法，该方法在子类中被实现
</span><span class="c1"></span>
<span class="c1">// 响应中断式上锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">lockInterruptibly</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">acquireInterruptibly</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// AQS中实现
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquireInterruptibly</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
        <span class="n">doAcquireInterruptibly</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 尝试以非公平方式获取锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">nonfairTryAcquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">tryAcquireNanos</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// AQS中实现
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">tryAcquireNanos</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">nanosTimeout</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">||</span>
        <span class="n">doAcquireNanos</span><span class="o">(</span><span class="n">arg</span><span class="o">,</span> <span class="n">nanosTimeout</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 每次只能解一个锁，所以如果多次上锁就需要多次解锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span> <span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="n">1</span><span class="o">);</span> <span class="o">}</span>
</code></pre></div><p>        其中 $doAcquireInterruptibly$ 方法和 $doAcquireNanos$ 方法的实现可以在<a href="https://z217blog.cn/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#33-%E5%85%B6%E4%BB%96">这里</a>查看。</p>
<h2 id="4-条件">4. 条件</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 创建条件
</span><span class="c1"></span><span class="kd">public</span> <span class="n">Condition</span> <span class="nf">newCondition</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否有线程在条件上等待
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasWaiters</span><span class="o">(</span><span class="n">Condition</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">condition</span> <span class="k">instanceof</span> <span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">))</span>
        <span class="c1">// 非AQS中定义的ConditionObject类型对象
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;not owner&#34;</span><span class="o">);</span>
    <span class="c1">// 使用AQS中的方法判断，检查条件队列中是否有状态为CONDITION的节点
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">hasWaiters</span><span class="o">((</span><span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">)</span><span class="n">condition</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 获取条件上等待的线程数量
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">getWaitQueueLength</span><span class="o">(</span><span class="n">Condition</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">condition</span> <span class="k">instanceof</span> <span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">))</span>
        <span class="c1">// 非AQS中定义的ConditionObject类型对象
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;now owner&#34;</span><span class="o">);</span>
    <span class="c1">// 使用AQS中的方法统计，遍历条件队列并统计CONDITION节点数量
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getWaitQueueLength</span><span class="o">((</span><span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">)</span><span class="n">condition</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 获取条件上等待的线程集合
</span><span class="c1"></span><span class="kd">protected</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="nf">getWaitingThreads</span><span class="o">(</span><span class="n">Condition</span> <span class="n">condition</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">condition</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(!(</span><span class="n">condition</span> <span class="k">instanceof</span> <span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">))</span>
        <span class="c1">// 非AQS中定义的ConditionObject类型对象
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;not owner&#34;</span><span class="o">);</span>
    <span class="c1">// 使用AQS中的方法统计，遍历条件队列并返回CONDITION节点中持有的线程集合
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getWaitingThreads</span><span class="o">((</span><span class="n">AbstractQueuedSynchronizer</span><span class="o">.</span><span class="na">ConditionObject</span><span class="o">)</span><span class="n">condition</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><h2 id="5-其他方法">5. 其他方法</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 当前线程上锁次数
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">getHoldCount</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getHoldCount</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否被当前线程持有
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isHeldByCurrentThread</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isHeldExclusively</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否上锁，即状态是否非零
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isLocked</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isLocked</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否公平锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isFair</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span> <span class="k">instanceof</span> <span class="n">FairSync</span><span class="o">;</span> <span class="o">}</span>

<span class="c1">// 获取持有者线程
</span><span class="c1"></span><span class="kd">protected</span> <span class="n">Thread</span> <span class="nf">getOwner</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getOwner</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 是否有等待中的线程
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedThreads</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">hasQueuedThreads</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// AQS中实现
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedThreads</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">head</span> <span class="o">!=</span> <span class="n">tail</span><span class="o">;</span> <span class="c1">// 首节点为哑节点，因此只要首尾不等即可
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// 线程是否在队列中等待，从尾部遍历等待队列，判断线程是否在其中
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedThread</span><span class="o">(</span><span class="n">Thread</span> <span class="n">thread</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">isQueued</span><span class="o">(</span><span class="n">thread</span><span class="o">);</span> <span class="o">}</span>

<span class="c1">// 获取等待线程的数量，从尾部遍历等待队列，统计等待线程数
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getQueueLength</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getQueueLength</span><span class="o">();</span> <span class="o">}</span>

<span class="c1">// 获取等待线程的集合，从尾部遍历等待队列，返回等待线程集合
</span><span class="c1"></span><span class="kd">protected</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Thread</span><span class="o">&gt;</span> <span class="nf">getQueuedThreads</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">sync</span><span class="o">.</span><span class="na">getQueuedThreads</span><span class="o">();</span> <span class="o">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2021 Mar 20 22:27</span> <a href="/post/reentranlock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">AQS源码解读</a></h1>
            </center>
            <div class="post-content">
                <p>        <code>AQS</code>提供了一个实现阻塞锁和相关的基于<code>FIFO</code>队列的同步器的框架。该类作为大部分依赖于一个状态字段的同步器的基础。子类必须定义 $protected$ 方法来改变状态，其他方法用于管理队列和实现阻塞机制。子类也可以包含其他状态字段，但必须通过原子性操作维护状态。</p>
<h2 id="1-成员变量">1. 成员变量</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 等待队列的头节点，懒加载，只能通过setHead方法修改
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>
<span class="c1">// 等待队列的尾部，懒加载，只能通过enq方法添加新节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">tail</span><span class="o">;</span>
<span class="c1">// 同步状态
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>
<span class="c1">// 如果超时时间大于该值，中断，单位为纳秒
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">spinForTimeoutThreshold</span> <span class="o">=</span> <span class="n">1000L</span><span class="o">;</span>
</code></pre></div><h2 id="2-内部类node">2. 内部类<code>Node</code></h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="c1">// 节点在共享模式等待的标志
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Node</span> <span class="n">SHARED</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">();</span>
    <span class="c1">// 节点在独占模式等待的标志
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Node</span> <span class="n">EXCLUSIVE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 表示线程被取消
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CANCELLED</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
    <span class="c1">// 表示线程在释放资源后需要唤醒后继节点
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SIGNAL</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="c1">// 表示线程在等待condition
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CONDITION</span> <span class="o">=</span> <span class="o">-</span><span class="n">2</span><span class="o">;</span>
    <span class="c1">// 共享模式下表示无条件传播
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">PROPAGATE</span> <span class="o">=</span> <span class="o">-</span><span class="n">3</span><span class="o">;</span>
    <span class="c1">// 等待状态
</span><span class="c1"></span>    <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">waitStatus</span><span class="o">;</span>
    <span class="c1">// 前驱节点
</span><span class="c1"></span>    <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">prev</span><span class="o">;</span>
    <span class="c1">// 后继节点
</span><span class="c1"></span>    <span class="kd">volatile</span> <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>
    <span class="c1">// 节点对应的线程
</span><span class="c1"></span>    <span class="kd">volatile</span> <span class="n">Thread</span> <span class="n">thread</span><span class="o">;</span>
    <span class="c1">// 下一个在condition上等待的节点，或者表示共享模式
</span><span class="c1"></span>    <span class="n">Node</span> <span class="n">nextWaiter</span><span class="o">;</span>

    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isShared</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">nextWaiter</span> <span class="o">==</span> <span class="n">SHARED</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">final</span> <span class="n">Node</span> <span class="nf">predecessor</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NullPointerException</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">Node</span><span class="o">()</span> <span class="o">{}</span> <span class="c1">// 用于创建头节点或者共享标记
</span><span class="c1"></span>
    <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span> <span class="n">thread</span><span class="o">,</span> <span class="n">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="n">mode</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">thread</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span> <span class="n">thread</span><span class="o">,</span> <span class="kt">int</span> <span class="n">waitStatus</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">=</span> <span class="n">waitStatus</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">thread</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="3-获取锁">3. 获取锁</h2>
<h3 id="31-独占模式">3.1 独占模式</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 独占模式获取资源，忽略中断，未获取成功则阻塞
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">acquireQueued</span><span class="o">(</span><span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">))</span>
        <span class="n">selfInterrupt</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 尝试以独占模式获取锁，需要在子类中重写
</span><span class="c1"></span><span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 根据给定模式创建队列节点
</span><span class="c1"></span><span class="kd">private</span> <span class="n">Node</span> <span class="nf">addWaiter</span><span class="o">(</span><span class="n">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(),</span> <span class="n">mode</span><span class="o">);</span>
    <span class="n">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 如果在此入队成功，直接返回
</span><span class="c1"></span>            <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 入队失败，循环直到成功
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 节点入队
</span><span class="c1"></span><span class="kd">private</span> <span class="n">Node</span> <span class="nf">enq</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(;;)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetHead</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">()))</span> <span class="c1">// 队列为空，设置哑节点
</span><span class="c1"></span>                <span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">t</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 自旋获取锁
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">acquireQueued</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span> <span class="c1">// 获取前驱节点
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 如果没有前驱节点在等待，尝试获取锁
</span><span class="c1"></span>                <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 帮助GC
</span><span class="c1"></span>                <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">interrupted</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="c1">// 根据状态判断是否阻塞
</span><span class="c1"></span>                <span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
                <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
            <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 检查和更新获取锁失败的节点状态，true表示需要阻塞
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">Node</span> <span class="n">pred</span><span class="o">,</span> <span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span> <span class="c1">// 获取前驱节点状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">)</span> <span class="c1">// SIGNAL状态下前驱节点释放资源后会通知后继节点，因而可以阻塞
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 前驱节点被取消
</span><span class="c1"></span>        <span class="k">do</span> <span class="o">{</span>
            <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">);</span> <span class="c1">// 寻找最近的一个处于正常状态的节点
</span><span class="c1"></span>        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// 其他状态则设置前驱节点为SIGNAL，令其在释放资源后通知自己
</span><span class="c1"></span>        <span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 挂起当前线程
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">parkAndCheckInterrupt</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 产生一个中断
</span><span class="c1"></span><span class="kd">static</span> <span class="kt">void</span> <span class="nf">selfInterrupt</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>        总结一下 $acquire$ 方法的执行步骤：</p>
<ol>
<li>尝试以独占方式获取锁，成功则直接返回</li>
<li>尝试以自旋等待方式获取锁，将节点加入队列</li>
<li>在自旋的过程中通过 $shouldParkAfterFailedAcquire$ 方法判断是否需要挂起，如果之间发生了中断，设置中断标志位；</li>
<li>自旋获取锁成功，如果发生了中断，通过 $selfInterrupt$ 方法产生一个中断。</li>
</ol>
<h3 id="32-共享模式">3.2 共享模式</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 共享模式获取锁，忽略中断
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tryAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
        <span class="n">doAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 共享模式获取锁，失败时返回负数，0表示获取成功但没有剩余资源，正数表示获取节点成功并且还有剩余资源
</span><span class="c1"></span><span class="kd">protected</span> <span class="kt">int</span> <span class="nf">tryAcquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 自旋获取锁
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">doAcquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">SHARED</span><span class="o">);</span> <span class="c1">// 创建节点并入队
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">tryAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 如果存在剩余资源则传播
</span><span class="c1"></span>                    <span class="n">setHeadAndPropagate</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">interrupted</span><span class="o">)</span>
                        <span class="n">selfInterrupt</span><span class="o">();</span>
                    <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                <span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
                <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
            <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 设置队列头节点并传播
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">setHeadAndPropagate</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">propagate</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 设置头节点
</span><span class="c1"></span>    <span class="c1">// 存在剩余资源、头节点为空、处于负状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">propagate</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">h</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span>
        <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">// 获取下一个节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">isShared</span><span class="o">())</span> <span class="c1">// 下一个节点为空或者处于共享模式
</span><span class="c1"></span>            <span class="n">doReleaseShared</span><span class="o">();</span> <span class="c1">// 唤醒后继并确保传播
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="33-其他">3.3 其他</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 是否存在等待中的前驱
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedPredecessors</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">s</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">h</span> <span class="o">!=</span> <span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="c1">// 队列非空
</span><span class="c1"></span>        <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">thread</span> <span class="o">!=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span> <span class="c1">// 当前等待节点非当前线程所在节点
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// 在规定时间内以独占模式获取锁
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">doAcquireNanos</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">nanosTimeout</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nanosTimeout</span> <span class="o">&lt;=</span> <span class="n">0L</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kd">final</span> <span class="kt">long</span> <span class="n">deadLine</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">()</span> <span class="o">+</span> <span class="n">nanosTimeout</span><span class="o">;</span> <span class="c1">// 到期时间
</span><span class="c1"></span>    <span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">);</span> <span class="c1">// 创建节点并加入队列
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span> <span class="c1">// 获取前驱
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 前驱为头节点，尝试获取锁
</span><span class="c1"></span>                <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">nanosTimeout</span> <span class="o">=</span> <span class="n">deadLine</span> <span class="o">-</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span> <span class="c1">// 计算剩余时间
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">nanosTimeout</span> <span class="o">&lt;=</span> <span class="n">0L</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="c1">// 判断是否应该阻塞
</span><span class="c1"></span>                <span class="n">nanosTimeout</span> <span class="o">&gt;</span> <span class="n">spinForTimeoutThreshold</span><span class="o">)</span> <span class="c1">// 超时时间大于阈值（1000），中断
</span><span class="c1"></span>                <span class="n">LockSupport</span><span class="o">.</span><span class="na">parkNanos</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nanosTimeout</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
            <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 以独占模式获取锁，可以响应中断
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">doAcquireInterruptibly</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">);</span> <span class="c1">// 添加节点
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span> <span class="c1">// 获取前驱
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 前驱为头节点，尝试获取锁
</span><span class="c1"></span>                <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="c1">// 判断是否中断
</span><span class="c1"></span>                <span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span> <span class="c1">// 不再设置中断状态，而是直接抛出线程
</span><span class="c1"></span>        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
            <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="4-释放锁">4. 释放锁</h2>
<h3 id="41-独占模式">4.1 独占模式</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 释放独占模式的锁
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">release</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tryRelease</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
            <span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span> <span class="c1">// 解除后继的阻塞状态
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 唤醒后继节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">unparkSuccessor</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span> <span class="c1">// 获取当前节点状态
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 负数则设置为正常状态
</span><span class="c1"></span>        <span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
    <span class="n">Node</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">// 获取后继
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 后继被取消
</span><span class="c1"></span>        <span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span> <span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">node</span><span class="o">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="c1">// 从尾节点开始往前遍历
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 最后一个未取消的节点
</span><span class="c1"></span>                <span class="n">s</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">thread</span><span class="o">);</span> <span class="c1">// 唤醒节点
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><h3 id="42-共享模式">4.2 共享模式</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 释放共享模式的锁
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">releaseShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tryReleaseShared</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">doReleaseShared</span><span class="o">();</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryReleaseShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 释放共享模式的锁，唤醒后继并且设置为传播状态
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">doReleaseShared</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span> <span class="o">!=</span> <span class="n">tail</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">,</span> <span class="n">0</span><span class="o">))</span> <span class="c1">// 设置正常状态
</span><span class="c1"></span>                    <span class="k">continue</span><span class="o">;</span>
                <span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span> <span class="c1">// 唤醒后继
</span><span class="c1"></span>            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="c1">// 已经是正常状态
</span><span class="c1"></span>                       <span class="o">!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">PROPAGATE</span><span class="o">))</span> <span class="c1">// 设置传播
</span><span class="c1"></span>                <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span> <span class="c1">// 设置完成后如果发现头节点改变，重新设置
</span><span class="c1"></span>            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="5-内部类conditionobject">5. 内部类<code>ConditionObject</code></h2>
<h3 id="51-成员变量">5.1 成员变量</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 队首节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="n">Node</span> <span class="n">firstWaiter</span><span class="o">;</span>
<span class="c1">// 队尾节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="n">Node</span> <span class="n">lastWaiter</span><span class="o">;</span>
<span class="c1">// 发生中断，设置该状态位，后续不抛出异常而是产生中断
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">REINTERRUPT</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
<span class="c1">// 发生中断，设置该状态位，后续抛出异常
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">THROW_IE</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
</code></pre></div><h3 id="52-阻塞">5.2 阻塞</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">await</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span> <span class="c1">// 线程中断
</span><span class="c1"></span>        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addConditionWaiter</span><span class="o">();</span> <span class="c1">// 添加节点
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">savedState</span> <span class="o">=</span> <span class="n">fullyRelease</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 释放当前节点所有资源
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">interruptMode</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">isOnSyncQueue</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 节点不在等待队列，则在condition的条件队列中
</span><span class="c1"></span>        <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="c1">// 阻塞节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">((</span><span class="n">interruptMode</span> <span class="o">=</span> <span class="n">checkInterruptWhileWaiting</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 中断状态变化
</span><span class="c1"></span>            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 唤醒后重新添加到等待队列中
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">acquireQueued</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">savedState</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">interruptMode</span> <span class="o">!=</span> <span class="n">THROW_IE</span><span class="o">)</span>
        <span class="n">interruptMode</span> <span class="o">=</span> <span class="n">REINTERRUPT</span><span class="o">;</span>
    <span class="c1">// 删除非CONDITION节点
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">unlinkCancelledWaiters</span><span class="o">();</span>
    <span class="c1">// 如果发生中断，处理中断
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">interruptMode</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
        <span class="n">reportInterruptAfterWait</span><span class="o">(</span><span class="n">interruptMode</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 向等待队列中添加节点
</span><span class="c1"></span><span class="kd">private</span> <span class="n">Node</span> <span class="nf">addConditionWaiter</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">lastWaiter</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">unlinkCancelledWaiters</span><span class="o">();</span> <span class="c1">// 删除非CONDITION节点
</span><span class="c1"></span>        <span class="n">t</span> <span class="o">=</span> <span class="n">lastWaiter</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">firstWaiter</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="n">t</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="n">lastWaiter</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 删除非CONDITION节点
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">unlinkCancelledWaiters</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">firstWaiter</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">trail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">nextWaiter</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">t</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">trail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">firstWaiter</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">trail</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">lastWaiter</span> <span class="o">=</span> <span class="n">trail</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="n">trail</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 释放节点持有的资源
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">int</span> <span class="nf">fullyRelease</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">savedState</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span> <span class="c1">// 获取当前状态
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">release</span><span class="o">(</span><span class="n">savedState</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 完全释放锁
</span><span class="c1"></span>            <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">savedState</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span> <span class="c1">// 释放失败，取消线程
</span><span class="c1"></span>            <span class="n">node</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="na">CANCELLED</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 节点是否处于等待队列中
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isOnSyncQueue</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span> <span class="o">||</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 如果为CONDITION节点或者首节点
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 如果存在后继，则位于等待队列中
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">findNodeFromTail</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 从尾节点查找结点
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// 检查阻塞过程中的中断情况
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">int</span> <span class="nf">checkInterruptWhileWaiting</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">()</span> <span class="o">?</span>
        <span class="o">(</span><span class="n">transferAfterCancelledWait</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">?</span> <span class="n">THROW_IE</span> <span class="o">:</span> <span class="n">REINTERRUPT</span><span class="o">)</span> <span class="o">:</span>
        <span class="n">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 传输节点到等待队列
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">transferAfterCancelledWait</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span><span class="o">,</span> <span class="n">0</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 取消CONDITION状态
</span><span class="c1"></span>        <span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 加入等待队列
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">isOnSyncQueue</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="c1">// 不在等待队列，阻塞
</span><span class="c1"></span>        <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 处理中断
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">reportInterruptAfterWait</span><span class="o">(</span><span class="kt">int</span> <span class="n">interruptMode</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">interruptMode</span> <span class="o">=</span> <span class="n">THROW_IE</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">interruptMode</span> <span class="o">==</span> <span class="n">REINTERRUPT</span><span class="o">)</span>
        <span class="n">selfInterrupt</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><h3 id="53-唤醒">5.3 唤醒</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 唤醒最长等待的线程
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">signal</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">isHeldExclusively</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
    <span class="n">Node</span> <span class="n">first</span> <span class="o">=</span> <span class="n">firstWaiter</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">doSignal</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 唤醒所有线程
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">signalAll</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">isHeldExclusively</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
    <span class="n">Node</span> <span class="n">first</span> <span class="o">=</span> <span class="n">firstWaiter</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">doSignalAll</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 是否被独占
</span><span class="c1"></span><span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">doSignal</span><span class="o">(</span><span class="n">Node</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">firstWaiter</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">lastWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">transferForSignal</span><span class="o">(</span><span class="n">first</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
             <span class="o">(</span><span class="n">first</span> <span class="o">=</span> <span class="n">firstWaiter</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">doSignalAll</span><span class="o">(</span><span class="n">Node</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">lastWaiter</span> <span class="o">=</span> <span class="n">firstWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="c1">// 唤醒并移除所有节点
</span><span class="c1"></span>    <span class="k">do</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span><span class="o">;</span>
        <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">transferForSignal</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 传输节点到等待队列
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">transferForSignal</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span><span class="o">,</span> <span class="n">0</span><span class="o">))</span> <span class="c1">// 取消CONDITION状态
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 加入队列
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">ws</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">))</span> <span class="c1">// 节点被取消或者更改状态失败
</span><span class="c1"></span>        <span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">thread</span><span class="o">);</span> <span class="c1">// 阻塞节点线程
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h3 id="54-其他">5.4 其他</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">awaitNanos</span><span class="o">(</span><span class="kt">long</span> <span class="n">nanosTimeout</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addConditionWaiter</span><span class="o">();</span> <span class="c1">// 添加节点
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">savedState</span> <span class="o">=</span> <span class="n">fullyRelease</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 释放节点
</span><span class="c1"></span>    <span class="kd">final</span> <span class="kt">long</span> <span class="n">deadline</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">()</span> <span class="o">+</span> <span class="n">nanosTimeout</span><span class="o">;</span> <span class="c1">// 计算截止时间
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">interruptMode</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">isOnSyncQueue</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 检查节点是否处于等待队列
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">nanosTimeout</span> <span class="o">&lt;=</span> <span class="n">0L</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 超时
</span><span class="c1"></span>            <span class="n">transferAfterCancelledWait</span><span class="o">(</span><span class="n">node</span><span class="o">);</span> <span class="c1">// 传输到等待队列
</span><span class="c1"></span>            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nanosTimeout</span> <span class="o">&gt;=</span> <span class="n">spinForTimeoutThreshold</span><span class="o">)</span> <span class="c1">// 剩余时间大于阈值，阻塞
</span><span class="c1"></span>            <span class="n">LockSupport</span><span class="o">.</span><span class="na">parkNanos</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">nanosTimeout</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">interruptMode</span> <span class="o">=</span> <span class="n">checkInterruptWhileWaiting</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 检查是否出现中断
</span><span class="c1"></span>            <span class="k">break</span><span class="o">;</span>
        <span class="n">nanosTimeout</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">acquireQueued</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">savedState</span><span class="o">)</span>  <span class="o">&amp;&amp;</span> <span class="n">interruptMode</span> <span class="o">!=</span> <span class="n">THROW_IE</span><span class="o">)</span> <span class="c1">// 插入等待队列
</span><span class="c1"></span>        <span class="n">interruptMode</span> <span class="o">=</span> <span class="n">REINTERRUPT</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// 移除非CONDITION节点
</span><span class="c1"></span>        <span class="n">unlinkCancelledWaiters</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">interruptMode</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// 处理中断
</span><span class="c1"></span>        <span class="n">reportInterruptAfterWait</span><span class="o">(</span><span class="n">interruptMode</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2021 Mar 19 20:14</span> <a href="/post/aqs%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">进程间通信</a></h1>
            </center>
            <div class="post-content">
                <p>        进程经常需要与其他进程通信。<strong>进程间通信</strong> ( $Inter\ \ Process\ \ Communication$, $IPC$ ) 最好使用一种结构良好的方式并且不要使用中断。进程间通信存在三个问题：一个进程如何把信息传递给另一个，如何确保两个或更多的进程在关键活动中不会出现交叉，以及进程之间执行顺序的正确性。<br/>
        在一些操作系统中，协作的进程可能共享一些彼此都能读写的公用存储区，可能是一块内存，也可能是一个共享文件。当两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，就称为<strong>竞争条件</strong> ( $race\ \ condition$ )。包含有竞争条件的程序在大多数情况下都不会出错，但在极少数情况下会产生一些奇怪的现象，尤其是在多核环境中更为明显。而要避免竞争条件带来的错误，关键是要找出某种途径来阻止多个进程同时读写共享数据。换言之，我们需要的是<strong>互斥</strong> ( $mutual\ \ exclusion$ )，即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。<br/>
        避免竞争条件的问题也可以用一种抽象的方式进行描述。一个进程的一部分时间做内部计算或另外一些不会引发竞争条件的操作。在某些时候进程可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作。我们把对共享内存进行访问的程序片段称作<strong>临界区域</strong> ( $critical\ \ region$ ) 或<strong>临界区</strong> ( $critical\ \ section$ )。如果我们能适当地安排，使得两个进程不可能同时处于临界区中，就能避免竞争条件。<br/>
        尽管这样的要求避免了竞争条件，但它还不能保证使用共享数据的并发进程能够正确和高效地进行协作。对于一个好的解决方案，需要满足以下 $4$ 个条件：</p>
<ol>
<li>任何两个进程不能同时处于临界区；</li>
<li>不应对<code>CPU</code>的速度和数量做任何假设；</li>
<li>临界区外运行的进程不得阻塞其他进程；</li>
<li>不得使进程无限期等待进入临界区。</li>
</ol>
<h2 id="1-互斥">1. 互斥</h2>
<h3 id="11-屏蔽中断">1.1 屏蔽中断</h3>
<p>        在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽。<code>CPU</code>只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断后<code>CPU</code>将不会被切换到其他进程。于是，一旦某个进程屏蔽中断后，它就可以检查和修改共享内存，而不必担心其他进程介入。<br/>
        但是这个方案并不好，因为屏蔽中断的权力交给了用户进程。而且对于多处理器系统，屏蔽中断指令仅仅对执行 $disable$ 指令的那个<code>CPU</code>有效，其他<code>CPU</code>仍然可以运行。另一方面，对于内核来说，屏蔽中断指令是非常方便的。所以屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。</p>
<h3 id="12-锁变量">1.2 锁变量</h3>
<p>        设想有一个共享锁变量，其初始值为 $0$ 。当一个进程想进入临界区时，会首先测试锁。如果锁的值为 $0$ ，则进程将其设置为 $1$ 并进入临界区。否则，进程等待直到值变为 $0$ 。虽然实现简单，但是却存在着多个进程同时读到 $0$ 的可能。</p>
<h3 id="13-严格轮换法">1.3 严格轮换法</h3>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 进程a
</span><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">critical_region</span><span class="p">();</span>
    <span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">noncritical_region</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 进程b
</span><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">critical_region</span><span class="p">();</span>
    <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">noncritical_region</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>        通过连续检查一个变量来决定哪个进程进入临界区。连续测试一个变量直到某个值出现为止，称为<strong>忙等待</strong> ( $busy\ \ waiting$ )。由于这种方式浪费<code>CPU</code>时间，所以通常应该避免。只有在有理由认为等待时间是非常短的情况下，才使用忙等待。用于忙等待的锁，称为<strong>自旋锁</strong> ( $spin\ \ lock$ )。</p>
<h3 id="14-peterson解法">1.4 <code>Peterson</code>解法</h3>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define FALSE 0
</span><span class="cp">#define TRUE 1
</span><span class="cp">#define N 2    </span><span class="c1">// 进程数
</span><span class="c1"></span>
<span class="kt">int</span> <span class="n">turn</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">interested</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>    <span class="c1">// 初始值为0 (FALSE)
</span><span class="c1"></span>
<span class="kt">void</span> <span class="nf">enter_region</span><span class="p">(</span><span class="kt">int</span> <span class="n">process</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">other</span><span class="p">;</span>

    <span class="n">other</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">process</span><span class="p">;</span>    <span class="c1">// 另一个进程号
</span><span class="c1"></span>    <span class="n">interested</span><span class="p">[</span><span class="n">process</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>    <span class="c1">// 设置感兴趣
</span><span class="c1"></span>    <span class="n">turn</span> <span class="o">=</span> <span class="n">process</span><span class="p">;</span>    <span class="c1">// 设置标志
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="n">process</span> <span class="o">&amp;&amp;</span> <span class="n">interested</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">);</span>    <span class="c1">// 其他进程感兴趣则挂起
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">leave_region</span><span class="p">(</span><span class="kt">int</span> <span class="n">process</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">interested</span><span class="p">[</span><span class="n">process</span><span class="p">]</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>    <span class="c1">// 表示离开临界区
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>        在进入临界区之前，各个进程使用其进程号作为参数来调用 $enter_-region$ 。该调用在需要时将使进程等待，直到能安全地进入临界区。在完成对共享变量的操作之后，进程将调用 $leave_-region$ ，表示操作已完成。</p>
<h3 id="15-tsl指令">1.5 <code>TSL</code>指令</h3>
<p>        在某些计算机中，特别是那些设计为多处理器的计算机，都有下面一条指令：</p>
<pre><code>TSL RX, LOCK
</code></pre><p>        称为<strong>测试并加锁</strong> ( $test\ \ and\ \ set\ \ lock$ )，它将一个内存字读到寄存器 $RX$ 中，然后在该内存地址上存一个非零值。读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。执行<code>TSL</code>指令的<code>CPU</code>将锁住内存总线，以禁止其他<code>CPU</code>在本指令结束之前访问内存。为了使用<code>TSL</code>指令，需要使用一个共享变量 $lock$ 来协调对共享内存的访问。当 $lock$ 为 $0$ 时，任何进程都可以使用<code>TSL</code>指令将其设置为 $1$ 并读写共享内存。当操作结束时，进程用一条普通的<code>MOV</code>指令将 $lock$ 的值重新设置为 $0$ 。</p>
<h2 id="2-睡眠与唤醒">2. 睡眠与唤醒</h2>
<p>        <code>Peterson</code>解法和<code>TSL</code>解法都是我们想要的正确的解法，但是都存在忙等待的缺点。这些解法的本质是：当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止。如果进程之间存在优先级，甚至还可能带来<strong>优先级反转问题</strong> ( $priority\ \ inversion\ \ problem$ )，即高优先级进程就绪时，低优先级进程仍处于临界区并且永远不会被调度的问题。<br/>
        $sleep$ 原语将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒。$wakeup$ 调用有一个参数，即将要被唤醒的进程。另一种方法是让 $sleep$ 和 $wakeup$ 各有一个参数，即有一个用于匹配 $sleep$ 和 $wakeup$ 的内存地址。<br/>
        <strong>生产者-消费者</strong> ( $producer-consumer$ ) 问题，也称为<strong>有界缓冲区</strong> ( $bounded-buffer$ ) 问题。两个进程共享一个公共的固定大小的缓冲区，其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出信息。问题在于当缓冲区已满，而此时生产者还想向其中放入一个新的数据项的情况，解决办法是让生产者睡眠，待消费者从缓冲区中取出一个或多个数据项时再唤醒。同样地，当消费者试图从缓冲区中取出数据而发现缓冲区为空时，消费者就睡眠，直到生产者向其中放入一些数据时再将其唤醒。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define N 100    </span><span class="c1">// 缓冲区中的槽数目
</span><span class="c1"></span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// 缓冲区中的数据项数目
</span><span class="c1"></span>
<span class="kt">void</span> <span class="nf">producer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">item</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="n">sleep</span><span class="p">();</span>
        <span class="n">insert_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">wakeup</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">item</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sleep</span><span class="p">();</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">remove_item</span><span class="p">();</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">wakeup</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span>
        <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        上述的实现有可能会出现竞争条件，因为对 $count$ 的访问未加限制。有可能出现以下情况：缓冲区为空，消费者读取 $count$ 发现为 $0$ ，于是准备暂停消费者并启动生产者。生产者在添加数据项之后，$count$ 加 $1$ ，并认为消费者一定在睡眠，于是调用 $wakeup$ 唤醒消费者。但是消费者此时在逻辑上并未睡眠，所以 $wakeup$ 信号丢失。而当生产者填满缓冲区时，也会进入睡眠，从而使得两个进程都进入睡眠。解决这个问题的关键在于丢失的 $wakeup$ 信号，一种弥补方法是修改规则，添加一个<strong>唤醒等待位</strong>。当一个 $wakeup$ 信号发送给一个清醒的进程信号时，该位置 $1$ 。在进程睡眠时，如果标志位为 $1$ ，则会清除标志位并唤醒。</p>
<h2 id="3-信号量">3. 信号量</h2>
<p>        <strong>信号量</strong> ( $semaphore$ ) 方法使用一个整形变量来累计唤醒次数，供以后使用。一个信号量的取值可以为 $0$ ( 表示没有保存下来的唤醒操作 ) 或者为正值 ( 表示有一个或多个唤醒操作 )。对一个信号量执行 $down$ 操作，会检查其值是否大于 $0$ ，如果是则减 $1$ ，否则进程进入睡眠状态。检查数值、修改变量值以及可能发生的睡眠操作均作为一个单一的、不可分割的原子操作完成，从而保证一旦一个信号量操作开始，则在操作完成或阻塞之前其他进程均无法访问信号量。对一个信号量执行 $up$ 操作会将其值加 $1$ 。对一个有进程在其上睡眠的信号量执行一次 $up$ 操作之后，该信号量的值仍旧是 $0$ ，但在其上睡眠的进程却少了一个。同样的，信号量的值加 $1$ 和唤醒一个进程的操作也是不可分割的。<br/>
        为了确保信号量能正确工作，最重要的是采用一种不可分割的方式实现它，通常是将 $up$ 和 $down$ 作为系统调用实现。我们可以使用信号解决 $wakeup$ 丢失的问题：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define N 100    </span><span class="c1">// 缓冲区中的槽数目
</span><span class="c1"></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">semaphore</span><span class="p">;</span>    <span class="c1">// 信号量是一种特殊的整型
</span><span class="c1"></span><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">// 控制对临界区的访问
</span><span class="c1"></span><span class="n">semaphore</span> <span class="n">empty</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>    <span class="c1">// 计数缓冲区的空槽数目
</span><span class="c1"></span><span class="n">semaphore</span> <span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// 计数缓冲区的满槽数目
</span><span class="c1"></span>
<span class="kt">void</span> <span class="nf">producer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">item</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
        <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>    <span class="c1">// 将空槽数目减1
</span><span class="c1"></span>        <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>    <span class="c1">// 进入临界区
</span><span class="c1"></span>        <span class="n">insert_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>    <span class="c1">// 离开临界区
</span><span class="c1"></span>        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>    <span class="c1">// 将满槽数目加1
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">item</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>    <span class="c1">// 将满槽数目减1
</span><span class="c1"></span>        <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>    <span class="c1">// 进入临界区
</span><span class="c1"></span>        <span class="n">item</span> <span class="o">=</span> <span class="n">remove_item</span><span class="p">();</span>
        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>    <span class="c1">// 离开临界区
</span><span class="c1"></span>        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>    <span class="c1">// 将空槽数目加1
</span><span class="c1"></span>        <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        信号量的另一种用途是用于实现<strong>同步</strong> ( $synchronization$ )。信号量 $full$ 和 $empty$ 用来保证某种事件的顺序发生或不发生。</p>
<h3 id="31-互斥量">3.1 互斥量</h3>
<p>        如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，称为<strong>互斥量</strong> ( $mutex$ )。互斥量仅仅适用于管理共享资源或一小段代码，是一个可以处于两态之一的变量：解锁和加锁。这样，只需要一个二进制位即可表示，不过实际上常常使用一个整型。<br/></p>
<h2 id="4-管程">4. 管程</h2>
<p>        信号量和互斥量虽然方便了进程间通信的进行，但也会带来<strong>死锁</strong> ( $dead\ \ lock$ ) 问题。为了更易于编写正确的程序，<strong>管程</strong> ( $monitor$ ) 就被提出了。一个管程是一个由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。进程可在任何需要的时候调用管程中的过程，但它们不能在管程之外声明的过程中直接访问管程内的数据结构。管程是一种语言概念，<code>C</code>语言并不支持管程。<br/>
        管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程，这一特性使管程能有效地完成互斥。管程是编程语言的组成部分，编译器直到它们的特殊性，因此可以采用与其他过程调用不同的方法来处理对管程的调用。进入管程的互斥由编译器负责，但通常的做法是用一个互斥量或二元信号量。为了使进程在无法继续运行时被阻塞，管程引入了两个<strong>条件变量</strong> ( $condition\ \ variables$ ) 以及相关的两个操作：$wait$ 和 $signal$ 。当一个管程过程发现它无法继续运行时，会在某个条件变量上执行 $wait$ 操作。该操作将导致调用进程自身阻塞，并且还将另一个以前等在管程之外的进程调入管程。如果在一个条件变量上有若干个进程正在等待，则在对该条件变量执行 $signal$ 操作后，系统调度程序只能在其中选择一个使其恢复运行。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Mar 18 19:44</span> <a href="/post/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/leetcode%E9%A2%98%E8%A7%A35lru%E4%B8%8Elinkedhashmap/">Leetcode题解（5）：LRU与LinkedHashMap</a></h1>
            </center>
            <div class="post-content">
                <p><a href="https://leetcode-cn.com/problems/lru-cache/">LeetCode146</a></p>
<p>        为了记录访问顺序，我们可以使用一个双向链表，首节点为最近最少访问的数据，尾节点为最近访问的数据。为了快速获取值，我们可以额外使用一个 $Map$ 存储键值映射。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">tail</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="o">-</span><span class="n">1</span> <span class="o">:</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">capacity</span><span class="o">)</span> <span class="n">removeHead</span><span class="o">();</span>
        <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="n">putToTail</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">node</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">getNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">putToTail</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">removeHead</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="n">tail</span><span class="o">)</span> <span class="n">head</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">head</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="o">--</span><span class="n">size</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">putToTail</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">tail</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="n">node</span><span class="o">)</span> <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">prev</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">n</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">tail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">key</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
        <span class="n">Node</span> <span class="n">prev</span><span class="o">;</span>
        <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        讲完了 $LRUCache$ 之后就可以讲讲 $LRUCache$ 与 $LinkedHashMap$ 之间的关系了。默认情况下 $LinkedHashMap$ 是一种保存了值写入顺序的 $HashMap$ ，扩展了 $HashMap$ ，也就是说底层与 $HashMap$ 相同。而写入顺序是通过一个双向链表存储的，在每次写入和删除时更新。<br/>
        可以发现 $LinkedHashMap$ 里面有一个特殊的构造函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">LinkedHashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span>
                     <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">,</span>
                     <span class="kt">boolean</span> <span class="n">accessOrder</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="n">loadFactor</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">accessOrder</span> <span class="o">=</span> <span class="n">accessOrder</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>        $accessOrder$ 是一个标志位，当它设置为 $true$ 时，允许我们通过访问顺序改变链表。以 $get$ 方法为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">accessOrder</span><span class="o">)</span>
        <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>        可以发现在每次 $get$ 之后，都会判断 $accessOrder$ ，然后调用 $afterNodeAccess$ 方法。后者的实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">afterNodeAccess</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">LinkedHashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">last</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">accessOrder</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">last</span> <span class="o">=</span> <span class="n">tail</span><span class="o">)</span> <span class="o">!=</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">LinkedHashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span>
            <span class="o">(</span><span class="n">LinkedHashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;)</span><span class="n">e</span><span class="o">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">before</span><span class="o">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">after</span><span class="o">;</span>
        <span class="n">p</span><span class="o">.</span><span class="na">after</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">b</span><span class="o">.</span><span class="na">after</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">a</span><span class="o">.</span><span class="na">before</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">last</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">p</span><span class="o">.</span><span class="na">before</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
            <span class="n">last</span><span class="o">.</span><span class="na">after</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        可以看到逻辑很简单，就是将节点 $p$ 置于链表尾部。而这个节点 $p$ 是我们刚刚通过 $get$ 方法尝试访问的节点 $e$ 转化过来的，也就是说这个方法实际上是将最近访问的节点放到链表尾部。除了 $get$ 方法之外，$put$ 方法和 $replace$ 方法也会调用该方法。<br/>
        除了这个方法外，$put$ 方法在添加键值对时，还会调用另一个方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span>
               <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
    <span class="cm">/*
</span><span class="cm">    将值插入表内
</span><span class="cm">    */</span>
    <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="n">resize</span><span class="o">();</span>
    <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>        $LinkedHashMap$ 本身并没有重写 $put$ 方法，也就是说它调用的是 $HashMap$ 中的版本。而在 $HashMap$ 里，$afterNodeInsertion$ 方法是空实现，也就是不执行任何操作。$LinkedHashMap$ 重写了该方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">afterNodeInsertion</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">LinkedHashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">evict</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">first</span> <span class="o">=</span> <span class="n">head</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">removeEldestEntry</span><span class="o">(</span><span class="n">first</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">K</span> <span class="n">key</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
        <span class="n">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        方法实现很简单，只要 $evict = true$ 、链表非空并且 $removeEldestEntry$ 方法为 $true$ ，就移除首节点，也就是最近最少访问的节点。而 $removeEldestEntry$ 方法的实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">removeEldestEntry</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">eldest</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>        可以发现默认返回 $false$ ，也就是不移除节点。所以如果要使用 $LinkedHashMap$ 实现 $LRUCache$ ，就需要重写该方法。而除了 $afterNodeInsertion$ 和 $afterNodeAccess$ 方法之外，还有一个用于移除时的 $afterNodeRemoval$ 方法，实现逻辑大致相同，在此就不赘述。<br/>
        使用 $LinkedHashMap$ 实现 $LRUCache$ 的方法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LRUCache</span> <span class="kd">extends</span> <span class="n">LinkedHashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">16</span><span class="o">,</span> <span class="n">0</span><span class="o">.</span><span class="na">75f</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="o">-</span><span class="n">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">removeEldestEntry</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">eldest</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2021 Mar 16 18:05</span> <a href="/post/leetcode%E9%A2%98%E8%A7%A35lru%E4%B8%8Elinkedhashmap/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
        if (tocFlag) tocInit();
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>