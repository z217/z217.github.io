<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.74.3" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  <title>z217&#39;s blog</title>
</head><body><aside id="sidenav">
    <header>
    
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>
        
    

    <a id="branding" href=https://z217blog.cn>
        
            z217&#39;s blog
        
    </a>
    </header>

    <nav>
        
            		
            <a href="/"
                
            >
                <i class="fas fa-home fa-ms"></i>
                <span>首页</span>
            </a>
        
            		
            <a href="/post/"
                
            >
                <i class="fas fa-keyboard fa-ms"></i>
                <span>文章</span>
            </a>
        
            		
            <a href="/tags"
                
            >
                <i class="fas fa-tags fa-sm"></i>
                <span>标签</span>
            </a>
        
            		
            <a href="/about"
                
            >
                <i class="fas fa-user fa-ms"></i>
                <span>关于</span>
            </a>
        
            		
            <a href="https://github.com/z217"
                
                    target="_blank"
                
            >
                <i class="fab fa-github fa-ms"></i>
                <span>Github</span>
            </a>
        
            		
            <a href="/index.xml"
                
            >
                <i class="fas fa-rss fa-sm"></i>
                <span>RSS</span>
            </a>
        
            		
            <a href="http://123.57.12.189"
                
                    target="_blank"
                
            >
                <i class="fas fa-link fa-sm"></i>
                <span>二站</span>
            </a>
        
    </nav>
</aside>
<main id="main">
            <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
            <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/">Geohash算法简介</a>
        
        
        <p>Geohash算法的简单解析以及在Redis中的使用</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 05 19:58
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Algorithm
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/">Git常用指令汇总</a>
        
        
        <p>Git 一些常用指令的简单汇总</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 04 19:36
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Other
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jwt%E7%AE%80%E4%BB%8B/">JWT简介</a>
        
        
        <p>JWT简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 04 16:41
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Other
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">Dijkstra算法原理及其实现</a>
        
        
        <p>Dijkstra原理的简单介绍及其Java实现</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Mar 03 17:27
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Algorithm, Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/">JavaScript的对象构造</a>
        
        
        <p>JavaScript的对象构造方法解析</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Feb 28 12:48
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JavaScript
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/">Geohash算法简介</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-geohash算法介绍">1. <code>Geohash</code>算法介绍</h2>

<p><a href="https://en.wikipedia.org/wiki/Geohash">Geohash-Wikipedia</a></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Geohash</code>是一种用于公共领域的地理编码系统，其将地理位置编码为字母和数字的短字符串。<code>Geohash</code>允许任意精度的属性，可以通过增长或缩短字符串来改变精度。当两个区域的公共前缀越长，说明他们的联系更加紧密。但是反过来，具有短公共前缀或者没有公共前缀并不一定代表着联系很小。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Geohash</code>算法可以将一个二维的经纬度坐标转换成一个可以比较的字符串，也就是降维。使用三十二进制，全球被划分为 <span  class="math">\(32\)</span> 个大块，再在每个大块内继续划分出 <span  class="math">\(32\)</span>个小块，因此对于越长的<code>geohash</code>字符串，其精度越大，代表的范围也就越小。通过<code>Base32</code>算法，<code>geohash</code>使用字母和数字表示值，如下所示：</p>

<table>
<thead>
<tr>
<th align="center">数字</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
<th align="center">21</th>
<th align="center">22</th>
<th align="center">23</th>
<th align="center">24</th>
<th align="center">25</th>
<th align="center">26</th>
<th align="center">27</th>
<th align="center">28</th>
<th align="center">29</th>
<th align="center">30</th>
<th align="center">31</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">32进制</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">b</td>
<td align="center">c</td>
<td align="center">d</td>
<td align="center">e</td>
<td align="center">f</td>
<td align="center">g</td>
<td align="center">h</td>
<td align="center">j</td>
<td align="center">k</td>
<td align="center">m</td>
<td align="center">n</td>
<td align="center">p</td>
<td align="center">q</td>
<td align="center">r</td>
<td align="center">s</td>
<td align="center">t</td>
<td align="center">u</td>
<td align="center">v</td>
<td align="center">w</td>
<td align="center">x</td>
<td align="center">y</td>
<td align="center">z</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使用了所有 <span  class="math">\(10\)</span> 以内的数字，以及除 <span  class="math">\(a\)</span>, <span  class="math">\(i\)</span>, <span  class="math">\(l\)</span> 和 <span  class="math">\(o\)</span> 之外的所有小写字母。在计算的时候只需要在十进制和三十二进制之间转换即可，举例：</p>

<div>
$$\begin{aligned}
(ezs42)_{32} &= e \times 32^4 + z \times 32^3 + s \times 32^2 + 4 \times 32^1 + 2 \times 32^0 \\
&= 13 \times 1048576 + 31 \times 32768 + 24 \times 1024 + 4 \times 32 + 2 \times 1 \\
&= 14672002.
\end{aligned}$$
</div>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如之前所说的，<code>geohash</code>算法将经纬度转换成一个字符串，自然也能由字符串转回经纬度。再以 <span  class="math">\(ezs42\)</span> 为例，将其转换为二进制：</p>

<div>
$$\begin{aligned}
    &(e)_{32} = (01101)_2, \\
    &(z)_{32} = (11111)_2, \\
    &(s)_{32} = (11000)_2, \\
    &(4)_{32} = (00100)_2, \\
    &(2)_{32} = (00010)_2.
\end{aligned}$$
</div>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果得到的二进制数字为：<span  class="math">\((0110111111110000010000010)_2\)</span> 。假设从左到右读，则奇数位代表纬度代码：<span  class="math">\((101111001001)_2\)</span>，偶数位代表经度代码：<span  class="math">\((0111110000000)_2\)</span>。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来再通过二分法对经纬度代码进行分别处理。纬度的范围为 <span  class="math">\(-90 \sim 90\)</span> ，我们将其划分为两块：<span  class="math">\(-90 \sim 0\)</span> 和 <span  class="math">\(0 \sim 90\)</span> 。查看纬度代码，第一位为 <span  class="math">\(1\)</span>，因此选择 <span  class="math">\(0 \sim 90\)</span>。如果为 <span  class="math">\(0\)</span> 的话，就要选择左边的区间。即为 <span  class="math">\(0\)</span> 选择左边，为 <span  class="math">\(1\)</span> 选择右边。如果没有更多的位数，那么可以认为纬度为 <span  class="math">\(45\)</span>，这样误差范围就为 <span  class="math">\(\pm45\)</span> 。但是在这里我们有更多的位数，因此可以继续下去。再对 <span  class="math">\(0 \sim 90\)</span> 进行二分分为 <span  class="math">\(0 \sim 45\)</span> 和 <span  class="math">\(45 \sim 90\)</span> ，可以看到纬度代码第二位为 <span  class="math">\(0\)</span> ，因此选择 <span  class="math">\(0 \sim 45\)</span> 。如此往复，可以确认纬度值。再使用同样的方法，可以确认经度值，不过要注意经度的范围是 <span  class="math">\(-180 \sim 180\)</span> 。<br>
经度确定：</p>

<table>
<thead>
<tr>
<th align="center">位数</th>
<th align="center">位值</th>
<th align="center">最小值</th>
<th align="center">中间值</th>
<th align="center">最大值</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">-90.000</td>
<td align="center">0.000</td>
<td align="center">90.000</td>
</tr>

<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0.000</td>
<td align="center">45.000</td>
<td align="center">90.000</td>
</tr>

<tr>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">0.000</td>
<td align="center">22.500</td>
<td align="center">45.000</td>
</tr>

<tr>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">22.500</td>
<td align="center">33.750</td>
<td align="center">45.000</td>
</tr>

<tr>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">33.750</td>
<td align="center">39.375</td>
<td align="center">45.000</td>
</tr>

<tr>
<td align="center">5</td>
<td align="center">1</td>
<td align="center">39.375</td>
<td align="center">42.188</td>
<td align="center">45.000</td>
</tr>

<tr>
<td align="center">6</td>
<td align="center">0</td>
<td align="center">42.188</td>
<td align="center">43.594</td>
<td align="center">45.000</td>
</tr>

<tr>
<td align="center">7</td>
<td align="center">0</td>
<td align="center">42.188</td>
<td align="center">42.891</td>
<td align="center">43.594</td>
</tr>

<tr>
<td align="center">8</td>
<td align="center">1</td>
<td align="center">42.188</td>
<td align="center">42.539</td>
<td align="center">42.891</td>
</tr>

<tr>
<td align="center">9</td>
<td align="center">0</td>
<td align="center">42.539</td>
<td align="center">42.715</td>
<td align="center">42.891</td>
</tr>

<tr>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">42.539</td>
<td align="center">42.627</td>
<td align="center">42.715</td>
</tr>

<tr>
<td align="center">11</td>
<td align="center">1</td>
<td align="center">42.539</td>
<td align="center">42.583</td>
<td align="center">42.627</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可得纬度为 <span  class="math">\(42.583\)</span> ，同理可得经度为 <span  class="math">\(-5.581\)</span> ，经纬度误差范围都在 <span  class="math">\(\pm0.022\)</span> 之间。根据经纬度与千米的比例表可得误差距离。</p>

<table>
<thead>
<tr>
<th align="left"><code>Geohash</code>长度</th>
<th align="left">纬度位数</th>
<th align="left">经度位数</th>
<th align="left">纬度误差</th>
<th align="left">经度误差</th>
<th align="left">千米误差</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left"><span  class="math">\(\pm23\)</span></td>
<td align="left"><span  class="math">\(\pm23\)</span></td>
<td align="left"><span  class="math">\(\pm2500\)</span></td>
</tr>

<tr>
<td align="left">2</td>
<td align="left">5</td>
<td align="left">5</td>
<td align="left"><span  class="math">\(\pm2.8\)</span></td>
<td align="left"><span  class="math">\(\pm5.6\)</span></td>
<td align="left"><span  class="math">\(\pm630\)</span></td>
</tr>

<tr>
<td align="left">3</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left"><span  class="math">\(\pm0.70\)</span></td>
<td align="left"><span  class="math">\(\pm0.70\)</span></td>
<td align="left"><span  class="math">\(\pm78\)</span></td>
</tr>

<tr>
<td align="left">4</td>
<td align="left">10</td>
<td align="left">10</td>
<td align="left"><span  class="math">\(\pm0.087\)</span></td>
<td align="left"><span  class="math">\(\pm0.18\)</span></td>
<td align="left"><span  class="math">\(\pm20\)</span></td>
</tr>

<tr>
<td align="left">5</td>
<td align="left">12</td>
<td align="left">13</td>
<td align="left"><span  class="math">\(\pm0.022\)</span></td>
<td align="left"><span  class="math">\(\pm0.022\)</span></td>
<td align="left"><span  class="math">\(\pm2.4\)</span></td>
</tr>

<tr>
<td align="left">6</td>
<td align="left">15</td>
<td align="left">15</td>
<td align="left"><span  class="math">\(\pm0.0027\)</span></td>
<td align="left"><span  class="math">\(\pm0.0055\)</span></td>
<td align="left"><span  class="math">\(\pm0.61\)</span></td>
</tr>

<tr>
<td align="left">7</td>
<td align="left">17</td>
<td align="left">18</td>
<td align="left"><span  class="math">\(\pm0.00068\)</span></td>
<td align="left"><span  class="math">\(\pm0.00068\)</span></td>
<td align="left"><span  class="math">\(\pm0.076\)</span></td>
</tr>

<tr>
<td align="left">8</td>
<td align="left">20</td>
<td align="left">20</td>
<td align="left"><span  class="math">\(\pm0.000085\)</span></td>
<td align="left"><span  class="math">\(\pm0.00017\)</span></td>
<td align="left"><span  class="math">\(\pm0.019\)</span></td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个给定的经纬度，要想求得经纬度的二进制代码值，只需要将上述步骤倒过来即可。再以 <span  class="math">\((42.583, -5.581)\)</span> 为例。<br>
经度代码确定：</p>

<table>
<thead>
<tr>
<th align="center">位数</th>
<th align="center">最小值</th>
<th align="center">中间值</th>
<th align="center">最大值</th>
<th align="center">位值</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">0</td>
<td align="center">-90.000</td>
<td align="center">0.000</td>
<td align="center">90.000</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">1</td>
<td align="center">0.000</td>
<td align="center">45.000</td>
<td align="center">90.000</td>
<td align="center">0</td>
</tr>

<tr>
<td align="center">2</td>
<td align="center">0.000</td>
<td align="center">22.500</td>
<td align="center">45.000</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">3</td>
<td align="center">22.500</td>
<td align="center">33.750</td>
<td align="center">45.000</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">4</td>
<td align="center">33.750</td>
<td align="center">39.375</td>
<td align="center">45.000</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">5</td>
<td align="center">39.375</td>
<td align="center">42.188</td>
<td align="center">45.000</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">6</td>
<td align="center">42.188</td>
<td align="center">43.594</td>
<td align="center">45.000</td>
<td align="center">0</td>
</tr>

<tr>
<td align="center">7</td>
<td align="center">42.188</td>
<td align="center">42.891</td>
<td align="center">43.594</td>
<td align="center">0</td>
</tr>

<tr>
<td align="center">8</td>
<td align="center">42.188</td>
<td align="center">42.539</td>
<td align="center">42.891</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">9</td>
<td align="center">42.539</td>
<td align="center">42.715</td>
<td align="center">42.891</td>
<td align="center">0</td>
</tr>

<tr>
<td align="center">10</td>
<td align="center">42.539</td>
<td align="center">42.627</td>
<td align="center">42.715</td>
<td align="center">0</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然通过<code>geohash</code>可以通过公共前缀来查找一些彼此相邻的点，但是在一些边缘情况无法通过这种方式进行查询。例如在本初子午线左右两端的<code>geohash</code>值并没有公共前缀，以及靠近南北极的区域的<code>geohash</code>值差异很大。因为<code>geohash</code>依赖经纬度得到数值，因此在这些经纬度变化迅速的区域，它们的<code>geohash</code>值的变化也很迅速。</p>

<h2 id="2-redis中使用geo数据类型">2. <code>Redis</code>中使用<code>geo</code>数据类型</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续以 <span  class="math">\((42.583, -5.581)\)</span> 为例，演示在<code>Redis</code>中操作<code>geo</code>数据类型。</p>
<pre><code class="language-redis" data-lang="redis">geoadd location -5.581 42.583 gw01</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 <span  class="math">\((42.583, -5.581)\)</span> 存入 <span  class="math">\(location\)</span> 并命名为 <span  class="math">\(gw01\)</span>。<span  class="math">\(location\)</span> 本质为 <span  class="math">\(zset\)</span> 数据类型。再对其获取得</p>
<pre><code class="language-redis" data-lang="redis">geopos location gw01</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算其<code>geohash</code>值</p>
<pre><code class="language-redis" data-lang="redis">geohash location gw01</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，通过</p>
<pre><code class="language-redis" data-lang="redis">geodist
georadius
georadiusbymember</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些指令可以计算范围内符合条件的坐标。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Aug 5 19:58</span> <a href="/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/">Git常用指令汇总</a></h1>
            </center>
            <div class="post-content">
                <h2 id="创建仓库init">创建仓库/init</h2>
<pre><code class="language-git" data-lang="git">git init</code></pre>
<p>创建成功后当前目录下会生成一个<code>.git</code>目录，用于跟踪和管理版本库。</p>

<h2 id="添加文件add">添加文件/add</h2>
<pre><code class="language-git" data-lang="git">git add</code></pre>
<p><code>.</code> 自动添加本地所有修改。</p>

<h2 id="提交commit">提交/commit</h2>
<pre><code class="language-git" data-lang="git">git commit</code></pre>
<p><span  class="math">\(-m\)</span> 增加提交信息。<br>
<span  class="math">\(-a\)</span> 自动寻找修改的文件并提交。</p>

<h2 id="状态查看status">状态查看/status</h2>
<pre><code class="language-git" data-lang="git">git status</code></pre>
<p><span  class="math">\(-s\)</span> 简短输出。</p>

<h2 id="改动查看diffblame">改动查看/diff&amp;blame</h2>
<pre><code class="language-git" data-lang="git">git diff</code></pre>
<p><span  class="math">\(--cached\)</span> 显示暂存区的改动。<br>
<span  class="math">\(HEAD\)</span> 查看所有改动。<br>
<span  class="math">\(--stat\)</span> 显示摘要。</p>
<pre><code class="language-git" data-lang="git">git blame</code></pre>
<p>文件修改记录。</p>

<h2 id="历史查看log">历史查看/log</h2>
<pre><code class="language-git" data-lang="git">git log</code></pre>
<p>按时间由近到远排序，列出最近的三次提交。<br>
<span  class="math">\(-p\;[filename]\)</span> 文件最后一次提交信息。<br>
<span  class="math">\(--pretty=oneline\)</span> 可以列出简略的信息。<br>
<span  class="math">\(--graph\)</span> 拓扑图显示。<br>
<span  class="math">\(--reverse\)</span> 逆向显示。<br>
<span  class="math">\(--author=\)</span> 查找指定作者。<br>
<span  class="math">\(--since\)</span>, <span  class="math">\(--before\)</span>, <span  class="math">\(--util\)</span>, <span  class="math">\(--after\)</span> 指定日期。<br>
<span  class="math">\(--decorate\)</span> 显示标签。</p>

<h2 id="提交撤销revert">提交撤销/revert</h2>
<pre><code class="language-git" data-lang="git">git revert</code></pre>
<h2 id="回退版本reset">回退版本/reset</h2>
<pre><code class="language-git" data-lang="git">git reset --hard HEAD^
git reset --hard HEAD~2
git reset --hard 56e7</code></pre>
<p><span  class="math">\(HEAD\)</span> 表示当前版本。<code>^</code> 表示回退一个版本，可以输入多个 <code>^</code>。<span  class="math">\(\sim\)</span> 之后可以输入任意数字，表示回退对应数量的版本。也可以直接输入版本号，版本号通过 <span  class="math">\(git\;log\)</span> 命令查询，使用版本号不仅可以回退版本，在错误回退版本之后，也可以前进到指定的版本，版本号可以不写全，但一定要写到<code>Git</code>能识别出唯一一个版本为止。</p>
<pre><code class="language-git" data-lang="git">git reset HEAD [filename]</code></pre>
<p>撤销暂存区的改动。</p>
<pre><code class="language-git" data-lang="git">git reset --keep</code></pre>
<p>回退并保存未提交的改动。</p>

<h2 id="指令记录查询reflog">指令记录查询/reflog</h2>
<pre><code class="language-git" data-lang="git">git reflog</code></pre>
<p>此指令会列出曾经执行过的指令，也会显示版本号。</p>

<h2 id="文件删除rm">文件删除/rm</h2>
<pre><code class="language-git" data-lang="git">git rm</code></pre>
<p><span  class="math">\(-f\)</span> 删除之前修改且放到暂存区的文件。<br>
<span  class="math">\(--cached\)</span> 只删除在暂存区的文件。<br>
<span  class="math">\(-r\)</span> 递归删除子目录和文件。</p>

<h2 id="文件移动mv">文件移动/mv</h2>
<pre><code class="language-git" data-lang="git">git mv</code></pre>
<p>也可以用于重命名文件。</p>

<h2 id="文件拷贝clone">文件拷贝/clone</h2>
<pre><code class="language-git" data-lang="git">git clone</code></pre>
<h2 id="分支切换checkoutswitch">分支切换/checkout&amp;switch</h2>
<pre><code class="language-git" data-lang="git">git checkout</code></pre>
<p><span  class="math">\(--\;\;[filename]\)</span> 丢弃工作区指定文件的改动（不切换分支）。<br>
<span  class="math">\(-b\)</span> 创建新分支并立即切换到该分支。</p>
<pre><code class="language-git" data-lang="git">git switch</code></pre>
<p><span  class="math">\(-c\)</span> 创建并切换到新的分支。</p>

<h2 id="分支管理branch">分支管理/branch</h2>
<pre><code class="language-git" data-lang="git">git branch</code></pre>
<p>不加分支名可以列出分支。<br>
<span  class="math">\(-d\)</span> 删除分支。<br>
<span  class="math">\(-D\)</span> 强制删除分支。<br>
<span  class="math">\( --set-upstream-to=[origin/branch]\;\;[local branch] \)</span> 关联本地分支与远程库分支。<br>
<span  class="math">\(--track\)</span> 基于远程分支创建新分支。<br>
<span  class="math">\([origin]\;\;--delete\;\;[branch]\)</span> 删除远程分支。</p>

<h2 id="合并分支mergemergetool">合并分支/merge&amp;mergetool</h2>
<pre><code class="language-git" data-lang="git">git merge</code></pre>
<p><span  class="math">\(--no-ff\)</span> 分支时提交（即保留分支信息）。</p>
<pre><code class="language-git" data-lang="git">git mergetool</code></pre>
<p>使用配置的合并工具解决冲突。</p>

<h2 id="远程库remote">远程库/remote</h2>
<pre><code class="language-git" data-lang="git">git remote</code></pre>
<p>查看远程库信息。<br>
<span  class="math">\(-v\)</span> 查看详细信息。</p>
<pre><code class="language-git" data-lang="git">git remote add [remote] [url]</code></pre>
<p>创建远程库，远程库名字默认为<span  class="math">\(origin\)</span>。</p>
<pre><code class="language-git" data-lang="git">git remote rename</code></pre>
<p>重命名远程库。</p>

<h2 id="远程库推送push">远程库推送/push</h2>
<pre><code class="language-git" data-lang="git">git push [remote] [local branch]</code></pre>
<p>也可以将本地分支名改为标签名，或改为 <span  class="math">\(--tags\)</span> 推送所有未推送的标签， <span  class="math">\(:refs/tags/[tag name]\)</span> 删除指定标签。<br>
<span  class="math">\(-u\)</span> 关联对应库和本地分支，简化后续操作。<br>
<span  class="math">\(-[remote]:[old name]\)</span> 重命名远程分支。</p>

<h2 id="提交抓取pullfetch">提交抓取/pull&amp;fetch</h2>
<pre><code class="language-git" data-lang="git">git pull [remote] [branch]
git fetch [remote]</code></pre>
<p>下载新数据与分支。</p>

<h2 id="工作区储存stash">工作区储存/stash</h2>
<pre><code class="language-git" data-lang="git">git stash
git stash list
git stash apply
git stash drop
git stash pop</code></pre>
<p>分别用于储存、列出、恢复、删除储存内容，<span  class="math">\(pop\)</span> 会在恢复同时删除储存内容。</p>

<h2 id="改动复制cherrypick">改动复制/cherry-pick</h2>
<pre><code class="language-git" data-lang="git">git cherry-pick</code></pre>
<p>将对应的提交改动复制到另一个分支。</p>

<h2 id="变基rebase">变基/rebase</h2>
<pre><code class="language-git" data-lang="git">git rebase</code></pre>
<p><span  class="math">\(--abort\)</span> 终止合并。<br>
<span  class="math">\(--continue\)</span> 继续合并。</p>

<h2 id="标签创建tag">标签创建/tag</h2>
<pre><code class="language-git" data-lang="git">git tag
git tag [tag name] [commit id]</code></pre>
<p>未指定标签名时列出所有标签，不指定版本号时默认为当前版本。
<span  class="math">\(-a\)</span> 为标签添加注解。
<span  class="math">\(-d\)</span> 删除指定标签。</p>

<h2 id="信息显示show">信息显示/show</h2>
<pre><code class="language-git" data-lang="git">git show</code></pre>
<p><span  class="math">\([tag name]\)</span> 查看标签信息。</p>
<pre><code class="language-git" data-lang="git">git remote show</code></pre>
<p><span  class="math">\([remote]\)</span> 查看远程库信息。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Aug 4 19:36</span> <a href="/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jwt%E7%AE%80%E4%BB%8B/">JWT简介</a></h1>
            </center>
            <div class="post-content">
                <p><a href="https://en.wikipedia.org/wiki/JSON_Web_Token">JWT-Wikipedia</a></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JWT</code>( <span  class="math">\(JSON\;Web\;Token\)</span> )是一种基于<code>JSON</code>的用于创建可选签名或可选加密的数据的互联网标准。<code>Token</code>使用一个私钥或者公钥进行签名，持有私钥或者公钥的一方可以验证令牌的合法性。<code>Token</code>被设计为紧凑且安全的，尤其适用于<code>Web</code>浏览器单点登录 ( <code>Single-sign-on</code>, <span  class="math">\(SSO\)</span> ) 场景。<code>JWT</code>声明一般用于在身份提供者和服务提供者之间传递用户身份信息，或者用于业务流程要求的任何其他类型的声明。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在传统的<code>session</code>认证中，通常使用<code>cookie</code>来保存用户的身份信息，方便下一次请求。由于<code>session</code>是存储在内存中的，因此存在开销隐患。而且使用<code>cookie</code>也意味着存在着<code>CSRF</code>问题。使用<code>JWT</code>进行认证时，用户在成功认证登录过后，将会得到一个<code>token</code>。<code>Token</code>会保存在本地（也可以保存在<code>session</code>或者<code>cookie</code>中），而不是传统的在服务器上创建一个<code>session</code>并返回<code>cookie</code>。每当用户想要访问受保护的资源时，用户代理需要发送<code>JWT</code>，<code>JWT</code>通常包含在请求头中。通过使用<code>JWT</code>，用户的状态永远也不会保存在服务器中。当接收到请求时，服务器将会检查<code>JWT</code>的有效性。由于<code>JWT</code>是独立的，存储着所有必要的信息，因此可以减少数据库查询的次数。</p>

<h2 id="jwt的结构"><code>JWT</code>的结构</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JWT</code>由三部分组成：<span  class="math">\(Header\)</span>, <span  class="math">\(Payload\)</span>, <span  class="math">\(Signature\)</span> 。</p>

<h3 id="1-header">1. Header</h3>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;alg&#34;</span><span class="p">:</span> <span class="s2">&#34;HS256&#34;</span><span class="p">,</span>
    <span class="nt">&#34;typ&#34;</span><span class="p">:</span> <span class="s2">&#34;JWT&#34;</span>
<span class="p">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Header\)</span> 标识用于生成签名的算法。典型的加密算法如<code>HMAC-SHA-256</code>, <code>RSA-SHA-256</code>。上例使用的是<code>HMAC-SHA-256</code>。</p>

<h3 id="2-payload">2. Payload</h3>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;loggedInAs&#34;</span><span class="p">:</span> <span class="s2">&#34;admin&#34;</span><span class="p">,</span>
    <span class="nt">&#34;iat&#34;</span><span class="p">:</span> <span class="mi">1422779638</span>
<span class="p">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Payload$ 包含了一组声明。<code>JWT</code>标准注册了七个声明：</p>

<ul>
<li><span  class="math">\(iss\)</span>：<code>JWT</code>签发者</li>
<li><span  class="math">\(sub\)</span>：<code>JWT</code>面向用户</li>
<li><span  class="math">\(aud\)</span>：<code>JWT</code>接收方</li>
<li><span  class="math">\(exp\)</span>：<code>JWT</code>过期时间</li>
<li><span  class="math">\(nbf\)</span>：<code>JWT</code>启用时间</li>
<li><span  class="math">\(iat\)</span>：<code>JWT</code>签发时间</li>
<li><span  class="math">\(jti\)</span>：<code>JWT</code>的唯一身份标识，可以用作一次性<code>token</code></li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Payload$ 中还可以添加自定义声明，如上例的 <span  class="math">\(loggedInAs\)</span>。</p>

<h3 id="3-signature">3. Signature</h3>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">signature</span> <span class="o">=</span> <span class="nx">HMAC</span><span class="o">-</span><span class="nx">SHA256</span><span class="p">(</span>
    <span class="nx">base64urlEncoding</span><span class="p">(</span><span class="nx">header</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nx">base64urlEncoding</span><span class="p">(</span><span class="nx">payload</span><span class="p">),</span>
    <span class="s1">&#39;secret&#39;</span>
<span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Signature\)</span> 用于安全地验证<code>token</code>。使用 <span  class="math">\(Base64urlEncoding\)</span> 对 <span  class="math">\(header\)</span> 和 <span  class="math">\(payload\)</span> 进行编码，再使用句点隔开，可以计算出签名。<span  class="math">\(secret\)</span>保存在服务器中，在使用指定算法生成签名的时候使用，生成哈希，确保数据不被篡改。然后再通过指定的算法，在此例中为 <code>HMAC-SHA256</code>， 进行加密。<span  class="math">\(Base64url\)</span> 编码类似于 <code>base64</code>。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终得到的<code>JWT</code>如下</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">token</span> <span class="o">=</span> <span class="nx">base64urlEncoding</span><span class="p">(</span><span class="nx">header</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nx">base64urlEncoding</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nx">base64urlEncoding</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后在请求头中加入</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">Authorization</span><span class="o">:</span> <span class="sb">`Bearer&#39; + token
</span></code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2020 Aug 4 16:41</span> <a href="/post/jwt%E7%AE%80%E4%BB%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">Dijkstra算法原理及其实现</a></h1>
            </center>
            <div class="post-content">
                <p><strong>参考书籍：《算法（第4版）》</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Dijkstra\)</span> 算法应用于带权有向图中求最短路径问题。通俗来讲就是不断选择权值最小的边加入集合直到所有顶点都在集合中，属于贪心算法。需要注意的是，<span  class="math">\(Dijkstra\)</span> 算法只能用于解决边权非负的图类问题。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设对于一个带权有向图 <span  class="math">\(G(V,E)\)</span> 以邻接矩阵表示，其所有边存储在一个二维整型数组 <span  class="math">\(matrix[\ \ ][\ \ ]\)</span> 中， <span  class="math">\(matrix[i][j]\)</span> 表示从顶点 <span  class="math">\(i\)</span> 到顶点 <span  class="math">\(j\)</span> 之间的边，值为边的权值，若值为 <span  class="math">\(∞\)</span> ，说明该边不存在。为了实现 <span  class="math">\(Dijkstra\)</span> 算法，我们需要一个布尔值数组 <span  class="math">\(visit[\ \ ]\)</span> ，用于判断顶点是否访问过，或者说是否在集合中；一个整型数组 <span  class="math">\(distance[\ \ ]\)</span> 用于储存原点到每个点的最短距离。定义了基本的结构，就可以实现算法了，步骤为：</p>

<ol>
<li>从 <span  class="math">\(V\)</span> 中选择一个点 <span  class="math">\(s\)</span> 作为原点，将邻接矩阵中的 <span  class="math">\(matrix[s]\)</span> 数组复制到 <span  class="math">\(distance[s]\)</span> （复制后 <span  class="math">\(distance[s]\)</span> 应为 <span  class="math">\(0\)</span> ），建立一个 <span  class="math">\(visit[\ \ ]\)</span> 数组并清零。</li>
<li>从 <span  class="math">\(V\)</span> 中选择一个顶点 <span  class="math">\(u\)</span> 加入集合，其中点 <span  class="math">\(u\)</span> 满足：<br>

<ul>
<li>之前未曾访问过点 <span  class="math">\(u\)</span> （即 <span  class="math">\(visit[u] = false\)</span> ）。</li>
<li>与 <span  class="math">\(s\)</span> 距离最短（即 <span  class="math">\(distance[u]\)</span> 的值最小）。</li>
</ul></li>
<li>以 <span  class="math">\(u\)</span> 为中心点，对于每个与 <span  class="math">\(u\)</span> 相邻的顶点 <span  class="math">\(k\)</span> ，令 <span  class="math">\(distance[k] = Min(distance[k], distance[u] + matrix[u][k])\)</span> ，这一步也称为<code>松弛</code>( <span  class="math">\(relaxation\)</span> )。</li>
<li>重复2、3直到所有顶点加入集合。</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Dijkstra\)</span> 算法类似于 <span  class="math">\(Prim\)</span> 算法，实质上都是构造了一颗树。经过以上步骤之后，我们得到了一个 <span  class="math">\(distance[\ \ ]\)</span> 数组，其中的值为从原点 <span  class="math">\(s\)</span> 到图中其他所有点的最短距离。在使用代码实现的过程中，有些情况下我们可以使用优先队列来简化寻找最小权值的这一过程。如果我们确认了一幅图是无环图，那么我们也可以不使用 <span  class="math">\(visit[\ \ ]\)</span> ，而是通过拓扑排序的顺序依次遍历顶点。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将上述过程转化为代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dijkstra</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dijkstra</span> <span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">bool</span><span class="o">[]</span> <span class="n">visit</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">distance</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
        <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">s</span><span class="o">],</span> <span class="n">0</span><span class="o">,</span> <span class="n">distance</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span> <span class="c1">// 复制邻接矩阵的值
</span><span class="c1"></span>        <span class="n">distance</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="n">visit</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// 遍历其他顶点
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
            <span class="c1">// 寻找最小权值
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visit</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">distance</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="n">visit</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="c1">// 松弛
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visit</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">k</span><span class="o">])</span>
                    <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">distance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此我们实现了 <span  class="math">\(Dijkstra\)</span> 算法。虽然这里我们没有使用优先队列，但是使用优先队列是可行的，也可以在一定程度上加快速度。 <span  class="math">\(Dijkstra\)</span> 算法有许多种优化策略，而不同的策略对应的时间复杂度也是不同，因此在此不作过多叙述，如果感兴趣的话可以在 <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Description">Dijkstra's algorithm - Wikipedia</a> 中查看。如果我们将寻找最小权值的过程改为寻找最大权值，那么就可以由最短路径算法改为最长路径算法。</p>

<hr>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 <span  class="math">\(Dijkstra\)</span> 算法有很多题，在这里举一道题为例。</p>

<p><a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">原题地址：Problem 1334</a></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然在这道题就是一道求最短距离的算法，分别以每个城市为原点计算 <span  class="math">\(distance[\ \ ]\)</span> 数组，再遍历数组得到答案，最终输出最大值即可。我们直接将上面的 <span  class="math">\(Dijkstra\)</span> 算法的模板套进去就行了。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTheCity</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distanceThreshold</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 将边集转换为邻接矩阵
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">)</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span> <span class="c1">// 用最大值代表无穷
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="n">matrix</span><span class="o">[</span><span class="n">edge</span><span class="o">[</span><span class="n">0</span><span class="o">]][</span><span class="n">edge</span><span class="o">[</span><span class="n">1</span><span class="o">]]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">edge</span><span class="o">[</span><span class="n">1</span><span class="o">]][</span><span class="n">edge</span><span class="o">[</span><span class="n">0</span><span class="o">]]</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="n">2</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">MIN</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
        <span class="c1">// 分别以每个点为原点，调用 Dijkstra算法
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">distance</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visit</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">0</span><span class="o">,</span> <span class="n">distance</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
            <span class="n">distance</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">visit</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">min</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                        <span class="n">u</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="n">visit</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">visit</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">k</span><span class="o">])</span>
                        <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// 计算相邻城市数
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">dist</span> <span class="o">:</span> <span class="n">distance</span><span class="o">)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">distanceThreshold</span><span class="o">)</span> <span class="n">count</span><span class="o">++;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="n">MIN</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">MIN</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2020 Mar 3 17:27</span> <a href="/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/">JavaScript的对象构造</a></h1>
            </center>
            <div class="post-content">
                <p><strong>参考书籍：《JavaScript高级程序设计》（第3版）</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JavaScript</code>是一门面向对象的语言，即拥有类的概念。但<code>ECMAScript</code>中没有类的概念，因此它的对象与其他基于类的语言不同，我们可以把<code>ECMAScript</code>中的对象想象成散列表，由一组组键值对构成，值可以是数据或者函数。</p>

<ol>
<li><a href="#2020-02-28-1"> <span  class="math">\(object\)</span> 构造函数模式</a></li>
<li><a href="#2020-02-28-2">对象字面量</a></li>
<li><a href="#2020-02-28-3">工厂模式</a></li>
<li><a href="#2020-02-28-4">构造函数模式</a></li>
<li><a href="#2020-02-28-5">原型模式</a>

<ul>
<li><a href="#2020-02-28-5-1">什么是原型对象</a></li>
</ul></li>
<li><a href="#2020-02-28-6">寄生构造函数模式</a></li>
<li><a href="#2020-02-28-7">稳妥构造函数模式</a></li>
<li><a href="#2020-02-28-8">属性类型</a></li>
</ol>

<hr>

<h2 id="span-id--2020022811object构造函数模式span"><span id = "2020-02-28-1">1.<code>object</code>构造函数模式</span></h2>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">object</span><span class="p">();</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;A&#34;</span><span class="p">;</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上例创建了一个 <span  class="math">\(person\)</span> 对象，并为其添加了 <span  class="math">\(name\)</span> 属性和 <span  class="math">\(sayName(\ )\)</span> 方法，是最简单的构造对象的方法。</p>

<hr>

<h2 id="span-id--2020022822对象字面量span"><span id = "2020-02-28-2">2.对象字面量</span></h2>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;XiaoMing&#34;</span><span class="p">,</span>
    <span class="nx">sayName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上例创建了相同的 <span  class="math">\(person\)</span> 对象，不同之处在于它是使用对象字面量定义的。以花括号表示开始和结束，属性名+冒号+值的格式定义属性，用逗号隔开多个不同的属性。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用对象字面量时，属性名也可以使用字符串。需要注意的是，<code>JSON</code>只支持此种语法。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&#34;name&#34;</span><span class="o">:</span> <span class="s2">&#34;XiaoMing&#34;</span><span class="p">,</span>
    <span class="s2">&#34;sayName&#34;</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般情况下，由于对象字面量语法的代码量少，开发人员大多采用此种方式构造对象。</p>

<hr>

<h2 id="span-id--2020022833工厂模式span"><span id = "2020-02-28-3">3.工厂模式</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不论是使用 <span  class="math">\(object\)</span> 构造函数还是对象字面量，都有一个很明显的缺点，就是创建多个对象时会产生大量重复代码。因此人们采取了工厂模式的一个变种。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">createPerson</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">object</span><span class="p">();</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="nx">createPerson</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="nx">createPerson</span><span class="p">(</span><span class="s2">&#34;XiaoHong&#34;</span><span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数 <span  class="math">\(createPerson(\ )\)</span> 接收参数并返回一个 <span  class="math">\(person\)</span> 对象，每次调用均可以得到一个新的 <span  class="math">\(person\)</span> 对象。以此，我们可以大量创建 <span  class="math">\(person\)</span> 对象。</p>

<hr>

<h2 id="span-id--2020022844构造函数模式span"><span id = "2020-02-28-4">4.构造函数模式</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ECMAScript</code>中的构造函数可以用于创建指定类型的对象，我们可以创建自定义构造函数，从而创建自定义对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;XiaoHong&#34;</span><span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此例使用 <span  class="math">\(Person(\ )\)</span> 函数替代了 <span  class="math">\(createPerson(\ )\)</span> 函数。可以发现， <span  class="math">\(Person(\ )\)</span> 中，我们并没有显示的创建对象，而是直接将属性和方法赋予 <span  class="math">\(this\)</span> 对象，并且在最后构造函数时使用了 <span  class="math">\(new\)</span> 操作符。实际上，该操作经历了  <span  class="math">\(4\)</span>  步：</p>

<ol>
<li>创建对象</li>
<li>将构造函数作用域赋予新对象</li>
<li>执行构造函数</li>
<li>返回新对象</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此例中，我们创建的对象可以通过 <span  class="math">\(instanceof\)</span> 操作符进行检验，这也正是使用构造函数模式的优点——对象实例被标识为特殊类型。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们不使用 <span  class="math">\(new\)</span> 操作符，而是直接调用构造函数，则属性会附加在 <span  class="math">\(window\)</span> 对象上。如下所示</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">);</span>
<span class="nx">windwo</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">//&#34;XiaoMing&#34;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而要避免这种情况，可以使用严格模式。这样在非严格模式下默认转换为全局对象的 <span  class="math">\(null\)</span> 或者 <span  class="math">\(undefined\)</span> 不会转换，因此上述调用会抛出错误。严格模式可以以如下方式使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="s1">&#39;use strict&#39;</span><span class="p">;</span> <span class="c1">//开启严格模式
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<hr>

<h2 id="span-id--2020022855原型模式span"><span id = "2020-02-28-5">5.原型模式</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在原型模式之前，我们可以先讨论下构造函数模式的缺点。构造函数模式的缺点就是其中每个对象的每个方法都要重新创建一遍。例如之前的 <span  class="math">\(person1\)</span> 对象和 <span  class="math">\(person2\)</span> 对象，其 <span  class="math">\(sayName(\ )\)</span> 方法不是同一个 <span  class="math">\(Function\)</span> 实例，而是两个不同的实例。当然我们可以通过以下方法解决：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="nx">sayName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在全局作用域中定义 <span  class="math">\(sayName(\ )\)</span> 函数。这种方法确实可以做到共享同一个实例，但问题是 <span  class="math">\(sayName(\ )\)</span> 函数定义在全局作用域中，却只被 <span  class="math">\(Person\)</span> 对象调用，而且由于是全局作用域，该函数可以被随意调用，不利于封装。为解决这个问题，我们可以使用原型模式。</p>

<h3 id="span-id--2020022851什么是原型对象span"><span id = "2020-02-28-5-1">什么是原型对象</span></h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们创建的每个对象中都有一个 <span  class="math">\(prototype\)</span> 属性，该属性是一个指针，指向一个包含可以被特定实例所共享的属性和方法。对于<code>ECMAScript</code>中的引用类型而言， <span  class="math">\(prototype\)</span> 是保存所有实例方法的地方。在构造函数模式中，我们提到了创建对象过程中的  <span  class="math">\(4\)</span>  步，而 <span  class="math">\(prototype\)</span> 可以理解为第  <span  class="math">\(1\)</span>  步当中创建的对象的原型指针。无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为其创建一个 <span  class="math">\(prototype\)</span> 属性，指向函数的原型对象。创建了构造函数之后，原型对象默认取得 <span  class="math">\(constructor\)</span> 属性，这是一个指向 <span  class="math">\(prototype\)</span> 属性所在函数的指针。通过 <span  class="math">\(isPrototypeOf(\ )\)</span> 函数，我们可以判断是否是一个实例的原型对象。在<code>EMCAScript5</code>中，新增的 <span  class="math">\(Object.getPrototype(\ )\)</span> 方法可以获取对象的原型。</p>

<hr>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型对象的优点就是可以让所有对象实例共享它的属性和方法。如下例所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">()</span> <span class="p">{}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;XiaoMing&#34;</span><span class="p">;</span>
<span class="nx">Perosn</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person1</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">==</span> <span class="nx">person2</span><span class="p">.</span><span class="nx">sayName</span><span class="p">);</span> <span class="c1">//true
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现，使用原型模式后，新对象的方法是同一个方法，即实现了方法共享。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用原型模式时，当我们为实例添加了一个属性时，该属性会屏蔽原型对象中的同名属性，但不会影响到原型中的属性。如果要再访问原型属性，可以调用 <span  class="math">\(delete\)</span> 操作。判断一个属性是原型属性还是对象属性，我们可以通过 <span  class="math">\(hasOwnProperty(\ )\)</span> 函数和 <span  class="math">\(in\)</span> 操作符。 <span  class="math">\(hasOwnProperty(\ )\)</span> 函数只有当属性是对象属性时才会返回 <span  class="math">\(true\)</span> ，而 <span  class="math">\(in\)</span> 操作符无论属性是对象属性还是原型属性，都会返回 <span  class="math">\(true\)</span> 。如下例所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">()</span> <span class="p">{}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;XiaoMing&#34;</span><span class="p">,</span>
    <span class="nx">sayName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;XiaoHong&#34;</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//“XiaoHong&#34;
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">));</span> <span class="c1">// true
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="s2">&#34;name&#34;</span> <span class="k">in</span> <span class="nx">person</span><span class="p">);</span> <span class="c1">//true
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//&#34;XiaoMing&#34;
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">));</span> <span class="c1">//true
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="s2">&#34;name&#34;</span> <span class="k">in</span> <span class="nx">person</span><span class="p">);</span> <span class="c1">//true;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 <span  class="math">\(hasOWnProperty(\ )\)</span> 返回 <span  class="math">\(false\)</span> 而 <span  class="math">\(in\)</span> 返回 <span  class="math">\(true\)</span> 时，我们可以确定该属性为原型属性；而两者都返回 <span  class="math">\(true\)</span> 时，可以确定其为对象属性。在此例中，我们采用字面量语法构造 <span  class="math">\(prototype\)</span> ，相比之下，这种语法更简洁。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式很好的实现了共享，但显然对象中所有的属性都是共享是十分不利的，因此我们要采取构造函数模式和原型模式结合的方式构造对象。如下例所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="o">:</span> <span class="nx">Person</span><span class="p">,</span>
    <span class="nx">sayName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们重新定义了 <span  class="math">\(constructor\)</span> 的值，因为每当创建一个新函数时，就会一起创建其 <span  class="math">\(prototype\)</span> 对象和 <span  class="math">\(constructor\)</span> 属性，使用字面量语法相当于重写了 <span  class="math">\(prototype\)</span> 对象，因而使得 <span  class="math">\(constructor\)</span> 属性也改变了（指向 <span  class="math">\(Object\)</span> 构造函数），虽然用 <span  class="math">\(instanceof\)</span> 操作符测试 <span  class="math">\(Person\)</span> 依然为 <span  class="math">\(true\)</span> ，但如果测试 <span  class="math">\(constructor\)</span> 属性则就为 <span  class="math">\(false\)</span> 了。因此需要重新定义 <span  class="math">\(cosntructor\)</span> 属性，以确保通过该属性能够访问到正确的值。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过结合构造函数模式和原型模式，我们可以保证属性的独立和方法的共享。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然通过构造函数模式和原型模式的结合，我们可以很好的构造对象，但是相比起其他面向对象语言，此种构造方式很奇怪。对此，我们可以采用动态原型模式。此种模式的本质是检查某个方法是否有效来决定是否初始化原型。如下例所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="k">this</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">!=</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在动态原型模式中，我们只有在 <span  class="math">\(sayName(\ )\)</span> 方法不存在的情况下才会将起添加到原型当中，之后则不需要再修改原型。</p>

<hr>

<h2 id="span-id--2020022866寄生构造函数模式span"><span id = "2020-02-28-6">6.寄生构造函数模式</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;寄生构造函数模式，本质是创建一个函数，用于封装创建对象的代码，再返回所创建的对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">object</span><span class="p">();</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式和工厂模式几乎一样，区别只在于其使用 <span  class="math">\(new\)</span> 操作符创建对象，并且将包装函数作为构造函数。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式用于特殊情况下创建对象的构造函数。如下例所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">SpecialArray</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
    <span class="c1">//添加值
</span><span class="c1"></span>    <span class="nx">a</span><span class="p">.</span><span class="nx">push</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">valuse</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
    <span class="c1">//添加方法
</span><span class="c1"></span>    <span class="nx">a</span><span class="p">.</span><span class="nx">toPipedString</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&#34;|&#34;</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">names</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SpecialArray</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">,</span> <span class="s2">&#34;XiaoHong&#34;</span><span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现，通过此种模式，我们可以构造一个具有额外方法的数组。但要注意，此种模式返回的对象与构造函数及其原型没有关系，即不能通过 <span  class="math">\(instanceof\)</span> 操作符确定类型，因此，一般不推荐使用此种模式。</p>

<hr>

<h2 id="span-id--2020022877稳妥构造函数模式span"><span id = "2020-02-28-7">7.稳妥构造函数模式</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;稳妥对象(  <span  class="math">\(durable\;objects\)</span>  )，指的是没有公共属性，并且其方法也不引用 <span  class="math">\(this\)</span> 的对象，最适合在一些安全环境中使用。其遵循类似于寄生构造函数的模式，不同之处在于不引用 <span  class="math">\(this\)</span> ，不使用 <span  class="math">\(new\)</span> 操作符。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">object</span><span class="p">();</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">);</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">//&#34;XiaoMing&#34;;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以此种模式创建的对象，除了其本身的 <span  class="math">\(sayName(\ )\)</span> 方法外，没有其他方式访问 <span  class="math">\(name\)</span> 属性。</p>

<hr>

<h2 id="span-id--2020022888属性类型span"><span id = "2020-02-28-8">8.属性类型</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ECMAScript</code>中有两种属性——数据属性和访问器属性，用于描述属性特性。需要注意的是，并非所有浏览器都支持下述方法。</p>

<h3 id="1-数据属性">(1) 数据属性</h3>

<p>数据属性是一个数据值的位置，有  <span  class="math">\(4\)</span>  个行为特性：</p>

<ul>
<li><span  class="math">\([[Configurable]]\)</span> ：表示能否通过 <span  class="math">\(delete\)</span> 删除该属性，能否修改属性特性，能否修改为访问器属性，在上述例子中我们直接将属性定义在对象上，其 <span  class="math">\([[Configurable]]\)</span> 特性默认为 <span  class="math">\(true\)</span> 。</li>
<li><span  class="math">\([[Enumerable]]\)</span> ：表示能否通过 <span  class="math">\(for-in\)</span> 循环返回属性。与 <span  class="math">\([[Configurable]]\)</span> 相同，默认为 <span  class="math">\(true\)</span> 。</li>
<li><span  class="math">\([[Writable]]\)</span> ：表示能否修改属性的值。默认为 <span  class="math">\(true\)</span> 。</li>
<li><span  class="math">\([[Value]]\)</span> ：保存属性的值。读写属性时从该位置读写。默认为 <span  class="math">\(undefined\)</span> 。</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要修改属性的特性，需要调用<code>ECMAScript5</code>中的 <span  class="math">\(Object.defineProperty(\ )\)</span> 方法。该方法接收三个参数——属性所在对象、属性名和一个描述符对象( <span  class="math">\(configurable\)</span> ,  <span  class="math">\(enumerable\)</span> ,  <span  class="math">\(writable\)</span> 和 <span  class="math">\(value\)</span> )。在使用该方法时，如果未指定，则 <span  class="math">\(configurable\)</span> ,  <span  class="math">\(writable\)</span> 以及 <span  class="math">\(enumerable\)</span> 默认为 <span  class="math">\(false\)</span> ，除非是对已定义的属性特性的修改。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;XiaoMing&#34;</span>
<span class="p">});</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设置数据属性的值后，作出不允许行为时，非严格模式下会被忽略，严格模式下则会抛出错误。</p>

<h3 id="2访问器属性">(2)访问器属性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;访问器属性包含 <span  class="math">\(getter\)</span> 和 <span  class="math">\(setter\)</span> 函数，分别用于读取和写入。访问器属性包含如下  <span  class="math">\(4\)</span>  个特性：</p>

<ul>
<li><span  class="math">\([[Configurable]]\)</span> ：同数据属性。</li>
<li><span  class="math">\([[Enumerable]]\)</span> ：同数据属性。</li>
<li><span  class="math">\([[Get]]\)</span> ：读取属性时调用的函数，默认为 <span  class="math">\(undefined\)</span> 。</li>
<li><span  class="math">\([[Set]]\)</span> ：写入属性时调用的函数，默认为 <span  class="math">\(undefined\)</span> 。</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与数据属性相同，定义访问器属性时也要用到 <span  class="math">\(Object.defineProperty(\ )\)</span> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">_age</span><span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&#34;age&#34;</span><span class="err">，</span> <span class="p">{</span>
    <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_age</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newAge</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">newAge</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">_age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span> <span class="c1">//8
</span><span class="c1"></span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span> <span class="c1">//18
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在非严格模式下可以不同时指定 <span  class="math">\(getter\)</span> 与 <span  class="math">\(setter\)</span> ：只指定 <span  class="math">\(getter\)</span> 则属性只读，相反只指定 <span  class="math">\(setter\)</span> 则属性只写。严格模式下必须同时指定。对于不支持该方法的浏览器，要定义 <span  class="math">\(getter\)</span> 和 <span  class="math">\(setter\)</span> 一般使用 <span  class="math">\(\_\_defineGetter\_\_(\ )\)</span> 方法和 <span  class="math">\(\_\_defineSetter(\ )\_\_\)</span> 方法。需要注意的是，在不支持 <span  class="math">\(Object.defineProperty(\ )\)</span> 的浏览器中无法修改 <span  class="math">\(configurable\)</span> 和 <span  class="math">\(enumerable\)</span> 。</p>

<h3 id="3属性类型相关方法">(3)属性类型相关方法</h3>

<h4 id="多属性定义">多属性定义</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>ECMAScript5</code>中定义了一个 <span  class="math">\(Object.defineProperties(\ )\)</span> 方法用于定义多个属性。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;XiaoMing&#34;</span>
    <span class="p">},</span>
    <span class="nx">_age</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">value</span><span class="o">:</span> <span class="mi">8</span>
    <span class="p">},</span>
    <span class="nx">age</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_age</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newAge</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">newAge</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<h4 id="读取属性特性">读取属性特性</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ECMAScript5</code>中定义的 <span  class="math">\(Object.getOwnPropertyDescriptor(\ )\)</span> 方法，接收两个参数——属性所在对象和要读取的属性名，返回一个记录属性特性值的对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">//接上段代码
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&#34;_age&#34;</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">//8
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">configurable</span><span class="p">);</span> <span class="c1">//false
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在大多数情况下可能没有必要使用 <span  class="math">\(Object.defineProperty(\ )\)</span> 等方法，但这对于理解<code>JavaScript</code>中的对象有所帮助。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Feb 28 12:48</span> <a href="/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/">JavaScript的对象继承</a></h1>
            </center>
            <div class="post-content">
                <p><strong>参考书籍：《JavaScript高级程序设计》（第3版）</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>继承</strong>是OO语言（面对对象语言）中的概念。许多OO语言都支持两种继承方式：接口继承（继承方法签名）和实现继承（继承实际方法）。但由于<code>JavaScript</code>中没有签名，因此在<code>ECMAScript</code>中只能实现方法继承。</p>

<ol>
<li><a href="#2019-12-06-1">原型链</a></li>
<li><a href="#2019-12-06-2">借用构造函数</a></li>
<li><a href="#2019-12-06-3">组合继承</a></li>
<li><a href="#2019-12-06-4">原型式继承</a></li>
<li><a href="#2019-12-06-5">寄生式继承</a></li>
<li><a href="#2019-12-06-6">寄生组合式继承</a></li>
</ol>

<hr>

<h2 id="span-id2019120611-原型链span"><span id="2019-12-06-1">1. 原型链</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>原型链</strong>（ <span  class="math">\(prototype\;chaining\)</span> ）是实现继承的主要方法。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">SuperType</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">property</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">SuperType</span><span class="p">.</span><span class="nx">property</span><span class="p">.</span><span class="nx">getSuperValue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">function</span> <span class="nx">SubType</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">subproperty</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//继承SuperType
</span><span class="c1"></span><span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuperType</span><span class="p">();</span>
<span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSubValue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">subproperty</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述代码中定义了两种类型—— <span  class="math">\(SuperType\)</span> 和 <span  class="math">\(SubType\)</span> ，其中 <span  class="math">\(SubType\)</span> 继承了 <span  class="math">\(SuperType\)</span> 。实现的本质是重写 <span  class="math">\(SubType\)</span> 的原型对象，即将一个 <span  class="math">\(SuperType\)</span> 对象赋给 <span  class="math">\(SubType.property\)</span> ，从而使得 <span  class="math">\(SuperType\)</span> 中所有的属性和方法均存在于 <span  class="math">\(SubType\)</span> 中。在实例中，我们也给 <span  class="math">\(SubType\)</span> 添加了一个新方法。此外，还要注意，以此种方式实现的继承中， <span  class="math">\(SubType.constructor\)</span> 指向的是 <span  class="math">\(SuperType\)</span> 。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型链能够实现继承，但也存在问题。由于是直接赋值给原型，因此其中的属性会被所有实例共享。如以下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">SuperType</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;red&#34;</span><span class="p">];</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">SubType</span><span class="p">()</span> <span class="p">{}</span>
<span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuperType</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">instance1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
<span class="nx">instance1</span><span class="p">.</span><span class="nx">colors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;blue&#34;</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">instance1</span><span class="p">.</span><span class="nx">colors</span><span class="p">);</span> <span class="c1">//&#34;red,blue&#34;
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">instance2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">instance2</span><span class="p">.</span><span class="nx">colors</span><span class="p">);</span> <span class="c1">//&#34;red,blue&#34;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有，不能通过子类调用超类的有参构造函数等。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于种种原因，实践中很少单独使用原型链。</p>

<hr>

<h2 id="span-id2019120622-借用构造函数span"><span id="2019-12-06-2">2. 借用构造函数</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>借用构造函数</strong>（ <span  class="math">\(constructor\;stealing\)</span> ）用于解决原型中包含引用类型值带来的问题。本质是在子类构造函数中调用超类构造函数。可以通过 <span  class="math">\(call(\ )\)</span> 或者 <span  class="math">\(apply(\ )\)</span> 方法实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="s2">&#34;Hello World!&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">SubType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">SuperType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，通过“借调”超类构造函数，子类的每个实例就都具有超类中属性和方法的副本了。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然该种方法避免了引用原型的问题，但对于超类中包含的方法（如上例中所示的 <span  class="math">\(sayHello(\ )\)</span> 方法）也被复制了一份，没有实现函数复用。因此，借用构造函数的方法也很少单独使用。</p>

<hr>

<h2 id="span-id2019120633-组合继承span"><span id="2019-12-06-3">3. 组合继承</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>组合继承</strong>（ <span  class="math">\(combination\;inheritance\)</span> ），也叫伪经典继承。顾名思义，即组合原型链和借用构造函数的技术。本质是利用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">SuperType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>
<span class="kd">function</span> <span class="nx">SubType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//继承属性
</span><span class="c1"></span>    <span class="nx">SuperType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//继承方法
</span><span class="c1"></span><span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuperType</span><span class="p">();</span>
<span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">SubType</span><span class="p">;</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，组合继承不仅让子类中的每个实例都拥有自己的属性，还能调用相同的方法。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;组合继承避免了原型链和借用构造函数的缺点，融合了他们的优点，因此成为了<code>JavaScript</code>中最常用的继承方式。而且，通过组合继承， <span  class="math">\(instanceof\)</span> 和 <span  class="math">\(isPrototypeOf(\ )\)</span> 也能用于识别其创建的对象。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="2019-12-06-3-1">组合继承也有其不足，即在任何时候都会调用两次超类构造函数。</span></p>

<hr>

<h2 id="span-id2019120644-原型式继承span"><span id="2019-12-06-4">4. 原型式继承</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>原型式继承</strong>（ <span  class="math">\(prototypal\;inheritance\)</span> ）是一种特殊的继承方式，该方法并没有严格意义上的构造函数，本质是借助原型可以基于已有对象创建新对象，还不必创建自定义类型的特性。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">object</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{}</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">friends</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;Tom&#34;</span><span class="p">];</span>
 <span class="p">};</span>
<span class="kd">var</span> <span class="nx">anotherPerson</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>
<span class="nx">anotherPerson</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;Rob&#34;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">yetAnotherPerson</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>
<span class="nx">yetAnotherPerson</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;Van&#34;</span><span class="p">);</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">friends</span><span class="p">);</span> <span class="c1">//&#34;Tom,Rob,Van&#34;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <span  class="math">\(object(\ )\)</span> 函数中，创建了函数 <span  class="math">\(F(\ )\)</span> 作为一个临时构造函数，将传入的对象作为其原型并返回一个新实例。在<code>ECMAScript5</code>中新增了 <span  class="math">\(Object.create(\ )\)</span> 方法规范化了原型式继承。该方法接收两个参数——一个用作新对象的原型，另一个为新对象定义额外属性（可选）。在传入一个参数时，行为与 <span  class="math">\(object(\ )\)</span> 方法相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">friends</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;Tom&#34;</span><span class="p">];</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">anotherPerson</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>
<span class="nx">anotherPerson</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;Rob&#34;</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">friends</span><span class="p">);</span> <span class="c1">//&#34;Tom,Rob&#34;
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">yetAnotherPerson</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;Van&#34;</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">yetAnotherPerson</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//&#34;Van&#34;
</span></code></pre></div>
<hr>

<h2 id="span-id2019120655-寄生式继承span"><span id="2019-12-06-5">5. 寄生式继承</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>寄生式继承</strong>（ <span  class="math">\(parasitic\;inheritance\)</span> ）与原型式继承紧密相关。其思路与寄生构造函数和工厂模式类似，创建一个用于封装继承过程的函数，在函数内部以某种方式增强对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">createAnother</span><span class="p">(</span><span class="nx">original</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">original</span><span class="p">);</span>
    <span class="nx">clone</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">()</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="s2">&#34;Hello World!&#34;</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">clone</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span  class="math">\(createAnother(\ )\)</span> 方法接受一个对象作为新对象的基础对象，再将其赋给 <span  class="math">\(clone\)</span> ，通过 <span  class="math">\(clone\)</span> 对象添加 <span  class="math">\(sayHello(\ )\)</span> 方法，最后返回 <span  class="math">\(clone\)</span> 对象。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与构造函数模式类似，寄生式继承会由于无法做到函数复用而降低效率。</p>

<hr>

<h2 id="span-id2019120666-寄生组合式继承span"><span id="2019-12-06-6">6. 寄生组合式继承</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>寄生组合式继承</strong>（ <span  class="math">\(parasitic\;combination\;inheritance\)</span> ）即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。在之前我们谈到了<a href="#2019-12-06-3-1">组合继承的不足</a>,而解决办法就是寄生组合式继承。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">object</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{}</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">inheritPrototype</span><span class="p">(</span><span class="nx">subType</span><span class="p">,</span> <span class="nx">superType</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">prototype</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">superType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
    <span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">subType</span><span class="p">;</span>
    <span class="nx">subType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">prototype</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span  class="math">\(inheritPrototype(\ )\)</span> 方法接收两个参数：子类构造函数和超类构造函数。其高效性在于只调用了一次 <span  class="math">\(SuperType\)</span> 构造函数，且避免了在 <span  class="math">\(SubType.prototype\)</span> 上创建不必要的属性，保持原型链不变，还能使用 <span  class="math">\(instanceof\)</span> 和 <span  class="math">\(isPrototypeOf(\ )\)</span> ，开发人员普遍认为寄生组合式继承是引用类型的最理想的继承方式。</p>

<hr>

<h2 id="7-小结">7. 小结</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JavaScript</code>主要通过原型链实现继承。但原型链不适宜单独使用，解决其问题的技术是借用构造函数。使用最多的继承模式是组合继承。此外还可以选择原型式继承、寄生式继承和寄生组合式继承。</p>

            </div>
            <div class="meta post-footer"> <span>2019 Dec 6 22:58</span> <a href="/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


            </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script></main>
    </body>
    <script src=https://z217blog.cn/js/navbutton.js></script>
</html>
