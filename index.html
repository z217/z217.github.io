<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.74.3" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="http://123.57.12.189"  target="_blank" >
            <i class="fas fa-link fa-sm"></i>
            <span>二站</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/java%E6%B3%9B%E5%9E%8B/">Java泛型</a>
        
        
        <p>Java泛型简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Sep 02 21:23
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/">Java类型信息</a>
        
        
        <p>Java类型信息简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 30 16:50
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/">JVM（3）：性能监控和故障处理</a>
        
        
        <p>深入理解Java虚拟机（3）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 25 20:11
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">JVM（2）：垃圾收集器</a>
        
        
        <p>深入理解Java虚拟机（2）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 23 16:33
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/">JVM（1）：技术体系与内存区域</a>
        
        
        <p>深入理解Java虚拟机（1）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 19 19:42
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/java%E6%B3%9B%E5%9E%8B/">Java泛型</a></h1>
            </center>
            <div class="post-content">
                <p>        泛型允许一个类应用于多种类型，实现了参数化类型的概念。促使泛型产生的原因之一就是容器类，泛型可以用于指定一个容器具体要持有怎样的类型。当然，也可以通过泛型实现持有多个类型的类，如元组类：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TwoTuple</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">A</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">B</span> <span class="n">second</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">TwoTuple</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">,</span> <span class="n">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">second</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        如果需要长度更长的元组如三元组，我们可以在二元组的基础上声明三元组类，并令其继承二元组类。<br>
        除了具体类外，泛型还可以应用于抽象类和接口当中。<br>
        <code>Java</code>泛型存在着很多局限性，第一个就是不能以基本类型作为其类型参数。当然，通过<code>Java</code>自动包装和自动拆包的功能，基本类型和其包装类型可以很方便地进行转换。<br>
        之前提到的泛型都是应用于一个类上的，但是泛型同样可以应用于方法上，而且不仅可以应用于泛型类的方法上，也可以应用于普通类的方法上。如果通过使用泛型方法就可以避免使用泛型类，那么推荐使用泛型方法。此外，由于 $static$ 方法无法获取类型参数，因此如果要让 $static$ 方法使用泛型，那么就必须让其成为泛型方法。与使用泛型类不同，使用泛型方法时可以不用指定具体类型，通过类型参数推断，编译器可以为我们找出具体类型。</p>
<h2 id="1-擦除">1. 擦除</h2>
<p>        通过泛型，我们可以声明一个 $ArrayList&lt;Integer&gt;$ 对象，然后我们可以获取 $ArraysList.class$ ，但是却不能获取 $ArrayList&lt;Integer&gt;.class$ 对象。这个行为说明了在编译器的眼中，$ArrayList&lt;Integer&gt;$ 和 $ArrayList&lt;String&gt;$ 是同一类型。更加夸张的是，不同于<code>C++</code>，在<code>Java</code>的泛型内，你无法获取任何有关于泛型参数类型的信息。这些行为的原因都是因为<code>Java</code>的泛型是使用擦除实现的。在基于擦除的实现中，泛型被认为是第二类类型，既不能在某些重要的上下文环境中使用的类型。泛型类型只有在静态类型检查期间才会出现，之后泛型类型将被擦除，并替换为非泛型边界如 $List$ , $Object$ 等。<br>
        在<code>C++</code>中，我们可以实现以下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Test</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">obj</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Test</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">obj</span><span class="p">.</span><span class="n">f</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        但是在<code>Java</code>中，这种行为就无法实现了。因为擦除的存在，<code>Java</code>编译器无法认为 $obj$ 含有 $f(\ )$ 方法。而为了调用 $f(\ )$ ，在<code>Java</code>中需要这样实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">HasF</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">HasF</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">obj</span><span class="o">;</span>
    <span class="n">Test</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">obj</span><span class="o">.</span><span class="na">f</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        通过给定泛型类的边界，泛型类只能接受符合这个边界的类型参数，从而就能确保含有 $f(\ )$ 方法了。<br>
        虽然通过擦除，<code>Java</code>保证了向后兼容。但是带来的代价也是显著的，所有关于类型参数的信息都丢失了。也因为这个原因，泛型并不是强制使用的：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Derived1</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Derived2</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">{}</span>
</code></pre></div><p>        但是擦除机制带来的最令人困惑的并不是这个，而是“看起来好像持有”：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayMaker</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">kind</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ArrayMaker</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">kind</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">kind</span> <span class="o">=</span> <span class="n">kind</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="n">T</span><span class="o">[]</span> <span class="nf">create</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">T</span><span class="o">[])</span> <span class="n">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">kind</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        即使使用了 $Class&lt;T&gt;$ 储存 $kind$ ，因为擦除的存在，它会被存储为 $Class$ 对象，从而使得创建数组时不会产生具体结果，只能配合转型使用。</p>
<h2 id="2-擦除的补偿">2. 擦除的补偿</h2>
<p>        因为擦除的原因，类内部无法得到类型参数信息，因此 $instanceof$ 不能使用。但是可以使用动态 $isInstance(\ )$ ：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Building</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">House</span> <span class="kd">extends</span> <span class="n">Building</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">ClassType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">kind</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ClassType</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">kind</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">kind</span> <span class="o">=</span> <span class="n">kind</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">f</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">kind</span><span class="o">.</span><span class="na">isInstance</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ClassType</span><span class="o">&lt;</span><span class="n">Building</span><span class="o">&gt;</span> <span class="n">classType</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassType</span><span class="o">&lt;&gt;(</span><span class="n">Building</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">classType</span><span class="o">.</span><span class="na">f</span><span class="o">(</span><span class="k">new</span> <span class="n">Building</span><span class="o">()));</span> <span class="c1">// true
</span><span class="c1"></span>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">classType</span><span class="o">.</span><span class="na">f</span><span class="o">(</span><span class="k">new</span> <span class="n">House</span><span class="o">()));</span> <span class="c1">// true
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        在泛型类中，通过类似 $new\ \ T(\ )$ 的方式创建类是不行的，因为<code>Java</code>编译器无法确认类型拥有默认构造器。而在<code>C++</code>中由于编译器的定期检查，这种行为的安全性得以确保。如果想要在<code>Java</code>中以类似方式创建对象，可以通过工厂模式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">ClassAsFactory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">T</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">ClassAsFactory</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">kind</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">NoSuchMethodException</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">kind</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">().</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalAccessException</span> <span class="o">|</span> <span class="n">InstantiationException</span> <span class="o">|</span> <span class="n">InvocationTargetException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        虽然编译可以通过，但是不一定每次都能成功创建，比如 $ClassAsFactory&lt;Integer&gt;$ 就会失败，因为 $Integer$ 类没有默认构造器。为了避免这个问题，可以使用显示工厂：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">Factory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">T</span> <span class="nf">create</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">IntegerFactory</span> <span class="kd">implements</span> <span class="n">Factory</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">F</span> <span class="kd">extends</span> <span class="n">Factory</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">Foo</span><span class="o">(</span><span class="n">F</span> <span class="n">factory</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        除了工厂方法之外，还可以使用模板方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">GenericWithCreate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">T</span> <span class="n">element</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">GenericWithCreate</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">create</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">T</span> <span class="nf">create</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">X</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Creator</span> <span class="kd">extends</span> <span class="n">GenericWithCreate</span><span class="o">&lt;</span><span class="n">x</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">X</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">X</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        在泛型类内，你无法直接通过 $new$ 创建泛型数组，一般情况下都是使用 $ArrayList$ 进行替代。但是在一些需要建立泛型数组的情况下，通过 $new$ 建立之后再进行转型这种方式是无效的。因为<code>Java</code>数组将跟踪它们被创建时的实际类型，信息在编译期存储，因此无论怎么转型，它都是 $Object$ 数组。因此最好是在集合内部使用 $Object[\ ]$ ，然后在取出元素时再将其转型为 $T$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">GenericArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">T</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">T</span><span class="o">)</span> <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        如果要获得整个数组对象，那么就不能使用 $new$ ，而要改为使用 $Class$ 对象：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericArrayWithTypeToken</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>

    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nf">GenericArrayWithTypeToken</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">array</span> <span class="o">=</span> <span class="o">(</span><span class="n">T</span><span class="o">[])</span> <span class="n">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">T</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span><span class="o">[]</span> <span class="nf">rep</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        可以发现，这两种情况都会产生大量警告。当然，警告是可以忽略的。</p>
<h2 id="3-边界">3. 边界</h2>
<p>        边界提供了一种限制泛型参数类型的机制，潜在的效果是允许泛型调用一些方法。如果能够将参数限制为某个类型的子集，那么就可以运用子集来调用方法。同时，如果你需要的话，还可以在继承的每个层次上添加不同的限制：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">B</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">C</span><span class="o">&lt;&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">B</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">D</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div><p>        再考虑一种情况，假设 $Apple$ 是 $Fruit$ 的子类，那么：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;();</span>
</code></pre></div><p>        虽然看起来好像是正确的，但却是错误的，因为 $Apple$ 的 $List$ 在类型上并不等价于 $Fruit$ 的 $List$ 。如果你想要让其正确地向上转型，就需要使用通配符：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Apple</span><span class="o">&gt;();</span>
</code></pre></div><p>        这种方式给定了一个“任何扩展了 $Fruit$ 对象”的边界，$List$ 就可以接受任何可以向上转型为 $Fruit$ 的类型了。除了这种方式外，还可以使用超类通配符，即声明某个特定类的基类：$&lt;?\ \ super\ \ MyClass&gt;$ ，甚至使用类型参数 $&lt;?\ \ super\ \ T&gt;$ 。<br>
        在上面的例子中使用了无界通配符 $?$ 。如果单独使用无界通配符，看起来好像就等价于原生类型。事实也确实是这样，编译器很少关心原生类型和仅使用无界通配符之间的区别。但这也并不意味着仅使用无界通配符没有意义，它可以标识你想在这里使用泛型。此外，无界通配符表示可以接受任何类型的特性还使得它成为存储泛型类的场所，可以将此特性应用于传参中。当然，编译器也会有关注它们间差异的时候：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Holder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">obj</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setObj</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">getObj</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">obj</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wildcards</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">rawArgs</span><span class="o">(</span><span class="n">Holder</span> <span class="n">holder</span><span class="o">,</span> <span class="n">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">holder</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">object</span><span class="o">);</span> <span class="c1">// warning
</span><span class="c1"></span>    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">unboundedArg</span><span class="o">(</span><span class="n">Holder</span><span class="o">&lt;?&gt;</span> <span class="n">holder</span><span class="o">,</span> <span class="n">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">holder</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">object</span><span class="o">);</span> <span class="c1">// error
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        当 $holder$ 是一个 $Holder&lt;?&gt;$ 时，调用 $rawArgs(\ )$ 后，因为编译器仍然知道它是个泛型类型，因此认为传递一个 $Object$ 类型对象是不安全的，所以会产生警告。同样的，在调用 $unboundedArg(\ )$ 时，因为 $Holder&lt;?&gt;$ 要持有一个具体类型的，因此不能只是向其传递 $Object$ 。<br>
        上面演示了需要使用原生类型的情况，也有情况需要使用 $&lt;?&gt;$ ：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CaptureConversion</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">f1</span><span class="o">(</span><span class="n">Holder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">holder</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">holder</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">f2</span><span class="o">(</span><span class="n">Holder</span> <span class="n">holder</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">f1</span><span class="o">(</span><span class="n">holder</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        在上面的例子中将原生类型传入 $f1(\ )$ 会产生异常，而传入 $f2(\ )$ 不会。因为 $f2(\ )$ 使用 $&lt;?&gt;$ 作为参数，编译器可能会推断出实际类型，这种行为称为捕获转换。</p>
<h2 id="4-自限定类型">4. 自限定类型</h2>
<p>        先看下面这个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">GenericType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CuriouslyRecurringGeneric</span> <span class="kd">extends</span> <span class="n">GenericType</span><span class="o">&lt;</span><span class="n">CuriouslyRecurringGeneric</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div><p>        这种泛型称为<em><strong>古怪的循环泛型</strong></em> ( $CRG$ ) ，本质是将基类的类型参数使用导出类来代替。类似的我们还可以进行下面的声明：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">SelfBounded</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">SelfBounded</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{}</span>
</code></pre></div><p>        这样 $T$ 的类型就被限定为类似于：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">A</span> <span class="kd">extends</span> <span class="n">SelfBounded</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div><p>        通过使用自限定类型，可以保证类型参数与当前正在被定义的类相同。当然，这个规则也可以通过下面方式避免：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">SelfBounded</span> <span class="o">{}</span>
</code></pre></div><p>        上面的代码可以编译，而且不会产生警告。因此自限定并非强制保证类型相同，如果你确实需要强制保证的话，就需要外部工具的辅助。<br>
        自限定类型的价值在于它们可以产生协变参数类型：方法参数类型随子类变化。可以对比下下面的两个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Base</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Derived</span> <span class="kd">extends</span> <span class="n">Base</span> <span class="o">{}</span>

<span class="kd">interface</span> <span class="nc">OrdinaryGetter</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Base</span> <span class="n">base</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">DerivedGetter</span> <span class="kd">extends</span> <span class="n">OrdinaryGetter</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Derived</span> <span class="n">derived</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>        在这个例子中，$DerivedGetter$ 重写了 $set(\ )$ 方法，这是合理的，但是会存在两个 $set(\ )$ 方法。有时候我们想要让方法接受子类作为参数，又不想因为重写而同时存在两个同名方法，那么可以通过自限定实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">SelfBounded</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">SelfBounded</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">T</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Setter</span> <span class="kd">extends</span> <span class="n">SelfBounded</span><span class="o">&lt;</span><span class="n">Setter</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div><h2 id="5-混型">5. 混型</h2>
<p>        混型可以混合多个类，产生一个表示混型中所有类型的类，使得组装多个类变得简单。在<code>C++</code>中可以这样使用混型：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="o">&lt;</span><span class="k">template</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">public</span> <span class="n">T</span> <span class="p">{}</span>
</code></pre></div><p>        但是在<code>Java</code>中因为擦除的原因，并不能使用这种方式。一种常见的解决方案是通过接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">A</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">AImpl</span> <span class="kd">implements</span> <span class="n">A</span> <span class="o">{}</span>
</code></pre></div><p>        第二种方案是通过装饰器模式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Basic</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Decorator</span> <span class="kd">extends</span> <span class="n">Base</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Basic</span> <span class="n">basic</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Decorator</span><span class="o">(</span><span class="n">Basic</span> <span class="n">basic</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">basic</span> <span class="o">=</span> <span class="n">basic</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A</span> <span class="kd">extends</span> <span class="n">Decorator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="n">Basic</span> <span class="n">basic</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">basic</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="n">Decorator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">B</span><span class="o">(</span><span class="n">Basic</span> <span class="n">basic</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">basic</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="6-潜在类型机制">6. 潜在类型机制</h2>
<p>        潜在类型机制或结构化类型机制，允许我们横跨类继承结构，可以调用不属于公共接口的方法。当然，因为<code>Java</code>擦除机制的存在，类内部无法保证传入的类型包含特定方法，因此无法像<code>C++</code>那样直接使用潜在类型机制。一个简单的模仿方法是通过接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">I</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">f1</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">I</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="nf">f2</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">t</span><span class="o">.</span><span class="na">f1</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        但是通过接口方式显然存在着局限性，为了消除这个局限性，我们需要付出更多工作，使用反射机制来实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">f3</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">CommunicateReflectively</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">f4</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Method</span> <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">&#34;f3&#34;</span><span class="o">);</span>
            <span class="n">f</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">NoSuchMethodException</span> <span class="o">|</span> <span class="n">IllegalAccessException</span> <span class="o">|</span> <span class="n">InvocationTargetException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        反射会在运行时进行动态检查。通过反射可以在运行时动态地确定所需要的方法是否需要并且调用，而且通过 $try-catch$ ，可以在缺少必须方法时部分实现目标。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Sep 2 21:23</span> <a href="/post/java%E6%B3%9B%E5%9E%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/">Java类型信息</a></h1>
            </center>
            <div class="post-content">
                <p>        <strong>运行时类型信息</strong> ( $RTTI$ ) 可以让我们在程序运行时发现和使用类型信息，主要有两种方式：传统<code>RTTI</code>，假定在编译时就已经知道了所有类型；以及反射，允许在运行时发现和使用类型信息。</p>
<h2 id="1-rtti">1. <code>RTTI</code></h2>
<p>        传统的<code>RTTI</code>在<code>Java</code>语句执行过程中也发挥着作用。</p>
<p><img src="/image/2020-08-30-01.png" alt="Shape基类和Circle子类"></p>
<p>        我们定义了一个 $Circle$ 对象，将其存储在一 $List&lt;Shape&gt;$ 容器之中。那么当对象被放入容器时，会向上转型为 $Shape$ ；而在取出时，由于 $List$ 容器会将所有对象当作 $Object$ 类型持有，因此会再次转换为 $Shape$ 对象。</p>
<h3 id="11-class对象">1.1 <code>Class</code>对象</h3>
<p>        $Class$ 对象负责表示运行时的类型信息，<code>Java</code>通过 $Class$ 对象执行<code>RTTI</code>。每个类都拥有一个 $Class$ 对象，当它被编译时，就会通过类加载器产生一个 $.class$ 文件，存储其 $Class$ 对象。<br>
        所有的类都是在被第一次使用时动态地被加载到<code>JVM</code>当中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。也就是说构造器也是静态的，因此使用 $new$ 创建对象就会创建一个对静态构造器的引用，从而使得这个类被加载。当类的 $Class$ 对象被载入后，这个类的所有对象都会使用 $Class$ 对象创建。$Class$ 对象还有一些常用方法：</p>
<ul>
<li>$forName(\ )$ ：通过全类名获取对应类的 $Class$ 对象；</li>
<li>$getName(\ )$ ：获取全限定的类名；</li>
<li>$getSimpleName(\ )$ ：获取不含包名的类名；</li>
<li>$getInterfaces(\ )$ ：$Class$ 对象中实现的接口；</li>
<li>$getSuperclass(\ )$ ：获取基类的 $Class$ 对象。</li>
</ul>
<p>        $Class.newInstance(\ )$ 方法允许你在不知道确切类型的情况下创建对象。通过该方法你可以得到一个 $Object$ 对象，要想正确地使用该对象，你需要对其进行转型。使用 $newInstance$ 创建对象的要求是该对象拥有一个默认构造器。<br>
        除了通过 $forName$ 获取 $Class$ 对象之外，还可以直接通过类字面常量获取，即访问一个类型的 $class$ 字段。而且因为这种方式在编译阶段就会受到检查，因此不需要对异常进行处理，所以也更高效。对于基本数据类型的包装类如 $Integer$ 这种，还拥有一个标准字段 $TYPE$ 。访问 $TYPE$ 就相当于访问对应基本类型的 $class$ 字段，即 $Integer.TYPE$ 相当于 $int.class$ 。<br>
        普通的 $Class$ 对象可以被重新赋值为任何其他的类型的 $Class$ 对象。而要想避免这种再次赋值，可以通过泛型进行限定。<br>
        在类型转换的过程中，<code>Java</code>要执行类型检查。如果执行了一个错误的类型转换，就会抛出一个 $ClassCastException$ 异常。<code>RTTI</code>还可以通过 $instanceof$ 进行检查，它用于判断某个对象是否是某个类型的实例，返回一个布尔值。</p>
<h2 id="2-反射">2. 反射</h2>
<p>        通过<code>RTTI</code>，我们可以知道某个对象的确切类型，但这是建立在编译时已知类型的前提下。如果获取了一个不在你的程序空间的对象引用，那么就无法使用<code>RTTI</code>获取其类型了。反射提供了一种获取对象可用方法以及方法名的机制。<br>
        $Class$ 对象与 $java.lang.reflect$ 类库一起对反射概念进行了支持，类库包含 $Field$ , $Method$ 以及 $Constructor$ 类（均实现了 $Member$ 接口），分别用于表示类里面不同类型的成员。这样我们就可以通过 $Constructor$ 创建对象，$Field$ 的 $get(\ )$ 和 $set(\ )$ 方法读取和修改字段，通过 $invoke(\ )$ 方法调用 $Method$ 对象关联的方法。这三种类型的对象分别通过 $Class$ 对象的 $getFields(\ )$ , $getMethods(\ )$ 和 $getConstructors(\ )$ 方法获取。<br>
        要获取类信息，就需要通过类的 $Class$ 对象，也即获取其 $.class$ 文件。反射与<code>RTTI</code>的不同之处在于，<code>RTTI</code>是在编译时检查 $.class$ 文件；而反射无法在编译时获取 $.class$ 文件，是在运行时检查。<br>
        虽然反射可以让我们获取类中字段、方法和构造器的信息，但它也带来了隐患：通过反射可以访问所有方法，甚至是 $private$ 方法。只需要取得方法关联的 $Method$ 对象，然后设置 $setAccessible(true)$ ，即可调用。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Aug 30 16:50</span> <a href="/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/">JVM（3）：性能监控和故障处理</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-基础故障处理工具">1. 基础故障处理工具</h2>
<p>        基础故障处理工具是<code>JDK</code>自带的一些位于 $/bin$ 目录下的小工具。这些工具主要用于监视虚拟机运行状态和进行故障处理，根据软件可用性和授权的不同，可以分为三类：</p>
<ul>
<li><strong>商业授权工具</strong>：主要是<code>JMC</code> ( $Java\ \ Mission\ \ Control$ ) 及其使用的<code>JFR</code> ( $Java\ \ Flight\ \ Recorder$ )。自<code>JDK 7</code>开始集成，在<code>JDK 11</code>前都无需独立下载，但是商业使用需要收费。</li>
<li><strong>正式支持工具</strong>：长期支持的工具，可能在不同平台和版本之间存在差异。</li>
<li><strong>实验性工具</strong>：没有技术支持，具有实验性质的工具，但通常很稳定且具有强大功能。</li>
</ul>
<h3 id="11-jps虚拟机进程状况工具">1.1 <code>jps</code>：虚拟机进程状况工具</h3>
<p>        <code>jps</code> ( $JVM\ \ Process\ \ Status\ \ Tool$ ) 的名字类似于<code>UNIX</code>系统中的 $ps$ 命令，功能也和其类似：列出正在运行的虚拟机进程，并显示主类名称和<em><strong>本地虚拟机唯一</strong></em><code>ID</code> ( $Local\ \ Virtual\ \ Machine\ \ Identifier$, $LVMID$ )。作为使用频率最高的<code>JDK</code>命令行工具，是其他工具查询进程的方法。对于本地虚拟机进程来说，<code>LVMID</code>与操作系统进程<code>ID</code> ( $Process\ \ Identifier$, $PID$ ) 是一致的，使用<code>Windows</code>任务管理器也可以查询到。但是如果存在多个虚拟机进程，使得无法通过进程定位时，<code>jps</code>命令显示的主类信息就可以帮助我们定位。</p>
<pre><code>jps [options] [hostid]
</code></pre><table>
<thead>
<tr>
<th align="center">$options$</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$-q$</td>
<td align="center">输出<code>LVMID</code>，省略主类信息</td>
</tr>
<tr>
<td align="center">$-m$</td>
<td align="center">输出主类 $main$ 函数参数</td>
</tr>
<tr>
<td align="center">$-l$</td>
<td align="center">输出主类全名，如果为<code>JAR</code>包则输出路径</td>
</tr>
<tr>
<td align="center">$-v$</td>
<td align="center">输出<code>JVM</code>参数</td>
</tr>
</tbody>
</table>
<p>        $hostid$ 为<code>RMI</code>注册表中注册的主机名，<code>jps</code>可以通过<code>RMI</code>协议查询开启<code>RMI</code>服务的远程虚拟机进程状态。</p>
<h3 id="12-jstat虚拟机统计信息监视工具">1.2 <code>jstat</code>：虚拟机统计信息监视工具</h3>
<p>        <code>jstat</code> ( $JVM\ \ Statistics\ \ Monitoring\ \ Tool$ ) 用于监视本地或者远程虚拟机的各种运行状态信息，包括类加载、内存、垃圾收集、即时编译等。</p>
<pre><code>jstat [option vmid [interval [s|ms] [count]]]
</code></pre><p>        如果为本地虚拟机进程，那么 $vmid$ 就是<code>LVMID</code>。如果是远程，那么格式应为：</p>
<pre><code>[protocol:][//]lvmid[@hostname[:port]/servername]
</code></pre><p>        $interval$ 和 $count$ 标识查询间隔和次数，默认为一次。在不加单位时，$interval$ 默认以 $ms$ 为单位。<br>
        通过 $jstat\ \ options$ 命令可以查询选项，选项对应的作用如下：</p>
<table>
<thead>
<tr>
<th align="center">$options$</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$-class$</td>
<td align="center">监视类加载、卸载数量，类的总空间，以及类装载时间</td>
</tr>
<tr>
<td align="center">$-compiler$</td>
<td align="center">输出即时编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td align="center">$-gc$</td>
<td align="center">监视<code>Java</code>堆中各个区域的容量、使用情况和垃圾收集时间等</td>
</tr>
<tr>
<td align="center">$-gccapacity$</td>
<td align="center">与 $-gc$ 基本相同，但是输出更关注各个区域使用的最大和最小空间</td>
</tr>
<tr>
<td align="center">$-gccause$</td>
<td align="center">与 $-gcutil$ 基本相同，但是会输出上次垃圾收集的原因</td>
</tr>
<tr>
<td align="center">$-gcmetacapacity$</td>
<td align="center">输出元数据空间信息</td>
</tr>
<tr>
<td align="center">$-gcnew$</td>
<td align="center">监视新生代垃圾收集状况</td>
</tr>
<tr>
<td align="center">$-gcnewcapacity$</td>
<td align="center">与 $-gcnew$ 基本相同，但是输出更关注使用的最大和最小空间</td>
</tr>
<tr>
<td align="center">$-gcold$</td>
<td align="center">监视老年代垃圾收集状况</td>
</tr>
<tr>
<td align="center">$-gcoldcapacity$</td>
<td align="center">与 $-gcold$ 基本相同，但是输出更关注使用的最大和最小空间</td>
</tr>
<tr>
<td align="center">$-gcutil$</td>
<td align="center">与 $-gc$ 基本相同，但是输出更关注已使用的空间占比</td>
</tr>
<tr>
<td align="center">$-printcompilation$</td>
<td align="center">输出已被即时编译的方法</td>
</tr>
</tbody>
</table>
<p>        使用 $jcstat\ \ -gcutil\ \ [vmid]$ 获得了一次结果如下：</p>
<table>
<thead>
<tr>
<th align="center">$S0$</th>
<th align="center">$S1$</th>
<th align="center">$E$</th>
<th align="center">$O$</th>
<th align="center">$M$</th>
<th align="center">$CCS$</th>
<th align="center">$YGC$</th>
<th align="center">$YGCT$</th>
<th align="center">$FGC$</th>
<th align="center">$FGCT$</th>
<th align="center">$GCT$</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$100.00$</td>
<td align="center">$0.00$</td>
<td align="center">$63.72$</td>
<td align="center">$72.36$</td>
<td align="center">$95.44$</td>
<td align="center">$93.29$</td>
<td align="center">$190$</td>
<td align="center">$0.966$</td>
<td align="center">$10$</td>
<td align="center">$1.028$</td>
<td align="center">$1.994$</td>
</tr>
</tbody>
</table>
<p>        $E$ 表示<code>Eden</code>区，使用了 $63.72$% 的空间；$S0$ 和 $S1$ 表示两个<code>Survivor</code>区，分别使用了 $100.00$% 和 $0.00$% ；$O$ 表示老年代，使用了 $72.36$% ；$M$ 表示方法区，使用了 $95.44$% ；$YGC$ 是程序运行以来进行<code>Minor GC</code>的次数，为 $190$ 次；$YGCT$ 是<code>Minor GC</code>的总耗时，为 $0.966$ 秒；$FGC$ 是程序运行以来的<code>Full GC</code>次数，为 $10$ 次；$FGCT$ 是<code>Full GC</code>总耗时，为 $1.028$ 秒；$GCT$ 是所有<code>GC</code>的总耗时，为 $1.994$ 秒。</p>
<h3 id="13-jinfojava配置信息工具">1.3 <code>jinfo</code>：<code>Java</code>配置信息工具</h3>
<p>        <code>jinfo</code> ( $Configuration\ \ Info\ \ for\ \ Java$ ) 用于实时查看和调整虚拟机的各项参数。虽然通过 $jps\ \ -v$ 就能看到<code>JVM</code>参数，但是如果想要查看没有显示指定的系统默认值，就只能使用 $jinfo -flag$ 了。</p>
<pre><code>jinfo [option] &lt;pid&gt;
</code></pre><table>
<thead>
<tr>
<th align="center">$options$</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$-flag\ \ &lt;name&gt;$</td>
<td align="center">查询指定参数</td>
</tr>
<tr>
<td align="center">$-flag\ \ [+/-]&lt;name&gt;$</td>
<td align="center">启用或禁用指定参数</td>
</tr>
<tr>
<td align="center">$-flag\ \ &lt;name&gt;=&lt;value&gt;$</td>
<td align="center">设置指定参数值</td>
</tr>
<tr>
<td align="center">$-flags$</td>
<td align="center">查询所有参数</td>
</tr>
<tr>
<td align="center">$-sysprops$</td>
<td align="center">查询<code>Java</code>系统属性，即 $System.getProperties(\ )$ 方法的值</td>
</tr>
</tbody>
</table>
<h3 id="14-jmapjava内存映像工具">1.4 <code>jmap</code>：<code>Java</code>内存映像工具</h3>
<p>        <code>jmap</code> ( $Memory\ \ Map\ \ for\ \ Java$ ) 用于生成<em><strong>堆转储快照</strong></em> ( $heapdump$ / $dump$ )，类似功能也可以通过设置 $-XX:+HeapDumpOnOutOfMemoryError$ 实现。此外，也可以通过 $-XX:+HeapDumpOnCtrlBreak$ 实现通过 $Ctrl+Break$ 键生成堆转储快照文件。在<code>Linux</code>系统下还可以通过 $kill\ \ -3$ 命令得到。除了获取堆转储快照外，<code>jmap</code>还可以查询 $finalize$ 执行队列、<code>Java</code>堆和方法区的详细信息。</p>
<pre><code>jmap [option] &lt;pid&gt;
</code></pre><table>
<thead>
<tr>
<th align="center">$options$</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$-heap$</td>
<td align="center">显示<code>Java</code>堆信息</td>
</tr>
<tr>
<td align="center">$-histo$</td>
<td align="center">显示堆中对象的统计信息，如类和实例数量、容量等</td>
</tr>
<tr>
<td align="center">$-clstats$</td>
<td align="center">显示类加载器信息</td>
</tr>
<tr>
<td align="center">$-finalizerinfo$</td>
<td align="center">在<code>F-Queue</code>中等待执行 $finalize$ 的对象</td>
</tr>
<tr>
<td align="center">$-dump$</td>
<td align="center">生成堆转储快照，格式为 $-dump:[live,]format=b,file=&lt;filename&gt;$ ，分别表示是否去除死亡对象，二进制格式和文件名</td>
</tr>
<tr>
<td align="center">$-F$</td>
<td align="center">强制生成堆转储快照</td>
</tr>
</tbody>
</table>
<p>        <code>jmap</code>有部分功能在<code>Windows</code>下受限，除了 $-dump$ 和 $-histo$ 外都不能使用。</p>
<h3 id="15-jhat虚拟机堆转储快照分析工具">1.5 <code>jhat</code>：虚拟机堆转储快照分析工具</h3>
<p>        <code>jhat</code> ( $JVM\ \ Heap\ \ Analysis\ \ Tool$ ) 与<code>jmap</code>搭配使用，用于分析堆转储快照。<code>jhat</code>内置了一个微型的<code>Web</code>服务器，分析完成后可以直接在浏览器中查看。但是一般情况下是不会在服务器上分析堆转储快照的，因为分析工作会占用大量资源，而且现在已经有了专门的图形化工具用于分析堆转储快照，并且功能也比<code>jhat</code>提供的要多。</p>
<h3 id="16-jstackjava堆栈跟踪工具">1.6 <code>jstack</code>：<code>Java</code>堆栈跟踪工具</h3>
<p>        <code>jstack</code> ( $Stack\ \ Trace\ \ for\ \ Java$ ) 用于生成虚拟机当前时刻的线程快照 ( $threaddump$ / $javacore$ )，即每一条线程正在执行的方法集合。线程快照可以用于定位线程问题，如死锁、死循环和请求外部资源导致的长时间挂起等。</p>
<pre><code>jstack [option] &lt;vmid&gt;
</code></pre><table>
<thead>
<tr>
<th align="center">$options$</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$-F$</td>
<td align="center">强制输出线程堆栈</td>
</tr>
<tr>
<td align="center">$-l$</td>
<td align="center">除堆栈外，显示锁信息</td>
</tr>
<tr>
<td align="center">$-m$</td>
<td align="center">如果有调用本地方法，可以用于显示<code>C/C++</code>堆栈</td>
</tr>
</tbody>
</table>
<p>        在<code>JDK 5</code>之后，通过 $java.lang.Thread.getAllStackTraces(\ )$ 方法可以获取所有线程的 $StackTraceElement$ 对象，从而实现<code>jstack</code>的大部分功能。</p>
<h2 id="2-可视化故障处理工具">2. 可视化故障处理工具</h2>
<h3 id="21-jhsdb基于服务性代理的调试工具">2.1 <code>JHSDB</code>：基于服务性代理的调试工具</h3>
<p>        <code>JDK</code>中提供了<code>JCMD</code>和<code>JHSDB</code>两个集成式的多功能工具箱，不仅整合了所有基础工具提供的而功能，而且还对他们进行了优化。</p>
<table>
<thead>
<tr>
<th align="center">基础工具</th>
<th align="center"><code>JCMD</code></th>
<th align="center"><code>JHSDB</code></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$jps\ \ -lm$</td>
<td align="center">$jcmd$</td>
<td align="center">$N/A$</td>
</tr>
<tr>
<td align="center">$jmap\ \ -dump\ \ &lt;pid&gt;$</td>
<td align="center">$jcmd\ \ &lt;pid&gt;\ \ GC.heap_-dump$</td>
<td align="center">$jhsdb\ \ jmap\ \ &ndash;binaryheap$</td>
</tr>
<tr>
<td align="center">$jmap\ \ -histo\ \ &lt;pid&gt;$</td>
<td align="center">$jcmd\ \ &lt;pid&gt;\ \ GC.class_-histogram$</td>
<td align="center">$jhsdb\ \ jmap\ \ &ndash;histo$</td>
</tr>
<tr>
<td align="center">$jstack\ \ &lt;pid&gt;$</td>
<td align="center">$jcmd\ \ &lt;pid&gt;\ \ Thread.print$</td>
<td align="center">$jhsdb\ \ jstack\ \ &ndash;locks$</td>
</tr>
<tr>
<td align="center">$jinfo\ \ -sysprops\ \ &lt;pid&gt;$</td>
<td align="center">$jcmd\ \ &lt;pid&gt;\ \ VM.system_-properties$</td>
<td align="center">$jhsdb\ \ info\ \ &ndash;sysprops$</td>
</tr>
<tr>
<td align="center">$jinfo\ \ -flags\ \ &lt;pid&gt;$</td>
<td align="center">$jcmd\ \ &lt;pid&gt;\ \ VM.flags$</td>
<td align="center">$jhsdb\ \ jinfo\ \ &ndash;flags$</td>
</tr>
</tbody>
</table>
<p>        <code>JHSDB</code>是一款基于<em><strong>服务性代理</strong></em> ( $Serviceability\ \ Agent$, $SA$ ) 实现的进程外调试工具。服务性代理是<code>HotSpot</code>虚拟机中一组用于映射<code>Java</code>虚拟机运行信息的<code>API</code>集合，将<code>C++</code>数据抽象出<code>Java</code>对象。通过服务性代理的<code>API</code>，可以在一个独立的<code>Java</code>虚拟机进程内分析其他<code>HotSpot</code>虚拟机的内部数据，或者从转出快照中还原其运行细节。<br>
        在使用 $jps$ 获取到进程<code>ID</code>后，可以通过</p>
<pre><code>jhsdb hsdb --pid &lt;pid&gt;;
</code></pre><p>        进入<code>JHSDB</code>的图形化模式。</p>
<h3 id="22-jconsolejava监视与管理控制台">2.2 <code>JConsole</code>：<code>Java</code>监视与管理控制台</h3>
<p>        <code>JConsole</code> ( $Java\ \ Monitoring\ \ and\ \ Management\ \ Console$ ) 是一款基于<code>JMX</code> ( $Java\ \ Management\ \ Extensions$ ) 的可视化监视、管理工具，主要通过<code>JMX</code>的<code>MBean</code> ( $Managed\ \ Bean$ ) 对系统进行信息收集和参数动态调整。<br>
        <code>JConsole</code>的启动很简单，通过 $/bin$ 目录下的 $jconsole.exe$ 即可启动，在启动后会自动扫描虚拟机进程，也可以通过远程连接对远程虚拟机进行监控。</p>
<h3 id="23-visualvm多合一故障处理工具">2.3 <code>VisualVM</code>：多合一故障处理工具</h3>
<p>        <code>VisualVM</code> ( $All-in-One\ \ Java\ \ Troubleshooting\ \ Tool$ ) 是功能最强大的运行监视和故障处理程序之一。除了常规的运行监视和故障处理之外，它还提供了<em><strong>性能分析</strong></em> ( $Profiling$ ) 等功能。<code>VisualVM</code>基于<code>NetBeans</code>平台开发工具，支持插件扩展。在<a href="https://visualvm.github.io/pluginscenters.html">官网</a>上下载包后，可以直接导入。当然，<code>VisualVM</code>也提供了自动安装功能，能够找到大部分插件。<br>
        <code>VisualVM</code>支持生成和浏览堆转储快照。虽然也支持性能分析功能，但是因为对运行有较大影响，因此一般不在生产环境使用，或者改用更强大、影响更小的<code>JMC</code>完成。通过插件，<code>VisualVM</code>中可以导入<code>BTrace</code>。<code>BTrace</code>可以在不中断程序的前提下加入调试代码。</p>
<h3 id="24-java-mission-control可持续在线的监控工具">2.4 <code>Java Mission Control</code>：可持续在线的监控工具</h3>
<p>        <code>JFR</code> ( $Java\ \ Flight\ \ Recorder$ ) 是一套内建在<code>HotSpot</code>虚拟机里面的监控和基于事件的信息搜集框架，具有<em><strong>可持续在线</strong></em> ( $Always-On$ ) 的特性。在监控过程中，它都是可动态的，不需要重启应用。<code>JMC</code> ( $Java\ \ Mission\ \ Control$ ) 使用<code>JMX</code>协议与虚拟机进行通信，显示<code>MBean</code>提供的数据，还可以作为<code>JFR</code>的分析工具，展示其数据。<code>JFR</code>的基本工作逻辑是开启一系列事件的录制，即使不考虑性能影响的优势，<code>JFR</code>的数据质量通常也比其他通过代理或者通过<code>MBean</code>获取的数据要高。</p>
<h2 id="3-hotspot虚拟机插件及工具">3. <code>HotSpot</code>虚拟机插件及工具</h2>
<p>        <code>HotSpot</code>虚拟机也含有很多插件和辅助工具：</p>
<ul>
<li><code>Ideal Graph Visualizer</code>：可视化展示<code>C2</code>即时编译器是如何将字节码转化为理想图，再转化为机器码的。</li>
<li><code>Client Compiler Visualizer</code>：查看<code>C1</code>即时编译器生成<strong>高级中间表示</strong> ( $HIR$ )，转换成<strong>低级中间表示</strong> ( $LIR$ ) 和做物理寄存器分配的过程。</li>
<li><code>MakeDeps</code>：处理<code>HotSpot</code>的编译依赖。</li>
<li><code>Project Creator</code>：生成<code>Visual Studio</code>的 $.project$ 文件。</li>
<li><code>LogCompilation</code>：将 $-XX:+LogCompilation$ 输出整理成更易阅读的形式。</li>
<li><code>HSDIS</code>：即时编译器的反汇编插件。</li>
</ul>
<h3 id="31-hsdisjit生成代码反汇编">3.1 <code>HSDIS</code>：<code>JIT</code>生成代码反汇编</h3>
<p>        <code>HSDIS</code>插件通过<code>HotSpot</code>的 $-XX:+PrintAssembly$ 指令调用，将即时编译器动态生成的本地代码还原为汇编代码输出，并产生注释。可以在<a href="http://lafo.ssw.uni-linz.ac.at/hsdis/att/">http://lafo.ssw.uni-linz.ac.at/hsdis/att/</a>上下载已编译好的<code>HSDIS</code>，如果为<code>Product</code>版虚拟机，还需要设置 $-XX:+UnlockDiagnosticVMOptions$ 。<br>
        在代码不多的时候，还可以直接查看输出，但是在大量代码中，显然无法直接查看。这时候就需要<code>JITWatch</code>的辅助。可以在<a href="https://github.com/AdoptOpenJDK/jitwatch">Github</a>上下载源码进行编译。<code>JITWatch</code>是用于分析日志的可视化工具，因此要将日志输出。输出日志可使用以下参数：</p>
<pre><code>-XX:+UnlockDiagnosticVMOptions
-XX:+TraceClassLoading
-XX:+LogCompilation
-XX:LogFile=/tmp/logfile.log
-XX:+PrintAssembly
-XX:+TraceClassLoading
</code></pre><p>        日志会输出到 $/tmp/logfile.log$ 文件中，在<code>JITWatch</code>上加载后，即可看到各种使用过的对象类型、方法，以及源代码、字节码和汇编代码了。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Aug 25 20:11</span> <a href="/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">JVM（2）：垃圾收集器</a></h1>
            </center>
            <div class="post-content">
                <p>        相比于程序计数器、虚拟机栈和本地方法栈这种应分配的内存大小在类确定时就已固定下来的内存区域，<code>Java</code>堆和方法区这两个区域有着不确定性：一个接口可能有多个实现类，一个方法可能有多个分支。垃圾收集器所关注的也就是这部分不确定的内存。</p>
<h2 id="1-对象状态">1. 对象状态</h2>
<p>        在进行垃圾收集之前，垃圾收集器需要对对象的状态进行判断，即判断其是否仍在被使用。</p>
<h3 id="11-引用计数算法">1.1 引用计数算法</h3>
<p>        <strong>引用计数</strong> ( $Reference\ \ Counting$ ) 算法，可以简单的解释为在对象中添加一个引用计数器，当对象被引用时计数器便加一，反之减一。如此往复，当对象的引用计数器为零时，可以认为其不再被使用。虽然这种算法简单而且效率很高，但是因为存在着很多例外情况，因此不被主流的<code>JVM</code>所采纳。比较简单的例子就比如存在对象 $A$ 和 $B$ ，它们都存在着一个字段互相引用对方，这样它们的引用计数器就都为 $1$ 。但实际上，除了互相引用之外，它们没有被其他对象引用，可以认为是无用的对象，应该被垃圾收集。另一方面，它们的引用计数又不为 $0$ ，无法触发垃圾收集。因此，引用计数算法需要配合大量额外处理才能保证正常工作。</p>
<h3 id="12-可达性分析算法">1.2 可达性分析算法</h3>
<p>        <strong>可达性分析</strong> ( $Reachability\ \ Analysis$ ) 算法，基本思路就是通过一系列的称为<code>GC Roots</code>的跟对象出发，不断搜索引用关系，搜索路径称为<em><strong>引用链</strong></em> ( $Reference\ \ Chain$ )。当一个对象没有被搜索到，或者称不可达时，就认为这个对象不再被使用。在<code>Java</code>技术体系里固定可作为<code>GC Roots</code>的对象包括：</p>
<ul>
<li>虚拟机栈中的引用对象</li>
<li>方法区中类静态属性的引用对象</li>
<li>方法区中常量引用对象</li>
<li>本地方法栈中<code>JNI</code> ( 即 $Native$ 方法 ) 的引用对象</li>
<li><code>JVM</code>内部引用，如基本数据类型对应的 $Class$ 对象，一些常驻的异常对象等，还有系统类加载器</li>
<li>同步锁 ( $synchronized$ 关键字 ) 持有的对象</li>
<li>反应<code>JVM</code>内部情况的<code>JMXBean</code>、<code>JVMTI</code>中注册的回调、本地代码缓存等</li>
</ul>
<p>        除此之外，根据用户选择的垃圾收集器以及当前收集的内存区域，还会有临时对象的加入。譬如要针对某个特定区域进行垃圾收集时，不仅要加入该区域的，还要加入关联区域的其他对象。虽然现在查找引用链的过程已经可以做到并发，但迄今为止，所有收集器在根节点枚举这一步骤都要暂停用户线程。</p>
<h3 id="13-对象引用">1.3 对象引用</h3>
<p>        在<code>JDK 1.2</code>之前，<code>Java</code>对应用的定义为：如果 $reference$ 类型的数据中存储的数值代表的是另一块内存的起始地址，就称其代表某块内存或某块对象的引用。而在<code>JDK 1.2</code>之后，<code>Java</code>扩充了引用的概念，分为 $4$ 种引用强度：</p>
<ul>
<li><strong>强引用</strong> ( $Strong\ \ Reference$ )：强引用是最传统的引用方式，即指引用赋值。</li>
<li><strong>软引用</strong> ( $Soft\ \ Reference$ )：软引用指一些有用但非必须的对象。当系统将发生内存溢出时，软引用对象会被回收。<code>JDK 1.2</code>之后提供了 $SoftReference$ 类实现软引用。</li>
<li><strong>弱引用</strong> ( $Weak\ \ Reference$ )：弱引用指非必须对象，但强度比软引用更弱。无论内存是否足够，都会被回收。<code>JDK 1.2</code>之后提供了 $WeakReference$ 类实现弱引用。</li>
<li><strong>虚引用</strong> ( $Phantom\ \ Reference$ )：虚引用是最弱的引用关系，不会对对象生命周期造成影响，也不能通过虚引用取得对象实例。关联虚引用只是为了在对象被回收之前获得系统通知。<code>JDK 1.2</code>之后提供了 $PhantomReference$ 类实现虚引用。</li>
</ul>
<h3 id="14-对象死亡">1.4 对象死亡</h3>
<p>        一个对象的死亡至少需要经历两次标记过程：第一次为可达性分析，第二次为筛选，筛选覆盖了 $finalize(\ )$ 方法或者执行过 $finalize(\ )$ 方法的对象。如果 $finalize(\ )$ 方法未被覆盖或者未被执行，那么对象会进入 $F-Queue$ 队列，并在之后由一条自动建立的低优先级的 $Finalizer$ 线程执行其 $finalize(\ )$ 方法。稍后收集器会检查队列中的对象，如果对象在 $finalize(\ )$ 方法中建立了与其他对象的关联，那么它就会被移出队列。需要注意的是，为了避免长时间等待或者进入死循环，收集器并不会等待对象的 $finalize(\ )$ 方法执行完毕，而且一个对象的 $finalize(\ )$ 方法只能调用一次，因此有可能在下次对象回收时该对象不能再次自救。</p>
<h3 id="15-方法区回收">1.5 方法区回收</h3>
<p>        正如之前所说的，方法区可以不实现垃圾收集，而且方法区进行垃圾收集的性价比也不高。方法区的垃圾收集包括废弃常量和不再使用的类型。相比于前者，后者的判定难度就大得多了。判断一个类型不再使用需要满足以下条件：</p>
<ul>
<li>该类所有实例均已回收。</li>
<li>该类的类加载器已回收。</li>
<li>该类的 $Class$ 对象没有被引用，无法通过反射方式访问该类方法。</li>
</ul>
<p>        是否对类型进行回收，<code>HotSpot</code>虚拟机中可以通过 $+Xnoclassgc$ 参数控制，还可以使用 $-verbose:class$、$-XX:+TraceClassLoading$、$-XX:+TraceClassUnLoading$ 查看类加载和卸载信息，前两者可以在<code>Product</code>版中使用，后者需要在<code>FastDebug</code>版中使用。</p>
<h2 id="2-垃圾收集算法">2. 垃圾收集算法</h2>
<p>        垃圾收集算法可以分为引用计数式垃圾收集和追踪式垃圾收集两大类，它们也被称作直接垃圾收集和间接垃圾收集。</p>
<h3 id="21-分代收集理论">2.1 分代收集理论</h3>
<p>        分代收集理论建立在两个假说上：</p>
<ul>
<li><strong>弱分代假说</strong> ( $Weak\ \ Generational\ \ Hypothesis$ )：绝大多数对象都是朝生夕灭的。</li>
<li><strong>强分代假说</strong> ( $Strong\ \ Generational\ \ Hypothesis$ )：经过越多次垃圾收集的对象越难以消亡。</li>
</ul>
<p>        根据这两个假说，多款垃圾收集器中都给<code>Java</code>堆中划分出不同的区域，每次回收根据对象的年龄，将对象分配到不同区域中。在划分出不同的区域后，垃圾收集器可以每次只回收某个或某些特定区域。在<code>Hotspot</code>虚拟机中，<code>Java</code>堆被分为<strong>新生代</strong> ( $Young\ \ Generation$ ) 和<strong>老年代</strong> ( $Old\ \ Generation$ ) 两个区域。但是分代收集并没有想象的那么简单，因为对象不是孤立的，跨代引用是存在的。在此基础上有了第三条经验法则:</p>
<ul>
<li><strong>跨代引用假说</strong> ( $Intergenerational\ \ Reference\ \ Hypothesis$ )：跨代引用相对于同代引用来说仅占少数。</li>
</ul>
<p>        隐含推论是：互相引用的两个对象，倾向于同时生存或者同时消亡。因此没必要再为跨代引用去扫描老年代，只需要在新生代上建立一个全局数据结构，称为<em><strong>记忆集</strong></em> ( $Remembered\ \ Set$ )，将老年代划分为若干小块，标识其中存在跨代引用的小块。在之后进行局限于新生代的垃圾收集 ( $Minor\ \ GC$ ) 时，只需要将这些小块中的对象加入<code>GC Roots</code>即可。</p>
<h3 id="22-标记-清除算法">2.2 标记-清除算法</h3>
<p>        <strong>标记-清除</strong> ( $Mark-Sweep$ ) 算法，首先标记处需要回收的对象，在标记完成后统一收集标记的对象，也可以反过来标记不应清除的对象。标记-清除算法的缺点主要有两个：效率不稳定以及会导致内存碎片化。</p>
<h3 id="23-标记-复制算法">2.3 标记-复制算法</h3>
<p>        标记-复制算法是为了解决标记-清除算法在面对大量可回收对象时的效率低下问题而提出的。首先是<em><strong>半区复制</strong></em> ( $Semispace\ \ Copying$ ) 算法，它将可用内存分为大小相等的两块，每次只使用一块。当其中一块使用完之后，将其中存活的对象移到另一块，再将这块内存清理掉。虽然实现简单，运行高效，但是可用内存缩小为一半，浪费了大量空间。之后又提出了 $Appel$ 式回收，它将新生代分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间，每次分配内存只使用<code>Eden</code>和一块<code>Survivor</code>。在垃圾收集时将它们中的存活对象复制到另一块<code>Survivor</code>中，然后清理自身空间。<code>HotSpot</code>虚拟机中<code>Eden</code>和<code>Survivor</code>的比例为 $8:1$ 。如果<code>Survivor</code>空间无法容纳存活对象，那么就需要其他内存区域进行<strong>分配担保</strong> ( $Handle\ \ Promotion$ )。</p>
<h3 id="24-标记-整理算法">2.4 标记-整理算法</h3>
<p>        标记-复制算法在面对大量存货对象时效率较低，所以不适用于老年代。<strong>标记-整理</strong> ( $Mark-Compact$ ) 算法，其标记过程和标记-复制算法一样，但不进行复制，而是将存活对象向内存一端移动，再清理掉边界外内存。但是对于老年代这种存在大量存活对象的内存区，移动需要耗费大量时间，而且必须暂停用户程序。</p>
<h2 id="3-hotspot虚拟机算法">3. <code>HotSpot</code>虚拟机算法</h2>
<p>        在可达性分析算法的根节点收集这一步中，用户线程必须暂停。为了减小这段暂停的时间，<code>HotSpot</code>虚拟机中有一组称为 $OopMap$ 的数据结构。当类加载完成时，<code>HotSpot</code>会把对象内偏移量对应的数据类型计算出来，并在即时编译过程中记录栈和寄存器中的引用位置。这样扫描器在扫描时就不需要慢慢查找了，可以直接获取这些信息。但是如果给每一条指令都建立一个 $OopMap$ ，那么会占用大量存储空间。因此引入了<strong>安全点</strong> ( $Safepoint$ ) 的概念。只有程序执行到安全点后，虚拟机才会生成 $OopMap$ 。同样，也只有执行到安全点后，程序才能开始垃圾收集。安全点的选取要以能否让程序长时间执行为标准，譬如方法调用、循环跳转、异常跳转这些需要指令序列的复用的地方就可以作为安全点。<br>
        在多线程环境下，每个线程的执行速度不同，可能会出现当一个线程到达安全点之后其他线程还未到达的情况，因此需要采取不同策略。这里有两种方案可以选择：<strong>抢占式中断</strong> ( $Preemptive\ \ Suspension$ ) 和<strong>主动式中断</strong> ( $Voluntary\ \ Suspension$ )，几乎所有虚拟机都采用了主动式中断的方案。抢占式中断会在垃圾收集发生时直接中断所有线程，如果这时某条线程不在安全点上，就恢复其执行，直到其在安全点上。主动式中断设置了一个标志位，线程们会不断轮询这个标志位，当其为真时，线程会执行到最近的一个安全点上然后中断。轮询点包括安全点、创建对象的地方和其他需要在<code>Java</code>堆上分配内存的地方，以避免因为内存不够而导致的无法分配问题。在<code>HotSpot</code>虚拟机中采用了内存保护陷阱的方式，使得轮询操作只需要一条汇编指令即可执行，从而保证了高效性。<br>
        虽然安全点的引入解决了停顿线程的问题，但是无法在程序不执行的状态下运行。这时候就引入了<strong>安全区域</strong> ( $Safe\ \ Region$ ) 的概念。安全区域指代一块代码段，在这段代码中，引用关系不会发生改变，因此可以在这段代码的任意地点开始垃圾收集。当线程进入安全区域，会标识其已进入安全区域，这样在垃圾收集时虚拟机就不会管这些线程。当线程离开时，如果仍在进行根节点枚举这种需要暂停用户线程的步骤，那么就要等待直到完成。<br>
        在进行<em><strong>部分区域收集</strong></em> ( $Partial\ \ GC$ ) 时，可能会存在跨代引用问题，因此引入了记忆集的概念。记忆集专门用于记录非收集区域指向收集区域的指针集合。设计者在设计记忆集时，可以选择不同的记忆精度，比较常见的有：</p>
<ul>
<li><strong>字长精度</strong>：每个记录精确到一个机器字长，即处理器的寻址长度。</li>
<li><strong>对象精度</strong>：每个记录精确到一个对象。</li>
<li><strong>卡精度</strong>：每个记录精确到一块内存区域。</li>
</ul>
<p>        卡精度通过一种称为<em><strong>卡表</strong></em> ( $Card\ \ Table$ ) 的方式实现，也是目前最常用的实现方式。最简单的卡表形式可以是一个字节数组，这也是<code>HotSpot</code>虚拟机中的实现方式。字节数组中的每一个元素都标识一块内存区域，称为<em><strong>卡页</strong></em> ( $Card\ \ Page$ )。当卡页中存在跨代指针时，就要将卡页标识为 $1$ ，称为元素变<em><strong>脏</strong></em> ( $Dirty$ )。在垃圾收集时，只需要筛选变脏的卡页，然后加入<code>GC Roots</code>即可。卡表变脏显然是需要虚拟机负责维护的，但是经过即时编译后的代码已经是一条条机器指令了，这时就需要一种手段可以将维护卡表的操作放到引用赋值之中。<code>HotSpot</code>虚拟机通过<em><strong>写屏障</strong></em> ( $Write\ \ Barrier$ ) 维护卡表状态。写屏障可以看作在虚拟机层面堆“引用类型字段赋值&quot;这个动作的<code>AOP</code>切面，在引用赋值时产生一个<em><strong>环形</strong></em> ( $Around$ ) 通知，供程序执行额外动作。赋值前的部分叫<em><strong>写前屏障</strong></em> ( $Pre-Write\ \ Barrier$ )，赋值后的部分叫做<em><strong>写后屏障</strong></em> ( $Post-Write\ \ Barrier$ )。写前屏障可以应用于<code>SATB</code>算法中，而写后屏障可以用于更新卡表中。<br>
        在对象标记的过程中，我们引入<em><strong>三色标记</strong></em> ( $Tri-color\ \ Marking$ ) 来辅导。白色指未被访问的对象，黑色指所有引用都被扫描过的对象，灰色指部分引用还未被扫描的对象。而在对象标记的过程中，如果用户线程仍在执行，那么可能会触发对象消失问题，即原本存活的对象被标记为死亡。当且仅当以下条件同时满足时，就会产生对象消失问题：</p>
<ul>
<li>赋值器插入了一条或多条从黑色到白色的新引用。</li>
<li>赋值器删除了全部从灰色到白色的直接或间接引用。</li>
</ul>
<p>        而要避免这种情况，实现并发标记，那么就要破坏这两个条件的任意一个。对此有两种方案：<em><strong>增量更新</strong></em> ( $Increment\ \ Update$ ) 和<em><strong>原始快照</strong></em> ( $Snapshot\ \ At\ \ The\ \ Beginning$, $SATB$ )。增量更新破坏第一个条件，即记录黑色到白色的新引用，在扫描结束后再以它们为根重新进行一次扫描。原始快照破坏第二个条件，即记录灰色对象删除指向白色对象的引用，在扫描结束后以其中灰色对象为根再进行一次扫描。在<code>HotSpot</code>虚拟机中，这两种方案都有应用。</p>
<h2 id="4-经典垃圾收集器">4. 经典垃圾收集器</h2>
<h3 id="41-serial收集器">4.1 <code>Serial</code>收集器</h3>
<p>        <code>Serial</code>是最基础、历史最悠久的收集器。它是一个单线程收集器，也就是说在其进行垃圾收集时，其他所有工作都要暂停。对新生代的收集会采用复制算法，对老年代的收集会采用标记-整理算法。<code>Serial</code>收集器虽然是单线程，但是它相比于其他收集器有着简单高效的特点。对于内存资源受限的环境，它的内存消耗是最小的，而且内存资源小往往也意味着需要收集的对象少，因此停顿时间也不会很多。</p>
<h3 id="42-parnew收集器">4.2 <code>ParNew</code>收集器</h3>
<p>        <code>ParNew</code>收集器本质上是<code>Serial</code>收集器的多线程版本，也就是除了使用多条线程并行扫描新生代外，其余的包括算法、控制参数和回收策略等都和<code>Serial</code>收集器一致。<code>ParNew</code>收集器和<code>Serial</code>收集器是仅有的能够与<code>CMS</code>收集器一起配合工作的收集器，其中<code>ParNew</code>是激活<code>CMS</code>后的默认收集器。</p>
<h3 id="43-parallel-scavenge收集器">4.3 <code>Parallel Scavenge</code>收集器</h3>
<p>        <code>Parallel Scavenge</code>收集器是一款新生代收集器，同样基于标记-复制算法实现，支持并行收集。它的目标是使处理器达到一个可控的<em><strong>吞吐量</strong></em> ( $Throughput$ )，即用户代码运行时间与处理器运行时间的比值。由于与吞吐量密切相关，因此也被称作吞吐量优先收集器。<code>Parallel Scavenge</code>收集器提供了一种自适应的调节策略，允许虚拟机根据当前系统的运行情况实现动态调整<code>Java</code>堆中各个区域的大小。</p>
<h3 id="44-serial-old收集器">4.4 <code>Serial Old</code>收集器</h3>
<p>        <code>Serial Old</code>是<code>Serial</code>收集器的老年代版本，同样也是一个单线程收集器，使用标记-整理算法。在服务器模式下可能有两种用途：在<code>JDK 5</code>之前版本中与<code>Parallel Scavenge</code>收集器搭配使用，或者作为<code>CMS</code>收集器发生失败时后备预案。</p>
<h3 id="45-parallel-old收集器">4.5 <code>Parallel Old</code>收集器</h3>
<p>        <code>Parallel Old</code>是<code>Parallel Scavenge</code>的老年代版本，同样支持多线程，基于标记-整理算法。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑<code>Parallel Scavenge</code>和<code>Parallel Old</code>这个组合。</p>
<h3 id="46-cms收集器">4.6 <code>CMS</code>收集器</h3>
<p>        <code>CMS</code> ( $Concurrent\ \ Mark\ \ Sweep$ ) 收集器是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法。在<code>JDK 8</code>之后，<code>CMS</code>收集器逐渐被<code>G1</code>收集器所取代。它的运行过程分为四步：</p>
<ul>
<li><strong>初始标记</strong> ( $initial\ \ mark$ )：记录<code>GC Roots</code>的直接关联对象，需要停顿用户线程</li>
<li><strong>并发标记</strong> ( $concurrent\ \ mark$ )：从<code>GC Roots</code>的直接关联对象开始遍历对象图</li>
<li><strong>重新标记</strong> ( $remark$ )：修正并发标记期间因用户线程持续运作导致的标记变动，需要停顿用户线程</li>
<li><strong>并发清除</strong> ( $concurrent\ \ sweep$ )：删除已死亡的对象</li>
</ul>
<p>        <code>CMS</code>具有并发收集、低停顿的优点。但是具有三个明显的缺点：</p>
<ul>
<li>占用处理器资源。并发阶段虽然不会使用户线程停顿，但会因为占用线程而导致程序变慢，降低吞吐量。</li>
<li>无法处理<em><strong>浮动垃圾</strong></em> ( $Floating\ \ Garbage$ )，可能出现<em><strong>并发失败</strong></em> ( $Concurrent\ \ Mode\ \ Failure$ )。并发阶段，用户可能还在产生垃圾对象。但这部分对象出现在标记结束后，<code>CMS</code>无法收集，只能等待下次垃圾收集。同样也是由于并发执行，<code>CMS</code>不能像其他收集器那样直到老年代快被填满时才开始垃圾收集，只能设置一个阈值。而如果这部分预留的空间无法满足，就会出现并发失败。这时虚拟机只能冻结用户线程，临时启用<code>Serial Old</code>收集器。阈值可以通过 $-XX:CMSInitiatingOccu-pancyFraction$ 来设置。</li>
<li>产生空间碎片。基于标记-清除算法，因此收集结束会产生碎片，不利于之后大对象的分配。为此，<code>CMS</code>默认开启了碎片整理功能，会在进入<code>Full GC</code>时开始碎片整理。</li>
</ul>
<h3 id="47-garbage-first收集器">4.7 <code>Garbage First</code>收集器</h3>
<p>        <code>Garbage First</code>，简称<code>G1</code>收集器开创了收集器面向局部收集的设计思路和基于<code>Region</code>的内存布局形式，是一款主要面向服务端应用的垃圾收集器。在<code>G1</code>之前，收集器范围要么是新生代 ( <code>Minor GC</code> )，要么是老年代 ( <code>Major GC</code> )，要么是整个<code>Java</code>堆 ( <code>Full GC</code> )。而<code>G1</code>可以面向堆内存的任何部分组成<em><strong>回收集</strong></em> ( $Collection\ \ Set$, $CSet$ ) 进行回收，称为<code>Mixed GC</code>。实现这个的关键是基于<code>Region</code>的堆内存布局。<code>G1</code>不是按照固定大小和固定数量的分代区域划分，而是将<code>Java</code>堆分为多个等大连续的区域，可以通过参数 $-XX:G1HeapRegionSize$ 设置，大小应为 $2$ 的 $N$ 次幂，每一个区域都可以作为<code>Eden</code>、<code>Survivor</code>或者老年代。<code>Region</code>中有一特殊的<code>Humongous</code>区域，专门用于存储大对象，而对应超过<code>Region</code>的大对象，会用几个连续的<code>Humongous</code>存放。<code>G1</code>的大多数行为都会把<code>Humongous</code>作为老年代看待。<code>Region</code>是每次收集的最小单元，这样可以避免<code>Full GC</code>。收集器会跟踪每个<code>Region</code>里的垃圾价值，并在后台维护一个优先级列表，每次根据用户设定收集允许停顿时间，通过 $-XX:MaxGCPauseMillis$ 设置，优先处理价值大的<code>Region</code>。<br>
        <code>G1</code>收集器的每个<code>Region</code>都会维护一个记忆集，以哈希表的形式，$Key$ 为其他指向自己的<code>Region</code>的起始地址，$Value$ 为一个存储着卡表索引号的集合，代表着 $Key$ 指向<code>Region</code>的范围。也因为这种复杂的卡表，<code>G1</code>比其他垃圾收集器有着更高的内存占用。<br>
        为了保证标记的正确进行，<code>CMS</code>收集器使用了增量更新算法，而<code>G1</code>使用了原始快照算法。此外，<code>G1</code>收集器为每个<code>Region</code>设计了两个<code>TAMS</code> ( $Top\ \ at\ \ Mark\ \ Start$ ) 指针，并发回收时的新分配对象必须要在这两个指针的位置上，<code>G1</code>会默认它们是存活的。<code>G1</code>收集器仍然存在于<code>CMS</code>相同的并发失败问题，一旦发生并发失败，那么同样也需要停顿用户线程。<br>
        <code>G1</code>提供的 $-XX:MaxGCPauseMillis$ 参数可以设定允许停顿的时间，为此需要可靠的停顿预测模型，即预测停顿时间。<code>G1</code>通过<em><strong>衰减均值</strong></em> ( $Decaying\ \ Average$ ) 理论，记录每个<code>Region</code>的回收耗时、脏卡数量等，由此得出统计信息，从而得到平均状态。<br>
        可以将<code>G1</code>收集器的运作过程分为四步：</p>
<ul>
<li><strong>初始标记</strong> ( $Initial\ \ Marking$ )：标记<code>GC Roots</code>能直接关联到的对象，并修改<code>TAMS</code>指针的值，需要停顿用户线程，但耗时很短。</li>
<li><strong>并发标记</strong> ( $Concurrent\ \ Marking$ )：进行可达性分析，扫描完成后再处理<code>SATB</code>记录下的变动对象。</li>
<li><strong>最终标记</strong> ( $Final\ \ Marking$ )：处理并发阶段后仍然遗留的小部分<code>SATB</code>记录，需要短暂停顿用户线程。</li>
<li><strong>筛选回收</strong> ( $Live\ \ Data\ \ Counting\ \ and\ \ Evacuation$ )：更新<code>Region</code>的统计数据，对<code>Region</code>的回收价值和成本进行排序。根据用户的期望停顿时间，制定回收计划，会将决定回收部分的<code>Region</code>的存活对象复制到空<code>Region</code>中，清空原<code>Region</code>。存活对象移动的过程需要暂停用户线程。</li>
</ul>
<p>        从整体上看，<code>G1</code>基于标记-整理算法，但从局部上看，又是基于标记-复制算法，但无论如何，都意味着不会产生内存碎片。再者，由于<code>G1</code>的卡表复杂，因此不能像<code>CMS</code>那样通过写后屏障更新卡表，而是使用类似于消息队列的方式，再在之后异步处理。自<code>G1</code>开始，垃圾收集器的设计导向开始变为追求内存<em><strong>分配速率</strong></em> ( $Allocation\ \ Rate$ )，而非清理干净，所以可以说<code>G1</code>是收集器技术发展的一个里程碑。</p>
<h2 id="5-低延迟垃圾收集器">5. 低延迟垃圾收集器</h2>
<p>        衡量垃圾收集器最重要的三个指标：<em><strong>内存占用</strong></em> ( $Footprint$ )、<em><strong>吞吐量</strong></em> ( $Throughput$ ) 和<em><strong>延迟</strong></em> ( $Latency$ )。随着硬件的发展，延迟越来越重要。对于一些只进行短暂停顿的垃圾收集器，我们称为<strong>低延迟垃圾收集器</strong> ( $Low-Latency\ \ Garbage\ \ Collector$ / $Low-Pause-Time\ \ Garbage\ \ Collector$ )。</p>
<h3 id="51-shenandoah收集器">5.1 <code>Shenandoah</code>收集器</h3>
<p>        <code>Shenandoah</code>收集器是第一款不由<code>Oracle</code>公司的虚拟机团队领导开发的<code>HotSpot</code>垃圾收集器，被<code>OracleJDK</code>所排斥在外，只有<code>OpenJDK</code>才会包含，成为<code>OpenJDK 12</code>的正式特性之一。<code>Shenandoah</code>与<code>G1</code>有着很多相似性，包括堆内存布局，初始标记、并发标记等阶段的处理思路等。但是它支持并发整理算法，即可以多线程回收；没有分代，即不存在新生代和老年代；摒弃了记忆集，改为<em><strong>连接矩阵</strong></em> ( $Connection\ \ Matrix$ )。<code>Shenandoah</code>收集器工作过程可以划分为九个阶段：</p>
<ul>
<li><strong>初始标记</strong> ( $Initial\ \ Marking$ )：标记与<code>GC Roots</code>直接关联的对象，需要停顿用户线程。</li>
<li><strong>并发标记</strong> ( $Concurrent\ \ Marking$ )：遍历对象图，标记可达对象。</li>
<li><strong>最终标记</strong> ( $Final\ \ Marking$ )：处理剩余的<code>SATB</code>扫描，统计<code>Region</code>价值，需要停顿用户线程。</li>
<li><strong>并发清理</strong> ( $Concurrent\ \ Cleanup$ )：清理没有存活对象的<code>Region</code>。</li>
<li><strong>并发回收</strong> ( $Concurrent\ \ Evacuation$ )：将回收集的存活对象复制到未使用的<code>Region</code>中，但是要并发执行。</li>
<li><strong>初始引用更新</strong> ( $Initial\ \ Update\ \ Reference$ )：创建一个线程集合点，确保回收阶段中的线程都已完成任务，产生一个短暂的停顿。</li>
<li><strong>并发引用更新</strong> ( $Concurrent\ \ Update\ \ Reference$ )：将旧对象引用修正为新地址。</li>
<li><strong>最终引用更新</strong> ( $Final\ \ Update\ \ Reference$ )：修正<code>GC Roots</code>中的引用，需要停顿用户线程。</li>
<li><strong>并发清理</strong> ( $Concurrent\ \ Cleanup$ )：回收集中的<code>Region</code>已无存活对象，称为 $Immediate\ \ Garbage\ \ Regions$ ，清理这些区域。</li>
</ul>
<p>        <code>Shenandoah</code>收集器做到短停顿的关键在于实现并发对象移动。在之前，要实现并发移动，通常是在被移动对象内存上设置<em><strong>保护陷阱</strong></em> ( $Memory\ \ Protection\ \ Trap$ )，用户访问旧对象时会产生自陷中段，进入异常处理器中，再由异常处理器转发到新对象上。但是这种方案需要操作系统层面的支持，用户态要频繁地切换到核心态。<code>Shenandoah</code>使用了<code>Brooks Pointer</code>的概念，在对象结构前添加一个引用字段，在没有进行并发移动时指向自己，在并发移动时将其指向新对象。缺点也很明显，访问对象需要进行两次转发。此外，还要对转发指针进行同步，因为对旧对象进行写操作是无意义的，写操作只能对新对象进行，<code>Shenandoah</code>使用<em><strong>比较并交换</strong></em> ( $Compare\ \ And\ \ Swap$, $CAS$ ) 操作来保证并发时对象的访问正确性。</p>
<h3 id="52-zgc收集器">5.2 <code>ZGC</code>收集器</h3>
<p>        <code>ZGC</code> ( $Z\ \ Garbage\ \ Collector$ ) 是<code>JDK 11</code>中加入的低延迟垃圾收集器，但是与<code>Shenandoah</code>的实现思路具有显著差异。它基于<code>Region</code>内存布局，（暂时）不设分代，使用读屏障、<em><strong>染色指针</strong></em> ( $Colored\ \ Pointer$ ) 和内存多重映射等技术实现并发的标记-整理算法。<code>ZGC</code>中的<code>Region</code>/<code>Page</code>可以动态创建和摧毁，具有动态大小，其中小型和中型<code>Region</code>容量固定，用于存放小对象，而大型<code>Region</code>容量不定，存放大对象。染色指针是一种直接将少量信息存放在指针的技术。$64$ 位<code>Linux</code>系统中高 $18$ 位不能寻址，染色指针技术从剩余的 $46$ 位中提取 $4$ 位作为标志位，也因此该技术限制了内存大小，也不支持 $32$ 位平台。染色指针很好的解决了写屏障的问题，因为不需要再去专门记录对象指针的变动。但是也带来了新问题：操作系统无法识别标志位。<code>Linux/x86-64</code>平台上的<code>ZGC</code>使用了<em><strong>多重映射</strong></em> ( $Multi-Mapping$ )，将多个不同的虚拟内存地址映射到同一物理内存地址上，即多对一映射。以此，染色指针中的标志位可以视为分段符，只需要将这些地址段都映射到同一物理内存空间，就可以正常寻址了。<br>
        <code>ZGC</code>的工作流程可以分为四个阶段，全部都可以并发执行：</p>
<ul>
<li><strong>并发标记</strong> ( $Concurrent\ \ Mark$ )：遍历对象图做可达性分析，前后也需要进行初始标记和最终标记，并有短暂停顿。不同之处在于，标记阶段更新的是指针中的标志位。</li>
<li><strong>并发预备重分配</strong> ( $Concurrent\ \ Prepare\ \ for\ \ Relocate$ )：根据统计得出要清理的<code>Region</code>，组成<em><strong>重分配集</strong></em> ( $Relocation\ \ Set$ )。不同于记忆集，<code>ZGC</code>每次都会扫描全堆。</li>
<li><strong>并发重分配</strong> ( $Concurrent\ \ Relocate$ )：将重分配集中的存活对象复制到其他<code>Region</code>，并为集合中的每个<code>Region</code>维护一个<em><strong>转发表</strong></em> ( $Forward\ \ List$ )，用于记录旧对象到新对象的转向关系。当对象被访问时，如果其指针标志位标识其处于重分配集中，那么就会通过这个转发表转发到新对象地址，同时修正引用值，这种行为称为<em><strong>自愈</strong></em> ( $Self-Healing$ )。因为要保证自愈能力，所以重分配集中的<code>Region</code>在被清理时会保留转发表，直到其相关的指针引用修正完毕。</li>
<li><strong>并发重映射</strong> ( $Concurrent\ \ Remap$ )：修正堆中指向重分配集中旧对象的所有引用。由于指针具有自愈能力，所以这个阶段并不是非常必要的。因此<code>ZGC</code>中这一阶段并到了下一次垃圾收集的并发标记阶段，在每次遍历对象时修正对象引用。在所有指针修正完成后，释放原来的转发表。</li>
</ul>
<p>        虽然<code>ZGC</code>给用户线程带来的负担很小，但它不能承受太高的对象分配速率，因为它会将垃圾收集期间的新对象都视为存活对象，从而在过高的分配速率下产生大量的浮动垃圾。</p>
<h2 id="6-垃圾收集器的选择">6. 垃圾收集器的选择</h2>
<p>        衡量垃圾收集器的三个最重要的指标：内存占用、吞吐量和延迟。不同的垃圾收集器对这三个方面有不同的侧重点，同样的，不同的程序也对这三方面有着不同的要求。因此，可以根据这三方面进行选择。除此之外，收集器的选择还受到操作系统以及<code>JDK</code>发行商和版本的限制。</p>
<h3 id="61-epsilon收集器">6.1 <code>Epsilon</code>收集器</h3>
<p>        <code>Epsilon</code>是一款<em><strong>无操作的垃圾收集器</strong></em> ( $No-Op\ \ Garbage\ \ Collector$ )，因为它并不能进行垃圾收集，更准确的工作应该是负责内存管理，即堆内存管理布局、对象分配、与解释器和编译器的协作等。<code>Epsilon</code>的主要应用在一些小型<code>Java</code>程序中，即只需要运行几分钟甚至数秒的程序，而<code>Epsilon</code>得工作就是保证虚拟机正确分配内存，使程序能在内存耗尽前退出。</p>
<h3 id="62-虚拟机以及垃圾收集器日志">6.2 虚拟机以及垃圾收集器日志</h3>
<p>        每个收集器的日志格式可能都不一样，而且在<code>JDK 9</code>之前，<code>HotSpot</code>并没有提供统一日志框架，因此在其之前的日志系统很混乱。<code>JDK 9</code>之后，<code>HotSpot</code>将所有日志功能收归到了 $-Xlog$ 参数下。</p>
<pre><code>-Xlog[:[selector][:[output][:[decorator][:output-options]]]]
</code></pre><p>        $Selector$ 用于选取日志输出，由标签和日志级别组成，标签可以视为虚拟机中某个功能模块的名字，垃圾收集器的标签名为 $gc$。日志级别分为六级：$Trace$, $Debug$, $Info$, $Warning$, $Error$, $Off$ 。$Decorator$ 用于附加额外内容，如时间、进程<code>ID</code>等。</p>
<h2 id="7-内存分配与回收策略">7. 内存分配与回收策略</h2>
<ol>
<li>大多数情况下，对象在新生代<code>Eden</code>区中分配，当<code>Eden</code>中没有足够空间时，就会发起一次<code>Minor GC</code>。</li>
<li>大对象容易导致垃圾收集提前触发，同时具有高昂的复制开销，通过 $-XX:PretenureSizeThreshold$ 参数 ( 只对<code>Serial</code>和<code>ParNew</code>有效 )，所有大于指定值的对象都会直接分配在老年代，从而减少复制操作。</li>
<li>虚拟机给每个对象定义了一个年龄计数器，存储在对象头中。通常对象在<code>Eden</code>区中诞生，每经历一次<code>Minor GC</code>并且进入<code>Survivor</code>区，年龄便加一。到一定程度 ( 默认为 $15$ )，就会晋升至老年代，可以通过 $-XX:MaxTenuringThreshold$ 设置。不过为了更好的适应不同程序的内存状况，当<code>Survivor</code>中某个年龄的对象内存总和达到一半以上时，所有大于等于该年龄的对象都可以进行老年代。</li>
<li>在<code>Minor GC</code>之前，虚拟机要检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果为真，那么可以认为这次<code>Minor GC</code>是安全的；否则，查看 $-XX:HandlePromotionFailure$ 参数是否允许担保失败。如果允许，那么检查之前的最大可用连续空间是否大于历次晋升到老年对象的平均大小，如果小于将会尝试一次<code>Minor GC</code>。如果不允许，改为<code>Full GC</code>。但是在<code>JDK 6</code>之后，这个参数不再被使用，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行<code>Minor GC</code>，否则进行<code>Full GC</code>。</li>
</ol>

            </div>
            <div class="meta post-footer"> <span>2020 Aug 23 16:33</span> <a href="/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>
<script src=https://z217blog.cn/js/navbutton.js></script>
<script src=https://z217blog.cn/js/tocbutton.js></script>

</html>