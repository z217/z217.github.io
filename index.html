<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.92.2" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85eventfd%E5%92%8Ctimerfd/">Unix网络编程补充：eventfd和timerfd</a>
        
        
        <p>《Unix网络编程》补充</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 26 17:30
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85epoll/">Unix网络编程补充：epoll</a>
        
        
        <p>《Unix网络编程》补充</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 25 19:23
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B20/">Unix网络编程（20）：共享内存</a>
        
        
        <p>《Unix网络编程》读书笔记（20）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 23 13:45
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B19/">Unix网络编程（19）：信号量</a>
        
        
        <p>《Unix网络编程》读书笔记（19）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 21 16:43
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B18/">Unix网络编程（18）：锁</a>
        
        
        <p>《Unix网络编程》读书笔记（18）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 21 14:36
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85eventfd%E5%92%8Ctimerfd/">Unix网络编程补充：eventfd和timerfd</a></h1>
            <div class="post-content">
                <h2 id="1-eventfd">1. <code>eventfd</code></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/eventfd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回eventfd描述符， 出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">eventfd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">initval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div><p>        $eventfd$ 调用返回一个 $eventfd$ 对象描述符，通过该描述符，进程可以在用户空间实现阻塞和唤醒机制，内核会负责唤醒阻塞在该描述符上的进程。$eventfd$ 对象包含一个无符号 $64$ 位整型计数器，由内核维护，初始化为 $initval$ 的值。$flags$ 值是以下值的或：</p>
<table>
<thead>
<tr>
<th style="text-align:left">$flag$</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$EFD_-CLOEXEC$</td>
<td style="text-align:left">设置该标志后，描述符将在 $execve$ 调用之后自动关闭</td>
</tr>
<tr>
<td style="text-align:left">$EFD_-NONBLOCK$</td>
<td style="text-align:left">非阻塞模式</td>
</tr>
<tr>
<td style="text-align:left">$EFD_-SEMAPHORE$</td>
<td style="text-align:left">为读提供类似于信号量的语义</td>
</tr>
</tbody>
</table>
<p>        对于<code>Linux 2.6.26</code>及以下的版本来说，$flags$ 参数没有作用且必须为 $0$ 。如果 $flags$ 参数非法，会返回 $EINVAL$ 错误。对于返回的描述符，可以进行以下操作：</p>
<ul>
<li>$read$ ：调用成功会返回一个以主机字节序排列的 $64$ 位无符号整型；如果返回值小于 $64$ 位，则调用失败，返回 $EINVAL$ 错误。
<ul>
<li>如果没有指定 $EFD_-SEMAPHORE$ 并且 $eventfd$ 计数器值非零，$read$ 调用会返回计数器值，同时计数器值会被设置为 $0$ ；</li>
<li>如果指定了 $EFD_-SEMAPHORE$ 并且 $eventfd$ 计数器值非零，$read$ 调用会返回 $1$ ，同时计数器值会减一；</li>
<li>如果 $eventfd$ 计数器值为 $0$ ，$read$ 调用会阻塞直到计数器值非零。如果指定了 $EFD_-NONBLOCK$ ，$read$ 调用会返回 $EAGAIN$ 错误。</li>
</ul>
</li>
<li>$write$ ：调用成功会为 $eventfd$ 计数器值加上一个 $64$ 位无符号整型的值的数量，最大为 $UINT_-MAX$ $-$ $1$ 。如果指定的值非 $64$ 位或者超过最大值，返回 $EINVAL$ 错误。
<ul>
<li>如果加上这个值会导致溢出，调用会阻塞直到该描述符被调用了一次 $read$ 。如果指定了 $EFD_-NONBLOCK$ ，$write$ 调用会返回 $EAGAIN$ 错误。</li>
</ul>
</li>
<li>$poll$ / $select$ / $epoll$ ：
<ul>
<li>如果 $eventfd$ 计数器值大于 $0$ ，则描述符可读；</li>
<li>如果 $eventfd$ 计数器值至少可以加 $1$ ，则描述符可写；</li>
<li>如果 $eventfd$ 计数器值溢出，对于 $select$ ，该描述符状态会被设置为既可读也可写；对于 $poll$ ，返回 $POLLERR$ ；对于 $epoll$ ，返回 $EPOLLERR$ 。</li>
</ul>
</li>
<li>$close$ ：递减该描述符的引用计数，当引用计数为零时，$eventfd$ 对象会被内核释放。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/eventfd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="kt">uint64_t</span> <span class="n">eventfd_t</span><span class="p">;</span>

<span class="cm">/* 成功返回调用传递的数据量，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">eventfd_read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">eventfd_t</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">eventfd_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">eventfd_t</span> <span class="n">value</span><span class="p">);</span>
</code></pre></div><p>        <code>GNU C</code>库定义了以上函数，与直接对 $eventfd$ 调用 $read$ 和 $write$ 的作用相同。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/eventfd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;inttypes.h&gt;  // definition of PRIu64 &amp; PRIx64</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;  // definition of uint64_t</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define handle_error(msg) \
</span><span class="cp">  do { \
</span><span class="cp">    perror(msg); \
</span><span class="cp">    exit(EXIT_FAILURE); \
</span><span class="cp">  } while (0)
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">efd</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">u</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Usage: %s &lt;num&gt;...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">efd</span> <span class="o">=</span> <span class="n">eventfd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">handle_error</span><span class="p">(</span><span class="s">&#34;eventfd&#34;</span><span class="p">);</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Child writing %s to efd</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
      <span class="n">u</span> <span class="o">=</span> <span class="n">strtoull</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">efd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">))</span>
        <span class="n">handle_error</span><span class="p">(</span><span class="s">&#34;write&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Child completed write loop</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>

  <span class="k">default</span><span class="o">:</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent about to read</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">efd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">))</span>
      <span class="n">handle_error</span><span class="p">(</span><span class="s">&#34;read&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Parent read %&#34;</span> <span class="n">PRIu64</span> <span class="s">&#34; (%#&#34;</span> <span class="n">PRIx64</span> <span class="s">&#34;) from efd</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>

  <span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span>
    <span class="n">handle_error</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="2-timerfd">2. <code>timerfd</code></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/timerfd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回timer描述符，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">timerfd_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">clockid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div><p>        这些系统调用用于创建和管理 $timerfd$ 计时器。$timerfd_-create$ 创建一个新的 $timer$ 对象，并返回该对象的描述符。$clockid$ 参数指定了 $timer$ 的时钟类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">$clock$</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$CLOCK_-REALTIME$</td>
<td style="text-align:left">可变的系统范围内的实时时钟</td>
</tr>
<tr>
<td style="text-align:left">$CLOCK_-MONOTONIC$</td>
<td style="text-align:left">不可修改的单调递增时钟，从过去某个指定时间开始，并且在系统启动后不再改变</td>
</tr>
<tr>
<td style="text-align:left">$CLOCK_-BOOTTIME$</td>
<td style="text-align:left">类似于 $CLOCK_-MONOTONIC$ ，但是可以在系统休眠时继续计时</td>
</tr>
<tr>
<td style="text-align:left">$CLOCK_-REALTIME_-ALARM$</td>
<td style="text-align:left">类似于 $CLOCK_-REALTIME$ ，但是可以阻止系统休眠。进程必须拥有 $CAP_-WAKE_-ALARM$ 能力才能设置该时钟</td>
</tr>
<tr>
<td style="text-align:left">$LOCK_-BOOTTIME_-ALARM$</td>
<td style="text-align:left">类似于 $CLOCK_-BOOTTIME$ ，但是可以阻止系统休眠。进程必须拥有 $CAP_-WAKE_-ALARM$ 能力才能设置该时钟</td>
</tr>
</tbody>
</table>
<p>        $flags$ 标志可以改变 $timer$ 的行为。</p>
<table>
<thead>
<tr>
<th style="text-align:left">$flag$</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$TFD_-NONBLOCK$</td>
<td style="text-align:left">非阻塞模式</td>
</tr>
<tr>
<td style="text-align:left">$TFD_-CLOEXEC$</td>
<td style="text-align:left">描述符会在 $execve$ 调用后自动关闭</td>
</tr>
</tbody>
</table>
<p>        如果 $clockid$ 或者 $flags$ 非法，返回 $EINVAL$ 错误。对于没有 $CAP_-WAKE_-ALARM$ 能力的进程指定 $CLOCK_-REALTIME_-ALARM$ 或者 $CLOCK_-BOOTTIME_-ALARM$ 标志会导致调用返回 $EPERM$ 错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/timerfd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">timerfd_settime</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">itimerspec</span> <span class="o">*</span><span class="n">new_value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">itimerspce</span> <span class="o">*</span><span class="n">old_value</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">timerfd_gettime</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">itimerspce</span> <span class="o">*</span><span class="n">curr_value</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">timespec</span> <span class="p">{</span>
  <span class="n">time_t</span> <span class="n">tv_sec</span><span class="p">;</span>  <span class="c1">// seconds
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">tv_nsec</span><span class="p">;</span>  <span class="c1">// nanoseconds
</span><span class="c1"></span><span class="p">};</span>

<span class="k">struct</span> <span class="n">itimerspec</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">timespec</span> <span class="n">it_interval</span><span class="p">;</span>  <span class="c1">// interval for periodic timer
</span><span class="c1"></span>  <span class="k">struct</span> <span class="n">timespec</span> <span class="n">it_value</span><span class="p">;</span>  <span class="c1">// initial expiration
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><p>        $timerfd_-settime$ 用于启动或者停止 $timer$ ，$new_-value$ 参数指定定时时间，如果 $it_-value$ 或者 $it_-interval$ 成员存在非零值，那么 $timer$ 会被启动；如果都为 $0$ ，那么 $timer$ 会停止。如果 $it_-value$ 和 $it_-interval$ 都非零，那么定时器会选择 $it_-value$ 的时间并且只会触发一次。$it_-value$ 默认为相对时间，可以通过 $flag$ 修改。$flag$ 参数可以为以下值：</p>
<ul>
<li>$TFD_-TIMER_-ABSTIME$ ：$it_-value$ 表达绝对时间 ( 默认为相对时间 )；</li>
<li>$TFD_-TIMER_-CANCEL_-ON_-SET$ ：如果和 $TFD_-TIMER_-ABSTIME$ 同时设置，并且时钟为 $CLOCK_-REALTIME$ 或 $CLOCK_-REALTIME_-ALARM$ ，那么在经历了非连续的更改 ( $settimeofday$ 、$clock_-settime$ 等 ) 之后，$timer$ 会被标记为可取消。当更改发生并且有其他进程正阻塞在对该 $timerfd$ 的 $read$ 调用上时，$read$ 调用将失败并返回 $CANCELED$ 错误。</li>
</ul>
<p>        如果 $old_-value$ 非空，那么原来的定时时间会被返回到 $old_-value$ 指向的地址中。<br>
        $timerfd_-gettime$ 调用会返回当前的定时时间。如果返回的时间值都为 $0$ ，表示当前定时器没有开始计时。无论当前定时器是否指定了 $TFD_-TIMER_-ABSTIME$ ，都将返回相对时间。<br>
        可以对 $timerfd$ 进行以下操作：</p>
<ul>
<li>$read$ ：如果 $timer$ 已经启动，并且在上一次调用 $read$ 到现在这段时间已经超时了一次或多次，那么这次 $read$ 调用会以主机字节序返回一个 $64$ 位无符号整型，值为超时次数。
<ul>
<li>如果没有发生超时，那么 $read$ 会阻塞直到超时发生。如果指定了 $TFD_-NONBLOCK$ ，那么会返回 $EAGAIN$ 错误；</li>
<li>如果提供的缓冲区小于 $64$ 位，返回 $EINVAL$ 错误；</li>
<li>如果指定了 $CLOCK_-REALTIME$ / $CLOCK_-REALTIME_-ALARM$ 、$TFD_-TIMER_-ABSTIME$ 和 $TFD_-TIMER_-CANCEL_-ON_-SET$ ，并且在阻塞期间时间被以非连续方式修改，那么会返回 $ECANCELED$ 错误。</li>
</ul>
</li>
<li>$poll$ / $select$ / $epoll$ ：如果发生了一次或多次超时，描述符将可读；</li>
<li>$ioctl$ ：可以执行 $TFD_-IOC_-SET_-TICKS$ 命令，修改该定时器的超时次数，参数为一个无符号 $64$ 位整型指针，指向新的超时次数。当调用成功时，所有在该定时器上等待的进程将被唤醒。只有内核配置了 $CONFIG_-CHECKPOINT_-RESTORE$ 选项后该命令才可用；</li>
<li>$close$ ：递减当前定时器描述符的引用计数，当引用计数为零时，该定时器将被内核释放。</li>
</ul>
<p>        如果 $fd$ 无效，返回 $EBADF$ 错误。如果 $fd$ 不是 $timerfd$ ，返回 $EINVAL$ 错误。如果 $new_-value$ 、$old_-value$ 或者 $curr_-value$ 无效，返回 $EFAULT$ 错误。此外，对于 $ECANCELED$ 错误，还存在特殊情况：</p>
<ol>
<li>创建一个 $CLCOK_-REALTIME$ / $CLOCK_-REALTIME_-ALARM$ 定时器，并启用 $TFD_-TIMER_-ABSTIME$ 和 $TFD_-TIMER_-CANCEL_-ON_-SET$ 标志；</li>
<li>调用 $timerfd_-settime$ 启动定时器；</li>
<li>对 $CLOCK_-REALTIME$ 时钟进行非连续修改 ( 比如 $settimeofday$ )；</li>
<li>再次调用 $timerfd_-settime$ 启动定时器。</li>
</ol>
<p>        在上述情况下，$timerfd_-settime$ 将返回 $-1$ ，同时设置 $ECANCELED$ 错误，这使得调用者得知上一次启动因为非连续修改而中止。虽然这次调用返回了错误，但是不意味着设置失败，定时器还是会按照调用中传递的定时时间设置并启动。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/timerfd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;inttypes.h&gt;  // definition of PRIu64</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;  // definition of uint64_t</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define handle_error(msg) \
</span><span class="cp">  do { \
</span><span class="cp">    perror(msg); \
</span><span class="cp">    exit(EXIT_FAILURE); \
</span><span class="cp">  } while(0)
</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_elapsed_time</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">start</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">timespec</span> <span class="n">curr</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">first_call</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">secs</span><span class="p">,</span> <span class="n">nsecs</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">first_call</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">first_call</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">handle_error</span><span class="p">(</span><span class="s">&#34;clock_gettime&#34;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">handle_error</span><span class="p">(</span><span class="s">&#34;clock_gettime&#34;</span><span class="p">);</span>

  <span class="n">secs</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">tv_set</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
  <span class="n">nsecs</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nsecs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">secs</span><span class="o">--</span><span class="p">;</span>
    <span class="n">nsecs</span> <span class="o">+=</span> <span class="mi">1000000000</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d.%03d: &#34;</span><span class="p">,</span> <span class="n">secs</span><span class="p">,</span> <span class="p">(</span><span class="n">nsecs</span> <span class="o">+</span> <span class="mi">500000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">itimerspec</span> <span class="n">new_value</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">max_exp</span><span class="p">,</span> <span class="n">fd</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">exp</span><span class="p">,</span> <span class="n">tot_exp</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;%s init-secs [interval-secs max-exp]</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_REALTIME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">handle_error</span><span class="p">(</span><span class="s">&#34;clock_gettime&#34;</span><span class="p">);</span>

  <span class="cm">/* Create a CLOCK_REALTIME absolute timer with initial
</span><span class="cm">     expiration and interval as specified in command line. */</span>
  <span class="n">new_value</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">new_value</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">new_value</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">max_exp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">new_value</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="n">max_exp</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">new_value</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">timerfd_create</span><span class="p">(</span><span class="n">CLOCK_REALTIME</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">handle_error</span><span class="p">(</span><span class="s">&#34;timerfd_create&#34;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">timerfd_settime</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">TFD_TIMER_ABSTIME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_value</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">handle_error</span><span class="p">(</span><span class="s">&#34;timerfd_settime&#34;</span><span class="p">);</span>

  <span class="n">print_elapsed_time</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;timer started</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">tot_exp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tot_exp</span> <span class="o">&lt;</span> <span class="n">max_exp</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">))</span>
      <span class="n">handle_error</span><span class="p">(</span><span class="s">&#34;read&#34;</span><span class="p">);</span>

    <span class="n">tot_exp</span> <span class="o">+=</span> <span class="n">exp</span><span class="p">;</span>
    <span class="n">print_elapsed_time</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read: %&#34;</span> <span class="n">PRIu64</span> <span class="s">&#34;; total=%&#34;</span> <span class="n">PRIu64</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">tot_exp</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 26 17:30</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85eventfd%E5%92%8Ctimerfd/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85epoll/">Unix网络编程补充：epoll</a></h1>
            <div class="post-content">
                <p>        $epoll$ 执行与 $select$ 和 $poll$ 类似的工作：监听多个描述符，当其中存在可用描述符时返回。$epoll$ 支持边缘触发和层级触发两种模式，并且在监听大量描述符的情况下有着很好的性能。<br>
        $epoll$ 的核心是 $epoll$ 对象，这是一个内核数据结构，形式上，可以认为是两个集合：</p>
<ul>
<li>监听集合 ( 有时候被称为 $epoll$ 集合 )：描述符集合，进程注册的新的待监听的描述符会被存放在该集合中；</li>
<li>可用集合：描述符集合，是监听集合的子集，内核通过该集合返回可用的文件描述符。</li>
</ul>
<h2 id="1-epoll操作">1. <code>epoll</code>操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功时返回0，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">epoll_create1</span><span class="p">(</span><span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div><p>        $epoll_-create$ 创建一个 $epoll$ 对象，返回该对象的描述符。从<code>Linux 2.6.8</code>开始，$size$ 参数不再有作用，会被忽略，但是必须大于 $0$ ，否则会设置 $EINVAL$ 错误。$epoll_-create1$ 与 $epoll_-create$ 类似，$flags$ 参数的值可以是 $EPOLL_-CLOEXEC$ ，当设置该标志时，该对象描述符会在执行 $execve$ 调用后自动关闭。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#inlcude &lt;sys/epoll.h&gt;
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">epoll_data</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">u32</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
<span class="p">}</span> <span class="n">epoll_data_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">epoll_event</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">events</span><span class="p">;</span>
  <span class="n">epoll_data_t</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><p>        $epoll_-ctl$ 从 $epoll$ 描述符中添加、修改或删除事件，$fd$ 指定待监听的描述符。其中 $op$ 可以是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">$op$</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$EPOLL_-CTL_-ADD$</td>
<td style="text-align:left">添加一个事件</td>
</tr>
<tr>
<td style="text-align:left">$EPOLL_-CTL_-MOD$</td>
<td style="text-align:left">修改一个事件</td>
</tr>
<tr>
<td style="text-align:left">$EPOLL_-CTL_-DEL$</td>
<td style="text-align:left">删除一个事件，$events$ 参数会被忽略</td>
</tr>
</tbody>
</table>
<p>        $epoll_-event$ 的 $data$ 成员指定该事件关联的对象，会被保存在内核中，并在可用时返回；$events$ 成员是多个标志位的或的值，用于注册进程感兴趣的事件，当其中的条件满足时会唤醒阻塞进程，同时也作为返回值接收事件状态。</p>
<table>
<thead>
<tr>
<th style="text-align:left">$event$</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$EPOLLIN$</td>
<td style="text-align:left">描述符可读</td>
</tr>
<tr>
<td style="text-align:left">$EPOLLOUT$</td>
<td style="text-align:left">描述符可写</td>
</tr>
<tr>
<td style="text-align:left">$EPOLLRDHUP$</td>
<td style="text-align:left">流套接字对端关闭连接或者进入写半关闭状态</td>
</tr>
<tr>
<td style="text-align:left">$EPOLLPRI$</td>
<td style="text-align:left"><code>TCP</code>套接字带外数据</td>
</tr>
<tr>
<td style="text-align:left">$EPOLLERR$</td>
<td style="text-align:left">描述符发生错误，不需要作为入参指定也能触发</td>
</tr>
<tr>
<td style="text-align:left">$EPOLLHUP$</td>
<td style="text-align:left">描述符挂起，一般是描述符未打开或异常关闭导致的，不需要作为入参指定也能触发</td>
</tr>
<tr>
<td style="text-align:left">$EPOLLET$</td>
<td style="text-align:left">边缘触发模式 ( 默认为层级触发模式 )，仅作为入参，不会被返回</td>
</tr>
<tr>
<td style="text-align:left">$EPOLLONESHOT$</td>
<td style="text-align:left">单次通知，完成后该描述符会被移除出监听集合</td>
</tr>
<tr>
<td style="text-align:left">$EPOLLWAKEUP$</td>
<td style="text-align:left">在非 $EPOLLET$ 和 $EPOLLONESHOT$ 的事件上，并且进程拥有 $CAP_-BLOCK_-SUSPEND$ 的能力，可以确保系统不会在等待该事件或者处理该事件时进入休眠状态。仅作为入参，不会被返回</td>
</tr>
</tbody>
</table>
<p>        当 $epfd$ 或 $fd$ 不可用时，返回 $EBADF$ 错误。当 $fd$ 已存在时，返回 $EEXIST$ 错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功时返回可用描述符数，出错时返回-1 */</span>

<span class="kt">int</span> <span class="nf">epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">epoll_pwait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">sigmask</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">epoll_pwait2</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span> <span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">sigmask</span><span class="p">);</span>
</code></pre></div><p>        $epoll_-wait$ 等待 $epoll$ 对象上的任意一个或多个描述符变为可用。$events$ 数组用于返回可用描述符，最多返回 $maxevents$ ( 必须大于 $0$ ) 个描述符。$timeout$ 参数指定超时事件，单位为毫秒，如果为 $-1$ ，意味着没有超时时间。文件描述符的状态会作为 $epoll_-event$ 中的 $events$ 成员返回。$epoll_-pwait$ 和 $epoll_-pwait2$ 与 $epoll_-wait$ 类似，其中 $sigmask$ 参数可以指定在等待描述符期间阻塞的信号，类似于以下操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">sigset_t</span> <span class="n">origmask</span><span class="p">;</span>

<span class="n">pthread_sigmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">origmask</span><span class="p">);</span>
<span class="n">ready</span> <span class="o">=</span> <span class="n">epoll</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="n">pthread_sigmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">origmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div><p>        如果 $epfd$ 不可用，返回 $EBADF$ 错误；如果 $epfd$ 不是一个 $epoll$ 描述符或者 $maxevents$ 不大于 $0$ ，返回 $EINVAL$ 错误；如果 $events$ 指向不可用区域，返回 $EFAULT$ 错误；如果阻塞过程中被中断，返回 $EINTR$ 错误。</p>
<h2 id="2-边缘触发和层级触发">2. 边缘触发和层级触发</h2>
<p>        $epoll$ 允许边缘触发 ( $edge-triggered$ ，$ET$ ) 和层级触发 ( $level-triggered$ ，$LT$ ) 两种行为。假设存在以下情形：</p>
<ol>
<li>一个管道的读描述符 $rfd$ 被注册进 $epoll$ 对象；</li>
<li>另一个进程往这个管道写入 $2KB$ 数据；</li>
<li>$epoll_-wait$ 调用返回，当前进程从管道中读入 $1KB$ 数据；</li>
<li>当前进程再次调用 $epoll_-wait$ 。</li>
</ol>
<p>        对于这种情况，$epoll$ 存在两种行为：</p>
<ul>
<li>边缘触发：描述符 $rfd$ 被认为不可用，尽管管道里面还存在数据，直到另一个进程再次向管道中写入数据。边缘触发只有在描述符被监听的时候才会改变事件状态；</li>
<li>层级触发：描述符 $rfd$ 可用，$epoll_-wait$ 立即返回。</li>
</ul>
<p>        在上述例子中，假设使用边缘触发并且对端进程在等待先前数据的响应，那么由于 $epoll_-wait$ 的调用，对端可能会无限等待下去。所以对于这种情况，建议使用非阻塞式<code>I/O</code>，或者多次调用 $read$ 或 $write$ 直到返回 $EAGAIN$ 错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define MAX_EVENTS 10
</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">epoll_event</span><span class="p">,</span> <span class="n">ev</span><span class="p">,</span> <span class="n">events</span><span class="p">[</span><span class="n">MAX_EVENTS</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">epollfd</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

<span class="cm">/* Code to set up listening socket, &#39;listenfd&#39;,
</span><span class="cm">   (socket(), bind(), listen()) omitted. */</span>

<span class="n">epollfd</span> <span class="o">=</span> <span class="n">epoll_create1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">epollfd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&#34;epoll_create1&#34;</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
<span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">listenfd</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">listenfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">perror</span><span class="p">(</span><span class="s">&#34;epoll_ctl: listenfd&#34;</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
  <span class="n">nfds</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_EVENTS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nfds</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&#34;epoll_wait&#34;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nfds</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="n">listenfd</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">connfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;accept&#34;</span><span class="p">);</span>
        <span class="n">eixt</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
      <span class="p">}</span>
      
      <span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;fcntl: F_GETFL&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fcntl</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">val</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;fcntl: F_SETFL&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLET</span><span class="p">;</span>
      <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">connfd</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">connfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&#34;epoll_ctl: connfd&#34;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">do_use_fd</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 25 19:23</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85epoll/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B20/">Unix网络编程（20）：共享内存</a></h1>
            <div class="post-content">
                <p>        共享内存是可用<code>IPC</code>形式中最快的。因为将内存区映射到进程的地址空间之后，进程间的数据传递就不用通过内核。</p>
<h2 id="1-共享内存操作">1. 共享内存操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回映射内存区的地址，出错返回MAP_FAILED
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">mmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">offset</span><span class="p">);</span>
</code></pre></div><p>        $mmap$ 函数把一个文件或一个<code>POSIX</code>共享内存区对象映射到调用进程的地址空间。使用该函数有三个目的：</p>
<ul>
<li>对普通文件使用内存映射<code>I/O</code>；</li>
<li>对特殊文件进行匿名内存映射；</li>
<li>使用 $shm_-open$ 提供无亲缘关系的进程间的<code>POSIX</code>共享内存区。</li>
</ul>
<p>        $addr$ 可以指定描述符 $fd$ 应该被映射到的进程内存空间的地址，也可以指定为 $NULL$ ，从而让内核自己选择。$len$ 是映射到调用进程地址空间中的字节数，从被映射字节开头第 $offset$ 个字节开始，$offset$ 可以为 $0$ 。内存映射区的保护由 $prot$ 参数提供，可选值有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">$prot$</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$PROT_-READ$</td>
<td style="text-align:left">数据可读</td>
</tr>
<tr>
<td style="text-align:left">$PROT_-WRITE$</td>
<td style="text-align:left">数据可写</td>
</tr>
<tr>
<td style="text-align:left">$PROT_-EXEC$</td>
<td style="text-align:left">数据可执行</td>
</tr>
<tr>
<td style="text-align:left">$PROT_-NONE$</td>
<td style="text-align:left">数据不可访问</td>
</tr>
</tbody>
</table>
<p>        $prot$ 参数的常见值为 $PROT_-READ$ | $PROT_-WRITE$ 。$flags$ 指定共享内存属性，可选值有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">$flag$</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$MAP_-SHARED$</td>
<td style="text-align:left">变动是共享的</td>
</tr>
<tr>
<td style="text-align:left">$MAP_-PRIVATE$</td>
<td style="text-align:left">变动是私有的</td>
</tr>
<tr>
<td style="text-align:left">$MAP_-FIXED$</td>
<td style="text-align:left">准确地解释 $addr$</td>
</tr>
</tbody>
</table>
<p>        其中 $MAP_-SHARED$ 和 $MAP_-PRIVATE$ 必须选择其中一个。如果选择 $MAP_-SHARED$ ，那么调用进程对映射区内所做的修改对其他进程可见，并且也会修改底层对象；如果选择 $MAP_-PRIVATE$ ，那么调用进程对映射区所做的修改只有当前进程可见，而且不会修改底层对象；从移植性上考虑，不应该指定 $MAP_-FIXED$ ，如果没有指定该标志并且 $addr$ 非空，则具体行为取决于实现。可移植的代码应该把 $addr$ 设置为 $NULL$ 并不指定 $MAP_-FIXED$ 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">munmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">);</span>

<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">msync</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div><p>        $munmap$ 从进程空间中删除映射区，删除之后再次访问先前映射区地址会产生 $SIGSEGV$ 信号。$msync$ 算法用于主动将映射区中的数据同步到硬盘，可选的 $flags$ 参数有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">$flag$</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$MS_-ASYNC$</td>
<td style="text-align:left">异步写</td>
</tr>
<tr>
<td style="text-align:left">$MS_-SYNC$</td>
<td style="text-align:left">同步写</td>
</tr>
<tr>
<td style="text-align:left">$MS_-INVALIDATE$</td>
<td style="text-align:left">使高速缓存中的数据失效</td>
</tr>
</tbody>
</table>
<p>        其中 $MS_-ASYNC$ 和 $MS_-SYNC$ 必须指定其中一个。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">shared</span> <span class="p">{</span>
  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">;</span>  <span class="c1">// the mutex: a Posix memory-based semaphore
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>  <span class="c1">// the counter
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nloop</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">shared</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: incr2 &lt;pathname&gt; &lt;#loops&gt;&#34;</span><span class="p">);</span>
  <span class="n">nloop</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

  <span class="c1">// open file, initalize to 0, map into memory
</span><span class="c1"></span>  <span class="n">fd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">);</span>
  <span class="n">Write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shared</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared</span><span class="p">));</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shared</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
             <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

  <span class="c1">// initialize semaphore that is shared between processes
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">setbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// stdout is unbuffered
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// child
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nloop</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;child: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">);</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// parent
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nloop</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;parent: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="2-匿名内存映射">2. 匿名内存映射</h2>
<p>        匿名内存映射可以让我们在不用创建文件的前提下使用内存映射。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nloop</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="n">sem_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: incr_map_anon &lt;#loops&gt;&#34;</span><span class="p">);</span>
  <span class="n">nloop</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// map into memory
</span><span class="c1"></span>  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
             <span class="n">MAP_SHARED</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">// 后略...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>        $/dev/zero$ 设备文件会不断产生空字符，也可以用于实现匿名内存映射。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nloop</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="n">sem_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: incr_dev_zero &lt;#loops&gt;&#34;</span><span class="p">);</span>
  <span class="n">nloop</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// open /dev/zerp, map into memory
</span><span class="c1"></span>  <span class="n">fd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="s">&#34;/dev/zero&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

  <span class="c1">// 后略...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h2 id="3-安全访问共享内存映射区">3. 安全访问共享内存映射区</h2>
<p>        访问共享内存映射区时可能会产生两种错误：</p>
<ol>
<li>当访问的区域位于映射区以外时，返回 $SIGSEGV$ 错误；</li>
<li>当访问的区域位于映射区以内但是超出文件大小时，返回 $SIGBUS$ 错误。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define FILE &#34;test.data&#34;
</span><span class="cp">#define SIZE 32768
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

  <span class="c1">// open: create or truncate; then mmap file
</span><span class="c1"></span>  <span class="n">fd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">FILE</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">);</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">SIZE</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4096</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;setting file size to %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">Ftruncate</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;ptr[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        上述程序使用了让文件持续增长的技巧。它指定了一个大于文件大小的内存映射区，同时不断跟踪文件大小，并让文件大小随着写入增长。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">ftruncate</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">off_t</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div><p>        处理 $mmap$ 的时候，普通文件或共享内存区的大小都可以通过 $ftruncate$ 修改。但是对于普通文件和共享内存区对象文件，<code>POSIX</code>对它们的处理逻辑不同：</p>
<ul>
<li>对于普通文件，如果文件大小大于 $length$ ，那么文件会被缩小并且丢弃额外的数据；如果文件大小小于 $length$ ，那么文件怎么修改和大小怎么改变是未定义的。实际上，对于一个普通文件，一种可移植的增加大小的方法是先使用 $lseek$ 定位到 $length - 1$ ，然后写入 $1$ 字节数据。所幸的是，几乎所有<code>Unix</code>实现都支持使用 $ftruncate$ 扩展一个文件；</li>
<li>对于共享内存区对象文件，$ftruncate$ 会把大小设置为 $length$ 字节。</li>
</ul>
<p>        普通文件指通过 $open$ 打开的文件，共享内存区对象文件则指通过 $shm_-open$ 打开的文件，稍后我们会看到 $shm_-open$ 的调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">fstat</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</code></pre></div><p>        当打开一个已存在的共享内存区对象文件时，我们可以通过 $fstat$ 获取该文件信息。$stat$ 结构有 $12$ 或以上的成员，然而当 $fd$ 指代一个共享内存区对象时，只有四个成员有效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">stat</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="n">mode_t</span> <span class="n">st_mode</span><span class="p">;</span>  <span class="c1">// mode: S_I{RW}{USR,GRP,OTH}
</span><span class="c1"></span>  <span class="n">uid_t</span> <span class="n">st_uid</span><span class="p">;</span>  <span class="c1">// user ID of owner
</span><span class="c1"></span>  <span class="n">gid_t</span> <span class="n">st_gid</span><span class="p">;</span>  <span class="c1">// group ID of owner
</span><span class="c1"></span>  <span class="n">off_t</span> <span class="n">st_size</span><span class="p">;</span>  <span class="c1">// size in bytes
</span><span class="c1"></span>  <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><h2 id="4-posix共享内存区操作">4. <code>POSIX</code>共享内存区操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回非负描述符，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">shm_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>

<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">shm_unlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</code></pre></div><p>        <code>POSIX</code>共享内存区涉及以下两个步骤要求：</p>
<ol>
<li>调用 $shm_-open$ 并指定文件名，创建或打开一个共享内存区对象文件；</li>
<li>调用 $mmap$ 把这个共享内存区对象文件映射到调用进程的地址空间。</li>
</ol>
<p>        $oflag$ 参数必须含有 $ORDONLY$ 和 $O_-RDWR$ 的其中一个，还可以指定 $O_-CREAT$ 、$O_-EXCL$ 和 $O_-TRUNC$ 。$mode$ 指定权限位，在指定了 $O_-CREAT$ 的前提下使用，如果没有指定 $O_-CREAT$ ，可以设置为 $0$ 。$shm_-unlink$ 则负责删除一个共享内存区对象文件，跟其他 $unlink$ 一样，已打开的文件不会影响删除。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd1</span><span class="p">,</span> <span class="n">fd2</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr2</span><span class="p">;</span>
  <span class="n">pid_t</span> <span class="n">childpid</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">stat</span> <span class="n">stat</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: test3 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="n">shm_unlink</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">fd1</span> <span class="o">=</span> <span class="n">Shm_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">);</span>
  <span class="n">Ftruncate</span><span class="p">(</span><span class="n">fd1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="n">fd2</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="s">&#34;/etc/hostname&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
  <span class="n">Fstat</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">childpid</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// child
</span><span class="c1"></span>    <span class="n">ptr2</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">ptr1</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
                <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;child: shm ptr = %p, hostname ptr = %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">);</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;shared memory integer = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// parent: mmap in reverse order from child
</span><span class="c1"></span>  <span class="n">ptr1</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">ptr2</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;parent: shm ptr = %p, hostname ptr = %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr1</span><span class="p">,</span> <span class="n">ptr2</span><span class="p">);</span>
  <span class="o">*</span><span class="n">ptr1</span> <span class="o">=</span> <span class="mi">777</span><span class="p">;</span>
  <span class="n">Waitpid</span><span class="p">(</span><span class="n">childpid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        上面的程序演示了父子进程可以把同一个共享内存区对象映射到不同的进程地址，并且通过这不同的进程地址读出相同的值。</p>
<h2 id="5-生产者-消费者模型">5. 生产者-消费者模型</h2>
<p>        我们可以通过共享内存技术实现生产者-消费者模型，通过共享内存区来容纳消息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define MESGSIZE 256  </span><span class="c1">// max #bytes per message, incl. null at end
</span><span class="c1"></span><span class="cp">#define NMESG 16  </span><span class="c1">// max #messages
</span><span class="c1"></span>
<span class="k">struct</span> <span class="n">shmstruct</span> <span class="p">{</span>  <span class="c1">// struct stored in shared memory
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">;</span>  <span class="c1">// three POSIX memory-based semaphores
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">nempty</span><span class="p">;</span>
  <span class="n">sem_t</span> <span class="n">nstored</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nput</span><span class="p">;</span>  <span class="c1">// index into msgoff[] for next put
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">noverflow</span><span class="p">;</span>  <span class="c1">// #overflows by senders
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">noverflowmutex</span><span class="p">;</span>  <span class="c1">// mutex for noverflow counter
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">msgoff</span><span class="p">[</span><span class="n">NMESG</span><span class="p">];</span>  <span class="c1">// offset in shared memory of each message
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">msgdata</span><span class="p">[</span><span class="n">NMESG</span> <span class="o">*</span> <span class="n">MESGSIZE</span><span class="p">];</span>  <span class="c1">// the actual messages
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><p>        当生产者想发送消息但是没有空间时，我们不会阻塞生产者，而是递增 $noverflow$ 计数。$msgoff$ 指出每个消息的偏移，其中 $msgoff[0] = 0$ 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;cliserv2.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">lastnoverflow</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">shmstruct</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: server2 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// create shm, set its size, map it, close descriptor
</span><span class="c1"></span>  <span class="n">shm_unlink</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>  <span class="c1">// OK if this fails
</span><span class="c1"></span>  <span class="n">fd</span> <span class="o">=</span> <span class="n">Shm_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">);</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmstruct</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
             <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Ftruncate</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmstruct</span><span class="p">));</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

  <span class="c1">// initialize the array of offsetss
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">NMESG</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">msgoff</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="n">MESGSIZE</span><span class="p">;</span>

  <span class="c1">// initialize the semaphores in shared memory
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NMESG</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflowmutex</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// this program is the consumer
</span><span class="c1"></span>  <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">lastnoverflow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nstored</span><span class="p">);</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">msgoff</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;index = %d: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">msgdata</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">NMESG</span><span class="p">)</span>
      <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// circular buffer
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nempty</span><span class="p">);</span>

    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflowmutex</span><span class="p">);</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflow</span><span class="p">;</span>  <span class="c1">// don&#39;t printf while mutex held
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflowmutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="n">lastnoverflow</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;noverflow = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
      <span class="n">lastnoverflow</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        消费者程序会先删除可能存在的共享内存区对象文件，然后重新创建。接着会初始化每个消息的偏移。最后，在每次循环的末尾都会检查 $noverflow$ ，如果改变了，就输出它的最新值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;cliserv2.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nloop</span><span class="p">,</span> <span class="n">nusec</span><span class="p">;</span>
  <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">mesg</span><span class="p">[</span><span class="n">MESGSIZE</span><span class="p">];</span>
  <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">shmstruct</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: client2 &lt;name&gt; &lt;#loops&gt; &lt;#usec&gt;&#34;</span><span class="p">);</span>
  <span class="n">nloop</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="n">nusec</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

  <span class="c1">// open and map shared memory that server must create
</span><span class="c1"></span>  <span class="n">fd</span> <span class="o">=</span> <span class="n">Shm_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDWR</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">);</span>
  <span class="n">ptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">shmstruct</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
             <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

  <span class="n">pid</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nloop</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sleep_us</span><span class="p">(</span><span class="n">nusec</span><span class="p">);</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">mesg</span><span class="p">,</span> <span class="n">MESGSIZE</span><span class="p">,</span> <span class="s">&#34;pid %ld: message %d&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">pid</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sem_trywait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nempty</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflowmutex</span><span class="p">);</span>
        <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflow</span><span class="o">++</span><span class="p">;</span>
        <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">noverflowmutex</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;sem_trywait error&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">msgoff</span><span class="p">[</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nput</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nput</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">NMESG</span><span class="p">)</span>
      <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nput</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// circular buffer
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">msgdata</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="n">mesg</span><span class="p">,</span> <span class="n">MESGSIZE</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">nstored</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        生产者程序使用不会阻塞 $sem_-trywait$ 调用，如果调用失败 ( 即 $nempty$ 信号量不大于 $0$ )，说明映射区中没有空间，递增 $noverflow$ 。</p>

            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 23 13:45</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B20/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B19/">Unix网络编程（19）：信号量</a></h1>
            <div class="post-content">
                <p>        <strong>信号量</strong> ( $semaphore$ ) 是一种用于不同进程间或一个进程内的不同线程间同步的原语。<code>POSIX</code>信号量不必在内核中维护，可能使用文件系统中的某个文件来标识。</p>
<h2 id="1-有名信号量操作">1. 有名信号量操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回信号量指针，出错返回SEM_FAILED
</span><span class="c1"></span><span class="n">sem_t</span> <span class="o">*</span><span class="nf">sem_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="p">...</span>
  <span class="cm">/* mode_t mode, unsigned int value */</span> <span class="p">);</span>
</code></pre></div><p>        $sem_-open$ 创建一个有名信号量或者打开一个有名信号量。有名信号量既可以用于线程间同步，又可以用于进程间同步。$oflag$ 参数可以是 $0$ 、$O_-CREAT$ 或 $O_-CREAT$ | $O_-EXCL$ 。如果指定了 $O_-CREAT$ ，那么也要指定权限位 $mode$ 和信号量初始值 $value$ 。信号量初始值不能超过 $SEM_-VALUE_-MAX$ ( 这个常值至少为 $32767$ )。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">sem_close</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_unlink</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div><p>        当进程终止时，内核会对仍然打开着的有名信号量执行关闭操作。关闭一个信号量只是减少其引用计数，并不会删除。如果想要删除一个信号量，需要调用 $sem_-unlink$ 函数。类似于 $unlink$ ，如果在调用 $sem_-unlink$ 时该信号量引用计数不为 $0$ ，依然会进行删除，但是析构会等到引用计数为 $0$ 时才会发生。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_trywait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_getvalue</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">valp</span><span class="p">);</span>
</code></pre></div><p>        $sem_-wait$ 测试指定信号量的值，如果大于 $0$ ，就将其减 $1$ 并返回；如果不大于 $0$ ，就会阻塞直到该值大于 $0$ ，然后减 $1$ 并返回。如果在阻塞的过程中被中断，$sem_-wait$ 会返回并设置 $EINTR$ 错误。考虑到可能使用同一信号量的其他线程的存在，测试并减 $1$ 这个过程是原子的。$sem_-trywait$ 是 $sem_-wait$ 的非阻塞版本，如果值不大于 $0$ ，它会返回并设置 $EAGAIN$ 错误。<br>
        当一个线程使用完信号量后，应该调用 $sem_-post$ 函数将信号值加 $1$ 。$sem_-getvalue$ 会在 $valp$ 中返回信号量的当前值。如果信号量非正值，那么返回值可能是 $0$ ，也可能是一个负数，其绝对值为阻塞在该信号量上的线程数。</p>
<h2 id="2-生产者-消费者问题">2. 生产者-消费者问题</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp">#define SEM_MUTEX &#34;mutex&#34;
</span><span class="cp">#define SEM_NEMPTY &#34;nempty&#34;
</span><span class="cp">#define SEM_NSTORED &#34;nstored&#34;
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">;</span>  <span class="c1">// read-only by producer and consumer
</span><span class="c1"></span><span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producer and consumer
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="n">sem_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="o">*</span><span class="n">nempty</span><span class="p">,</span> <span class="o">*</span><span class="n">nstored</span><span class="p">;</span>
<span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">,</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons1 &lt;#items&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// create three semaphores
</span><span class="c1"></span>  <span class="n">shared</span><span class="p">.</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">Sem_open</span><span class="p">(</span><span class="n">SEM_MUTEX</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span>
                          <span class="n">FILE_MODE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">shared</span><span class="p">.</span><span class="n">nempty</span> <span class="o">=</span> <span class="n">Sem_open</span><span class="p">(</span><span class="n">SEM_NEMPTY</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span>
                           <span class="n">FILE_MODE</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">shared</span><span class="p">.</span><span class="n">nstored</span> <span class="o">=</span> <span class="n">Sem_open</span><span class="p">(</span><span class="n">SEM_NSTORED</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span>
                            <span class="n">FILE_MODE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// create one producer thread and one consumer thread
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// wait for the two threads
</span><span class="c1"></span>  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// remove the semaphores
</span><span class="c1"></span>  <span class="n">Sem_unlink</span><span class="p">(</span><span class="n">SEM_MUTEX</span><span class="p">);</span>
  <span class="n">Sem_unlink</span><span class="p">(</span><span class="n">SEM_NEMPTY</span><span class="p">);</span>
  <span class="n">Sem_unlink</span><span class="p">(</span><span class="n">SEM_NSTORED</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// store i into circular buffer
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">[</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        上述程序声明 $3$ 个信号量。$mutex$ 保护共享缓冲区；$nempty$ 统计共享缓冲区中的空槽数；$nstored$ 统计共享缓冲区中的元素数。</p>
<h2 id="3-匿名信号量操作">3. 匿名信号量操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 成功返回0，出错返回-1 */</span>

<span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shared</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_destroy</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div><p>        匿名信号量是存储在内存中的信号量。匿名信号量通过 $sem_-init$ 初始化，如果 $shared$ 为 $0$ ，那么待初始化的信号量是在同一进程的各个线程间共享的，否则该信号量是在进程间共享的。当 $shared$ 为非零值时，信号量必须存放在某种类型的共享内存区中，从而能让多个进程访问。与 $sem_-open$ 一样，$value$ 指定信号量初始值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">;</span>  <span class="c1">// read-only by producer and consumer
</span><span class="c1"></span><span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores, not pointers
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">,</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons2 &lt;#items&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// initialize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">Set_concurrency</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="4-生产者-消费者问题多生产者和单个消费者">4. 生产者-消费者问题：多生产者和单个消费者</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp">#define MAXNTHREADS 100
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">,</span> <span class="n">nproducers</span><span class="p">;</span>  <span class="c1">// read-only by producer and consumer
</span><span class="c1"></span>
<span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producers and consumer
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">nput</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nputval</span><span class="p">;</span>
  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores, not pointers
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">];</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">],</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons3 &lt;#items&gt; &lt;#producers&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">nproducers</span> <span class="o">=</span> <span class="n">mi</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">MAXNTHREADS</span><span class="p">);</span>

  <span class="c1">// initialize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// create all producers and one consumer
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="n">nproducers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">// wait for all producers and the consumer
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;count[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">&gt;=</span> <span class="n">nitems</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// all done
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nput</span><span class="o">++</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="p">;</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>    <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nitems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error: buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]);</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        相较于单生产者单消费者的情况，生产者的循环会在放置了 $nitems$ 个值后终止。</p>
<h2 id="5-生产者-消费者问题多生产者和多消费者">5. 生产者-消费者问题：多生产者和多消费者</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 10
</span><span class="cp">#define MAXNTHREADS 100
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">nitems</span><span class="p">,</span> <span class="n">nproducers</span><span class="p">,</span> <span class="n">nconsumers</span><span class="p">;</span>  <span class="c1">// read-only
</span><span class="c1"></span>
<span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producers and consumers
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">buff</span><span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">nput</span><span class="p">;</span>  <span class="c1">// item number
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">nputval</span><span class="p">;</span>  <span class="c1">// value to store in buff[]
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">nget</span><span class="p">;</span>  <span class="c1">// item number
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">ngetval</span><span class="p">;</span>  <span class="c1">// value fetched from buff[]
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">prodcount</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">],</span> <span class="n">conscount</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">];</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">],</span> <span class="n">tid_consume</span><span class="p">[</span><span class="n">MAXNTHREADS</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: prodcons4 &lt;#items&gt; &lt;#producers&gt; &lt;#consumers&gt;&#34;</span><span class="p">);</span>
  <span class="n">nitems</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">nproducers</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">MAXNTHREADS</span><span class="p">);</span>
  <span class="n">nconsumers</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">MAXNTHREADS</span><span class="p">);</span>

  <span class="c1">// initalize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// create all producers and all consumers
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="n">nproducers</span> <span class="o">+</span> <span class="n">nconsumers</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">prodcount</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prodcount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nconsumers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">conscount</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conscont</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="c1">// wait for all producers and all consumers
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">nproducers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;producer count[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">prodcount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nconsumers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;consumer count[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">conscount</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">&gt;=</span> <span class="n">nitems</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// let consumers terminate
</span><span class="c1"></span>      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// all done
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">shared</span><span class="p">.</span><span class="n">nput</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nput</span><span class="o">++</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nputval</span><span class="o">++</span><span class="p">;</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>    <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shard</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">nget</span> <span class="o">&gt;=</span> <span class="n">nitems</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// all done
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">nget</span> <span class="o">%</span> <span class="n">NBUFF</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">shared</span><span class="p">.</span><span class="n">ngetval</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;error: buff[%d] = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">nget</span><span class="o">++</span><span class="p">;</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">ngetval</span><span class="o">++</span><span class="p">;</span>

    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>    <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        这里的生产者函数增添了一行，在检测到已经生产了 $nitems$ 个数据后，为了唤醒阻塞在 $nstored$ 上的线程，会在线程终止前递增 $nstored$ 信号值。同时我们修改消费者函数，每次消费前比较 $nget$ 和 $nitems$ ，确定是否完成所有消费。</p>
<h2 id="6-多缓冲区">6. 多缓冲区</h2>
<p>        在一些处理数据的程序中，我们可能会用到以下形式的循环：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fdin</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* process the data */</span>
  <span class="n">write</span><span class="p">(</span><span class="n">fdout</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        以上循环读入一行文件，并对其处理，然后写回一行输出。我们可以考虑将这个操作分为两个线程，一个线程负责读，另一个负责写。表面上看这可以改善程序的运行，其实不然，因为我们使用的还是同一个缓冲区，写线程还是要等待读线程完成。为了解决这个问题，我们可以使用两个缓冲区。同时，要注意大多数<code>Unix</code>内核检测出对一个文件的顺序读之后，不仅会读出我们需要的磁盘块的内容，还会顺便读取下一个磁盘块的内容，从而可以改善下次读取的操作时间。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define NBUFF 8
</span><span class="cp"></span>
<span class="k">struct</span> <span class="p">{</span>  <span class="c1">// data shared by producer and consumer
</span><span class="c1"></span>  <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="n">BUFFSIZE</span><span class="p">];</span>  <span class="c1">// a buffer
</span><span class="c1"></span>    <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">// count of #bytes in the buffer
</span><span class="c1"></span>  <span class="p">}</span> <span class="n">buff</span> <span class="p">[</span><span class="n">NBUFF</span><span class="p">];</span>  <span class="c1">// NBUFF of these buffers/counts
</span><span class="c1"></span>  <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">,</span> <span class="n">nempty</span><span class="p">,</span> <span class="n">nstored</span><span class="p">;</span>  <span class="c1">// semaphores
</span><span class="c1"></span><span class="p">}</span> <span class="n">shared</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>  <span class="c1">// input file to copy to stdout
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="o">*</span><span class="n">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">tid_produce</span><span class="p">,</span> <span class="n">tid_consume</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mycat2 &lt;pathname&gt;&#34;</span><span class="p">);</span>

  <span class="n">fd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>

  <span class="c1">// initalize three semaphores
</span><span class="c1"></span>  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NBUFF</span><span class="p">);</span>
  <span class="n">Sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// one producer thread, one consumer thread
</span><span class="c1"></span>  <span class="n">Set_concurrency</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// reader thread
</span><span class="c1"></span>  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid_consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consume</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// writer thread
</span><span class="c1"></span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_produce</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">Pthread_join</span><span class="p">(</span><span class="n">tid_consume</span><span class="p">.</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>
  <span class="n">Sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">produce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// wait for at least 1 empty slot
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="c1">// critical region
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span> <span class="o">=</span> <span class="n">Read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">,</span> <span class="n">BUFFSIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">NBUFF</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// circular buffer
</span><span class="c1"></span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// 1 more stored item
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">consume</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nstored</span><span class="p">);</span>  <span class="c1">// wait for at least 1 stored item
</span><span class="c1"></span>    <span class="n">Sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="c1">// critical region
</span><span class="c1"></span>    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">,</span> <span class="n">shared</span><span class="p">.</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">n</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">NBUFF</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// circular buffer
</span><span class="c1"></span>
    <span class="n">Sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shared</span><span class="p">.</span><span class="n">nempty</span><span class="p">);</span>  <span class="c1">// 1 more empty slot
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        本例子中由 $mutex$ 锁住的临界区是空的，如果我们的数据以链表形式而不是数组形式存储，那么这块区域可用于操作链表。</p>
<h2 id="7-信号量限制">7. 信号量限制</h2>
<p>        <code>POSIX</code>定义了两个信号量限制：</p>
<ul>
<li>$SEM_-NSEMS_-MAX$ ：一个进程可同时打开着的最大信号量 ( <code>POSIX</code>要求至少为 $256$ )；</li>
<li>$SEM_-VALUE_-MAX$ ：一个信号量的最大值 ( <code>POSIX</code>要求至少为 $32767$ )。</li>
</ul>
<p>        这两个常值通常定义在 &lt;$unistd.h$&gt; 头文件中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;SEM_NSEMS_MAX = %ld, SEM_VALUE_MAX = %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
    <span class="n">Sysconf</span><span class="p">(</span><span class="n">_SC_SEM_NSEMS_MAX</span><span class="p">),</span> <span class="n">Sysconf</span><span class="p">(</span><span class="n">_SC_SEM_VALUE_MAX</span><span class="p">));</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 21 16:43</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B19/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2022, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>