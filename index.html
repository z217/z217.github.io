<!DOCTYPE html>
<html lang="zh-CN"><head>
	<meta name="generator" content="Hugo 0.147.5">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="z217&#39;s blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/jquery.floatingscroll.css>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"
    integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src=https://z217blog.cn/js/jquery.floatingscroll.min.js></script>
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/navbutton.js></script>
<script src=https://z217blog.cn/js/lightswitcher.js></script>
<script src=https://z217blog.cn/js/toc.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn/><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>
        

        <a id="branding" href=https://z217blog.cn/>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a><br/>
        <a href="javascript:void(0)" id="scroll-top" onclick="scrollToTop()">回到顶部</a>
        <a href="javascript:void(0)" id="light-switcher">暗色模式</a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B5%E7%90%86%E8%A7%A3%E7%BC%96%E8%AF%91%E5%99%A8%E8%BD%AC%E6%8D%A2/">C&#43;&#43;协程（5）：理解编译器转换</a>
        
        
        <p>无栈协程介绍，翻译自 https://lewissbaker.github.io/</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2025 Apr 23 23:34
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&amp;C&#43;&#43;
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B4%E7%90%86%E8%A7%A3%E5%AF%B9%E7%A7%B0%E8%BD%AC%E7%A7%BB/">C&#43;&#43;协程（4）：理解对称转移</a>
        
        
        <p>无栈协程介绍，翻译自 https://lewissbaker.github.io/</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2024 Jan 28 23:45
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&amp;C&#43;&#43;
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B3%E7%90%86%E8%A7%A3promise/">C&#43;&#43;协程（3）：理解promise</a>
        
        
        <p>无栈协程介绍，翻译自 https://lewissbaker.github.io/</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2024 Jan 27 16:19
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&amp;C&#43;&#43;
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/">C&#43;&#43;协程（2）：理解co_await</a>
        
        
        <p>无栈协程介绍，翻译自 https://lewissbaker.github.io/</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2024 Jan 25 00:00
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&amp;C&#43;&#43;
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/">C&#43;&#43;协程（1）：协程理论</a>
        
        
        <p>无栈协程介绍，翻译自 https://lewissbaker.github.io/</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2024 Jan 23 23:59
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: C&amp;C&#43;&#43;
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B5%E7%90%86%E8%A7%A3%E7%BC%96%E8%AF%91%E5%99%A8%E8%BD%AC%E6%8D%A2/">C&#43;&#43;协程（5）：理解编译器转换</a></h1>
            <div class="post-content">
                
                
                <h2 id="介绍">介绍</h2>
<p>        之前的“理解C++协程”文章中讲到了编译器会对协程，以及它的 $co_-await$、$co_-yield$、$co_-return$ 表达式执行的不同类型的转换。这些文档描述了编译器如何将每个表达式翻译成底层的对多种自定义的点 / 用户定义的方法调用。</p>
<ol>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/">协程理论</a></li>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/">理解 $co_-await$</a></li>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B3%E7%90%86%E8%A7%A3promise/">理解 $promise$</a></li>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B4%E7%90%86%E8%A7%A3%E5%AF%B9%E7%A7%B0%E8%BD%AC%E7%A7%BB/">理解对称转移</a></li>
</ol>
<p>        然而，这些描述还有一部分你可能不太满意。它们对于“挂起点”的概念一笔带过，含糊地说成“协程在这里挂起”、“协程在这里恢复”，并没有详细说明它的含义，以及编译器是怎么实现的。<br>
        在这篇文章，我会把之前文章的所有概念更深入地讲解。我会把一个协程转换为底层等价的非协程、命令式的<code>C++</code>代码，来展示当协程执行到挂起点时发生了什么。<br>
        注意我不会描述某个特定编译器怎么把协程编译成机器码 ( 编译器在这方面会有些额外技巧 )，而是只描述一种可能的把协程转化成可移植的<code>C++</code>代码的方式。<br>
        警告：这次讨论会有点深！</p>
<h2 id="设置场景">设置场景</h2>
<p>        对于初学者，我们假设有一个基本的 $task$ 类型，同时作为 $awaitable$ 和协程的返回类型。为了简化，假设这个协程类型异步生成一个 $int$ 类型结果。<br>
        在这篇文章，我们会描述怎么把下面的协程代码转换为不包含任何协程关键字 $co_-await$、$co_-return$的<code>C++</code>代码，以便我们更好理解它的含义。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// Forward declaration of some other function. Its implementation is not relevant.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">task</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// A simple coroutine that we are going to translate to non-C++ code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_return</span> <span class="n">fx</span> <span class="o">*</span> <span class="n">fx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="定义-task-类型">定义 task 类型</h2>
<p>        首先，我们声明一个会被用到的 $task$ 类。<br>
        为了理解协程怎么转化成底层代码，我们不需要明白这个类型的方法定义。对它们的调用会被插入转换中。<br>
        这些方法的定义并不复杂，我会把它们作为读者理解以前文章的练习实践。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">task</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">awaiter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">promise_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">promise_type</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">promise_type</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">final_awaiter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">task</span> <span class="nf">get_return_object</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span> <span class="n">initial_suspend</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">final_awaiter</span> <span class="nf">final_suspend</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">unhandled_exception</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">return_value</span><span class="p">(</span><span class="kt">int</span> <span class="n">result</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">continuation_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">monostate</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&gt;</span> <span class="n">result_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">task</span><span class="p">(</span><span class="n">task</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">task</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">task</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">task</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">awaiter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="nf">awaiter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">awaite_ready</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">coro_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span> <span class="k">operator</span> <span class="nf">co_await</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">coro_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        这个 $task$ 类型的定义与<a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B3%E7%90%86%E8%A7%A3promise/">理解 $promise$</a>的相似。</p>
<h2 id="第一步确定-promise-类型">第一步：确定 promise 类型</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_return</span> <span class="n">fx</span> <span class="o">*</span> <span class="n">fx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        当编译器看到这个函数包含三个协程关键字 ( $co_-await$、$co_-yield$、$co_-return$ ) 中的一个时，它开始执行协程转换步骤。<br>
        第一步是确定协程的 $promise$ 类型。<br>
        这一步是通过把函数签名的返回类型和参数类型作为 $std$::$coroutine_traits$ 类型的模板参数判断的。<br>
        例如，我们的函数 $g$，返回类型为 $task$，有一个参数类型是 $int$，编译器会使用 $std$::$coroutine_-traits$&lt;$task$, $int$&gt;::$promise_-type$ 判断。<br>
        让我们定义个别名，方便以后使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">__g_promise_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_traits</span><span class="o">&lt;</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span></code></pre></div><p>        <strong>注意：我使用了两个下划线开始的类型名，表示这个符号是编译器内部生成的。这种符号是实现时保留的，并且不应该在你的代码中使用。</strong><br>
        现在，因为我们没有特例化 $std$::$coroutine_-traits$，这会导致主模板实例化，而主模板只是把内嵌的 $promise_-type$ 作为返回类型的 $promise_-type$ 的别名，在我们的例子中也就是解析为 $task$::$promise_-type$。</p>
<h2 id="第二步创建协程状态">第二步：创建协程状态</h2>
<p>        一个协程函数需要在挂起时保存协程状态、参数和局部变量，以便在后续恢复时保持可用。<br>
        这个状态，在<code>C++</code>标准中，被称为协程状态，通常分配在堆上。<br>
        让我们开始给协程 $g$ 定义个协程状态结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        协程状态包含了一系列不同的东西：</p>
<ul>
<li>$promise$ 对象</li>
<li>所有函数参数的副本</li>
<li>协程当前挂起所在的挂起点信息，以及如何恢复 / 销毁它</li>
<li>所有局部变量 / 跨挂起点的临时变量存储</li>
</ul>
<p>        让我们加上 $promise$ 对象和参数副本存储。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_promise_t</span> <span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        接着，我们加个构造函数来初始化这些数据成员。<br>
        回想一下，编译器会先尝试使用参数副本的左值引用来调用 $promise$ 的构造函数，如果不行，就会调用 $promise$ 的默认构造函数。<br>
        让我们创建一个简单的 $helper$ 来帮忙：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Params</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Promise</span> <span class="n">construct_promise</span><span class="p">(</span><span class="na">[[maybe_unused]]</span> <span class="n">Params</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">constructible_from</span><span class="o">&lt;</span><span class="n">Promise</span><span class="p">,</span> <span class="n">Params</span><span class="o">&amp;</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Promise</span><span class="p">(</span><span class="n">params</span><span class="p">...);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">Promise</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        因此，协程状态构造器看起来可能会像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">,</span> <span class="n">__promise</span><span class="p">(</span><span class="n">construct_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_promise_t</span> <span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        现在我们有了一个表示协程状态的类型雏形，我们可以通过在堆上分配一个 __$g_-state$ 实例，传递函数参数给它拷贝 / 移动的方式，构建出 $g\left(\right)$ 底层实现的雏形。<br>
        一些术语：我使用“启动函数” ( $ramp$ $function$ ) 指代协程初始化协程状态和准备开始执行协程的逻辑，就像一条进入协程体执行的坡道。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... implement rest of the ramp function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        注意我们的 $promise$ 类型没有重载 $operator$ $new$，所以我们会调用全局的 ::$operator$ $new$。<br>
        如果 $promise$ 类型重载了 $operator$ $new$，我们不会调用全局的 ::$operator$ $new$，而是先确认参数列表 $\left(size, paramLvalues&hellip;\right)$ 是否可以作为 $operator$ $new$ 的参数，如果可以的话，就使用这个参数列表调用；否则，我们只会使用 $\left(size\right)$ 参数列表调用。$operator$ $new$ 的访问协程函数参数列表的能力有时被称为“参数预览” ( $parameter$ $preview$ )，在你想要使用 $allocator$ 作为参数来给协程状态分配空间时很有用。<br>
        如果编译器发现 __$g_-promise_-t$::$operator$ $new$ 的实现，逻辑会被转换为以下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="n">__promise_allocate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="na">[[maybe_unused]]</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="k">requires</span> <span class="p">{</span> <span class="n">Promise</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">args</span><span class="p">...);</span> <span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Promise</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">args</span><span class="p">...);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Promise</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span><span class="o">*</span> <span class="n">state_mem</span> <span class="o">=</span> <span class="n">__promise_allocate</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">__g_state</span><span class="p">),</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="o">*</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span> <span class="o">=</span> <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="n">state_mem</span><span class="p">)</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">__g_promise_t</span><span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">state_mem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... implement rest of the ramp function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        同样，这个 $promise$ 类型没有定义静态函数成员 $get_-return_-object_-on_-allocation_-failure\left(\right)$。如果 $promise$ 类型定义了这个函数，这里的分配会使用 $std$::$nothrow_-t$ 形式的 $operator$ $new$，并且当分配返回 $nullptr$ 时返回 __$g_-promise_-t$::$get_-return_-object_-on_-allocation_-failure\left(\right)$。<br>
        即，看起来会像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="o">::</span><span class="k">new</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nothrow</span><span class="p">)</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">__g_promise_t</span><span class="o">::</span><span class="n">get_return_object_on_allocation_failure</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... implement rest of the ramp function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        为了简化剩下的例子，我们使用最简单的调用全局 ::$operator$ $new$ 内存分配函数。</p>
<h2 id="第三步调用-get_return_object">第三步：调用 get_return_object()</h2>
<p>        启动函数要做的下一件事是调用 $promise$ 对象的 $get_-return_-object\left(\right)$ 方法，获取启动函数的返回值。<br>
        返回值会作为局部变量存储，并在启动函数结束返回 ( 在其他步骤完成后 )。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... implement rest of ramp function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">return_value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        然而，$get_-return_-object\left(\right)$ 的调用可能抛出异常，这时我们想要释放协程状态分配的内存。一种比较好的方法是使用 $std$::$unique_-ptr$ 来管理，这样在后续操作抛出异常时，它会被释放：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">(</span><span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... implement rest of ramp function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">return_value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="第四步初始化挂起点">第四步：初始化挂起点</h2>
<p>        启动函数在调用 $get_-return_-object\left(\right)$ 之后的下一件事是开始执行协程体，协程体执行的第一件事是初始化挂起点，即等价于 $co_-await$ $promise.initial_-suspend\left(\right)$。<br>
        现在，理想的话，我们只需要让协程初始化挂起，然后实现恢复一个初始化挂起协程的启动。然而，初始化挂起点在处理协程以及协程状态的生命周期问题上，有一些奇怪的细节。这些是<code>C++20</code>发布前对初始化挂起点语义的一些后期调整，目的是修复一些存在的问题。<br>
        根据初始化挂起点的定义，如果一个异常从这些地方抛出：</p>
<ul>
<li>$initial_-suspend\left(\right)$ 的调用，</li>
<li>对返回的 $awaitable$ 的 $operator$ $co_-await\left(\right)$ ( 如果有定义 )，</li>
<li>调用 $awaiter$ 的 $await_-ready\left(\right)$，或者</li>
<li>调用 $awaiter$ 的 $await_-suspend\left(\right)$</li>
</ul>
<p>        那么异常会传播到启动函数的调用方，协程状态会被自动销毁。<br>
        如果一个异常从以下地方抛出：</p>
<ul>
<li>$await_-resume\left(\right)$ 调用，</li>
<li>$operator co_-await\left(\right)$ 返回对象的析构函数 ( 如果可用 )，或者</li>
<li>$initial_-suspend\left(\right)$ 返回对象的析构函数</li>
</ul>
<p>        那么异常会被协程体捕获，然后调用 $promise.unhandled_-exception\left(\right)$。<br>
        这意味着我们需要注意这部分的转换，一部分需要实现在启动函数，另一部分需要放在协程体。<br>
        而且，因为 $initial_-suspend\left(\right)$ 返回的对象和 $operator$ $co_-await$ 返回的对象 ( 可选的 ) 具有跨挂起点的生命周期 ( 它们会在协程挂起点前创建，恢复后销毁 )，这些对象的存储需要放在协程状态里。<br>
        在我们特别的例子中，$initial_-suspend\left(\right)$ 返回类型是 $std$::$suspend_-always$，后者是一个空的、平凡构造类型。然而，逻辑上我们还是需要在协程状态里保存这个对象的实例，所以我们会一直加上这部分存储，展示它如何工作。<br>
        这个对象只在调用 $initial_-suspend\left(\right)$ 的位置构造，所以我们需要新增一个确定类型的数据成员，允许我们显示地控制它的生命周期。<br>
        为了支持这些功能，我们先定义一个 $helper$ 类 $manual_-lifetime$，后者具有平凡的构造和析构函数，我们会在需要的时候显式地构造 / 析构存储在其中的值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">manual_lifetime</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">manual_lifetime</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Not copyable/movable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">manual_lifetime</span><span class="p">(</span><span class="k">const</span> <span class="n">manual_lifetime</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="p">(</span><span class="n">manual_lifetime</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">manual_lifetime</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">manual_lifetime</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Factory</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">requires</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">invocable</span><span class="o">&lt;</span><span class="n">Factory</span><span class="o">&amp;&gt;</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result_t</span><span class="o">&lt;</span><span class="n">Factory</span><span class="o">&amp;&gt;</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">&amp;</span> <span class="n">construct_from</span><span class="p">(</span><span class="n">Factory</span> <span class="n">factory</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_nothrow_invocable_v</span><span class="o">&lt;</span><span class="n">Factory</span><span class="o">&amp;&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*::</span><span class="k">new</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storage</span><span class="p">))</span> <span class="n">T</span><span class="p">(</span><span class="n">factory</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">destroy</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_nothrow_destructible_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launder</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storage</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">launder</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">storage</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">byte</span> <span class="n">storage</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        注意 $construct_-from\left(\right)$ 方法设计成接受<code>lambda</code>而不是接受构造函数参数。这让我们可以使用拷贝消除特性，就地通过函数调用结果初始化构造对象。如果使用构造函数参数，我们就需要进行一次不必要的移动构造函数。<br>
        现在我们可以通过 $manual_-lifetime$ 声明 $promise.initial_-suspend\left(\right)$ 返回的临时对象数据成员。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_promise_t</span> <span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        $std$::$suspend_-always$ 类型没有定义 $operator$ $co_-await\left(\right)$，所以我们不需要额外的内存保存其返回的临时对象。<br>
        一旦我们通过 $initial_-suspend\left(\right)$ 构造这个对象，我们就需要调用 $await_-ready\left(\right)$、$await_-suspend\left(\right)$ 和 $await_-resume\left(\right)$ 实现 $co_-await$ 表达式。<br>
        当调用 $await_-suspend\left(\right)$ 时，我们需要传递当前协程句柄。现在我们可以通过直接把 $promise$ 引用作为参数调用 $std$::$coroutine_-handle$&lt;__$g_-promise_-t$&gt;::$from_-promise\left(\right)$ 的方式实现。我们稍后再看看它的内部结构。<br>
        同样，$.await_-suspend\left(handle\right)$ 调用的结果类型是 $void$，因此不需要像 $bool$ 返回或者 $coroutine_-handle$ 返回那样考虑是否恢复当前协程或者另一个协程。<br>
        最终，所有 $std$::$suspend_-always$ $awaiter$ 的方法都是 $noexcept$ 的，我们不需要担心异常。如果它们可能会抛出异常，我们需要添加额外的代码保证临时的 $std$::$supsend_-always$ 对象在异常传播到启动函数之外前被销毁。<br>
        一旦 $await_-suspend\left(\right)$ 成功返回或者协程体准备开始执行时，如果有异常抛出，我们就不再需要自动销毁协程状态。所以我们可以调用持有协程状态的 $std$::$unique_-ptr$ 的 $release\left(\right)$ 来避免当我们从函数返回时协程状态的自动销毁。<br>
        所以现在我们可以实现初始化挂起表达式的第一部分：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">(</span><span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ... suspend-coroutine here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// fall through to return statement below.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Coroutine did not suspend.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ... start executing the coroutine body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">__return_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        $await_-resume\left(\right)$ 调用和 __$tmp1$ 的析构函数会在协程体出现，所以不会在启动函数出现。<br>
        现在我们有了一个 ( 大部分 ) 功能等价的初始化挂起点逻辑，但启动函数仍然有一系列 TODO。为了解决这些，我们首先需要绕道研究一下挂起然后恢复一个协程的策略。</p>
<h2 id="第五步记录挂起点">第五步：记录挂起点</h2>
<p>        当协程挂起时，需要确保恢复点与之前的挂起点相同。<br>
        此外，还需要跟踪每个挂起点上自动生命周期对象的存活状态，以便之后协程如果被销毁而不是挂起时，知道需要销毁哪些对象。<br>
        一种实现方式是给每个挂起点一个唯一编号，然后在协程状态使用一个整型数据成员存储。<br>
        无论什么时候，当一个协程挂起，它需要把当前挂起点编号写入协程状态，在之后恢复 / 销毁的时候，根据这个整型来找到之前的挂起点。<br>
        注意这不是通过协程状态存储挂起点的唯一方法，然而，主流的三个编译器 ( <code>MSVC</code>、<code>Clang</code>和<code>GCC</code> ) 在这篇文章发布 ( $2022$ 年 ) 的时候都采用了这个方法。另一个可能的解决办法是每个挂起点都使用不同的恢复 / 销毁函数指针，但这篇文章不会讲解这个办法。<br>
        那么让我们来扩展协程状态，使用一个整型数据成员来保存挂起点下标，并初始化为 $0$ ( 我们把使用值表示初始化挂起点 )。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_promise_t</span> <span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// &lt;-- add the suspend-point index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h2 id="第六步实现-coroutine_handleresume-和-coroutine_handledestory">第六步：实现 coroutine_handle::resume() 和 coroutine_handle::destory()</h2>
<p>        当协程被 $coroutine_-handle$::$resume\left(\right)$ 调用恢复时，我们需要调用某些函数实现被挂起协程的剩余部分，被调用的函数查找挂起点下标，然后跳转到控制流中的适当位置。<br>
        此外，我们需要实现 $coroutine_-handle$::$destroy\left(\right)$ 函数，通过合适的逻辑销毁当前挂起点作用内的对象。然后我们需要实现 $coroutine_-handle$::$done\left(\right)$ 来确认当前挂起点是否为最终挂起点。<br>
        $coroutine_-handle$ 方法接口不知道协程状态的具体类型，$coroutine_-handle$&lt;$void$&gt; 类型可以指向任何协程实例。这意味着我们需要以类型被擦除的协程状态实现。<br>
        我们可以存储指向协程类型的恢复 / 销毁函数指针，并让 $coroutine_-handle$::$resume$ / $destroy\left(\right)$ 调用这些函数指针。<br>
        $coroutine_-handle$ 类型同样需要实现通过 $coroutine_-handle$::$address\left(\right)$ 转换为 $void*$，和通过 $coroutine_-handle$::$from_-address\left(\right)$ 转换为 $void*$。<br>
        进一步，协程可以被任意一个指向它的句柄恢复 / 销毁，不只是最近一个传给 $await_-suspend\left(\right)$ 调用的。<br>
        这些要求让我们定义的 $coroutine_-handle$ 类型只能包含一个指向协程状态的指针，在状态里通过数据成员存储恢复 / 销毁函数指针，而不是把恢复 / 销毁函数指针存在 $coroutine_-handle$ 里。<br>
        同样，因为我们需要 $coroutine_-handle$ 能够指向任意协程状态对象，所以所有协程状态类型的函数指针数据成员应该保持一致。<br>
        一种直接方法是让协程状态类型继承一些包含这些数据成员的基类。<br>
        例如，我们可以定义以下类型作为所有协程状态类型的基类：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__coroutine_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__resume_fn</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__destroy_fn</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">__resume_fn</span><span class="o">*</span> <span class="n">__resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__destroy_fn</span><span class="o">*</span> <span class="n">__destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        这样 $coroutine_-handle$::$resume\left(\right)$ 可以直接叫 __$resume\left(\right)$，使用 __$coroutine_-state$ 指针作为参数。$coroutine_-handle$::$destroy\left(\right)$ 和 __$destroy\left(\right)$ 函数指针也是一样。<br>
        对于 $coroutine_-handle$::$done\left(\right)$ 方法，我们选择一个空 __$resume\left(\right)$ 函数指针表示最终挂起点。这种方法很方便，因为最终挂起点不支持 $resume\left(\right)$，只支持 $destroy\left(\right)$。如果尝试对一个在最终挂起点挂起的协程调用 $resume\left(\right)$ ( 这是未定义行为 )，那么会调用一个空函数指针，这会失败并且能快速指出错误。<br>
        基于这些，我们可以实现 $coroutine_-handle$&lt;$void$&gt;：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">coroutine_handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_handle</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_handle</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_handle</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">state_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">coroutine_handle</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">h</span><span class="p">.</span><span class="n">state_</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">coroutine_handle</span> <span class="n">a</span><span class="p">,</span> <span class="n">coroutine_handle</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">state_</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">resume</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state_</span><span class="o">-&gt;</span><span class="n">__resume</span><span class="p">(</span><span class="n">state_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state_</span><span class="o">-&gt;</span><span class="n">__destroy</span><span class="p">(</span><span class="n">state_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state_</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">state_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="第七步实现-coroutine_handlepromisepromise-和-from_promise">第七步：实现 coroutine_handle&lt;Promise&gt;::promise() 和 from_promise()</h2>
<p>        对于更通用的 $coroutine_-handle$&lt;$Promise$&gt; 特例化，大部分实现都可以复用 $coroutine_-handle$&lt;$void$&gt; 实现。然而，我们也需要通过 $promise\left(\right)$ 方法的返回，访问协程状态的 $promise$ 对象，以及从 $promise$ 对象引用构造出一个 $coroutine_-handle$ 。<br>
        然而，因为 $coroutine_-handle$&lt;$Promise$&gt; 类型必须能指向任何 $promise$ 类型是 $Promise$ 的协程状态，因此我们无法简单从指针获取具体协程类型。<br>
        我们需要定义一个新的协程状态基类继承 __$coroutine_-state$，前者应当包含 $promise$ 对象，这样我们就可以定义所有使用特定 $promise$ 类型的协程状态类型，并让它们继承基类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__coroutine_state_with_promise</span> <span class="o">:</span> <span class="n">__coroutine_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__coroutine_state_with_promise</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__coroutine_state_with_promise</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Promise</span> <span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        你可能好奇为什么 __$promise$ 成员会定义在一个匿名的 $union$ 里面……<br>
        原因是派生类是为特定的包含参数副本数据成员的协程函数创建的。派生类的数据成员默认会在所有基类数据成员后初始化，所以把 $promise$ 对象声明为普通数据成员意味着它会在参数副本数据成员之前被构造。<br>
        然而，我们需要 $promise$ 的构造函数在参数副本构造函数之后调用，因为参数副本引用可能会被传给 $promise$ 构造函数。<br>
        因此，我们在基类中为 $promise$ 对象保留空间，这样它们就在协程状态内部有一个一致的偏移量，并在参数副本被初始化后的合适点位，调用派生类的构造 / 析构函数。这种控制是通过把 $promise$ 声明为 $union$ 成员实现的。<br>
        让我们更新 __$g_-state$ 类型，继承新的基类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">__x</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Use placement-new to intialise the promise object in the base-class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">::</span><span class="k">new</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="n">__g_promise_t</span><span class="p">(</span><span class="n">construct_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__g_state</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Also need to manually call the promise destructor before the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// argument objects are destroyed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="o">~</span><span class="n">__g_promise_t</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// to be filled out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        现在我们已经定义了 $promise$ 基类，可以开始实现 $std$::$coroutine_-handle$&lt;$Promise$&gt; 类模板。<br>
        大部分实现都很像 $coroutine_-handle$&lt;$void$&gt;，除了使用 __$coroutine_-state_-with_-promise$&lt;$Promise$&gt; 指针而不是 __$coroutine_-state$ 指针。<br>
        新增部分只有 $promise\left(\right)$ 和 $from_-promise\left(\right)$ 函数。</p>
<ul>
<li>$promise\left(\right)$ 方法直接返回协程状态的 __$promise$ 成员。</li>
<li>$from_-promise\left(\right)$ 方法需要我们从 $promise$ 对象地址计算出协程状态对象地址。我们只需要从 $promise$ 对象地址中减去 __$promise$ 成员的偏移量就可以了。</li>
</ul>
<p>        $coroutine_-handle$&lt;$Promise$&gt; 的实现是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">coroutine_handle</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">state_t</span> <span class="o">=</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">Promise</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_handle</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_handle</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">coroutine_hanlde</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">operator</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">from_address</span><span class="p">(</span><span class="n">address</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">coroutine_handle</span> <span class="n">a</span><span class="p">,</span> <span class="n">coroutine_handle</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">state_</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">state_</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">coroutine_handle</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">h</span><span class="p">.</span><span class="n">state_</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">state_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state_</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_promise</span><span class="p">(</span><span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">coroutine_handle</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// We know the address of the __promise member, so calculate the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// address of the coroutine-state by subtracting the offset of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the __promise field from this address.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">h</span><span class="p">.</span><span class="n">state_</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">state_t</span><span class="o">*&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">promise</span><span class="p">)</span> <span class="o">-</span>
</span></span><span class="line"><span class="cl">        <span class="n">offsetof</span><span class="p">(</span><span class="n">state_t</span><span class="p">,</span> <span class="n">__promise</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Define these in terms of their coroutine_handle&lt;void&gt; implementations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">resume</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">done</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">state_t</span><span class="o">*</span> <span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        现在已经定义了协程恢复机制，我们可以回到启动函数，并实现初始化我们往协程状态新加的函数指针数据成员。</p>
<h2 id="第八步函数体开始部分">第八步：函数体开始部分</h2>
<p>        现在我们前向声明具有正确签名的恢复/销毁函数，并更新 __$g_-state$ 构造函数来初始化协程状态，以便恢复/销毁函数指针指向它们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">__x</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialise the function-pointers used by coroutine_handle methods.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__g_resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__destroy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__g_destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Use placement-new to intialise the promise object in the base-class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">::</span><span class="k">new</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="n">__g_promise_t</span><span class="p">(</span><span class="n">construct_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ... rest omitted for brevity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">(</span><span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// fall through to return statement below.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Coroutine did not suspend. Start executing the body immediately.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__g_resume</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">return_value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        完成了启动函数部分后，我们可以开始看 $g\left(\right)$ 的恢复/销毁函数。<br>
        让我们继续转换初始化挂起表达式。<br>
        当 __$g_-resume\left(\right)$ 被调用且 __$suspend_-point$ 的下标是 $0$，我们就需要调用 __$tmp1$ 的 $await_-resume\left(\right)$，并在之后调用 $tmp1$ 的析构函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// We know that &#39;s&#39; points to a __g_state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Generate a jump-table to jump to the correct place in the code based
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on the value of the suspend-point index.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO: Implement rest of coroutine body.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// int fx = co_await f(x);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// co_return fx * fx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        当 __$g_-destroy\left(\right)$ 被调用且 __$suspend_-point$ 下标是 $0$，我们要在销毁和释放协程状态前销毁 __$tmp1$。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO: Add extra logic for other suspend-points here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">destroy_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="第九步转换-co_await-表达式">第九步：转换 <code>co_await</code> 表达式</h2>
<p>        接着，我们看看怎么转换 $co_-await$ $f\left(x\right)$ 表达式。<br>
        首先我们来看看一个返回 $task$ 临时对象的 $f\left(x\right)$。<br>
        因为临时的 $task$ 直到语句结尾的分号才会被销毁，而且语句含有 $co_-await$ 表达式，$task$ 的生命周期会扩散出挂起点，因此它需要存储在协程状态中。<br>
        当计算这个临时 $task$ 的 $co_-await$ 表达式时，我们需要调用返回临时 $awaiter$ 对象的 $operator$ $co_-await\left(\right)$ 方法。这个对象的生命周期也扩散出挂起点，所以也要保存在协程状态中。<br>
        让我们给 __$g_-state$ 类型加上必要成员：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__g_state</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&gt;</span> <span class="n">__tmp2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="o">&gt;</span> <span class="n">__tmp3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        然后我们可以更新 __$g_-resume\left(\right)$ 函数来初始化这些临时对象，接着再计算 $co_-await$ 表达式包含的 $await_-ready$、$await_-suspend$ 和 $await_-resume$ 这 $3$ 个调用。<br>
        注意 $task$::$awaiter$::$await_-suspend\left(\right)$ 方法返回协程句柄，因此我们需要生成恢复返回句柄的代码。<br>
        我们也需要再调用 $await_-suspend\left(\right)$ 之前更新挂起点下标 ( 使用下标 $1$ )，然后给跳表添加额外的条目，确保在正确的位置恢复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// We know that &#39;s&#39; points to a __g_state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Generate a jump-table to jump to the correct place in the code based
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on the value of the suspend-point index.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>  <span class="c1">// &lt;-- add new jump-table entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// int fx = co_await f(x);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">construct_from</span><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">get</span><span class="p">()).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// mark the suspend-point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Resume the returned coroutine_handle before returning.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">h</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TOOD: Implement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// co_return fx * fx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        注意 $int$ $fx$ 局部变量生命周期没有扩散出挂起点，因此它不需要存储在协程状态中。我们可以把它作为一个普通的 __$g_-resume$ 函数局部变量。<br>
        我们也需要给 __$g_-destroy\left(\right)$ 函数添加必要的条目来处理协程在挂起点销毁的情况。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>  <span class="c1">// &lt;-- add new jump-table entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO: Add extra logic for other suspend-ponits here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">destroy_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        这样我们就完成了语句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span></code></pre></div><p>        然而，函数 $f\left(\right)$ 并没有标为<code>noexcept</code>，意味着它可能抛出异常。同样，$awaiter$::$await_-resume\left(\right)$ 方法也没有标为<code>noexcept</code>，也可能抛出异常。<br>
        当协程体抛出异常时，编译器生成代码来捕获，然后调用 $promise$.$unhandled_-exception\left(\right)$ 来给 $promise$ 机会对异常做些事情。我们来看看这方面的实现。</p>
<h2 id="第十步实现-unhandled_exception">第十步：实现 <code>unhandled_exception()</code></h2>
<p>        协程定义规范 <a href="https://eel.is/c++draft/dcl.fct.def.coroutine">dcl.fct.def.coroutine</a> 中说，协程的行为就好像它的函数体被替换为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">promise</span><span class="o">-</span><span class="n">type</span> <span class="n">promise</span> <span class="n">promise</span><span class="o">-</span><span class="n">constructor</span><span class="o">-</span><span class="n">arguments</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">function</span><span class="o">-</span><span class="n">body</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intiali</span><span class="o">-</span><span class="n">await</span><span class="o">-</span><span class="n">resume</span><span class="o">-</span><span class="n">called</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span><span class="o">-</span><span class="nl">suspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        我们已经单独处理了启动函数中的 $initial-await_-resume-called$ 分支，所以我们不需要关注这块。<br>
        来让我们调整 __$g_-resume\left(\right)$ 函数体，插入<code>try/catch</code>块。<br>
        注意我们需要小心放置 $switch$，跳转到<code>try</code>块的正确位置，因为我们不允许通过 $goto$ 进入一个<code>try</code>块。<br>
        同样，我们需要谨慎地对 $await_-suspend\left(\right)$ 返回的在<code>try/catch</code>块外的协程句柄调用 $.resume\left(\right)$。如果一个返回的协程的 $.resume\left(\right)$ 抛出了异常，它不应被当前协程捕获，而是传播给调用 $resume\left(\right)$ 恢复它的协程。因此我们在函数开头声明一个存储协程句柄的变量，然后 $goto$ 到<code>try/catch</code>之外的位置，执行 $.resume\left(\right)$ 调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">coro_to_resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>  <span class="c1">// &lt;-- add new jump-table entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// int fx = co_await f(x);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">get</span><span class="p">()).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">coro_to_resume</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">resume_coro</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Implement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// co_return fx * fx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">final_suspend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">final_suspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO: Implement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// co_await promise.final_suspend();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">resume_coro</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">coro_to_resume</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        上面的代码有个 bug。当 __$tmp3$.$get\left(\right)$.$await_-resume\left(\right)$ 调用因为异常退出，我们会在没有调用 __$tmp3$ 和 __$tmp2$ 的析构函数情况下捕获异常。<br>
        注意我们不能简单地捕获异常，调用析构函数然后重新抛出异常，因为这样会改变这些析构函数的行为，相当于在调用 $std$::$unhandled_-exceptions\left(\right)$ 前“处理”了异常。如果在异常展开时调用析构函数，那么 $std$::$unhandled_-exceptions\left(\right)$ 应该返回非零值。<br>
        我们可以定义个<code>RAII</code>辅助类确保当异常抛出，退出作用域时析构函数被调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">destructor_guard</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">destructor_guard</span><span class="p">(</span><span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">ptr_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// non-movable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">destructor_guard</span><span class="p">(</span><span class="n">destructor_guard</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">destructor_guard</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">destructor_guard</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">destructor_guard</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_nothrow_destructible_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ptr_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ptr_</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">cancel</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">ptr_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">ptr_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Partial specialisation for types that don&#39;t need their destructors called.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_trivially_destrcutible_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">destructor_guard</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="nf">destructor_guard</span><span class="p">(</span><span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">cancel</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Class-template argument deduction to simplify usage
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">destructor_guard</span><span class="p">(</span><span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">destructor_guard</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</span></span></code></pre></div><p>        通过这个工具，我们现在可以确保当异常抛出时协程状态中的变量被正确析构。<br>
        让我们对其他变量也使用这个类，确保当退出作用域时它们的析构函数也会被调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">coro_to_resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>  <span class="c1">// &lt;-- add new jump-table entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp1_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// int fx = co_await f(x);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp2_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">get</span><span class="p">()).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp3_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">coro_to_resume</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// A coroutine suspends without exiting scopes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// So cancel the destructor-guards.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">tmp3_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp2_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">resume_coro</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Don&#39;t exit the scope here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// We can&#39;t &#39;goto&#39; a label that enters the scope of a variable with a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// non-trivial destructor. So we have to exit the scope of the destructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// guards here without calling the destructors and then recreate them after
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the `suspend_point_1` label.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">tmp3_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">tmp2_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp2_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp3_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Implement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// co_return fx * fx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">final_suspend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">final_suspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO: Implement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// co_await promise.final_suspend();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nl">resume_coro</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">coro_to_resume</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        现在我们的协程体会在任何异常出现的地方正确销毁局部变量，并且会在这些异常传播出协程体时正确调用 $promise$.$unhandled_-exception\left(\right)$。<br>
        要注意的是，如果 $promise$.$unhandled_-exception\left(\right)$ 方法自身因为异常退出 ( 例如重新抛出当前异常 ) 时，可能需要特殊处理。<br>
        在这种情况，协程需要捕获异常，标记为在最终挂起点挂起，然后重抛异常。<br>
        例如，__$g_-resume\left(\right)$ 函数的<code>catch</code>块会像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// mark as final-suspend-point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">throw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        然后我们需要给 __$g_-destroy$ 函数跳表增加额外条目：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>  <span class="c1">// no variables in scope that need to be destroyed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                             <span class="c1">// just destroy the coroutine-state object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>        注意这个例子中，最终挂起点并不是必须跟 $co_-await$ $promise$.$final_-suspend\left(\right)$ 的挂起点一样。<br>
        这是因为 $promise$.$final_-suspend\left(\right)$ 挂起点通常有些额外的与 $co_-await$ 表达式相关的临时对象，这些对象需要在 $coroutine_-handle$::$destroy\left(\right)$ 调用时销毁。而在这里，如果 $promise$.$unhandled_-exception\left(\right)$ 因为异常退出，这些对象不再存活，所以不需要被 $coroutine_-handle$::$destroy\left(\right)$ 销毁。</p>
<h2 id="第十一步实现-co_return">第十一步：实现 <code>co_return</code></h2>
<p>        下一步是实现 $co_-return$ $fx$ $*$ $fx;$ 语句。<br>
        与前面相比，这一步相对简单。<br>
        $co_-return$ &lt;$expr$&gt; 语句会映射成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">promise</span><span class="p">.</span><span class="n">return_value</span><span class="p">(</span><span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">goto</span> <span class="k">final</span><span class="o">-</span><span class="n">suspend</span><span class="o">-</span><span class="n">point</span><span class="p">;</span>
</span></span></code></pre></div><p>        所以我们可以简单地把 TODO 注释替换成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">return_value</span><span class="p">(</span><span class="n">fx</span> <span class="o">*</span> <span class="n">fx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">goto</span> <span class="n">final_suspend</span><span class="p">;</span>
</span></span></code></pre></div><p>        简单。</p>
<h2 id="第十二步实现-final_suspend">第十二步：实现 <code>final_suspend()</code></h2>
<p>        代码的最后一个 TODO 是实现 $co_-await$ $promise$.$final_-suspend\left(\right)$ 语句。<br>
        $final_-suspend\left(\right)$ 方法返回一个临时的 $task$::$promise_-type$::$final_-awaiter$ 类型，后者存储在协程状态中，并在 __$g_-destroy$ 内销毁。<br>
        这个类型没有重载 $operator$ $co_-await\left(\right)$，所以我们不需要额外的临时对象存储调用结果。<br>
        就像 $task$::$awaiter$ 类型，它也通过 $await_-suspend\left(\right)$ 返回协程句柄。所以我们需要确保对返回的句柄调用 $resume\left(\right)$。<br>
        如果协程没有在最终挂起点挂起，那么协程状态会被隐式销毁。所以我们需要在执行到协程结束时，删除状态对象。<br>
        而且，因为所有的最终挂起逻辑需要是<code>noexcept</code>的，我们不需要担心这里的子表达式会抛出异常。<br>
        我们先给 __$g_-state$ 类型加上数据成员。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">__x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__g_state</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&gt;</span> <span class="n">__tmp2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="o">&gt;</span> <span class="n">__tmp3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">promise_type</span><span class="o">::</span><span class="n">final_awaiter</span><span class="o">&gt;</span> <span class="n">__tmp4</span><span class="p">;</span>  <span class="c1">// &lt;---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>        然后我们可以像下面这样实现最终挂起表达式体：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="nl">final_suspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// co_await promise.final_suspend
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">destructor_guard</span> <span class="n">tmp4_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// mark as final suspend-point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="n">coro_to_resume</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">tmp4_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">goto</span> <span class="n">resume_coro</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Destroy coroutine-state if execution flows off end of coroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span><span class="p">;</span>
</span></span></code></pre></div><p>        接着我们需要更新 __$g_-destroy$ 函数来处理新的挂起点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">destroy_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        现在我们有了一个完整的 $g\left(\right)$ 协程函数转换结果。<br>
        结束了！<br>
        还是……</p>
<h2 id="第十三步实现对称转移和无操作协程">第十三步：实现对称转移和无操作协程</h2>
<p>        我们上面实现的 __$g_-resume\left(\right)$ 函数方式有个问题。<br>
        之前的文章中有详细讨论过，所以如果你想了解更多，可以查看<a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B4%E7%90%86%E8%A7%A3%E5%AF%B9%E7%A7%B0%E8%BD%AC%E7%A7%BB/">C++协程（4）：理解对称转移</a>。<br>
        <a href="https://eel.is/c++draft/expr.await">expr.await</a> 规范给了一点关于我们应该怎么处理返回协程句柄的 $await_-suspend$ 的线索：</p>
<blockquote>
<p>如果 $await_-suspend$ 类型时 $std$::$coroutine_-handle$&lt;$Z$&gt;，会调用 $.resume\left(\right)$。<br>
备注1：这会恢复 $await_-suspend$ 返回的协程。可以用这种方式连续恢复任意数量的协程，最终控制流会返回给现在协程的调用者/恢复者。</p></blockquote>
<p>        这个备注，虽然不是规范，也不是约束，但是十分鼓励编译器以尾调用方式实现恢复协程，而不是递归方式。因为在协程循环恢复对方的过程中，递归方式很容易导致栈无限制增长。<br>
        问题原因是我们是在 __$g_-resume\left(\right)$ 函数体内调用下一个协程的 $.resume\left(\right)$ 然后返回，因此 __$g_-resume\left(\right)$ 的栈帧会在下一个协程挂起返回后才会释放。<br>
        编译器可以把恢复下一个协程优化为尾调用。以这种方式，编译器生成的代码会先弹出当前栈帧，保留返回地址，然后执行 $jmp$ 指令跳转到下一个协程的恢复函数。<br>
        因为<code>C++</code>并没有机制让尾部位置的函数调用变成尾调用，我们需要从恢复函数中返回来释放栈空间，然后让调用者恢复下一个协程。<br>
        下一个协程也可能需要在挂起时恢复另一个协程，而且这种恢复可能会无限下去，所以调用者需要在循环中恢复协程。<br>
        这种循环通常叫做<em><strong>蹦床循环</strong></em> ( $trampoline$ $loop$ )，因为我们从一个协程回到循环然后再跳到下一个协程。<br>
        如果我们把恢复函数的签名改成返回指向下个协程状态的指针，而不是 $void$，那么 $coroutine_-handle$::$resume\left(\right)$ 函数可以立即调用下个协程的 __$resume\left(\right)$ 指针来恢复它。<br>
        我们改一下 __$coroutine_-state$ 的 __$resume_-fn$ 的签名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__coroutine_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__resume_fn</span> <span class="o">=</span> <span class="n">__coroutine_state</span><span class="o">*</span> <span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__destroy_fn</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">__resume_fn</span><span class="o">*</span> <span class="n">__resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__destroy_fn</span><span class="o">*</span> <span class="n">__destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        然后我们可以像这样编写 $coroutine_-handle$::$resume\left(\right)$：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">resume</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">__resume</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="cm">/*some condition*/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        下个问题是：“循环条件是什么？”<br>
        这时就轮到 $std$::$noop_-coroutine\left(\right)$ 帮忙了。<br>
        $std$::$noop_-coroutine$ 是一个工厂函数，返回一个特殊协程句柄，具有无操作的 $resume\left(\right)$ 和 $destroy\left(\right)$ 方法。如果一个协程挂起，并且 $await_-suspend\left(\right)$ 返回无操作句柄，意味着没有协程需要恢复，它的 $coroutine_-handle$::$resume\left(\right)$ 会返回给调用者。<br>
        所以我们需要实现 $std$::$noop_-coroutine\left(\right)$ 以及 $coroutine_-handle$::$resume\left(\right)$ 条件，让 __$coroutine_-state$ 指针指向无操作协程状态时变为 $false$ 并退出循环。<br>
        一种策略是定义一个静态 __$coroutine_-state$ 变量，作为无操作协程状态。$std$::$noop_-coroutine\left(\right)$ 函数可以返回一个指向该对象的协程句柄，然后我们可以比较 __$coroutine_-state$ 指针和那个对象的地址，判断协程句柄是否为无操作协程。<br>
        首先我们定义这个特殊的无操作协程状态对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__coroutine_state</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__resume_fn</span> <span class="o">=</span> <span class="n">__coroutine_state</span><span class="o">*</span> <span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">__destroy_fn</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">__resume_fn</span><span class="o">*</span> <span class="n">__resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">__destroy_fn</span><span class="o">*</span> <span class="n">__destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">__coroutine_state</span><span class="o">*</span> <span class="nf">__noop_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">state</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span> <span class="nf">__noop_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="k">const</span> <span class="n">__coroutine_state</span> <span class="n">__noop_coroutine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="k">const</span> <span class="n">__coroutine_state</span> <span class="n">__coroutine_state</span><span class="o">::</span><span class="n">__noop_coroutine</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">&amp;</span><span class="n">__coroutine_state</span><span class="o">::</span><span class="n">__noop_resume</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="o">&amp;</span><span class="n">__coroutine_state</span><span class="o">::</span><span class="n">__noop_destroy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        然后我们可以特例化实现 $std$::$coroutine_-handle$&lt;$noop_-coroutine_-promise$&gt;。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">noop_coroutine_promise</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">noop_coroutine_handle</span> <span class="o">=</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">noop_coroutine_promise</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">noop_coroutine_handle</span> <span class="nf">noop_coroutine</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">coroutine_handle</span><span class="o">&lt;</span><span class="n">noop_coroutine_promise</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="n">coroutine_handle</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=*</span><span class="p">(</span><span class="k">const</span> <span class="n">coroutine_handle</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">coroutine_handle</span><span class="p">,</span> <span class="n">coroutine_handle</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">operator</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">from_address</span><span class="p">(</span><span class="n">address</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">noop_coroutine_promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">static</span> <span class="n">noop_coroutine_promise</span> <span class="n">promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">resume</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__coroutine_state</span><span class="o">::</span><span class="n">__noop_coroutine</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="n">coroutine_handle</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">friend</span> <span class="n">noop_coroutine_handle</span> <span class="nf">noop_coroutine</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        然后我们可以更新 $coroutine_-handle$::$resume\left(\right)$，在返回无操作协程状态时退出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">resume</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">state_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">__resume</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">__coroutine_state</span><span class="o">::</span><span class="n">__noop_coroutine</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        最后，我们可以更新 __$g_-resume\left(\right)$ 返回 __$coroutine_-state*$。<br>
        这部分只涉及更新签名并替换：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">coro_to_resume</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl"><span class="k">goto</span> <span class="n">resume_coro</span><span class="p">;</span>
</span></span></code></pre></div><p>        以及</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">address</span><span class="p">());</span>
</span></span></code></pre></div><p>        并在函数的最后面 ( $delete$ $state;$ 语句之后 ) 添加：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">noop_coroutine</span><span class="p">().</span><span class="n">address</span><span class="p">());</span>
</span></span></code></pre></div><h2 id="最后一件事">最后一件事</h2>
<p>        细心的人可能发现了，协程状态类型 __$g_-state$ 要比需要的大。<br>
        $4$ 个存储临时值的数据成员分别为它们的值保留了空间。然而，一些临时值的生命周期并不重叠，所以理论上可以通过在对象生命周期结束后，给下一个对象重复使用空间的方式，节省空间。<br>
        为了利用这点，我们可以把数据成员定义在一个合适的匿名<code>union</code>中。<br>
        看一下我们现在的临时变量生命周期：</p>
<ul>
<li>__$tmp1$ - 只在 $co_-await$ $promise$.$initial_-suspend\left(\right);$ 语句存活</li>
<li>__$tmp2$ - 只在 $int$ $fx$ $=$ $co_-await$ $f\left(x\right);$ 语句存活</li>
<li>__$tmp3$ - 只在 $int$ $fx$ $=$ $co_-await$ $f\left(x\right);$ 语句存活 - 生命周期内嵌于 __$tmp2$</li>
<li>__$tmp4$ - 只在 $co_-await$ $promise$.$final_-suspend\left(\right);$ 语句存活</li>
</ul>
<p>        因为 __$tmp2$ 和 __$tmp3$ 的生命周期重启，我们必须把它们一起放在同一个<code>struct</code>，保证同时间它们都存活。<br>
        然而，__$tmp1$ 和 __$tmp4$ 成员生命周期不重叠，所以可以一起放在匿名<code>union</code>中。<br>
        因此，我们可以把数据成员定义改成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__g_state</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">__scope1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&gt;</span> <span class="n">__tmp2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">manula_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="o">&gt;</span> <span class="n">__tmp3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">manul_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__scope1</span> <span class="n">__s1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">promise_type</span><span class="o">::</span><span class="n">final_awaiter</span><span class="o">&gt;</span> <span class="n">__tmp4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        然后，因为 __$tmp2$ 和 __$tmp3$ 变量都内嵌在 __$s1$ 对象，我们需要把它们的引用改成例如 $state$-&gt;__$s1$.$tmp2$ 的方式。不过其他代码不用变。<br>
        这样协程状态可以节省 $16$ 字节，因为 __$tmp1$ 和 __$tmp4$ 数据成员不再需要额外的空间对齐，它们会被对齐到指针大小，即使是空类型。</p>
<h2 id="放到一起">放到一起</h2>
<p>        好的，让我们看看下面协程函数生成的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_return</span> <span class="n">fx</span> <span class="o">*</span> <span class="n">fx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        是下面这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">/////
</span></span></span><span class="line"><span class="cl"><span class="c1">// The coroutine promise-type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">__promise_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_traits</span><span class="o">&lt;</span><span class="n">task</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__coroutine_state</span><span class="o">*</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/////
</span></span></span><span class="line"><span class="cl"><span class="c1">// The coroutine-state definition
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__g_state</span> <span class="o">:</span> <span class="n">__coroutine_state_with_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__g_state</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialise the function-pointers used by coroutine-handle methods.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__g_resume</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__destroy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__g_destroy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Used placement-new to initialise the promise object in the base-class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// after we&#39;ve intialised the argument copies.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">::</span><span class="k">new</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="n">__g_promise_t</span><span class="p">(</span><span class="n">construct_promise</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">__g_state</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="o">~</span><span class="n">__g_promise_t</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Argument copies
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Local variables/temporaries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">__scope1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&gt;</span> <span class="n">__tmp2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="o">&gt;</span> <span class="n">__tmp3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span><span class="o">&gt;</span> <span class="n">__tmp1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__scope</span> <span class="n">__s1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual_lifetime</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">promise_type</span><span class="o">::</span><span class="n">final_awaiter</span><span class="o">&gt;</span> <span class="n">__tmp4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/////
</span></span></span><span class="line"><span class="cl"><span class="c1">// The &#34;ramp&#34; function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">&gt;</span> <span class="n">state</span><span class="p">(</span><span class="k">new</span> <span class="n">__g_state</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">return_value</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// fall through to return statement below.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Coroutine did not suspend. Start excuting the body immediately.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__g_resume</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">return_value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/////
</span></span></span><span class="line"><span class="cl"><span class="c1">// The &#34;resume&#34; function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">__coroutine_state</span><span class="o">*</span> <span class="nf">__g_resume</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>  <span class="c1">// &lt;-- add new jump-table entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp1_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// int fx = co_await f(x);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp2_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">get</span><span class="p">()).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp3_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// A coroutine suspends without exiting scopes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// So cancel the destructor-guards.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">tmp3_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp2_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">address</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Don&#39;t exit the scope here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// We can&#39;t &#39;goto&#39; a label that enters the scope of a variable with a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// non-trivial destructor. So we have to exit the scope of the destructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// guards here without calling the destructors and then recreate them after
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the `suspend_point_1` label.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">tmp3_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">tmp2_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fx</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp2_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="n">destructor_guard</span> <span class="n">tmp3_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// co_return fx * fx;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">return_value</span><span class="p">(</span><span class="n">fx</span> <span class="o">*</span> <span class="n">fx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">final_suspend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">final_suspend</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">final_suspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// co_await promise.final_suspend
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">construct_from</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">destructor_guard</span> <span class="n">tmp4_dtor</span><span class="p">{</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_ready</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">__resume</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// mark as final suspend-point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">__g_promise_t</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="n">tmp4_dtor</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">address</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Destroy coroutine-state if execution flows off end of coroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__coroutine_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">noop_coroutine</span><span class="p">().</span><span class="n">address</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/////
</span></span></span><span class="line"><span class="cl"><span class="c1">// The &#34;destroy&#34; function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__g_destroy</span><span class="p">(</span><span class="n">__coroutine_state</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">__g_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">__suspend_point</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">goto</span> <span class="n">suspend_point_2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp1</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp3</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__s1</span><span class="p">.</span><span class="n">__tmp2</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">suspend_point_2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="o">-&gt;</span><span class="n">__tmp4</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">goto</span> <span class="n">destroy_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">destroy_state</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        最终代码的完全可编译版本可以看<a href="https://godbolt.org/z/xaj3Yxabn">https://godbolt.org/z/xaj3Yxabn</a>。<br>
        有关<code>C++</code>协程机制的 $5$ 部分系列文章到此结束。<br>
        这些信息可能比你想要了解的还要多，希望它能帮助你理解和揭开协程的神秘面纱。<br>
        感谢您坚持到最后！<br>
        下次再见，Lewis.</p>

            </div>
            <div class="meta post-footer">
                <span>2025 Apr 23 23:34</span>
                <a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B5%E7%90%86%E8%A7%A3%E7%BC%96%E8%AF%91%E5%99%A8%E8%BD%AC%E6%8D%A2/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B4%E7%90%86%E8%A7%A3%E5%AF%B9%E7%A7%B0%E8%BD%AC%E7%A7%BB/">C&#43;&#43;协程（4）：理解对称转移</a></h1>
            <div class="post-content">
                
                
                <p>        协程标准提供了一种有趣的方式来编写异步代码，就好像你还在写同步代码那样。你只需要在合适的点调用 $co_-await$，编译器就会负责挂起协程，在挂起点之间保存状态，并在操作完成后恢复协程执行。<br>
        然而，协程标准，就像它最初定义的那样，有着很不友好的限制，一不小心就很容易导致栈溢出。并且如果想要避免这种溢出，就需要你在的 $task$&lt;$T$&gt; 类型中进行额外的同步开销。<br>
        还好，2018年对协程设计进行了调整，增加了一种叫做“对称转移” ( $symmetric$ $transfer$ ) 的功能，让你可以在不消耗任何额外栈空间的前提下挂起一个协程的同时恢复另一个协程的执行。此功能的加入解决了协程标准的一个关键限制，并且允许更简单有效的，不需要任何安全方面的措施来防止栈溢出的方式来实现一个异步协程。<br>
        在这篇文章我会试着解释栈溢出问题，以及这个关键的“对称转移”能力是怎么解决这个问题的。</p>
<h2 id="首先是一些关于任务协程怎么工作的背景">首先是一些关于任务协程怎么工作的背景</h2>
<p>        考虑如下协程：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_await</span> <span class="n">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        假设我们有一个简单的 $task$ 类型，当其他协程等待它时会懒执行。这个特别的 $task$ 类型没有返回值。<br>
        让我们分析下当 $bar\left(\right)$ 执行 $co_-await$ $foo\left(\right)$ 时发生了什么。</p>
<ul>
<li>$bar\left(\right)$ 协程调用 $foo\left(\right)$ 函数。注意从调用方的角度看协程只是一个普通函数。</li>
<li>$foo\left(\right)$ 调用执行一些步骤：
<ul>
<li>分配协程帧内存 ( 一般在堆上 )。</li>
<li>把参数拷贝到协程帧 ( 如果没有参数，不执行这一步 )。</li>
<li>在协程帧构造 $promise$ 对象。</li>
<li>调用 $promise.get_-return_-object\left(\right)$ 来获取 $foo\left(\right)$ 的返回值。这一步生成将被返回的 $task$ 对象，使用指向刚创建的协程帧的 $std$::$coroutine_-handle$ 初始化。</li>
<li>在最初挂起点 ( 即左大括号 ) 处挂起协程。</li>
<li>把 $task$ 对象返回给 $bar\left(\right)$。</li>
</ul>
</li>
<li>接着 $bar\left(\right)$ 协程对 $foo\left(\right)$ 返回的 $task$ 执行 $co_-await$ 表达式。
<ul>
<li>$bar\left(\right)$ 协程挂起，调用返回的 $task$ 对象的 $await_-suspend\left(\right)$ 方法，传入指向 $bar\left(\right)$ 协程帧的 $std$::$coroutine_-handle$ 。</li>
<li>$await_-suspend\left(\right)$ 函数保存 $bar\left(\right)$ 的 $std$::$coroutine_-handle$ 到 $foo\left(\right)$ 的 $promise$ 对象中，调用 $foo\left(\right)$ 的 $std$::$coroutine_-handle$ 的 $.resume\left(\right)$ 方法，恢复 $foo\left(\right)$ 协程的执行。</li>
</ul>
</li>
<li>$foo\left(\right)$ 协程同步执行完成。</li>
<li>$foo\left(\right)$ 协程在最终挂起点 ( 即右大括号 ) 处挂起，通过开始执行前存储的 $promise$ 对象的 $std$::$coroutine_-handle$ ( 即 $bar\left(\right)$ 协程 ) 恢复 $bar\left(\right)$ 的执行。</li>
<li>$bar\left(\right)$ 协程恢复，继续执行，直到到达 $co_-await$ 表达式语句的结尾，这时它调用 $foo\left(\right)$ 返回的临时变量 $task$ 的析构函数。</li>
<li>$task$ 的析构函数再调用 $foo\left(\right)$ 协程句柄的 $.destroy\left(\right)$ 方法，销毁协程帧，包括 $promise$ 对象和拷贝的参数。</li>
</ul>
<p>        好，这么看来一个简单的调用包含了许多步骤。<br>
        为了更好地理解这些步骤，让我们看看一种简单的使用协程标准设计 ( 不支持对称转移 ) 的 $task$ 类实现。</p>
<h2 id="task-的大体实现">task 的大体实现</h2>
<p>        类的实现大体是这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">task</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">promise_type</span> <span class="p">{</span> <span class="cm">/* see below */</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">task</span><span class="p">(</span><span class="n">task</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">coro_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">coro_</span><span class="p">,</span> <span class="p">{}))</span>
</span></span><span class="line"><span class="cl">  <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">task</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">coro_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">coro_</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">awaiter</span> <span class="p">{</span> <span class="cm">/* see below */</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span> <span class="k">operator</span> <span class="nf">co_await</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">coro_</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">coro_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        $task$ 独占一个指向协程帧的 $std$::$coroutine_-handle$，在协程调用时创建。$task$ 对象是<code>RAII</code>对象，保证当 $task$ 离开作用域时，$std$::$coroutine_-handle$ 的 $.destroy\left(\right)$ 会被调用。<br>
        接着让我们实现 $promise$ 类型。</p>
<h2 id="实现-taskpromise_type">实现 task::promise_type</h2>
<p>        根据<a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B3%E7%90%86%E8%A7%A3promise/">以前的文章</a>，我们知道 $promise$ 类型成员定义了协程帧中的 $Promise$ 对象类型，控制协程行为。<br>
        首先，我们需要实现 $get_-return_-object\left(\right)$ 来构造在协程创建时返回的 $task$ 对象。这个方法只需要使用新创建的协程帧的 $std$::$coroutine_-handle$ 来初始化 $task$。<br>
        我们可以使用 $std$::$coroutine_-handle$::$from_-promise\left(\right)$ 方法来从 $promise$ 对象构造出一个句柄。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">task</span><span class="o">::</span><span class="n">promise_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">task</span> <span class="n">get_return_object</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">task</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        接着，我们想要协程在左大括号处进行初始化挂起，这样稍后可以在挂起 $task$ 的点恢复协程。<br>
        协程懒启动有一些优点：</p>
<ol>
<li>可以在开始协程执行前绑定续体的 $std$::$coroutine_-handle$。这意味着我们不需要使用线程同步来处理绑定续体和协程执行完成之间的竞态。</li>
<li>$task$ 析构函数可以无条件地销毁协程帧，不需要担心协程是否还在另一个线程运行，因为协程只会在 $co_-await$ 时执行。并且开始后调用方协程会被挂起，所以直到协程执行完成，我们才能调用 $task$ 的析构函数。这让编译器可以更好的把协程帧直接分配在调用方的调用栈上，参考<a href="https://wg21.link/P0981R0">P0981R0</a>了解更多关于堆分配跳过优化 ( $Heap$ $Allocation$ $eLision$ $Optimisation$, $HALO$ )。</li>
<li>提升协程代码的异常安全性。如果你没有立马对返回的 $task$ 调用 $co_-await$，并且做了一些其他逻辑，抛出了异常，导致栈回退，这时 $task$ 的析构函数会被调用，这样我们也可以安全地销毁协程帧，因为我们知道它还没开始执行。我们不需要处理 $detach$，悬垂引用，析构函数阻塞，进程终止或者未定义行为。这也是我在<a href="https://www.youtube.com/watch?v=1Wy5sq3s2rg">CppCon 2019 talk on Structured Concurrency</a>中讲到的，后者包含更多细节。</li>
</ol>
<p>        为了让协程在左大括号处进行初始化挂起，我们实现了一个返回内置 $suspend_-always$ 类型的 $initial_-suspend\left(\right)$ 方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">suspend_always</span> <span class="n">initial_suspend</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        接着，我们需要定义 $return_-void\left(\right)$ 方法，这个方法会在执行到 $co_-return;$ 时，或者协程执行结束时被调用。这个方法并不需要做任何事，只需要声明一下来让编译器知道这个协程类型可以使用 $co_-return;$ 语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">return_void</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span></code></pre></div><p>        我们也需要增加一个 $unhandled_-exception\left(\right)$ 方法，如果一个异常逃逸出协程体之外，这个方法会被调用。在我们的场景，可以认为 $task$ 协程体是<code>noexcept</code>的，如果出现异常，直接调用 $std$::$terminate\left(\right)$。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unhandled_exception</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">terminate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        最后，当协程执行到右大括号时，我们想让协程在最终挂起点挂起，并恢复续体，即等待它完成的另一个协程的执行。<br>
        为了实现这个，我们需要 $promise$ 有一个数据成员来保存续体的 $std$::$coroutine_-handle$。我们也需要定义 $final_-suspend\left(\right)$ 方法，返回一个 $awaitble$ 对象，在当前协程在最终挂起点挂起后，恢复续体。<br>
        把恢复延后到当前协程挂起后进行是很重要的，因为下一个协程可能会立即调用 $task$ 的析构函数，后者再调用协程帧的 $.destroy\left(\right)$ 。$.destroy\left(\right)$ 只对挂起协程有效，所以这时可能会导致未定义行为。<br>
        编译器会在右大括号处插入 $co_-await$ $promise.final_-suspend\left(\right)$ 语句。<br>
        特别要注意的是，当 $final_-suspend\left(\right)$ 被调用时，当前协程还没有挂起。在协程挂起前，我们需要等待直到返回的 $awaitble$ 对象 $await_-suspend\left(\right)$ 方法被调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">final_awaiter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutin_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The coroutine is now suspended at the final-suspend point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Lookup its continuation in the promise and resume it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">h</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">continuation</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">final_awaiter</span> <span class="nf">final_suspend</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">continuation</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        好了，$promise$ 类型完成了。最后还剩下 $task$::$operator$ $co_-await\left(\right)$。</p>
<h2 id="实现-taskoperator-co_await">实现 task::operator co_await()</h2>
<p>        你可能记得<a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/">理解co_await</a>这篇文章讲的，当执行 $co_-await$ 表达式时，编译器会生成一个对 $operator$ $co_-await\left(\right)$ 的调用，如果定义了这个方法，返回对象必须同时定义 $await_-ready\left(\right)$、$await_-suspend\left(\right)$ 和 $await_-resume\left(\right)$ 方法。<br>
        当一个协程等待一个 $task$ 时，我们希望等待中的协程总是挂起，并且在挂起后，把等待中协程的句柄保存在即将恢复的协程的 $promise$ 中，并在之后对 $task$ 的 $std$::$coroutine_-handle$ 调用 $.resume\left(\right)$ 来开始 $task$ 执行。<br>
        因此代码会相对直接：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">task</span><span class="o">::</span><span class="n">awaiter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">continuation</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Store the continuation in the task&#39;promise so that the final_suspend()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// knows to resume this corotuine when the task completes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">coro_</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">continuation</span> <span class="o">=</span> <span class="n">continuation</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Then we resume the task&#39;s coroutine, which is currently suspended
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// at the initial-suspend-point (ie. at the open curly brace).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">coro_</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">explicit</span> <span class="n">awaiter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">coro_</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">task</span><span class="o">::</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">coro_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span><span class="o">::</span><span class="n">awaiter</span> <span class="n">task</span><span class="o">::</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">awaiter</span><span class="p">{</span><span class="n">coro_</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        这样就完成了 $task$ 类型功能所需的代码。<br>
        你可以在 $Compiler$ $Explorer$ 查看完整代码：<a href="https://godbolt.org/z/-Kw6Nf">https://godbolt.org/z/-Kw6Nf</a>。</p>
<h3 id="栈溢出问题">栈溢出问题</h3>
<p>        然而，当你尝试在协程中编写循环，并且 $co_-await$ 可能在循环体内同步完成的 $task$ 时，会受到一些限制。<br>
        例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">completes_synchronously</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">loop_synchronously</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">co_await</span> <span class="n">completes_synchronously</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        使用上文中的 $task$ 实现，$loop_-synchronously\left(\right)$ 函数 ( 可能 ) 会在 $count$ 是 $10$、$10000$，甚至 $100'000$ 时都能正常运行。但是有些值会导致协程崩溃。<br>
        例如，当 $count$ 是 $1'000'000$ 时就会崩溃，可以查看：<a href="https://godbolt.org/z/gy5Q8q">https://godbolt.org/z/gy5Q8q</a>。<br>
        崩溃的原因是栈溢出。<br>
        为了理解栈溢出的原因，我们需要看看代码执行的时候发生了什么，尤其是栈帧上面发生了什么。<br>
        当其他协程 $co_-await$ 了返回的 $task$ 后，$loop_-synchronously\left(\right)$ 开始执行。这将挂起等待中的协程，调用 $task$::$awaiter$::$await_-suspend\left(\right)$，后者调用 $task$ 的 $std$::$coroutine_-handle$ 的 $.resume\left(\right)$ 方法。<br>
        因此在 $loop_-synchronously\left(\right)$ 启动时，栈看起来就像这样：</p>
<pre tabindex="0"><code>           Stack                                                   Heap
+------------------------------+  &lt;-- top of stack   +--------------------------+
| loop_synchronously$resume    | active coroutine -&gt; | loop_synchronously frame |
+------------------------------+                     | +----------------------+ |
| coroutine_handle::resume     |                     | | task::promise        | |
+------------------------------+                     | | - continuation --.   | |
| task::awaiter::await_suspend |                     | +------------------|---+ |
+------------------------------+                     | ...                |     |
| awaiting_coroutine$resume    |                     +--------------------|-----+
+------------------------------+                                          V
|  ....                        |                     +--------------------------+
+------------------------------+                     | awaiting_coroutine frame |
                                                     |                          |
                                                     +--------------------------+
</code></pre><blockquote>
<p>注意：一个协程函数通常被编译器编译成两部分：</p>
<ol>
<li>“启动函数” ( $ramp$ $function$ )，处理协程帧构造、参数拷贝，$promise$ 构造和生成返回值，以及</li>
<li>“协程体” ( $coroutine$ $body$ )，包含用户编写的逻辑。</li>
</ol></blockquote>
<blockquote>
<p>我使用 $\$resume$ 后缀表示协程的“协程体”部分。<br>
后面的文章会详细介绍这种分割方式。</p></blockquote>
<p>        当 $loop_-synchronously\left(\right)$ $co_-await$ $completes_-synchronously\left(\right)$ 返回的 $task$ 时，当前协程会被挂起，调用 $task$::$awaiter$::$await_-suspend\left(\right)$。$await_-suspend\left(\right)$ 方法再调用 $completes_-synchronously\left(\right)$ 协程句柄的 $.resume\left(\right)$ 方法。<br>
        这会恢复 $completes_-synchronously\left(\right)$ 协程，后者会同步执行直到结束，并在最终挂起点处挂起，然后调用 $task$::$promise$::$final_-awaiter$::$await_-suspend\left(\right)$ 方法，后者会调用 $loop_-synchronously\left(\right)$ 协程句柄的 $.resume\left(\right)$ 方法。<br>
        接着当 $loop_-synchronously\left(\right)$ 协程恢复之后、$completes_-synchronously\left(\right)$ 返回的临时变量 $task$ 在分号处销毁时，我们再看看当前程序状态，栈 / 堆看起来就像这样：</p>
<pre tabindex="0"><code>           Stack                                                   Heap
+-------------------------------+ &lt;-- top of stack
| loop_synchronously$resume     | active coroutine -.
+-------------------------------+                   |
| coroutine_handle::resume      |            .------&#39;
+-------------------------------+            |
| final_awaiter::await_suspend  |            |
+-------------------------------+            |  +--------------------------+ &lt;-.
| completes_synchronously$resume|            |  | completes_synchronously  |   |
+-------------------------------+            |  | frame                    |   |
| coroutine_handle::resume      |            |  +--------------------------+   |
+-------------------------------+            &#39;---.                             |
| task::awaiter::await_suspend  |                V                             |
+-------------------------------+ &lt;-- prev top  +--------------------------+   |
| loop_synchronously$resume     |     of stack  | loop_synchronously frame |   |
+-------------------------------+               | +----------------------+ |   |
| coroutine_handle::resume      |               | | task::promise        | |   |
+-------------------------------+               | | - continuation --.   | |   |
| task::awaiter::await_suspend  |               | +------------------|---+ |   |
+-------------------------------+               | - task temporary --|---------&#39;
| awaiting_coroutine$resume     |               +--------------------|-----+
+-------------------------------+                                    V
|  ....                         |               +--------------------------+
+-------------------------------+               | awaiting_coroutine frame |
                                                |                          |
                                                +--------------------------+
</code></pre><p>        接着下一个要做的就是调用 $task$ 的析构函数，销毁 $completes_-synchronously\left(\right)$ 的协程帧，并递增 $count$ 变量，继续循环，再创建一个新的 $completes_-synchronously\left(\right)$ 协程并恢复它。<br>
        事实上，这里会做的就是 $loop_-synchronously\left(\right)$ 和 $completes_-synchronously\left(\right)$ 返回递归调用对方，每次调用都会占用一部分栈空间，直到迭代够一定次数后，栈会溢出并产生未定义行为，通常会导致程序立即崩溃。<br>
        协程内编写循环这种看着没有任何递归的行为，却很容易导致函数产生无限递归。<br>
        那么，在这种原始协程标准设计之下，又该怎么解决这个问题呢？</p>
<h2 id="协程标准解法">协程标准解法</h2>
<p>        好，那么这种无限递归问题该怎么避免呢？<br>
        在上面的实现中，我们使用返回 $void$ 的 $await_-suspend\left(\right)$。协程标准中还有另外一个返回<code>bool</code>的 $await_-suspend\left(\right)$，返回<code>true</code>代表协程已挂起，控制权移交给 $resume\left(\right)$ 的调用方，返回<code>false</code>则协程立即恢复，不需要消耗任何额外的栈空间。<br>
        所以，为了避免无限地循环递归，我们希望利用返回<code>bool</code>版本的 $await_-suspend\left(\right)$，让 $task$::$awaiter$::$await_-suspend\left(\right)$ 在任务同步结束时返回<code>false</code>，而不是递归地通过 $std$::$coroutine_-handle$::$resume\left(\right)$ 恢复协程。<br>
        实现这种解法需要两部分：</p>
<ol>
<li>在 $task$::$awaiter$::$await_-suspend\left(\right)$ 方法，你可以调用 $.resume\left(\right)$ 来启动协程执行。然后在 $.resume\left(\right)$ 返回时，检查协程是否执行完成。如果执行完成，我们可以返回<code>false</code>，表示等待中的协程应当立即恢复。如果没有完成，我们可以返回<code>true</code>，表示将控制权移交给 $std$::$coroutine_-handle$::$resume\left(\right)$ 的调用方。</li>
<li>在协程执行完成后调用的 $task$::$promise_-type$::$final_-awaiter$::$await_-suspend\left(\right)$ 方法内，我们需要检查等待中协程是否已经 ( 或者即将 ) 从 $task$::$awaiter$::$await_-suspend\left(\right)$ 调用中返回<code>true</code>。如果是，调用 $.resume\left(\right)$ 来恢复它。否则我们需要避免恢复协程，并且通知 $task$::$awaiter$::$await_-suspend\left(\right)$，让它返回<code>false</code>。</li>
</ol>
<p>        然而，有一个更复杂的问题，就是协程可能在当前线程开始执行、挂起，并在 $.resume\left(\right)$ 调用返回前，在其他线程恢复并执行完成。因此，我们需要解决第一部分和第二部分之间可能的竞态。<br>
        我们需要使用 $std$::$atomic$ 值同步。<br>
        现在我们可以对代码进行以下修改：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">task</span><span class="o">::</span><span class="n">promise_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">continuation</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">ready</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="o">::</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">continuation</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">promise_type</span><span class="o">&amp;</span> <span class="n">promise</span> <span class="o">=</span> <span class="n">coro_</span><span class="p">.</span><span class="n">promise</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">promise</span><span class="p">.</span><span class="n">continuation</span> <span class="o">=</span> <span class="n">continuation</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">coro_</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">!</span><span class="n">promise</span><span class="p">.</span><span class="n">ready</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">task</span><span class="o">::</span><span class="n">promise_type</span><span class="o">::</span><span class="n">final_awaiter</span><span class="o">::</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">promise_type</span><span class="o">&amp;</span> <span class="n">promise</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">promise</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">promise</span><span class="p">.</span><span class="n">ready</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The coroutine did not complete synchronously, resume it here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">promise</span><span class="p">.</span><span class="n">continuation</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        可以在 $Compiler$ $Explorer$ 上查看修改后的例子：<a href="https://godbolt.org/z/7fm8Za">https://godbolt.org/z/7fm8Za</a>。注意这时当 $count$ $==$ $1'000'000$ 时，程序不再崩溃了。<br>
        这就是 $cppcoro$::$task$&lt;$T$&gt; 里面实现的，规避无限递归问题的方式 ( 在某些平台也是一样 )，而且运行得很好。<br>
        哇哦！问题解决了，吗？发布！可以吗&hellip;？</p>
<h2 id="问题">问题</h2>
<p>        以上方法在解决递归的同时，也引入了一些问题。<br>
        首先，它需要 $std$::$atomic$ 操作，开销可能很大。调用方挂起等待中协程的过程中需要进行一次原子交换，并且被调方执行完成后也需要一次原子交换。如果你的程序是单线程的，那么你会在永远不需要的线程同步原子操作上花费额外的开销。<br>
        其次，它引入了额外的分支。一个在调用方，需要判断是否挂起或者立即恢复协程，另一个在被调方，需要判断是否恢复续体或者挂起。<br>
        注意这个额外分支的开销，甚至原子操作的开销，跟协程程序的业务逻辑相比通常不值一提。然而，协程被称为零成本抽象，并且有许多人使用协程挂起操作来避免等待<code>L1</code>缓存未命中问题 ( 更多细节可以查看 Gor 的 <a href="https://www.youtube.com/watch?v=j9tlJAqMV7U">great CppCon talk on nanocoroutines</a> )。<br>
        最后，也可能是最重要的，它在恢复等待中协程的过程中引入了一些运行上下文中不确定的值。<br>
        假设我有以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">cppcoro</span><span class="o">::</span><span class="n">static_thread_pool</span> <span class="n">tp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;foo1 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Suspend coroutine and reschedule onto thread-poll thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">co_await</span> <span class="n">tp</span><span class="p">.</span><span class="n">schedule</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;foo2 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">bar</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;bar1 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_await</span> <span class="n">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;bar2 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        在原来实现中，我们保证在 $co_-await$ $foo\left(\right)$ 执行完成后的代码会在相同的线程中内联执行。<br>
        例如，一种可能的输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">bar1</span> <span class="mi">1234</span>
</span></span><span class="line"><span class="cl"><span class="n">foo1</span> <span class="mi">1234</span>
</span></span><span class="line"><span class="cl"><span class="n">foo2</span> <span class="mi">3456</span>
</span></span><span class="line"><span class="cl"><span class="n">bar2</span> <span class="mi">3456</span>
</span></span></code></pre></div><p>        然而，使用原子变量后，$foo\left(\right)$ 执行完成可能与 $bar\left(\right)$ 的挂起之间产生竞态，在一些情况下，这意味着 $co_-await$ $foo\left(\right)$ 之后的代码可能在 $bar\left(\right)$ 启动的线程上执行。<br>
        例如，一种可能的输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">bar1</span> <span class="mi">1234</span>
</span></span><span class="line"><span class="cl"><span class="n">foo1</span> <span class="mi">1234</span>
</span></span><span class="line"><span class="cl"><span class="n">foo2</span> <span class="mi">3456</span>
</span></span><span class="line"><span class="cl"><span class="n">bar2</span> <span class="mi">1234</span>
</span></span></code></pre></div><p>        对于许多用例来说，这种行为没有区别。然而，对于想要传递运行上下文的算法来说就有问题了。<br>
        例如，$via\left(\right)$ 算法等待一些 $Awaitable$，然后在对应的 $scheduler$ 的运行上下文上返回。这个算法的一个简单版本如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Awaitable</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Scheduler</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">task</span><span class="o">&lt;</span><span class="n">await_result_t</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&gt;&gt;</span> <span class="n">via</span><span class="p">(</span><span class="n">Awaitable</span> <span class="n">a</span><span class="p">,</span> <span class="n">Scheduler</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_await</span> <span class="n">s</span><span class="p">.</span><span class="n">schedule</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">get_value</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">consume</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">consumer</span><span class="p">(</span><span class="n">static_thread_pool</span><span class="o">::</span><span class="n">scheduler</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span> <span class="n">result</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">via</span><span class="p">(</span><span class="n">get_value</span><span class="p">(),</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">consume</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        最初版本的 $consume\left(\right)$ 调用总是保证在线程池 $s$ 上执行。然而，在使用原子变量后，$consume\left(\right)$ 可能在与 $scheduler$ $s$ 相关的线程上执行，也可能在 $consumer\left(\right)$ 开始执行的线程上执行。<br>
        所以我们应该怎么在没有原子操作、额外分支和不确定的恢复上下文的前提下解决栈溢出问题呢？</p>
<h2 id="进入对称转移">进入“对称转移”!</h2>
<p>        Gor Nishanov ( $2018$ ) 的论文<a href="https://wg21.link/P0913R0">P0913R0</a>《增加对称协程控制转移》，提出了这种问题的解法，通过提供一种允许一种不需要消耗任何额外栈空间的前提下，让一个协程挂起时对称恢复另一个协程的能力。<br>
        论文提出了两个关键改变：</p>
<ul>
<li>允许 $await_-suspend\left(\right)$ 返回 $std$::$coroutine_-handle$&lt;$T$&gt;，表示执行需要对称转移给返回的句柄标识的协程。</li>
<li>增加 $std$::$experimental$::$noop_-coroutine\left(\right)$ 函数，返回一个特别的 $std$::$coroutine_-handle$，可以作为 $await_-suspend\left(\right)$ 的返回值，挂起当前协程，从 $.resume\left(\right)$ 调用返回而不是将控制权转移给其他协程。</li>
</ul>
<p>        所以“对称转移”是什么意思呢？<br>
        当你调用 $std$::$coroutine_-handle$ 的 $.resume\left(\right)$ 来恢复协程，$.resume\left(\right)$ 的调用方在协程恢复后仍然是活跃的。接着，协程再次挂起，在挂起点调用 $await_-suspend\left(\right)$ 返回<code>void</code>( 无条件挂起 ) 或者<code>true</code> ( 有条件挂起 ) 时，$.resume\left(\right)$ 的调用才会返回。<br>
        这可以认为是一种“对称转移”，协程执行和行为就像普通函数调用一样。$.resume\left(\right)$ 的调用方可以是任意函数 ( 协程或非协程 )。当协程挂起并且 $await_-suspend\left(\right)$ 返回<code>true</code>或者<code>void</code>时，控制权会返回给 $.resume\left(\right)$ 的调用者。<br>
        每次调用 $.resume\left(\right)$ 恢复协程时，都会创建一个新的协程的栈帧。<br>
        然而，通过“对称转移”，我们可以简单地挂起一个协程，并恢复另一个协程。两个协程之间不需要隐式的调用方 / 被调方关系，一个协程挂起时，它就可以把控制权转移给另一个挂起的协程 ( 包括它自己 )，并且不需要在下次挂起或者执行完成时把控制权转移给上一个协程。<br>
        让我们看看在 $awaiter$ 使用对称转移时，编译器会怎么处理 $co_-await$ 表达式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">value</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">awaitble</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">get_awaitable</span><span class="p">(</span><span class="n">promise</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">awaiter</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">get_awaiter</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">awaitable</span><span class="p">)</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">awaiter</span><span class="p">.</span><span class="n">await_ready</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">handle_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// &lt;suspend-coroutine&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">awaiter</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">handle_t</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">h</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// &lt;return-to-caller-or-resumer&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// &lt;resume-point&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">awaiter</span><span class="p">.</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        让我们放大与其他 $co_-await$ 行为不同的部分：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">awaiter</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">handle_t</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">h</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// &lt;return-to-caller-or-resumer&gt;
</span></span></span></code></pre></div><p>        一旦协程状态机完成底层转换后 ( 另一篇文章的主题 )，&lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 部分一般是 $return;$ 语句，这会导致最近一次恢复协程的 $.resume\left(\right)$ 的调用将返回给调用方。<br>
        这意味着我们当前函数体的 $std$::$coroutine_-handle$::$resume\left(\right)$ 调用内，又产生了一个对同一个签名的函数的调用，即 $std$::$coroutine_-handle$::$resume\left(\right)$ ，紧跟着一条 $return;$ 语句。<br>
        一些编译器在开启编译优化后，能够在条件满足的时候，把函数结尾的调用 ( 即返回之前 ) 转变为尾调用 ( $tail$-$calls$ )。<br>
        而这种优化正是我们想要的，可以避免栈溢出问题的方式。但是与其期望优化器来决定进行尾调用转移，我们更想要确保这种优化一直有效，即使是未开启优化的情况。<br>
        但是首先，我们先了解下尾调用的含义。</p>
<h3 id="尾调用">尾调用</h3>
<p>        尾调用指在调用前弹出当前栈帧，把当前函数的返回地址作为被调方的返回地址 ( 即被调直接返回给当前函数的调用方 )。<br>
        在<code>X86/X64</code>架构，这通常意味着编译器生成的代码会先弹出当前栈帧，然后调用 $jmp$ 指令来跳转到被调函数入口，而不是使用 $call$ 指令，并在 $call$ 返回后才弹出当前栈帧。<br>
        这个优化通常只会在有限情况下发生，然而：<br>
        特别的，它需要：</p>
<ul>
<li>调用机制支持尾调用，包括调用方和被调方；</li>
<li>返回类型相同；</li>
<li>没有需要在调用返回前执行的非默认析构函数；</li>
<li>调用不在<code>try/catch</code>块内。</li>
</ul>
<p>        $co_-await$ 对称转移形式的设计使得它刚好能满足所有需求。我们一个个来看。<br>
        <strong>调用机制</strong>：当编译器把协程转换成底层状态机时，它实际上分成两部分：启动部分 ( $ramp$，分配和初始化协程框架 ) 和主体 ( 包含用户编写的协程体的状态机 )。<br>
        协程的函数签名 ( 以及所有用户指定的调用机制 ) 只会影响启动函数部分，主体部分则受编译器控制，永远不会被用户代码调用，只能通过 $ramp$ 函数和 $std$::$coroutine_-handle$::$resume\left(\right)$ 调用。<br>
        协程体部分的调用机制是用户不可见的，完全由编译器决定，因此它可以选择一种合适的支持尾调用的机制，并被所有协程体使用。<br>
        <strong>返回类型相同</strong>：源和目的协程的 $.resume\left(\right)$ 方法的返回值都是<code>void</code>，所以这个需求也能满足。<br>
        <strong>没有非默认析构函数</strong>：当执行尾调用时，我们需要在调用目标函数前释放当前栈帧，这需要所有栈上对象的生命周期都在调用结束之前。<br>
        一般情况下，一旦作用域内有对象的析构函数非默认且分配在栈上，这些对象会在协程挂起的时候存活，就会产生问题。<br>
        然而，当一个协程挂起时，它不会退出任何作用域，实现方式是把生命周期跨挂起点的对象放在协程帧上而不是栈上。<br>
        局部变量的生命周期不会跨挂起点，可能分配在栈帧上，它们的生命周期会在协程下次挂起时结束。<br>
        因此栈分配对象不存在需要在尾调用返回之前调用的非默认析构函数。<br>
        <strong>调用不在<code>try/catch</code>块内</strong>：这个可能有点 trick，因为每个协程内都有个隐式的<code>try/catch</code>块，包裹用户编写的协程体。<br>
        根据规范，协程被定义为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">promise_type</span> <span class="n">promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span> <span class="p">{</span> <span class="n">F</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span> <span class="n">promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nl">final_suspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        $F$ 就是用户编写的协程体部分。<br>
        因此所有用户编写的 $co_-await$ 表达式 ( 除了 $initial$/$final_-suspend$ ) 都在<code>try/catch</code>块的上下文中。<br>
        然而，实现上会把 $.resume\left(\right)$ 执行放到<code>try/catch</code>块的外部。<br>
        我希望在另一篇文章讲协程怎么变成状态机的文章中讲解更多这方面的细节 ( 这篇文章已经够长了 )。</p>
<blockquote>
<p>注意，然而，当前<code>C++</code>规范对实现这个操作需求的描述不够清晰，并且只是一个非规范注释，暗示这可能是必须的。希望我们将来能够修复这个规范。</p></blockquote>
<p>        那么我们知道了执行对称转移的协程已经满足了所有尾调用的需求。编译器会确保它永远是尾调用，无论是否开启了优化。<br>
        这意味着通过使用 $await_-suspend\left(\right)$ 返回 $std$::$coroutine_-handle$ 的风格，我们可以挂起当前协程，并在不消耗额外栈空间的前提下，把控制权转移给另一个协程。<br>
        这让我们可以编写任意深度的相互递归调用代码，不需要担心栈溢出。<br>
        这就是我们需要修复的 $task$ 的实现。</p>
<h2 id="再看task">再看<code>task</code></h2>
<p>        有了“对称转移”能力，我们再来修复 $task$ 类型实现。<br>
        我们要修改两个 $await_-suspend\left(\right)$ 方法的实现：</p>
<ul>
<li>首先当我们等待 $task$ 时，我们执行对称转移，来恢复任务协程。</li>
<li>其次当任务协程完成，它执行一次对称转移，恢复等待中的协程。</li>
</ul>
<p>        为了指明等待的方向，我们需要把 $task$::$awaiter$ 方法从：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="o">::</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">continuation</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Store the continuation in the task&#39;s promise so that the final_suspend()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// knows to resume this coroutine when the task completes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">coro_</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">continuation</span> <span class="o">=</span> <span class="n">continuation</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Then we resume the task&#39;s coroutine, which is currently suspended
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// at the initial-suspend-point (ie. at the open curly brace).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">coro_</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        改成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">task</span><span class="o">::</span><span class="n">awaiter</span><span class="o">::</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">continuation</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Store the continuation in the task&#39;s promise so that the final_suspend()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// knows to resume this coroutine when the task completes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">coro_</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">continuation</span> <span class="o">=</span> <span class="n">continuation</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Then we tail-resume the task&#39;s coroutine, which is currently suspended
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// at the initial-suspend-point (ie. at the open curly brace), by returning
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// its handle from await_suspend().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">coro_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        同时为了指明返回路径，我们需要把 $task$::$promise_-type$::$final_-awaiter$ 方法从：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">task</span><span class="o">::</span><span class="n">promise_type</span><span class="o">::</span><span class="n">final_awaiter</span><span class="o">::</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// The coroutine is now suspended at the final-suspend point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Lookup its continuation in the promise and resume it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">h</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">continuation</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        改成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">task</span><span class="o">::</span><span class="n">promise_type</span><span class="o">::</span><span class="n">final_awaiter</span><span class="o">::</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// The coroutine is now suspended at the final-suspend point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Lookup its continuation in the promise and resume it symmetrically.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">h</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">continuation</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        这样我们就有了一个不需要担心栈溢出问题的 $task$ 实现，并且 $await_-suspend$ 是<code>void</code>返回的，没有<code>bool</code>返回带来的不确定恢复上下文问题。</p>
<h3 id="观察栈">观察栈</h3>
<p>        现在让我们看看最初的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">completes_synchronously</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">task</span> <span class="nf">loop_synchronously</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">co_await</span> <span class="n">completes_synchronously</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        当其他协程 $co_-await$ $task$ 时，$loop_-synchronously\left(\right)$ 协程首次开始执行。这会触发其他协程的对称转移，并通过 $std$::$coroutine_-handle$::$resume\left(\right)$ 调用恢复。<br>
        因此当 $loop_-synchronously\left(\right)$ 开始时，栈看起来会像这样：</p>
<pre tabindex="0"><code>           Stack                                                Heap
+---------------------------+  &lt;-- top of stack   +--------------------------+
| loop_synchronously$resume | active coroutine -&gt; | loop_synchronously frame |
+---------------------------+                     | +----------------------+ |
| coroutine_handle::resume  |                     | | task::promise        | |
+---------------------------+                     | | - continuation --.   | |
|     ...                   |                     | +------------------|---+ |
+---------------------------+                     | ...                |     |
                                                  +--------------------|-----+
                                                                       V
                                                  +--------------------------+
                                                  | awaiting_coroutine frame |
                                                  |                          |
                                                  +--------------------------+
</code></pre><p>        现在，当执行 $co_-await$ $completes_-synchronously\left(\right)$ ，它会对称转移到 $completes_-synchronously$ 协程。<br>
        通过：</p>
<ul>
<li>调用 $task$::$operator$ $co_-await\left(\right)$，后者会在稍后返回 $task$::$awaiter$ 对象</li>
<li>然后挂起并调用 $task$::$awaiter$::$await_-suspend\left(\right)$，后者稍后返回 $completes_-synchronously$ 协程的 $coroutine_-handle$。</li>
<li>然后执行尾调用 / 跳转到 $completes_-synchronously$ 协程，在激活 $completes_-synchronously$ 栈帧前弹出 $loop_-synchronously$ 栈帧。</li>
</ul>
<p>        在 $completes_-synchronously$ 恢复后，栈看起来会像这样：</p>
<pre tabindex="0"><code>              Stack                                          Heap
                                            .-&gt; +--------------------------+ &lt;-.
                                            |   | completes_synchronously  |   |
                                            |   | frame                    |   |
                                            |   | +----------------------+ |   |
                                            |   | | task::promise        | |   |
                                            |   | | - continuation --.   | |   |
                                            |   | +------------------|---+ |   |
                                            `-, +--------------------|-----+   |
                                              |                      V         |
+-------------------------------+ &lt;-- top of  | +--------------------------+   |
| completes_synchronously$resume|     stack   | | loop_synchronously frame |   |
+-------------------------------+ active -----&#39; | +----------------------+ |   |
| coroutine_handle::resume      | coroutine     | | task::promise        | |   |
+-------------------------------+               | | - continuation --.   | |   |
|     ...                       |               | +------------------|---+ |   |
+-------------------------------+               | task temporary     |     |   |
                                                | - coro_       -----|---------`
                                                +--------------------|-----+
                                                                     V
                                                +--------------------------+
                                                | awaiting_coroutine frame |
                                                |                          |
                                                +--------------------------+
</code></pre><p>        注意这里栈帧数量增长了。<br>
        在 $completes_-synchronously$ 协程完成，执行到右大括号处，它会执行 $co_-await$ $promise.final_-suspend\left(\right)$。<br>
        这会挂起协程，并调用 $final_-awaiter$::$await_-suspend\left(\right)$ ，后者返回续体的 $std$::$coroutine_-handle$ ( 即指向 $loop_-synchronously$ 协程的句柄 )。这会触发一次对称转移 / 尾调用来恢复 $loop_-synchronously$ 协程。<br>
        $loop_-synchronously$ 恢复后的栈看起来就像这样：</p>
<pre tabindex="0"><code>           Stack                                                   Heap
                                                   +--------------------------+ &lt;-.
                                                   | completes_synchronously  |   |
                                                   | frame                    |   |
                                                   | +----------------------+ |   |
                                                   | | task::promise        | |   |
                                                   | | - continuation --.   | |   |
                                                   | +------------------|---+ |   |
                                                   +--------------------|-----+   |
                                                                        V         |
+----------------------------+  &lt;-- top of stack   +--------------------------+   |
| loop_synchronously$resume  | active coroutine -&gt; | loop_synchronously frame |   |
+----------------------------+                     | +----------------------+ |   |
| coroutine_handle::resume() |                     | | task::promise        | |   |
+----------------------------+                     | | - continuation --.   | |   |
|     ...                    |                     | +------------------|---+ |   |
+----------------------------+                     | task temporary     |     |   |
                                                   | - coro_       -----|---------`
                                                   +--------------------|-----+
                                                                        V
                                                   +--------------------------+
                                                   | awaiting_coroutine frame |
                                                   |                          |
</code></pre><p>        $loop_-synchronously$ 协程被恢复后，在执行到达分号后，要做的第一件事就是调用 $completes_-synchronously$ 返回的临时 $task$ 的析构函数。这会销毁协程帧，释放内存，这时情况会是这样：</p>
<pre tabindex="0"><code>           Stack                                                   Heap
+---------------------------+  &lt;-- top of stack   +--------------------------+
| loop_synchronously$resume | active coroutine -&gt; | loop_synchronously frame |
+---------------------------+                     | +----------------------+ |
| coroutine_handle::resume  |                     | | task::promise        | |
+---------------------------+                     | | - continuation --.   | |
|     ...                   |                     | +------------------|---+ |
+---------------------------+                     | ...                |     |
                                                  +--------------------|-----+
                                                                       V
                                                  +--------------------------+
                                                  | awaiting_coroutine frame |
                                                  |                          |
                                                  +--------------------------+
</code></pre><p>        我们现在返回到 $loop_-synchronously$ 协程的执行，并且栈帧和协程帧数量与开始执行时一样，并且之后每次循环也是一样。<br>
        因此我们可以执行许多次迭代，只消耗常数级的存储空间。<br>
        完整的对称转移版本的 $task$ 类型可以看以下的 $Compiler$ $Explorer$ 链接：<a href="https://godbolt.org/z/9baieF">https://godbolt.org/z/9baieF</a>。</p>
<h2 id="通用形式-await_suspend-的对称转移">通用形式 <code>await_suspend</code> 的对称转移</h2>
<p>        既然我们已经见识过了对称转移形式的 $awaitable$ $concept$ 的能力和重要性，我想向你展示一下通用形式，理论上可以替换<code>void</code>和<code>bool</code>返回形式的 $await_-suspend\left(\right)$。<br>
        但首先，我们需要看一下<a href="https://wg21.link/P0913R0">P0913R0</a>提案添加的新的协程设计：$std$::$noop_-coroutine\left(\right)$。</p>
<h3 id="循环终止">循环终止</h3>
<p>        通过对称转移形式的协程，每次协程挂起，它都会对称恢复另一个协程。只要你有其他协程可以恢复，它就非常有用。但是有时我们不想要执行其他协程，只需要挂起并把控制权返回给 $std$::$coroutine_-handle$::$resume\left(\right)$ 的调用方。<br>
        <code>void</code>和<code>bool</code>返回形式的 $await_-suspend\left(\right)$ 都允许协程挂起并从 $std$::$coroutine_-handle$::$resmue\left(\right)$ 调用中返回，那么我们怎么让对称转移形式的协程返回呢？<br>
        答案是使用内置的特殊 $std$::$coroutine_-handle$，称为无操作协程句柄 ( $noop$ $coroutine$ $handle$ )，通过函数 $std$::$noop_-coroutine\left(\right)$ 生成。<br>
        无操作协程句柄之所以叫这个名字，是因为它的 $.resume\left(\right)$ 实现是立即返回，即恢复协程后没有操作。一般它的实现包含一条简单的 $ret$ 指令。<br>
        如果 $await_-suspend\left(\right)$ 方法返回 $std$::$noop_-coroutine\left(\right)$ 句柄，那么协程不会把控制权转移给下一个协程，而是转移给 $std$::$coroutine_-handle$::$resume\left(\right)$ 的调用方。</p>
<h3 id="其他风格的-await_suspend-表示方式">其他风格的 <code>await_suspend()</code> 表示方式</h3>
<p>        有了这个信息，我们再看其他风格的 $await_-suspend\left(\right)$ 如何使用对称转移。<br>
        我们有<code>void</code>返回格式的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">my_awaiter</span><span class="o">::</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="o">-&gt;</span><span class="n">coro</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">enqueue</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        可以改成<code>bool</code>返回格式的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">my_awaiter</span><span class="o">::</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="o">-&gt;</span><span class="n">coro</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">enqueue</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        也可以再改成对称转移风格：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">noop_coroutine_handle</span> <span class="n">my_awaiter</span><span class="o">::</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="o">-&gt;</span><span class="n">coro</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">enqueue</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">noop_coroutine</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        我们有<code>bool</code>返回格式的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">my_awaiter</span><span class="o">::</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="o">-&gt;</span><span class="n">coro</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">try_start</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Operation will complete asynchronously.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Return true to transfer execution to caller of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// coroutine_handle::resume().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Operation completed asynchronously.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Return false to immediately resume the current coroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        可以改成对称转移格式的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">my_awaiter</span><span class="o">::</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="o">-&gt;</span><span class="n">coro</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">try_start</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Operation will complete asynchronously.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Return std::noop_coroutine() to transfer execution to caller of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// coroutine_handle::resume().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">noop_coroutine</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Operation completed asynchronously.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Return current coroutine&#39;s handle to immediately resume
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the current coroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="为什么有三种风格">为什么有三种风格？</h3>
<p>        那么为什么在有对称转移风格的前提下，我们还继续使用<code>void</code>和<code>bool</code>返回风格的 $await_-suspend\left(\right)$ 呢？<br>
        一部分历史原因，一部分实用性原因，一部分性能原因。<br>
        $await_-suspend\left(\right)$ 返回 $std$::$noop_-coroutine_-handle$ 可以完全替代<code>void</code>返回版本，因为这两种对于编译器来说，都表示协程会无条件地把控制权转移给 $std$::$coroutine_-handle$::$resume\left(\right)$ 的调用方。<br>
        在我看来，它还能留下来的原因，一部分是它在对称转移被提出之前就已经在使用了，另一部分是因为<code>void</code>返回对于无条件挂起的情况可以少写一点代码。<br>
        <code>bool</code>返回版本，在某些情况下，可以优化得比对称转移形式的更好。<br>
        假设我们有一个<code>bool</code>返回的 $await_-suspend\left(\right)$，定义在另一个编译单元。这时编译器可以在等待协程处生成代码，挂起当前协程并在 $await_-suspend\left(\right)$ 调用返回之后，通过执行下一块代码的方式来有条件地恢复它。如果 $await_-suspend\left(\right)$ 返回<code>false</code>，那么就可以明确知道需要执行哪段代码。<br>
        即使有了对称转移风格，我们还是需要表示相同的结果：返回给调用方 / 恢复方，或者恢复当前协程。相比返回<code>true</code>或者<code>false</code>，我们需要返回 $std$::$noop_-coroutine\left(\right)$ 或者当前协程的句柄。我们可以把这些句柄都统一成 $std$::$coroutine_-handle$&lt;$void$&gt; 返回。<br>
        然而，因为 $await_-suspend\left(\right)$ 定义在其他编译单元，编译器看不到协程返回的句柄指向什么，所以当协程恢复后，它需要一些更重的间接调用，并且相比<code>bool</code>返回的单个分支而言，可能会有更多的恢复协程分支。<br>
        有可能在将来的某一天，对称转移版本可以获得同等性能。例如，我们可以编写内联的 $await_-suspend\left(\right)$，但是调用一个<code>bool</code>返回的非内联方法，并有条件地返回合适的句柄。<br>
        例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_awaiter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Compiler should in-theory be able to optimise this to the same
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// as the bool-returning version, but currently don&#39;t do this optimisation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">try_start</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">noop_coroutine</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// This method is defined out-of-line in a seperate translation unit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">try_start</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">h</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        然而，现在的编译器 ( 比如<code>Clang 10</code> ) 还不能把这种情况优化成和<code>bool</code>返回版本一样高效的代码。话虽如此，除非你编写了一个非常紧凑的循环，否则可能不会注意到它们的差异。<br>
        到目前为止，通用的规则是：</p>
<ul>
<li>如果你需要无条件地返回给 $.resume\left(\right)$ 的调用方，使用<code>void</code>返回风格。</li>
<li>如果你需要有条件地返回给 $.resume\left(\right)$ 的调用方，或者恢复当前协程，使用<code>bool</code>返回风格。</li>
<li>如果你需要恢复其他协程，使用对称转移风格。</li>
</ul>
<h2 id="补充">补充</h2>
<p>        <code>C++ 20</code>新加的对称转移能力，使得协程递归恢复对方变得简单，不需要担心栈溢出。这个能力是编写高效、安全的异步协程类型的关键，就像 $task$ 那样。<br>
        这篇关于对称转移的文章比预期的要长，十分感谢你坚持读完了它！希望能帮到你。<br>
        在下篇文章，我会讲解编译器怎么把协程函数转换成状态机。</p>
<h2 id="致谢">致谢</h2>
<p>        也是不翻了~</p>

            </div>
            <div class="meta post-footer">
                <span>2024 Jan 28 23:45</span>
                <a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B4%E7%90%86%E8%A7%A3%E5%AF%B9%E7%A7%B0%E8%BD%AC%E7%A7%BB/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B3%E7%90%86%E8%A7%A3promise/">C&#43;&#43;协程（3）：理解promise</a></h1>
            <div class="post-content">
                
                
                <p>        这篇文章是<a href="http://wg21.link/N4736"><code>C++</code>协程标准</a>系列的第三篇文章。<br>
        之前的文章可以在这里查看：</p>
<ul>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/">协程理论</a></li>
<li><a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/">理解co_await</a></li>
</ul>
<p>        在这篇文章我会讲解你写的代码是怎么被编译器编译成协程代码的，并且你可以通过定义自己的 $Promise$ 类型来自定义协程行为。</p>
<h2 id="协程概念">协程概念</h2>
<p>        协程标准添加了三个新的关键字：$co_-await$，$co_-yield$ 和 $co_-return$ 。无论你在函数体里使用哪个，编译器都会把这个函数编译成协程，这个函数也不再是普通函数。<br>
        编译器使用一些相当机械的转换来把你写的代码变成状态机，从而可以在函数内的特定点挂起，并在之后恢复执行。<br>
        在之前的文章我描述了协程标准引入的两个接口中的第一个接口：$Awaitable$ 接口。而第二个接口, $Promise$ 接口则对于这种代码转换来说十分重要。<br>
        $Promise$ 接口规定了自定义它所在协程行为的方法。库开发者可以用它定义协程被调用时的行为，协程返回的行为 ( 包括普通方式返回或者通过未处理异常返回 )，协程内使用 $co_-await$ 或者 $co_-yield$ 表达式的行为。</p>
<h2 id="promise对象">Promise对象</h2>
<p>        $Promise$ 对象通过实现协程执行过程中特定点的调用方法的形式来定义和控制对应协程的行为。</p>
<blockquote>
<p>在继续之前，我希望你能忘掉之前所有关于 $promise$ 是什么的记忆。在一些用例中，协程的 $promise$ 对象与 $std$::$future$ 的 $std$::$promise$ 的功能很相似，但在其他用例中，并不能拿来相比。可能把协程的 $promise$ 对象想象成一个用于控制协程行为、跟踪协程状态的“协程状态控制器”会更合适。</p></blockquote>
<p>        $promise$ 对象实例会跟随着每个协程函数调用时创建的协程帧一起被构造。<br>
        编程器会在协程执行的关键点生成对 $promise$ 对象的特定方法的调用。<br>
        在接下来的例子中，我们把某个特定协程在协程帧内创建的 $promise$ 对象叫做 $promise$ 。<br>
        当你编写一个协程函数体 &lt;$body$-$statement$&gt; ，函数体包含了某个协程关键字 ( $co_-return$，$co_-await$，$co_-yield$ )，那么协程体将转变为 ( 大致地 ) 如下形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">initial_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">try</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">body</span><span class="o">-</span><span class="n">statement</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">catch</span> <span class="p">(...)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">promise</span><span class="p">.</span><span class="n">unhandled_exception</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nl">FinalSuspend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">co_await</span> <span class="n">promise</span><span class="p">.</span><span class="n">final_suspend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        一个协程函数被调用后，在执行之前会有一系列的准备步骤，这些步骤与常规的函数会有些不同。<br>
        以下是一个步骤总结 ( 我会在接下来详细介绍每个步骤 )：</p>
<ol>
<li>通过 $operator$ $new$ 分配协程帧 ( 可选的 )。</li>
<li>将所有函数参数拷贝到协程帧。</li>
<li>调用 $promise$ 对象的构造函数，$promise$ 类型记为 $P$ 。</li>
<li>调用 $promise.get_-return_-object\left(\right)$ 方法获取协程首次挂起时需要返回给调用方的返回值，并保存为一个局部变量。</li>
<li>调用 $promise.initial_-suspend\left(\right)$ ，并将返回值作为 $co_-await$ 的参数调用。</li>
<li>当 $co_-await$ $promise.initial_-suspend\left(\right)$ 表达式恢复 ( 可能立即恢复或者异步恢复 ) 后，协程开始执行你编写的协程体语句。</li>
</ol>
<p>        当协程执行到 $co_-return$ 语句时，会进行一些额外的步骤：</p>
<ol>
<li>调用 $promise.return_-void\left(\right)$ 或者 $promise.return_-value$(&lt;$expr$&gt;)。</li>
<li>以与创建顺序相反的顺序自动销毁所有具有自动生命周期的变量。</li>
<li>$co_-await$ 调用 $promise.final_-suspend\left(\right)$ 获取结果。</li>
</ol>
<p>        如果执行因为一个未处理异常停止，那么会发生：</p>
<ol>
<li>在<code>catch</code>块中捕获异常，调用 $promise.unhandled_-exception\left(\right)$ 。</li>
<li>调用 $promise.final_-suspend\left(\right)$ ，并将返回值作为 $co_-await$ 的参数调用。</li>
</ol>
<p>        一旦执行到协程体之外，协程帧就会被销毁。通过以下步骤销毁协程帧：</p>
<ol>
<li>调用 $promise$ 对象的析构函数。</li>
<li>调用拷贝的函数参数的析构函数。</li>
<li>调用 $operator$ $delete$ 释放协程帧的内存空间 ( 可选的 )。</li>
<li>返回控制权给调用方 / 恢复方。</li>
</ol>
<p>        当执行首次到达 $co_-await$ 表达式的 &lt;$return$-$to$-$caller$-$resumer$&gt; 点，或者协程没有到达任何 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点就完成时，协程要么被挂起，要么被销毁，然后之前调用 $promise.get_-return_-object\left(\right)$ 返回的结果就会被返回给协程的调用方。</p>
<h3 id="分配协程帧">分配协程帧</h3>
<p>        首先，编译器生成一个对协程帧的 $operator$ $new$ 调用来分配内存。<br>
        如果 $promise$ 类型 $P$，定义了一个自身版本的 $operator$ $new$ ，那么就会调用它定义的，否则就调用全局的。<br>
        这里有几个重点需要注意：<br>
        传给 $operator$ $new$ 的大小不是 $sizeof\left(P\right)$ ，而是整个编译过程中编译器根据：入参数量和大小、$promise$ 对象的大小、局部变量的数量和大小、以及一些其他编译相关的管理协程状态的空间大小，计算出来的协程帧大小。<br>
        如果满足以下条件，编译器可以省掉对 $operator$ $new$ 的调用：</p>
<ul>
<li>协程帧的生命周期严格内嵌于调用方的生命周期。</li>
<li>编译器可以在调用点计算出协程帧需要的内存大小。</li>
</ul>
<p>        在这种情况下，编译器可以在调用方的调用帧 ( 栈帧部分或者协程帧部分 ) 上分配协程帧的空间。<br>
        协程标准没有定义什么情况下需要跳过分配，所以你需要在协程帧分配可能抛出 $std$::$bad_-alloc$ 异常的前提下编写代码。这意味着你不应该把一个协程函数声明成<code>noexcept</code>，除非你确定协程分配协程帧内存失败后会调用 $std$::$terminate\left(\right)$ 。<br>
        然而，有一个后备方案可以处理协程帧分配失败。在不允许异常的环境下，例如集成场景或者高性能场景这种不能容忍异常开销的场景，这种方式十分必要。<br>
        如果 $promise$ 类型提供了一个静态的 $P$::$get_-return_-object_-on_-allocation_-failure\left(\right)$ 成员函数，编译器会生成一个对 $operator$ $new$($size_-t$, $nothrow_-t$) 的重载调用。如果调用返回<code>nullptr</code>，那么协程会立即调用 $P$::$get_-return_-object_-on_-allocation_-failure\left(\right)$ 并把结果返回给调用方，而不是抛出异常。</p>
<h4 id="自定义协程帧内存分配">自定义协程帧内存分配</h4>
<p>        你的 $promise$ 类型可以重载 $operator$ $new$ ，这样如果编译器需要分配协程帧内存，就会使用你定义的 $operator$ $new$ 而不是全局的 $operator$ $new$ 。<br>
        例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_promise_type</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">my_custom_allocate</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">my_custom_free</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        我知道你想问什么：“要怎么自定义 $allocator$ 呢?”。<br>
        你也可以提供 $P$::$operator$ $new\left(\right)$ 的重载，接收额外的参数，如果能找到合适的重载，将使用协程函数参数的左值引用调用。这种方式可以用来 $hook$ $operator$ $new$ ，使其调用某个作为参数传递给协程函数的 $allocator$ 的 $allocate\left(\right)$ 方法。<br>
        你需要做一些额外工作来在分配好的内存中拷贝一份 $allocator$ 的副本，这样才能在相应的 $operator$ $delete$ 调用中引用它，因为 $allocator$ 不会作为参数传递给的 $operator$ $delete$ 。这是因为入参会被存储在协程帧，所以他们有可能会在 $operator$ $delete$ 调用之前就被销毁了。<br>
        例如，你可以实现 $operator$ $new$ 来给协程帧分配一些额外内存，并利用这个空间来存储 $allocator$，用于释放协程帧内存。<br>
        例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ALLOCATOR</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">my_promise_type</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">sz</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">ALLOCATOR</span><span class="o">&amp;</span> <span class="n">allocator</span><span class="p">,</span> <span class="n">ARGS</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Round up sz to next multiple of ALLOCATOR alignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">allocatorOffset</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="n">sz</span> <span class="o">+</span> <span class="k">alignof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// CAll onto allocator to allocate space for coroutine frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">allocatorOffset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Take a copy of the allocator (assuming noexcept copy constructor here)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">new</span> <span class="p">(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">)</span> <span class="o">+</span> <span class="n">allocatorOffset</span><span class="p">)</span> <span class="n">ALLOCATOR</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">sz</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">allocatorOffset</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="n">sz</span> <span class="o">+</span> <span class="k">alignof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1u</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ALLOCATOR</span><span class="o">&amp;</span> <span class="n">allocator</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">ALLOCATOR</span><span class="o">*&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">)</span> <span class="o">+</span> <span class="n">allocatorOffset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Move allocator to local variable first so it isn&#39;t freeing its
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// own memory from underneath itself.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Assuming allocator move-constructor is noexcept here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ALLOCATOR</span> <span class="n">allocatorCopy</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// But don&#39;t forget to destruct allocator object in coroutine frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">allocator</span><span class="p">.</span><span class="o">~</span><span class="n">ALLOCATOR</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Finally, free the memory using the allocator.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">allocatorFactory</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">allocatorOffset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ALLOCATOR</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        为了 $hook$ 成功，让自定义的 $my_-promise_-type$ 被协程使用，需要让 $std$::$allocator_-arg$ 作为第一个入参，这需要通过 $coroutine_-traits$ 类 ( 详细见后续的 $coroutine_-traits$ 章节 ) 来指定。<br>
        例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ALLOCATOR</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_traits</span><span class="o">&lt;</span><span class="n">my_return_type</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">ALLOCATOR</span><span class="p">,</span> <span class="n">ARGS</span><span class="p">...</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="n">my_promise_type</span><span class="o">&lt;</span><span class="n">ALLOCATOR</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        注意，即使你自定义了协程的内存分配策略，<strong>编译器还是可以选择跳过你的自定义内存分配器</strong>。</p>
<h3 id="拷贝参数到协程帧">拷贝参数到协程帧</h3>
<p>        协程需要从原始调用方中把所有传给协程的参数拷贝到协程帧，这样才能保证协程被挂起后，它们依然有效。<br>
        如果参数是值传递的，那么这些参数将会通过移动构造函数拷贝到协程帧。<br>
        如果参数以引用传递 ( 左值或者右值 )，那么只有引用会被拷贝到协程帧，而不是它们指向的值。<br>
        注意如果类型的析构函数是默认的，并且在到达 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点后不再引用，编译器可以选择跳过该参数副本的析构函数。<br>
        在以引用方式传递参数给协程的过程中，存在几个陷阱，也因此你不能在协程生命周期中依赖引用。许多常见的用于普通函数的技术，例如完美转发和通用引用，用到协程上可能导致代码出现未定义行为。如果你想了解更多，Toby Allsopp 写了一篇关于这个主题的<a href="https://toby-allsopp.github.io/2017/04/22/coroutines-reference-params.html">好文章</a>。<br>
        如果某个参数的拷贝/移动构造函数抛出了异常，那么已经构造好的参数的析构函数将被调用，协程帧会被释放，异常会传播给调用方。</p>
<h3 id="构造-promise-对象">构造 promise 对象</h3>
<p>        一旦所有参数被拷贝到协程帧，协程会构造 $promise$ 对象。<br>
        参数在 $promise$ 对象之前构造的原因是让 $promise$ 对象可以在构造函数中访问先前拷贝的参数。<br>
        首先，编译器检查 $promise$ 是否存在接收每个拷贝参数左值引用作为参数的重载构造函数，如果找到了这种函数，编译器会生成对这个构造函数的调用，如果没有找到，编译器会使用 $promise$ 类型的默认构造函数。<br>
        注意 $promise$ 构造函数可以“看到”入参是一个对协程标准相对较新的改动，在 Jacksonville 2018 会议的<a href="http://wg21.link/N4723">N4723</a> 中被采纳，提案为<a href="http://wg21.link/P0914R1">P0914R1</a>。因此对于一些较老版本的<code>Clang</code>或者<code>MSVC</code>来说可能还不支持。<br>
        如果 $promise$ 构造函数抛出了一个异常，那么入参的拷贝会析构，协程帧会在异常传播回给调用方之前被释放。</p>
<h3 id="获取返回对象">获取返回对象</h3>
<p>        协程要对 $promise$ 对象做的第一件事是调用 $promise.get_-return_-object\left(\right)$ 获取返回对象。<br>
        返回对象是协程函数初次挂起或者运行完成移交控制权后要返回给调用方的值。<br>
        你可以认为控制流 ( 大致上 ) 是这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// Pretend there&#39;s a compiler-generated structure called &#39;coroutine_frame&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1">// that holds all of the state needed for the coroutines. Its constructor
</span></span></span><span class="line"><span class="cl"><span class="c1">// takes a copy of parameters and default-constructs a promise object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">coroutine_frame</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="nf">some_corouine</span><span class="p">(</span><span class="n">P</span> <span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">coroutine_frame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">returnObject</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">promise</span><span class="p">.</span><span class="n">get_return_object</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Start execution of the coroutine body by resuming it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This call will return when the coroutine gets to the first.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// suspend-point or when the coroutine runs to completion.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">promise</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">promise</span><span class="p">).</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Then the return object is returned to the caller.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">returnObject</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        注意我们需要在协程体开始执行之前获取返回对象，因为协程帧 ( 或者说 $promise$ 对象 ) 可能在 $coroutine_-handle$::$resume\left(\right)$ 调用返回前就被销毁，可能在当前线程销毁，也可能在其他线程，所以在协程体开始执行后调用 $get_-return_-object\left(\right)$ 是不安全的。</p>
<h3 id="初次挂起点">初次挂起点</h3>
<p>        协程帧初始化，获取返回对象之后，要做的下一件事是执行 $co_-await$ $promise.initial_-suspend\left(\right);$ 。<br>
        这让 $promise$ 类型的开发者可以控制协程在执行编写好的协程体代码之前是否需要挂起，或者立即执行协程体。<br>
        如果协程在初次挂起点挂起，那么它可以在之后你选择的某个时间点对 $coroutine_-handle$ 调用 $resume\left(\right)$ 来恢复，或者调用 $destroy\left(\right)$ 销毁。<br>
        $co_-await$ $promise.initial_-suspend\left(\right)$ 表达式的结果会被丢弃，所以 $awaiter$ 的 $await_-resume\left(\right)$ 函数实现应该返回<code>void</code>。<br>
        特别注意这个语句是在<code>try/catch</code>块保护之外的 ( 如果你忘记了，可以往上翻翻再看下代码 )。这意味着 $co_-await$ $promise.initial_-suspend\left(\right)$ 抛出的异常等同于到达它的 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点，会在协程销毁调用栈和返回对象后，再抛回给调用方。<br>
        要明白如果你的返回对象是<code>RAII</code>的，即会在协程帧被析构的时候销毁，那么你需要保证 $co_-await$ $promise.initial_-suspend\left(\right)$ 是<code>noexcept</code>的，这样才能避免 double-free。</p>
<blockquote>
<p>注意这里有个提案，希望调整语义，以便 $co_-await$ $promise.initial_-suspend\left(\right)$ 表达的全部或者部分位于<code>try/catch</code>块内，所以这里的明确语义可能会在最终确定前发生变化。</p></blockquote>
<p>        对于许多协程类型来说，$initial_-suspend\left(\right)$ 方法要么返回 $std$::$experimental$::$suspend_-always$ ( 如果操作懒开始 )，要么返回 $std$::$experimental$::$suspend_-never$ ( 如果操作立即开始 )。而它们都是<code>noexcept</code>的 $awaitable$ ，所以这通常不是问题。</p>
<h3 id="返回给调用方">返回给调用方</h3>
<p>        当协程函数达到首个 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点 ( 或者没有到达，但是协程执行完成 ) 时，通过 $get_-return_-object\left(\right)$ 获取的返回对象会返回给协程的调用方。<br>
        注意返回对象的类型并不需要与协程函数的返回类型相同。在必要的时候，返回对象可以是一个能够隐式转换为协程返回类型的类型。</p>
<blockquote>
<p>注意<code>Clang</code>的协程实现 ( 从$5.0$ 开始 ) 会在返回对象从协程调用返回后才会转换，而<code>MSVC</code>自从 2017 Update 3 开始会在 $get_-return_-object\left(\right)$ 调用之后立即转换。虽然协程标准没有显式给出预期行为，我相信<code>MSVC</code>有计划把它们的实现改成更像<code>Clang</code>的实现，因为这种实现允许一些<a href="https://github.com/toby-allsopp/coroutine_monad">有趣的用例</a>。</p></blockquote>
<h3 id="使用-co_return-从协程返回">使用 co_return 从协程返回</h3>
<p>        当协程到达 $co_-return$ 语句，它会被翻译成一个 $promise.return_-void\left(\right)$ 调用或者 $promise.return_-value$(&lt;$expr$&gt;) 以及一个 $goto$ $FinalSuspend$; 调用。<br>
        翻译规则如下：</p>
<ul>
<li>$co_-return$;
<ul>
<li>-&gt; $promise.return_-void\left(\right)$</li>
</ul>
</li>
<li>$co_-return$ &lt;$expr$&gt;
<ul>
<li>-&gt; 如果 &lt;$expr$&gt; 类型为<code>void</code>，&lt;$expr$&gt;; $promise.return_-void\left(\right)$;</li>
<li>-&gt; 如果 &lt;$expr$&gt; 类型不为<code>void</code>，$promise.return_-value$(&lt;$expr$&gt;);</li>
</ul>
</li>
</ul>
<p>        随后的 $goto$ $FinalSuspend;$ ，会在 $co_-await$ $promise.final_-suspend\left(\right)$ 之前触发所有自动生命周期的局部变量按照与构造顺序相反的顺序析构。<br>
        注意如果协程函数体代码没有以 $co_-return$ 语句结束，会等同于以 $co_-return;$ 结束。在这个例子中，如果 $promise$ 类型没有 $return_-void\left(\right)$ 方法，那么行为会是未定义的。<br>
        如果 &lt;$expr$&gt; 或者 $promise.return_-void\left(\right)$ 调用或者 $promise.return_-value\left(\right)$ 抛出了一个异常，那么异常仍然会传给 $promise.unhandled_-exception\left(\right)$ ( 见下方 )。</p>
<h3 id="处理传播到协程体以外的异常">处理传播到协程体以外的异常</h3>
<p>        如果一个异常传播到协程体之外，那么异常会被<code>catch</code>块捕获，并调用 $promise.unhandled_-exception\left(\right)$ 方法。<br>
        这个方法典型实现是调用 $std$::$current_-exception\left(\right)$ 来捕获异常的副本，在后续抛出到其他上下文。<br>
        其他可选实现是立即通过 $throw;$ 语句重新抛出异常，例如 <a href="https://github.com/facebook/folly/blob/4af3040b4c2192818a413bad35f7a6cc5846ed0b/folly/Optional.h#L587">$folly$::$Optional$</a>。然而，这么做会 ( 或者说很可能，见下方 ) 导致协程帧被立即销毁，并将异常传播回调用方 / 恢复方。这可能会导致某些抽象出现问题，因为它们假设 / 要求对 $coroutine_-handle$::$resume\left(\right)$ 的调用是<code>noexcept</code>，所以你应该只在能够完全控制谁 / 什么调用 $resume\left(\right)$ 时使用这种方式。<br>
        注意现在<a href="http://wg21.link/N4736">协程标准</a>在调用 $unhandled_-exception\left(\right)$ 时重新抛出异常 ( 或者在<code>try-catch</code>块之外抛出异常 ) 的预期行为描述<a href="https://github.com/GorNishanov/CoroutineWording/issues/17">并不是很清晰</a>。<br>
        我现在对标准的解释是如果控制权离开了协程体，可以通过 $co_-await$ $promise.initial_-suspend\left(\right)$ 、$promise.unhandled_-exception\left(\right)$ 或者 $co_-await$ $promise.final_-suspend\left(\right)$ 把异常传播出去，也可以通过 $co_-await$ $promise.final_-suspend\left(\right)$ 调用同步结束协程执行。无论哪种方式，都会在返回给调用方 / 恢复方前自动销毁协程帧。然而，这种解释也有问题。<br>
        我希望未来版本能够细化并描述清楚这种情况。无论如何，在那之前我不会从 $initial_-suspend\left(\right)$ 、$final_-suspend\left(\right)$ 或者 $unhandled_-exception\left(\right)$ 中抛出异常。敬请关注！</p>
<h3 id="最终挂起点">最终挂起点</h3>
<p>        一旦协程体执行离开了用户定义的部分后，结果会通过 $return_-void\left(\right)$ 、$return_-value\left(\right)$ 或者 $unhandled_-exception\left(\right)$ 调用捕获，所有局部变量被析构，在返还控制权给调用方 / 恢复方之前，协程可以执行一些额外的逻辑。<br>
        这时候协程执行的是 $co_-await$ $promise.final_-suspend\left(\right);$ 语句。<br>
        它允许协程执行一些逻辑，比如发布结果，发出完成信号或者恢复后续协程执行。它也允许协程选择性地在协程执行完成、协程帧被销毁前立即挂起。<br>
        注意 $resume\left(\right)$ 一个在 $final_-suspend$ 点挂起的协程是未定义行为。对于这种协程，你只能调用 $destroy\left(\right)$。<br>
        根据 Gor Nishanov 的观点，这种限制的理由是它能让编译器做出更多优化，因为最终挂起点无需维护完整的协程上下文，从而优化了协程状态，而且降低了分支复杂度。<br>
        注意协程也可以不在 $final_-suspend$ 点挂起，<strong>只是建议你尽可能设计一个会在这个点挂起的协程</strong>。因为这样可以强制你在协程外调用 $.destroy\left(\right)$ ( 通常通过<code>RAII</code>对象的析构函数调用 )，并且可以方便编译器确定协程帧的生命周期是否内嵌于调用方，从更让编译器更有可能优化掉协程帧的内存分配。</p>
<h3 id="编译器怎么选择-promise-类型">编译器怎么选择 promise 类型</h3>
<p>        让我们看看编译器怎么决定协程使用哪个 $promise$ 类型。<br>
        协程 $promise$ 对象的类型通过 $std$::$experimental$::$coroutine_-traits$ 类决定。<br>
        如果你有一个协程函数签名如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">x</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">flag</span><span class="p">);</span>
</span></span></code></pre></div><p>        那么编译器会通过返回类型和参数类型作为 $coroutine_-traits$ 的模板参数来推导协程的 $promise$ 类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typename</span> <span class="n">coroutine_traits</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span></code></pre></div><p>        如果函数是非静态成员函数，<code>class</code>类型会作为第二个模板参数传递给 $coroutine_-traits$。注意如果你的方法是右值引用重载的，那么第二个模板参数也会是右值引用。<br>
        例如，如果你有以下方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">my_class</span><span class="o">::</span><span class="n">method1</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">task</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span> <span class="n">my_class</span><span class="o">::</span><span class="n">method2</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
</span></span></code></pre></div><p>        编译器会使用以下 $promise$ 类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// method1 promise type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typename</span> <span class="n">coroutine_traits</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">const</span> <span class="n">my_class</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// method2 promise type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typename</span> <span class="n">coroutine_traits</span><span class="o">&lt;</span><span class="n">task</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">my_class</span><span class="o">&amp;&amp;&gt;::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span></code></pre></div><p>        $coroutine_-traits$ 模板会默认查找返回类型是否存在内嵌 $promise$ 类型，并使用其作为 $promise$ 类型，例如这样 ( 不过通过一些<code>SFINAE</code>魔法，如果 $RET$::$promise_-type$ 没有定义，那么 $promise$ 类型也是未定义的 )：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RET</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_traits</span><span class="o">&lt;</span><span class="n">RET</span><span class="p">,</span> <span class="n">ARGS</span><span class="p">...</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">RET</span><span class="o">::</span><span class="n">promise_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        所以对于你可以控制的协程返回类型，你可以在里面定义一个内嵌的 $promise$ 类型，让编译器直接使用作为协程的 $promise$ 对象。<br>
        例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">task</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="n">task_promise</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        然而，对于你无法控制的协程返回类型，你可以在不修改类型的前提下，通过指定 $coroutine_-traits$ 来控制 $promise$ 类型。<br>
        例如，给一个返回 $std$::$optional$&lt;$T$&gt; 的协程定义 $promise$ 类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">ARGS</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_traits</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ARGS</span><span class="p">...</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">promise_type</span> <span class="o">=</span> <span class="n">optional_promise</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="识别特定协程调用帧">识别特定协程调用帧</h3>
<p>        当你调用一个协程函数时，协程帧会被创建。为了恢复关联的协程或者销毁协程帧，你需要一些方法识别或者引用对应的协程帧。<br>
        协程标准通过 $coroutine_-handle$ 类型提供了这个机制。<br>
        类型接口 ( 大致上 ) 如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Type-erased coroutine handle. Can refer to any kind of coroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Doesn&#39;t allow access to the promise object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Constructs to the null handle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">constexpr</span> <span class="nf">coroutine_handle</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Convert to/from a void* for passing into C-style interop functions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">constexpr</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Query if the handle is non-null.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">constexpr</span> <span class="k">explicit</span> <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Query if the coroutine is suspended at the final_suspend point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Undefined behavior if coroutine is not currently suspended.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Resume/Destroy the suspended coroutinie
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Coroutine handle for coroutines with a known promise type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Template argument must exactly match coroutine&#39;s promise type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span> <span class="o">:</span> <span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">coroutine_handle</span><span class="o">&lt;&gt;::</span><span class="n">coroutine_handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Access to the coroutine&#39;s promise object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// You can reconstruct the coroutine handle from the promise object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_promise</span><span class="p">(</span><span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        你可以通过两种方式获取一个协程的 $coroutine_-handle$ ：</p>
<ol>
<li>$coroutine_-handle$ 会在 $co_-await$ 表达式中被传递给 $await_-suspend\left(\right)$ 。</li>
<li>如果你有一个协程 $promise$ 对象的引用，你可以通过 $coroutine_-handle$&lt;$Promise$&gt;::$from_-promise\left(\right)$ 重新构造出它的 $coroutine_-handle$ 。</li>
</ol>
<p>        当协程到达$co_-await$ 表达式的 &lt;$suspend$-$point$&gt; 被挂起后，等待该协程的其他协程的 $coroutine_-handle$ 会被传给 $awaiter$ 的 $await_-suspend\left(\right)$ 方法。你可以认为这个 $coroutine_-handle$ 是 <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">续体传递风格</a> ( $continuation-passing$ $style$ ) 中协程续体的表示。<br>
        注意 $coroutine_-handle$ <strong>不是</strong><code>RAII</code>对象。你必须手动调用 $.destroy\left(\right)$ 来销毁协程帧，释放资源。可以把它视为一个用于管理内存的 $void*$ 值。这么设计是出于性能原因：<code>RAII</code>会带来额外的开销，比如需要引用计数管理。<br>
        你应该尝试使用更高级的支持协程<code>RAII</code>语义的类型，例如<a href="https://github.com/lewissbaker/cppcoro">cppcoro</a>提供的 ( 不要脸地植入 )，或者编写一个你自己的更高级的类型，封装你协程类型的协程帧生命周期。</p>
<h3 id="自定义-co_await-行为">自定义 co_await 行为</h3>
<p>        $promise$ 类型可以自定义出现在协程体内的每个 $co_-await$ 表达式行为。<br>
        通过简单地定义 $promise$ 类型的 $await_-transform\left(\right)$ 方法，编译器会把协程体里的每个 $co_-await$ &lt;$expr$&gt; 转换成 $co_-await$ $promise.await_-transform$(&lt;$expr$&gt;)。<br>
        这里有一些重要且有用的用法：<br>
        <strong>它能让协程等待一些非 $awaitable$ 类型。</strong><br>
        例如，一个返回 $std$::$optional$&lt;$T$&gt; 类型的协程可能会重载 $promise$ 类型的 $await_-transform\left(\right)$ ，接受 $std$::$optional$&lt;$U$&gt; 并返回一个 $awaitable$ 类型，该类型会返回类型 $U$ 的值，或者在<code>nullopt</code>时挂起协程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">optional_promise</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">await_transform</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">awaiter</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">explicit</span> <span class="n">awaiter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">has_value</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="kt">void</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">      <span class="n">U</span><span class="o">&amp;</span> <span class="n">await_resume</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">awaiter</span><span class="p">{</span> <span class="n">value</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        <strong>它可以让你通过删除 $await_-transform$ 方法来禁止等待一个特定类型。</strong><br>
        例如，一个 $std$::$generator$&lt;$T$&gt; 返回类型的 $promise$ 类型可能会声明一个已删除的 $await_-transform\left(\right)$ 且接收所有类型的模板成员函数。这基本上禁止了所有在协程内的 $co_-await$ 调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">generator_promise</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Disable any use of co_await within this type of coroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">suspend_never</span> <span class="n">await_transform</span><span class="p">(</span><span class="n">U</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        <strong>它可以适配和改变常规 $awaitable$ 值的行为。</strong><br>
        例如，你可以定义一个协程类型，通过把 $awaitable$ 包装在 $resume_-on\left(\right)$ 操作中 ( 参考 $cppcoro$::$resume_-on\left(\right)$ )，保证协程始终在关联的 $executor$ 上的 $co_-await$ 表达式中恢复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Executor</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">executor_task_promise</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Executor</span> <span class="n">executor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Awaitable</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">await_transform</span><span class="p">(</span><span class="n">Awaitable</span><span class="o">&amp;&amp;</span> <span class="n">awaitable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">cppcoro</span><span class="o">::</span><span class="n">resume_on</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">resume_on</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">executor</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        作为 $await_-transform\left(\right)$ 介绍的最后一句话，特别要注意的是，如果 $promise$ 类型定义了 $await_-transform\left(\right)$ 成员，编译器就会把所有 $co_-await$ 替换成 $promise.await_-transform\left(\right)$ 调用。这意味着如果你想要只给某些类型定制 $co_-await$ 行为，你也需要重载默认的只转发参数的 $await_-transform\left(\right)$ 实现。</p>
<h3 id="自定义-co_yield-行为">自定义 co_yield 行为</h3>
<p>        最后一个你可以通过 $promise$ 类型自定义行为的是 $co_-yield$ 关键字。<br>
        如果 $co_-yield$ 关键字在协程内出现，编译器会把表达式 $co_-yield$ &lt;$expr$&gt; 翻译成 $co_-await$ $promise.yield_-value$(&lt;$expr$&gt;) 。因此 $co_-yield$ 的行为可以通过定义一个或多个 $promise$ 类型的 $yield_-value\left(\right)$ 方法定制。<br>
        注意，不像 $await_-transform$ ，如果 $promise$ 类型没有定义 $yield_-value\left(\right)$ 方法，$co_-yield$ 没有默认行为。所以如果需要禁止 $co_-await$ 表达式，$promise$ 类型需要显式删除 $await_-transform\left(\right)$ 方法，但是 $co_-yield$ 则不用。<br>
        一种典型的 $promise$ 类型的 $yield_-value\left(\right)$ 方法实现是 $generator$&lt;$T$&gt; 类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">generator_promise</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">T</span><span class="o">*</span> <span class="n">valuePtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">suspend_always</span> <span class="n">yield_value</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Stash the address of the yielded value and then return an awaitable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// that will cause the coroutine to suspend at the co_yield expression.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Execution will then return from the call to coroutine_handle&lt;&gt;::resume()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// inside either generator&lt;T&gt;::begin() or generator&lt;T&gt;::iterator::operator++().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">valuePtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="总结">总结</h2>
<p>        在这篇文章中，我依次介绍了编译器将函数编译成协程时的每个转换。<br>
        希望这篇能够帮你理解怎么通过定义自己的 $promise$ 类型的方式来定制不同类型的协程行为。协程机制中有许多可以变动的部分，所以有许多种自定义行为的方式。<br>
        然而，编译器有一个更重要的转换我还没讲——把协程体转换成状态机。不过要是讲这块的话，这篇文章就太长了，所以我把它放到了下一篇文章。请保持关注！</p>

            </div>
            <div class="meta post-footer">
                <span>2024 Jan 27 16:19</span>
                <a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B3%E7%90%86%E8%A7%A3promise/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/">C&#43;&#43;协程（2）：理解co_await</a></h1>
            <div class="post-content">
                
                
                <p>        在<a href="https://z217blog.cn/post/c++%E5%8D%8F%E7%A8%8B1%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/">之前的文章</a>中，我介绍了函数和协程在高级表现的区别，但还没有讲到到<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf"><code>C++</code>协程标准</a>的语法和语义。<br>
        <code>C++</code>协程标准提供的一个关键能力是挂起协程，并在之后恢复。这个机制是通过 $co_-await$ 提供的。<br>
        在揭开协程的神秘面纱前，我们需要理解 $co_-await$ 的工作方式，了解它是如何挂起和恢复协程的。在这篇文章中，我会解释 $co_-await$ 的机制，并介绍<strong>Awaitable</strong>与<strong>Awaiter</strong>的概念。<br>
        在这之前，作为背景，我想先简单回顾下协程标准。</p>
<h2 id="协程标准带来了什么">协程标准带来了什么？</h2>
<ul>
<li>三个关键字 $co_-await$ ，$co_-yield$ 和 $co_-return$</li>
<li>一些 $std$::$experimental$ 命名空间的新类型：
<ul>
<li>$coroutine_-handle$&lt;$P$&gt;</li>
<li>$coroutine_-traits$&lt;$Ts$&hellip;&gt;</li>
<li>$suspend_-always$</li>
<li>$suspend_-never$</li>
</ul>
</li>
<li>一种允许库开发者与协程交互、定制化行为的机制</li>
<li>一个让异步代码更容易编写的语言能力</li>
</ul>
<p>        <code>C++</code>协程标准可以认为在语言层面提供了一个低级汇编语言协程。这些功能很难以一种安全的方式直接使用，主要是提供给库开发者来实现高级抽象，从而应用开发者可以安全使用。<br>
        之后的语言标准 ( 希望是<code>C++20</code> ) 计划加入这些低级功能，同时让标准库提供一些包装了这些功能的高级类型，让应用开发者以更方便安全的方式使用。</p>
<h2 id="编译器---库交互">编译器 &lt;-&gt; 库交互</h2>
<p>        有趣的是，协程标准并没有明确定义协程语义，包括协程如何把值返回给调用方，$co_-return$ 如何处理返回值，如何处理传播到协程之外的异常，以及协程应该在哪个线程恢复。<br>
        相反的，它指定了一种可以让库代码定制化协程行为的机制，通过实现特定的接口类型。编译器使用库代码生成对应的调用。这种方式很像<code>range</code>模式，后者可以让库开发者通过定义 $begin\left(\right)$ / $end\left(\right)$ 和 $iterator$ 类型，来定制化代码。<br>
        协程的这种没有给机制定义特殊语义的方式，让它变成了一个强大的工具，允许库开发者实现各种类型的协程，以各种方式，出于各种目的。<br>
        例如，你可以实现一个异步生成单个值的协程，或者一个懒生成值序列的协程，或者一个简单消费 $optional$&lt;$T$&gt; 值，如果遇到 $nullopt$ 就提前退出的协程。<br>
        协程标准定义了两个接口：$Promise$ 和 $Awaitable$ 。<br>
        $Promise$ 接口指定了协程定制化行为的方法。库开发者可以通过该接口，实现当协程被调用时的行为，协程返回时的行为 ( 包括正常返回和抛出未处理异常 )，协程内使用 $co_-await$ 或者 $co_-yield$ 的行为。<br>
        $Awaitable$ 接口指定控制 $co_-await$ 语义的方法。当一个值是可以 $co_-await$ 的，代码就会被翻译成一系列的对 $awaitable$ 对象方法的调用。这个对象可以决定是否挂起当前协程，在挂起前执行一些逻辑用于后续的恢复，以及在恢复后生成 $co_-await$ 表达式的值。<br>
        我会在之后的文章再介绍 $Promise$ ，现在先来看看 $Awaitable$ 接口。</p>
<h2 id="awaiters-和-awaitables解释co_await">Awaiters 和 Awaitables：解释<code>co_await</code></h2>
<p>        $co_-await$ 运算符是一个新的一元运算符，接收一个值，比如：$co_-await$ $someValue$ 。<br>
        $co_-await$ 运算符只能在协程上下文中使用。这有一点重复定义了，因为根据定义，包含 $co_-await$ 操作符的函数都应该被编译成协程。<br>
        支持 $co_-await$ 运算符的类型被叫做 $Awaitable$ 类型。<br>
        注意，$co_-await$ 运算符能否对一个类型使用，取决于 $co_-await$ 表达式所在的上下文。协程使用的 $promise$ 类型可以通过 $await_-transform$ 方法 ( 之后介绍 )，决定 $co_-await$ 的语义。<br>
        为了更精确，我喜欢使用术语<strong>常规 Awaitable</strong> ( $Normally$ $Awaitable$ ) 来描述 $promise$ 类型未定义 $await_-transform$ 方法的协程，这种协程上下文支持 $co_-await$ 操作。使用术语<strong>语境化 Awaitable</strong>来描述 $promise$ 类型定义了 $await_-transform$ 方法的协程，这种类型仅在某些特别的上下文中才支持 $co_-await$ 运算符。<br>
        一个<strong>Awaiter</strong>类型实现了 $co_-await$ 调用会时使用到的三个方法：$await_-ready$ ，$await_-suspend$ 和 $await_-resume$ 。<br>
        注意我不要脸地从<code>C#</code> <code>asnyc</code>关键字中“借了” $Awaiter$ 这个术语。<code>C#</code>中这个术语指代可以通过 $GetAwaiter\left(\right)$ 方法返回类似于<code>C++</code> $Awaiter$ 对象的类型，而<code>C#</code>的 $Awaiter$ 也与<code>C++</code>有着诡异的相似，具体可以看<a href="https://weblogs.asp.net/dixin/understanding-c-sharp-async-await-2-awaitable-awaiter-pattern">这篇文章</a>。<br>
        注意一个类型既可以是 $Awaitable$ 类型，也可以是 $Awaiter$ 类型。<br>
        当编译器看到 $co_-awaiter$&lt;$expr$&gt; 表达式时，根据类型的不同，可能会有多种行为。</p>
<h3 id="获取-awaiter">获取 Awaiter</h3>
<p>        编译器要做的第一件事就是生成被等待值获取 $Awaiter$ 对象的代码。$N4680$ 在<code>5.3.8(3)</code>小节中列出了一系列的获取 $awaiter$ 对象的步骤。<br>
        假设等待中的协程的 $promise$ 类型是 $P$ ，并且 $promise$ 在当前协程中是一个左值引用。<br>
        如果 $promise$ 类型 $P$ 存在 $await_-transform$ 成员，&lt;$expr$&gt; 会被传入 $promise$.$await_-transform$(&lt;$expr$&gt;) 调用来获取 $Awaitable$ 值，记为 $awaitable$ 。相反，如果 $promise$ 类型没有 $await_-transform$ 成员，我们会直接使用 &lt;$expr$&gt; 来作为 $Awaitable$ 对象，同样记为 $awaitable$ 。<br>
        然后，如果 $Awaitable$ 对象 $awaitable$ 覆写了 $operator$ $co_-awaiter\left(\right)$ ，那么这个函数就会被调用，来获取 $Awaiter$ 对象。否则，$awaitable$ 会被直接作为 $awaiter$ 对象使用。<br>
        如果我们把这些规则使用函数 $get_-awaitable\left(\right)$ 和 $get_-awaiter\left(\right)$ 来编码，看起来就是这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">P</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get_awaitable</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">expr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">has_any_await_transform_member_v</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">promise</span><span class="p">.</span><span class="n">await_transform</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Awaitable</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">get_awaiter</span><span class="p">(</span><span class="n">Awaitable</span><span class="o">&amp;&amp;</span> <span class="n">awaitable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">has_member_operator_co_await_v</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">has_non_member_operator_co_await_v</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">operator</span> <span class="k">co_await</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">awaitable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="等待-awaiter">等待 Awaiter</h3>
<p>        假设我们把逻辑重新封装，把 &lt;$expr$&gt; 转换成上面那种获取 $Awaiter$ 对象的函数，那么 $co_-await$&lt;$expr$&gt; 可以简单翻译成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">expr</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">awaitable</span> <span class="o">=</span> <span class="n">get_awaitable</span><span class="p">(</span><span class="n">promise</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">awaiter</span> <span class="o">=</span> <span class="n">get_awaiter</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">awaitable</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)(</span><span class="n">awaitable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">awaiter</span><span class="p">.</span><span class="n">await_ready</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">handle_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">using</span> <span class="n">await_suspend_result_t</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="k">decltype</span><span class="p">(</span><span class="n">awaiter</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">handle_t</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">promise</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">suspend</span><span class="o">-</span><span class="n">coroutine</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_void_v</span><span class="o">&lt;</span><span class="n">await_suspend_result_t</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">awaiter</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">handle_t</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="k">return</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">caller</span><span class="o">-</span><span class="n">or</span><span class="o">-</span><span class="n">resumer</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">static_assert</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">await_suspend_result_t</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="s">&#34;await_suspend() must reutrn &#39;void&#39; or &#39;bool&#39;.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">awaiter</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">handle_t</span><span class="o">::</span><span class="n">from_promise</span><span class="p">(</span><span class="n">promise</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">&lt;</span><span class="k">return</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">caller</span><span class="o">-</span><span class="n">or</span><span class="o">-</span><span class="n">resumer</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="n">resume</span><span class="o">-</span><span class="n">point</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">awaiter</span><span class="p">.</span><span class="n">await_resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        <code>void</code>版本的 $await_-suspend\left(\right)$ 无条件地在调用返回后交还控制权，而<code>bool</code>版本的则允许 $awaiter$ 对象有条件地在返回后恢复协程执行而非交换控制权给调用方/恢复方。<br>
        <code>bool</code>版本的 $await_-suspend\left(\right)$ 在 $awaiter$ 发起一个需要异步完成的操作时十分有用。在这种情况下，当任务异步完成后，$await_-suspend$ 可以返回<code>false</code>，表示协程应该立即恢复并继续执行。<br>
        在 &lt;$suspend$-$coroutine$&gt; ( 挂起协程 ) 处，编译器会生成一些代码来保存协程状态，并准备好被恢复。这些状态包括保存 &lt;$resume$-$point$&gt;，以及将一些寄存器值保存到当前协程帧内存中。<br>
        当前协程在 &lt;$suspend$-$coroutine\left(\right)$&gt; 操作完成后，就被认为已挂起。$await_-suspend$ 调用内部是第一个可以观测到被挂起协程的地方。一旦被挂起，就可以在之后被恢复或者销毁。<br>
        一旦 $await_-suspend\left(\right)$ 操作完成，就要在之后对这个协程进行恢复 ( 或者销毁 )。注意 $await_-suspend\left(\right)$ 返回<code>false</code>相当于在当前线程中立即恢复协程。<br>
        $await_-ready\left(\right)$ 方法可以让你避免 &lt;$suspend$-$coroutine$&gt; 带来的开销，因为它可以返回操作是否可以在不需要挂起的前提下同步完成。<br>
        在 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点，控制权会返还给调用方或者恢复方，并弹出协程调用栈帧，保留协程栈帧。<br>
        当 ( 或者 ) 执行到 &lt;$resume$-$point$&gt; ( 恢复点 )，挂起的协程将被恢复。例如，在通过 $await_-resume\left(\right)$ 方法获取结果之前。<br>
        $await_-resume\left(\right)$ 方法的返回值会作为 $co_-await$ 表达式的结果。$await_-resume\left(\right)$ 方法也可以抛出一个异常，并将其传播到 $co_-await$ 表达式之外。<br>
        注意如果一个异常传播到 $await_-suspend\left(\right)$ 调用之外，协程将在没有 $await_-resume\left(\right)$ 调用的情况下被自动恢复，并将异常传播到 $co_-await$ 表达式之外。</p>
<h2 id="协程句柄">协程句柄</h2>
<p>        你可能注意到了，$coroutine_-handle$&lt;$P$&gt; 类型会被作为参数，在 $co_-await$ 表达式中传给 $await_-suspend\left(\right)$ 调用。 <br>
        这个类型代表一个无主的协程帧句柄，可以用来恢复协程执行，或者销毁协程帧。它可以用来获取协程的 $promise$ 对象。<br>
        $coroutine_-handle$ 类型有着如下 (省略了的) 接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">experimental</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">done</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="nf">address</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Promise</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">coroutine_handle</span> <span class="o">:</span> <span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_promise</span><span class="p">(</span><span class="n">Promise</span><span class="o">&amp;</span> <span class="n">promise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">coroutine_handle</span> <span class="nf">from_address</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        实现一个 $Awaitable$ 类型的时候，与 $coroutine_-handle$ 相关的关键方法是 $.resume\left(\right)$，它会在操作完成并且想要恢复等待中的协程执行的时候被调用。对 $coroutine_-handle$ 调用 $.resume\left(\right)$ 会在 &lt;$resume$-$point$&gt; 重新激活一个挂起的协程，在到达下一个 &lt;$return$-$to$-$caller$-$or$-$resumer$&gt; 点处返回。<br>
        $.destroy\left(\right)$ 方法销毁协程帧，调用作用域内的变量析构器，释放协程帧使用的内存空间。一般情况下，你不需要主动 (  事实上需要避免 ) 调用 $.destroy\left(\right)$，除非你是一个正在实现协程 $promise$ 类型的库开发者。通常，协程帧会被某些协程返回的<code>RAII</code>类型所持有。所以再调用 $.destroy\left(\right)$ 可能导致一个双重析构的bug。<br>
        $.promise\left(\right)$ 方法返回一个协程 $promise$ 对象的引用。然而，就像 $.destroy\left(\right)$，一般只会在需要编写 $promise$ 类型时有用。你应该把 $promise$ 对象视为协程的一个内部细节实现。对于大部分<strong>常规</strong> $Awaitable$ 类型，你应该使用 $coroutine_-handle$&lt;$void$&gt; 而不是 $coroutine_-handle$&lt;$Promise$&gt; 作为 $await_-suspend\left(\right)$ 方法的参数。<br>
        $coroutine_-handle$&lt;$P$&gt;::$from_-promise$($P$&amp; $promise$) 函数允许从协程 $promise$ 对象引用中重新构造协程。注意你必须保证类型 $P$ 与某个正在使用的协程帧匹配，如果 $P$ 的类型继承了 $promise$ 类型，并用于构造 $coroutine_-handle$&lt;$Base$&gt; ，会导致一些未定义行为。<br>
        $.address\left(\right)$ / $.from_-address\left(\right)$ 函数允许把一个协程句柄转换为 $void*$ 指针，或者从一个 $void*$ 指针转换为协程句柄。这主要是用来作为<code>context</code>参数传递给现有的<code>C</code>风格<code>API</code>使用，所以你可能在一些实现 $Awaitable$ 类型的情况会用到。然而，大部分情况<code>context</code>参数都需要一些额外的信息用来回调，所以我通常会把协程句柄存储在结构中并通过把结构指针作为<code>context</code>传递，而不是直接使用 $.address\left(\right)$ 的返回值。</p>
<h2 id="不需要同步的异步代码">不需要同步的异步代码</h2>
<p>        $co_-await$ 的一个十分有用的设计是协程可以在被挂起后，把控制权移交给调用方 / 恢复方前执行代码。<br>
        这可以让 $Awaiter$ 对象在被挂起后发起一个异步操作，把被挂起协程的 $coroutine_-handle$ 传给该操作，并在不需要任何额外同步的前提下安全地恢复操作 ( 可能在其他线程上 )。<br>
        例如，在 $await_-suspend\left(\right)$ 调用中，发起一个异步读操作，当协程被挂起，意味着我们可以在读操作完成后，恢复协程的执行。这一步不需要任何线程同步操作，不需要协调发起线程和执行线程的关系。</p>
<pre tabindex="0"><code>Time     Thread 1                           Thread 2
  |      --------                           --------
  |      ....                               Call OS - Wait for I/O event
  |      Call await_ready()                    |
  |      &lt;supend-point&gt;                        |
  |      Call await_suspend(handle)            |
  |        Store handle in operation           |
  V        Start AsyncFileRead ---+            V
                                  +-----&gt;   &lt;AsyncFileRead Completion Event&gt;
                                            Load coroutine_handle from operation
                                            Call handle.resume()
                                              &lt;resume-point&gt;
                                              Call to await_resume()
                                              execution continues....
           Call to AsyncFileRead returns
         Call to await_suspend() returns
         &lt;return-to-caller/resumer&gt;
</code></pre><p>        当使用这种方便的方式时，你需要小心的一点是，当把协程句柄发给其他线程时，其他线程可能在 $await_-suspend\left(\right)$ 调用返回前就尝试恢复协程执行，导致在 $await_-suspend\left(\right)$ 未完成时，协程继续执行了。<br>
        当协程恢复后，做的第一件事是调用 $await_-resume\left(\right)$ 获取结果，然后通常立马析构 $Awaiter$ 对象 ( 例如，$await_-suspend\left(\right)$ 调用的<code>this</code>指针 )。然后协程可能执行直到完成，在 $await_-suspend\left(\right)$ 返回前销毁协程和 $promise$ 对象。<br>
        所以在 $await_-suspend\left(\right)$ 方法，一旦协程有可能被另一个线程并行地恢复，你就需要避免访问<code>this</code>或者协程的 $.promise\left(\right)$ 对象，因为两者都可能被摧毁。总的来说，当挂起操作从发起到完成期间，只有局部变量是安全的。</p>
<h3 id="与有栈协程相比">与有栈协程相比</h3>
<p>        我想换个话题，快速地与现有的其他有栈协程比较下无栈协程在挂起后执行逻辑的能力，比如<code>Win32 fibers</code>或者<code>boost::context</code>。<br>
        对于许多有栈协程来说，挂起和恢复操作被合并成了“上下文切换”操作。通过“上下文切换”操作，当前协程在挂起后没有机会去执行逻辑，只是单纯地将控制权移交给其他协程。<br>
        这意味着，如果我们想要基于有栈协程实现一个类似于异步文件读取操作，我们需要在挂起协程之前发起操作。因此有可能操作会在线程被挂起之前就在其他线程上完成了，并等待恢复。这种潜在的其他线程完成操作和协程挂起之间的竞态，需要一些线程同步机制来选择并决定胜者。<br>
        一种可选的方式是使用内嵌上下文 ( $trampoline$ $context$ )，它可以在初始上下文被挂起后，代表初始上下文来表示发起某个操作。然而，这可能需要额外的架构支持，和另外的上下文切换来保证正常使用，并且成本可能大于它试图避免的同步操作的成本。</p>
<h2 id="减少内存分配">减少内存分配</h2>
<p>        异步操作经常需要给每个操作分配状态，用于跟踪操作执行阶段。这些状态需要在操作执行过程中保留，直到操作完成才会被释放。<br>
        例如，调用异步<code>Win32 I/O</code>函数需要你分配并传递一个 $OVERLAPPED$ 结构指针。调用方需要保证指针在操作完成前都是有效的。<br>
        典型的基于回调的<code>API</code>要求这些状态分配在堆上，并保证它们有着合适的生命周期。如果你正在执行很多操作，你可能需要给每个操作都分配和释放状态。如果这导致性能问题，你可能需要通过内存池来分配这些状态。<br>
        然而，当使用协程时，利用局部变量在协程帧内的特性，我们可以避免堆分配存储，因为协程帧内的变量在协程被挂起时也是存活的。<br>
        通过把 $co_-await$ 表达式中每个操作状态放到 $Awaiter$ 对象中，我们可以有效地从协程帧中“借用”内存。一旦操作完成，协程被恢复，$Awaiter$ 对象被摧毁，释放协程帧中其他局部变量使用的内存。<br>
        最终，协程帧还是分配在堆上。然而，只需要一次堆分配，协程帧就可以被用来执行许多异步操作。<br>
        你想一想，协程帧其实就是<code>arena</code>内存分配器的一种高级表现。编译器计算出所有局部变量需要的<code>arena</code>大小，然后零成本地分配所有局部变量！试着用传统的分配器来战胜它;)</p>
<h2 id="例子实现一个单线程同步原语">例子：实现一个单线程同步原语</h2>
<p>        现在我们已经讲了许多 $co_-await$ 运算符的机制，我想实现一个基本的 $awaitable$ 同步原语：一个异步手动重置 $event$，来把这些知识运用到实践上。<br>
        这个 $event$ 的基本需求是对许多并行执行的协程来说是 $Awaitble$ 的，当协程对其等待时，会挂起协程，直到一个线程调用 $.set\left(\right)$ 方法，此时恢复所有挂起的协程。如果一个线程已经调用了 $.set\left(\right)$，协程应该在不挂起的前提下继续执行。<br>
        理想情况下，我想要让方法<code>noexcept</code>，这需要避免堆分配，以及无锁实现。<br>
        <strong>2017/11/23 编辑：增加 async_manual_reset_event 的用例</strong><br>
        用例看起来像是这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">T</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// A single call to produce a value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">value</span> <span class="o">=</span> <span class="n">some_long_running_computation</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Publish the value by setting the event.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">event</span><span class="p">.</span><span class="n">set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Supports multiple concurrent consumers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">task</span><span class="o">&lt;&gt;</span> <span class="n">consumer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Wait until the event is signalled by call to event.set()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// in the producer() function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">co_await</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Now it&#39;s safe to consume &#39;value&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This is guaranteed to &#39;happen after&#39; assignment to &#39;value&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        让我们先想想这个 $event$ 可能的状态：$not$ $set$ 和 $set$ 。<br>
        当处于 $not$ $set$ 状态，存在一个等待 $set$ 状态的等待协程列表 ( 可能为空 )。<br>
        当设置 $set$ 状态，就不应该存在等待中的协程，因为正在 $co_-await$ 这个 $event$ 的协程可以不挂起地继续执行。<br>
        这个状态可以通过一个 $std$::$atomic$&lt;$void*$&gt; 表示：</p>
<ul>
<li>保存一个特殊指针，指向 $set$ 状态。我们使用 $event$ 的<code>this</code>指针来表示，因为它不可能跟列表中其他对象的地址相同。</li>
<li>否则，$event$ 处于 $not$ $set$ 状态，指针值是一个等待协程的单向链表头。</li>
</ul>
<p>        我们可以通过把状态存储在协程帧的 $awaiter$ 对象的方式，避免在堆上对节点进行额外分配。<br>
        让我们实现一个类似如下的类接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">async_manual_reset_event</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="kt">bool</span> <span class="n">initiallySet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// No copying/moving
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="k">const</span> <span class="n">asnyc_manual_reset_event</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="p">(</span><span class="n">async_manual_reset_event</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">asnyc_manual_reset_event</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">async_manual_reset_event</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">is_set</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">awaiter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span> <span class="k">operator</span> <span class="nf">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">set</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">struct</span> <span class="nc">awaiter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// - &#39;this&#39; =&gt; set state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// - otherwise =&gt; not set, head of linked list of awaiter*.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span> <span class="n">m_state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        这里我们给出了一个相当简单直接的接口。主要要注意的点是 $operator$ $co_-await\left(\right)$ 返回一个未定义的 $awaiter$ 类型。<br>
        让我们先实现 $awaiter$ 。</p>
<h3 id="实现-awaiter">实现 Awaiter</h3>
<p>        首先，需要知道正在等待哪个 $async_-manual_-reset_-event$ ，所以需要一个 $event$ 引用和一个初始化它的构造器。<br>
        它同样需要作为 $awaiter$ 链表的节点，所以也需要保存下一个 $awaiter$ 对象的指针。<br>
        它还需要保存正在执行 $co_-await$ 的等待中协程的 $coroutine_-handle$ ，用来在 $event$ 被 $set$ 之后恢复协程。我们不关心协程的 $promise$ 类型，所以只需要使用 $coroutine_-handle$&lt;&gt; ( $coroutine_-handle$&lt;$void$&gt; 的缩写 )。<br>
        最后，它需要实现 $Awaiter$ 接口，所以需要三个特殊方法 $await_-ready$ ，$await_-suspend$ 和 $await_-resume$ 。我们不需要 $co_-await$ 返回值，所以 $await_-resume$ 可以返回 $void$ 。<br>
        一旦我们把所有东西放到一起，基本的 $awaiter$ 接口看起来就像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">async_manual_reset_event</span><span class="o">::</span><span class="n">awaiter</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span><span class="p">(</span><span class="k">const</span> <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl">  <span class="o">:</span> <span class="n">m_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaitinigCoroutine</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">class</span> <span class="nc">async_manual_reset_event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">async_manual_reset_event</span><span class="o">&amp;</span> <span class="n">m_event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">m_awaitingCoroutine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">awaiter</span><span class="o">*</span> <span class="n">m_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>        当 $co_-await$ 一个 $event$ 时，我们不想让等待中的协程在 $event$ 被 $set$ 的时候挂起。所以我们让 $await_-ready\left(\right)$ 在 $event$ 已经 $set$ 的时候返回<code>true</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">awaiter</span><span class="o">::</span><span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">m_event</span><span class="p">.</span><span class="n">is_set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        接下来，让我们看看 $await_-suspend\left(\right)$ 方法，许多 $awaitable$ 类型的有趣行为都发生在这里。<br>
        首先它需要在 $m_-awaitingCoroutine$ 成员中保存协程句柄，用于后续调用 $.resume\left(\right)$ 。<br>
        保存句柄之后，需要把 $awaiter$ 自动地加入链表中。成功入队之后，如果 $event$ 还没有被设置成 $set$ 状态，返回<code>true</code>表示我们不希望立即恢复协程，否则返回<code>false</code>，表示协程应该立马恢复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="nl">awaiter</span><span class="p">:</span><span class="n">await_suspend</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">awaitingCoroutine</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Special m_state value that indicates the event is in the &#39;set&#39; state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="k">const</span> <span class="n">setState</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Remember the handle of the awaiting coroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">m_awaitingCoroutine</span> <span class="o">=</span> <span class="n">awaitingCoroutine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Try to atomically push this awaiter onto the front of the list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span><span class="o">*</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">m_event</span><span class="p">.</span><span class="n">m_state</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Resume immediately if already in &#39;set&#39; state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">oldValue</span> <span class="o">==</span> <span class="n">setState</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Upload linked list to point at current head.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">m_next</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">awaiter</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">oldValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Finally, try to swap the old list head, inserting this awaiter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// as the new list head.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">m_event</span><span class="p">.</span><span class="n">m_state</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">oldValue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// Successfully enqueued. Remain suspend.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        注意我们使用 $acquire$ 内存序读取旧状态，这样我们就可以看到所有发生在 $set\left(\right)$ 调用之前的写操作了。<br>
        我们需要用 $release$ 内存序调用 $compare$-$exchange$ ，这样之后的 $set\left(\right)$ 就可以看到我们写入的 $m_-awaitingCoroutine$ 和更早写入的协程状态。</p>
<h3 id="完成-event-类的剩余实现">完成 event 类的剩余实现</h3>
<p>        我们已经定义好了 $awaiter$ 类型，再看回来 $async_-manual_-reset_-event$ 的方法。<br>
        首先是构造函数，它需要使用空的链表 ( 比如<code>nullptr</code>) 初始化为 $not$ $set$ 状态，或者初始化为 $set$ 状态 ( 比如<code>this</code> )。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">async_manual_reset_event</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">initiallySet</span><span class="p">)</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span> <span class="n">m_state</span><span class="p">(</span><span class="n">initiallySet</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{}</span>
</span></span></code></pre></div><p>        接下来，$is_-set\left(\right)$ 方法更直接，如果持有<code>this</code>指针，那么就是 $set$ 状态。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">is_set</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">m_state</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">==</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        接着是 $reset\left(\right)$ 方法，如果当前是 $set$ 状态，我们需要重置为空链表的 $not$ $set$ 状态，否则不做任何事：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">reset</span><span class="p">()</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span><span class="o">*</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">m_state</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">oldValue</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        通过 $set\left(\right)$ 方法，我们可以用特殊的<code>this</code>指针与当前值交换，从而设置状态为 $set$。如果存在挂起的协程，我们需要在返回前依次恢复。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">set</span><span class="p">()</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Needs to be &#39;release&#39; so that subsequent &#39;co_await&#39; has
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// visibility of our prior writes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Needs to be &#39;acquire&#39; so that we have visibility of prior
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// writes by awaiting coroutines.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span><span class="o">*</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">m_state</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">oldValue</span> <span class="o">!=</span> <span class="k">this</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Wasn&#39;t already in &#39;set&#39; state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Treat old value as head of a linked-list of waiters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// which we have now acquired and need to resume.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span><span class="o">*</span> <span class="n">waiters</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">awaiter</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">oldValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">waiters</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Read m_next before resuming the coroutines as resuming
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the coroutine will likely destroy the awaiter object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">auto</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">waiters</span><span class="o">-&gt;</span><span class="n">m_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">waiters</span><span class="o">-&gt;</span><span class="n">m_awaitingCoroutine</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">waiters</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        最后我们需要实现 $operator$ $co_-await\left(\right)$ 方法，只需要构造一个 $awaiter$ 对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span><span class="o">::</span><span class="n">awaiter</span>
</span></span><span class="line"><span class="cl"><span class="n">async_manual_reset_event</span><span class="o">::</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">awaiter</span><span class="p">{</span> <span class="o">*</span><span class="k">this</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>        这样我们就完成了一个无锁，无额外内存分配，<code>noexcept</code>实现的 $awaitable$ 的异步手动-重置 $event$ 。<br>
        如果你想要试试这段代码，看看它在<code>MSVC</code>和<code>Clang</code>下的编译结果，可以看一下<a href="https://godbolt.org/g/Ad47tH">godbolt上的源码</a>。<br>
        你也可以在<a href="https://github.com/lewissbaker/cppcoro">cppcoro库</a>上看到这段实现，以及更多的其他的有用的 $awaitable$ 类型，例如 $async_-mutex$ 和 $async_-auto_-reset_-event$ 。</p>
<h2 id="写在结尾">写在结尾</h2>
<p>        这篇文章介绍了 $operator$ $co_-await$ 是怎么通过 $Awaitable$ 和 $Awaiter$ 这两个<code>concept</code>实现的。<br>
        同样也讲了怎么实现一个 $awaitable$ 的异步线程同步原语，使用了 $awaiter$ 对象在协程帧上分配的优点，避免了额外的堆分配。<br>
        我希望这篇文章可以帮助你理解新的 $co_-await$ 运算符。<br>
        在下一篇文章中，我将介绍 $Promise$ <code>concept</code>，以及一个协程类型的开发者可以怎样设计协程的行为。</p>
<h2 id="致谢">致谢</h2>
<p>        这段就不翻了吧~</p>

            </div>
            <div class="meta post-footer">
                <span>2024 Jan 25 00:00</span>
                <a href="https://z217blog.cn/post/c&#43;&#43;%E5%8D%8F%E7%A8%8B2%E7%90%86%E8%A7%A3co_await/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:zihan.zhouchn@outlook.com">zihan.zhouchn@outlook.com</a>
            </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2025, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
    <script>
        InitLightSwitcher()
    </script>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
</main>
</body>

</html>