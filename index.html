<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.74.3" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  <title>z217&#39;s blog</title>
</head><body><aside id="sidenav">
    <header>
    
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>
        
    

    <a id="branding" href=https://z217blog.cn>
        
            z217&#39;s blog
        
    </a>
    </header>

    <nav>
        
            		
            <a href="/"
                
            >
                <i class="fas fa-home fa-ms"></i>
                <span>首页</span>
            </a>
        
            		
            <a href="/post/"
                
            >
                <i class="fas fa-keyboard fa-ms"></i>
                <span>文章</span>
            </a>
        
            		
            <a href="/tags"
                
            >
                <i class="fas fa-tags fa-sm"></i>
                <span>标签</span>
            </a>
        
            		
            <a href="/about"
                
            >
                <i class="fas fa-user fa-ms"></i>
                <span>关于</span>
            </a>
        
            		
            <a href="https://github.com/z217"
                
                    target="_blank"
                
            >
                <i class="fab fa-github fa-ms"></i>
                <span>Github</span>
            </a>
        
            		
            <a href="/index.xml"
                
            >
                <i class="fas fa-rss fa-sm"></i>
                <span>RSS</span>
            </a>
        
            		
            <a href="http://123.57.12.189"
                
                    target="_blank"
                
            >
                <i class="fas fa-link fa-sm"></i>
                <span>二站</span>
            </a>
        
    </nav>
</aside>
<main id="main">
            <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
            <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/">Geohash算法简介</a>
        
        
        <p>Geohash算法的简单解析以及在Redis中的使用</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 05 19:58
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Algorithm
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/">Git常用指令汇总</a>
        
        
        <p>Git 一些常用指令的简单汇总</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 04 19:36
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Other
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jwt%E7%AE%80%E4%BB%8B/">JWT简介</a>
        
        
        <p>JWT简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 04 16:41
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Other
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
        
        
        <p>设计模式简单笔记</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Jul 10 16:57
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java, Other
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">数据库系统（9）：事务管理</a>
        
        
        <p>数据库系统学习笔记（9）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Jun 13 17:55
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: DBS
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/">Geohash算法简介</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-geohash算法介绍">1. <code>Geohash</code>算法介绍</h2>

<p><a href="https://en.wikipedia.org/wiki/Geohash">Geohash-Wikipedia</a></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Geohash</code>是一种用于公共领域的地理编码系统，其将地理位置编码为字母和数字的短字符串。<code>Geohash</code>允许任意精度的属性，可以通过增长或缩短字符串来改变精度。当两个区域的公共前缀越长，说明他们的联系更加紧密。但是反过来，具有短公共前缀或者没有公共前缀并不一定代表着联系很小。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Geohash</code>算法可以将一个二维的经纬度坐标转换成一个可以比较的字符串，也就是降维。使用三十二进制，全球被划分为 <span  class="math">\(32\)</span> 个大块，再在每个大块内继续划分出 <span  class="math">\(32\)</span>个小块，因此对于越长的<code>geohash</code>字符串，其精度越大，代表的范围也就越小。通过<code>Base32</code>算法，<code>geohash</code>使用字母和数字表示值，如下所示：</p>

<table>
<thead>
<tr>
<th align="center">数字</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
<th align="center">21</th>
<th align="center">22</th>
<th align="center">23</th>
<th align="center">24</th>
<th align="center">25</th>
<th align="center">26</th>
<th align="center">27</th>
<th align="center">28</th>
<th align="center">29</th>
<th align="center">30</th>
<th align="center">31</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">32进制</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">b</td>
<td align="center">c</td>
<td align="center">d</td>
<td align="center">e</td>
<td align="center">f</td>
<td align="center">g</td>
<td align="center">h</td>
<td align="center">j</td>
<td align="center">k</td>
<td align="center">m</td>
<td align="center">n</td>
<td align="center">p</td>
<td align="center">q</td>
<td align="center">r</td>
<td align="center">s</td>
<td align="center">t</td>
<td align="center">u</td>
<td align="center">v</td>
<td align="center">w</td>
<td align="center">x</td>
<td align="center">y</td>
<td align="center">z</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使用了所有 <span  class="math">\(10\)</span> 以内的数字，以及除 <span  class="math">\(a\)</span>, <span  class="math">\(i\)</span>, <span  class="math">\(l\)</span> 和 <span  class="math">\(o\)</span> 之外的所有小写字母。在计算的时候只需要在十进制和三十二进制之间转换即可，举例：</p>

<div>
$$\begin{aligned}
(ezs42)_{32} &= e \times 32^4 + z \times 32^3 + s \times 32^2 + 4 \times 32^1 + 2 \times 32^0 \\
&= 13 \times 1048576 + 31 \times 32768 + 24 \times 1024 + 4 \times 32 + 2 \times 1 \\
&= 14672002.
\end{aligned}$$
</div>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如之前所说的，<code>geohash</code>算法将经纬度转换成一个字符串，自然也能由字符串转回经纬度。再以 <span  class="math">\(ezs42\)</span> 为例，将其转换为二进制：</p>

<div>
$$\begin{aligned}
    &(e)_{32} = (01101)_2, \\
    &(z)_{32} = (11111)_2, \\
    &(s)_{32} = (11000)_2, \\
    &(4)_{32} = (00100)_2, \\
    &(2)_{32} = (00010)_2.
\end{aligned}$$
</div>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果得到的二进制数字为：<span  class="math">\((0110111111110000010000010)_2\)</span> 。假设从左到右读，则奇数位代表纬度代码：<span  class="math">\((101111001001)_2\)</span>，偶数位代表经度代码：<span  class="math">\((0111110000000)_2\)</span>。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来再通过二分法对经纬度代码进行分别处理。纬度的范围为 <span  class="math">\(-90 \sim 90\)</span> ，我们将其划分为两块：<span  class="math">\(-90 \sim 0\)</span> 和 <span  class="math">\(0 \sim 90\)</span> 。查看纬度代码，第一位为 <span  class="math">\(1\)</span>，因此选择 <span  class="math">\(0 \sim 90\)</span>。如果为 <span  class="math">\(0\)</span> 的话，就要选择左边的区间。即为 <span  class="math">\(0\)</span> 选择左边，为 <span  class="math">\(1\)</span> 选择右边。如果没有更多的位数，那么可以认为纬度为 <span  class="math">\(45\)</span>，这样误差范围就为 <span  class="math">\(\pm45\)</span> 。但是在这里我们有更多的位数，因此可以继续下去。再对 <span  class="math">\(0 \sim 90\)</span> 进行二分分为 <span  class="math">\(0 \sim 45\)</span> 和 <span  class="math">\(45 \sim 90\)</span> ，可以看到纬度代码第二位为 <span  class="math">\(0\)</span> ，因此选择 <span  class="math">\(0 \sim 45\)</span> 。如此往复，可以确认纬度值。再使用同样的方法，可以确认经度值，不过要注意经度的范围是 <span  class="math">\(-180 \sim 180\)</span> 。<br>
纬度确定：</p>

<table>
<thead>
<tr>
<th align="center">位数</th>
<th align="center">位值</th>
<th align="center">最小值</th>
<th align="center">中间值</th>
<th align="center">最大值</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">-90.000</td>
<td align="center">0.000</td>
<td align="center">90.000</td>
</tr>

<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0.000</td>
<td align="center">45.000</td>
<td align="center">90.000</td>
</tr>

<tr>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">0.000</td>
<td align="center">22.500</td>
<td align="center">45.000</td>
</tr>

<tr>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">22.500</td>
<td align="center">33.750</td>
<td align="center">45.000</td>
</tr>

<tr>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">33.750</td>
<td align="center">39.375</td>
<td align="center">45.000</td>
</tr>

<tr>
<td align="center">5</td>
<td align="center">1</td>
<td align="center">39.375</td>
<td align="center">42.188</td>
<td align="center">45.000</td>
</tr>

<tr>
<td align="center">6</td>
<td align="center">0</td>
<td align="center">42.188</td>
<td align="center">43.594</td>
<td align="center">45.000</td>
</tr>

<tr>
<td align="center">7</td>
<td align="center">0</td>
<td align="center">42.188</td>
<td align="center">42.891</td>
<td align="center">43.594</td>
</tr>

<tr>
<td align="center">8</td>
<td align="center">1</td>
<td align="center">42.188</td>
<td align="center">42.539</td>
<td align="center">42.891</td>
</tr>

<tr>
<td align="center">9</td>
<td align="center">0</td>
<td align="center">42.539</td>
<td align="center">42.715</td>
<td align="center">42.891</td>
</tr>

<tr>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">42.539</td>
<td align="center">42.627</td>
<td align="center">42.715</td>
</tr>

<tr>
<td align="center">11</td>
<td align="center">1</td>
<td align="center">42.539</td>
<td align="center">42.583</td>
<td align="center">42.627</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可得纬度为 <span  class="math">\(42.583\)</span> ，同理可得经度为 <span  class="math">\(-5.581\)</span> ，经纬度误差范围都在 <span  class="math">\(\pm0.022\)</span> 之间。根据经纬度与千米的比例表可得误差距离。</p>

<table>
<thead>
<tr>
<th align="left"><code>Geohash</code>长度</th>
<th align="left">纬度位数</th>
<th align="left">经度位数</th>
<th align="left">纬度误差</th>
<th align="left">经度误差</th>
<th align="left">千米误差</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
<td align="left"><span  class="math">\(\pm23\)</span></td>
<td align="left"><span  class="math">\(\pm23\)</span></td>
<td align="left"><span  class="math">\(\pm2500\)</span></td>
</tr>

<tr>
<td align="left">2</td>
<td align="left">5</td>
<td align="left">5</td>
<td align="left"><span  class="math">\(\pm2.8\)</span></td>
<td align="left"><span  class="math">\(\pm5.6\)</span></td>
<td align="left"><span  class="math">\(\pm630\)</span></td>
</tr>

<tr>
<td align="left">3</td>
<td align="left">7</td>
<td align="left">8</td>
<td align="left"><span  class="math">\(\pm0.70\)</span></td>
<td align="left"><span  class="math">\(\pm0.70\)</span></td>
<td align="left"><span  class="math">\(\pm78\)</span></td>
</tr>

<tr>
<td align="left">4</td>
<td align="left">10</td>
<td align="left">10</td>
<td align="left"><span  class="math">\(\pm0.087\)</span></td>
<td align="left"><span  class="math">\(\pm0.18\)</span></td>
<td align="left"><span  class="math">\(\pm20\)</span></td>
</tr>

<tr>
<td align="left">5</td>
<td align="left">12</td>
<td align="left">13</td>
<td align="left"><span  class="math">\(\pm0.022\)</span></td>
<td align="left"><span  class="math">\(\pm0.022\)</span></td>
<td align="left"><span  class="math">\(\pm2.4\)</span></td>
</tr>

<tr>
<td align="left">6</td>
<td align="left">15</td>
<td align="left">15</td>
<td align="left"><span  class="math">\(\pm0.0027\)</span></td>
<td align="left"><span  class="math">\(\pm0.0055\)</span></td>
<td align="left"><span  class="math">\(\pm0.61\)</span></td>
</tr>

<tr>
<td align="left">7</td>
<td align="left">17</td>
<td align="left">18</td>
<td align="left"><span  class="math">\(\pm0.00068\)</span></td>
<td align="left"><span  class="math">\(\pm0.00068\)</span></td>
<td align="left"><span  class="math">\(\pm0.076\)</span></td>
</tr>

<tr>
<td align="left">8</td>
<td align="left">20</td>
<td align="left">20</td>
<td align="left"><span  class="math">\(\pm0.000085\)</span></td>
<td align="left"><span  class="math">\(\pm0.00017\)</span></td>
<td align="left"><span  class="math">\(\pm0.019\)</span></td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个给定的经纬度，要想求得经纬度的二进制代码值，只需要将上述步骤倒过来即可。再以 <span  class="math">\((42.583, -5.581)\)</span> 为例。<br>
纬度代码确定：</p>

<table>
<thead>
<tr>
<th align="center">位数</th>
<th align="center">最小值</th>
<th align="center">中间值</th>
<th align="center">最大值</th>
<th align="center">位值</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">0</td>
<td align="center">-90.000</td>
<td align="center">0.000</td>
<td align="center">90.000</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">1</td>
<td align="center">0.000</td>
<td align="center">45.000</td>
<td align="center">90.000</td>
<td align="center">0</td>
</tr>

<tr>
<td align="center">2</td>
<td align="center">0.000</td>
<td align="center">22.500</td>
<td align="center">45.000</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">3</td>
<td align="center">22.500</td>
<td align="center">33.750</td>
<td align="center">45.000</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">4</td>
<td align="center">33.750</td>
<td align="center">39.375</td>
<td align="center">45.000</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">5</td>
<td align="center">39.375</td>
<td align="center">42.188</td>
<td align="center">45.000</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">6</td>
<td align="center">42.188</td>
<td align="center">43.594</td>
<td align="center">45.000</td>
<td align="center">0</td>
</tr>

<tr>
<td align="center">7</td>
<td align="center">42.188</td>
<td align="center">42.891</td>
<td align="center">43.594</td>
<td align="center">0</td>
</tr>

<tr>
<td align="center">8</td>
<td align="center">42.188</td>
<td align="center">42.539</td>
<td align="center">42.891</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">9</td>
<td align="center">42.539</td>
<td align="center">42.715</td>
<td align="center">42.891</td>
<td align="center">0</td>
</tr>

<tr>
<td align="center">10</td>
<td align="center">42.539</td>
<td align="center">42.627</td>
<td align="center">42.715</td>
<td align="center">0</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然通过<code>geohash</code>可以通过公共前缀来查找一些彼此相邻的点，但是在一些边缘情况无法通过这种方式进行查询。例如在本初子午线左右两端的<code>geohash</code>值并没有公共前缀，以及靠近南北极的区域的<code>geohash</code>值差异很大。因为<code>geohash</code>依赖经纬度得到数值，因此在这些经纬度变化迅速的区域，它们的<code>geohash</code>值的变化也很迅速。</p>

<h2 id="2-redis中使用geo数据类型">2. <code>Redis</code>中使用<code>geo</code>数据类型</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续以 <span  class="math">\((42.583, -5.581)\)</span> 为例，演示在<code>Redis</code>中操作<code>geo</code>数据类型。</p>
<pre><code class="language-redis" data-lang="redis">geoadd location -5.581 42.583 gw01</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 <span  class="math">\((42.583, -5.581)\)</span> 存入 <span  class="math">\(location\)</span> 并命名为 <span  class="math">\(gw01\)</span>。<span  class="math">\(location\)</span> 本质为 <span  class="math">\(zset\)</span> 数据类型。再对其获取得</p>
<pre><code class="language-redis" data-lang="redis">geopos location gw01</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算其<code>geohash</code>值</p>
<pre><code class="language-redis" data-lang="redis">geohash location gw01</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，通过</p>
<pre><code class="language-redis" data-lang="redis">geodist
georadius
georadiusbymember</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些指令可以计算范围内符合条件的坐标。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Aug 5 19:58</span> <a href="/post/geohash%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/">Git常用指令汇总</a></h1>
            </center>
            <div class="post-content">
                <h2 id="创建仓库init">创建仓库/init</h2>
<pre><code class="language-git" data-lang="git">git init</code></pre>
<p>创建成功后当前目录下会生成一个<code>.git</code>目录，用于跟踪和管理版本库。</p>

<h2 id="添加文件add">添加文件/add</h2>
<pre><code class="language-git" data-lang="git">git add</code></pre>
<p><code>.</code> 自动添加本地所有修改。</p>

<h2 id="提交commit">提交/commit</h2>
<pre><code class="language-git" data-lang="git">git commit</code></pre>
<p><span  class="math">\(-m\)</span> 增加提交信息。<br>
<span  class="math">\(-a\)</span> 自动寻找修改的文件并提交。</p>

<h2 id="状态查看status">状态查看/status</h2>
<pre><code class="language-git" data-lang="git">git status</code></pre>
<p><span  class="math">\(-s\)</span> 简短输出。</p>

<h2 id="改动查看diffblame">改动查看/diff&amp;blame</h2>
<pre><code class="language-git" data-lang="git">git diff</code></pre>
<p><span  class="math">\(--cached\)</span> 显示暂存区的改动。<br>
<span  class="math">\(HEAD\)</span> 查看所有改动。<br>
<span  class="math">\(--stat\)</span> 显示摘要。</p>
<pre><code class="language-git" data-lang="git">git blame</code></pre>
<p>文件修改记录。</p>

<h2 id="历史查看log">历史查看/log</h2>
<pre><code class="language-git" data-lang="git">git log</code></pre>
<p>按时间由近到远排序，列出最近的三次提交。<br>
<span  class="math">\(-p\;[filename]\)</span> 文件最后一次提交信息。<br>
<span  class="math">\(--pretty=oneline\)</span> 可以列出简略的信息。<br>
<span  class="math">\(--graph\)</span> 拓扑图显示。<br>
<span  class="math">\(--reverse\)</span> 逆向显示。<br>
<span  class="math">\(--author=\)</span> 查找指定作者。<br>
<span  class="math">\(--since\)</span>, <span  class="math">\(--before\)</span>, <span  class="math">\(--util\)</span>, <span  class="math">\(--after\)</span> 指定日期。<br>
<span  class="math">\(--decorate\)</span> 显示标签。</p>

<h2 id="提交撤销revert">提交撤销/revert</h2>
<pre><code class="language-git" data-lang="git">git revert</code></pre>
<h2 id="回退版本reset">回退版本/reset</h2>
<pre><code class="language-git" data-lang="git">git reset --hard HEAD^
git reset --hard HEAD~2
git reset --hard 56e7</code></pre>
<p><span  class="math">\(HEAD\)</span> 表示当前版本。<code>^</code> 表示回退一个版本，可以输入多个 <code>^</code>。<span  class="math">\(\sim\)</span> 之后可以输入任意数字，表示回退对应数量的版本。也可以直接输入版本号，版本号通过 <span  class="math">\(git\;log\)</span> 命令查询，使用版本号不仅可以回退版本，在错误回退版本之后，也可以前进到指定的版本，版本号可以不写全，但一定要写到<code>Git</code>能识别出唯一一个版本为止。</p>
<pre><code class="language-git" data-lang="git">git reset HEAD [filename]</code></pre>
<p>撤销暂存区的改动。</p>
<pre><code class="language-git" data-lang="git">git reset --keep</code></pre>
<p>回退并保存未提交的改动。</p>

<h2 id="指令记录查询reflog">指令记录查询/reflog</h2>
<pre><code class="language-git" data-lang="git">git reflog</code></pre>
<p>此指令会列出曾经执行过的指令，也会显示版本号。</p>

<h2 id="文件删除rm">文件删除/rm</h2>
<pre><code class="language-git" data-lang="git">git rm</code></pre>
<p><span  class="math">\(-f\)</span> 删除之前修改且放到暂存区的文件。<br>
<span  class="math">\(--cached\)</span> 只删除在暂存区的文件。<br>
<span  class="math">\(-r\)</span> 递归删除子目录和文件。</p>

<h2 id="文件移动mv">文件移动/mv</h2>
<pre><code class="language-git" data-lang="git">git mv</code></pre>
<p>也可以用于重命名文件。</p>

<h2 id="文件拷贝clone">文件拷贝/clone</h2>
<pre><code class="language-git" data-lang="git">git clone</code></pre>
<h2 id="分支切换checkoutswitch">分支切换/checkout&amp;switch</h2>
<pre><code class="language-git" data-lang="git">git checkout</code></pre>
<p><span  class="math">\(--\;\;[filename]\)</span> 丢弃工作区指定文件的改动（不切换分支）。<br>
<span  class="math">\(-b\)</span> 创建新分支并立即切换到该分支。</p>
<pre><code class="language-git" data-lang="git">git switch</code></pre>
<p><span  class="math">\(-c\)</span> 创建并切换到新的分支。</p>

<h2 id="分支管理branch">分支管理/branch</h2>
<pre><code class="language-git" data-lang="git">git branch</code></pre>
<p>不加分支名可以列出分支。<br>
<span  class="math">\(-d\)</span> 删除分支。<br>
<span  class="math">\(-D\)</span> 强制删除分支。<br>
<span  class="math">\( --set-upstream-to=[origin/branch]\;\;[local branch] \)</span> 关联本地分支与远程库分支。<br>
<span  class="math">\(--track\)</span> 基于远程分支创建新分支。<br>
<span  class="math">\([origin]\;\;--delete\;\;[branch]\)</span> 删除远程分支。</p>

<h2 id="合并分支mergemergetool">合并分支/merge&amp;mergetool</h2>
<pre><code class="language-git" data-lang="git">git merge</code></pre>
<p><span  class="math">\(--no-ff\)</span> 分支时提交（即保留分支信息）。</p>
<pre><code class="language-git" data-lang="git">git mergetool</code></pre>
<p>使用配置的合并工具解决冲突。</p>

<h2 id="远程库remote">远程库/remote</h2>
<pre><code class="language-git" data-lang="git">git remote</code></pre>
<p>查看远程库信息。<br>
<span  class="math">\(-v\)</span> 查看详细信息。</p>
<pre><code class="language-git" data-lang="git">git remote add [remote] [url]</code></pre>
<p>创建远程库，远程库名字默认为<span  class="math">\(origin\)</span>。</p>
<pre><code class="language-git" data-lang="git">git remote rename</code></pre>
<p>重命名远程库。</p>

<h2 id="远程库推送push">远程库推送/push</h2>
<pre><code class="language-git" data-lang="git">git push [remote] [local branch]</code></pre>
<p>也可以将本地分支名改为标签名，或改为 <span  class="math">\(--tags\)</span> 推送所有未推送的标签， <span  class="math">\(:refs/tags/[tag name]\)</span> 删除指定标签。<br>
<span  class="math">\(-u\)</span> 关联对应库和本地分支，简化后续操作。<br>
<span  class="math">\(-[remote]:[old name]\)</span> 重命名远程分支。</p>

<h2 id="提交抓取pullfetch">提交抓取/pull&amp;fetch</h2>
<pre><code class="language-git" data-lang="git">git pull [remote] [branch]
git fetch [remote]</code></pre>
<p>下载新数据与分支。</p>

<h2 id="工作区储存stash">工作区储存/stash</h2>
<pre><code class="language-git" data-lang="git">git stash
git stash list
git stash apply
git stash drop
git stash pop</code></pre>
<p>分别用于储存、列出、恢复、删除储存内容，<span  class="math">\(pop\)</span> 会在恢复同时删除储存内容。</p>

<h2 id="改动复制cherrypick">改动复制/cherry-pick</h2>
<pre><code class="language-git" data-lang="git">git cherry-pick</code></pre>
<p>将对应的提交改动复制到另一个分支。</p>

<h2 id="变基rebase">变基/rebase</h2>
<pre><code class="language-git" data-lang="git">git rebase</code></pre>
<p><span  class="math">\(--abort\)</span> 终止合并。<br>
<span  class="math">\(--continue\)</span> 继续合并。</p>

<h2 id="标签创建tag">标签创建/tag</h2>
<pre><code class="language-git" data-lang="git">git tag
git tag [tag name] [commit id]</code></pre>
<p>未指定标签名时列出所有标签，不指定版本号时默认为当前版本。
<span  class="math">\(-a\)</span> 为标签添加注解。
<span  class="math">\(-d\)</span> 删除指定标签。</p>

<h2 id="信息显示show">信息显示/show</h2>
<pre><code class="language-git" data-lang="git">git show</code></pre>
<p><span  class="math">\([tag name]\)</span> 查看标签信息。</p>
<pre><code class="language-git" data-lang="git">git remote show</code></pre>
<p><span  class="math">\([remote]\)</span> 查看远程库信息。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Aug 4 19:36</span> <a href="/post/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%B1%87%E6%80%BB/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jwt%E7%AE%80%E4%BB%8B/">JWT简介</a></h1>
            </center>
            <div class="post-content">
                <p><a href="https://en.wikipedia.org/wiki/JSON_Web_Token">JWT-Wikipedia</a></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JWT</code>( <span  class="math">\(JSON\;Web\;Token\)</span> )是一种基于<code>JSON</code>的用于创建可选签名或可选加密的数据的互联网标准。<code>Token</code>使用一个私钥或者公钥进行签名，持有私钥或者公钥的一方可以验证令牌的合法性。<code>Token</code>被设计为紧凑且安全的，尤其适用于<code>Web</code>浏览器单点登录 ( <code>Single-sign-on</code>, <span  class="math">\(SSO\)</span> ) 场景。<code>JWT</code>声明一般用于在身份提供者和服务提供者之间传递用户身份信息，或者用于业务流程要求的任何其他类型的声明。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在传统的<code>session</code>认证中，通常使用<code>cookie</code>来保存用户的身份信息，方便下一次请求。由于<code>session</code>是存储在内存中的，因此存在开销隐患。而且使用<code>cookie</code>也意味着存在着<code>CSRF</code>问题。使用<code>JWT</code>进行认证时，用户在成功认证登录过后，将会得到一个<code>token</code>。<code>Token</code>会保存在本地（也可以保存在<code>session</code>或者<code>cookie</code>中），而不是传统的在服务器上创建一个<code>session</code>并返回<code>cookie</code>。每当用户想要访问受保护的资源时，用户代理需要发送<code>JWT</code>，<code>JWT</code>通常包含在请求头中。通过使用<code>JWT</code>，用户的状态永远也不会保存在服务器中。当接收到请求时，服务器将会检查<code>JWT</code>的有效性。由于<code>JWT</code>是独立的，存储着所有必要的信息，因此可以减少数据库查询的次数。</p>

<h2 id="jwt的结构"><code>JWT</code>的结构</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JWT</code>由三部分组成：<span  class="math">\(Header\)</span>, <span  class="math">\(Payload\)</span>, <span  class="math">\(Signature\)</span> 。</p>

<h3 id="1-header">1. Header</h3>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;alg&#34;</span><span class="p">:</span> <span class="s2">&#34;HS256&#34;</span><span class="p">,</span>
    <span class="nt">&#34;typ&#34;</span><span class="p">:</span> <span class="s2">&#34;JWT&#34;</span>
<span class="p">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Header\)</span> 标识用于生成签名的算法。典型的加密算法如<code>HMAC-SHA-256</code>, <code>RSA-SHA-256</code>。上例使用的是<code>HMAC-SHA-256</code>。</p>

<h3 id="2-payload">2. Payload</h3>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;loggedInAs&#34;</span><span class="p">:</span> <span class="s2">&#34;admin&#34;</span><span class="p">,</span>
    <span class="nt">&#34;iat&#34;</span><span class="p">:</span> <span class="mi">1422779638</span>
<span class="p">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Payload$ 包含了一组声明。<code>JWT</code>标准注册了七个声明：</p>

<ul>
<li><span  class="math">\(iss\)</span>：<code>JWT</code>签发者</li>
<li><span  class="math">\(sub\)</span>：<code>JWT</code>面向用户</li>
<li><span  class="math">\(aud\)</span>：<code>JWT</code>接收方</li>
<li><span  class="math">\(exp\)</span>：<code>JWT</code>过期时间</li>
<li><span  class="math">\(nbf\)</span>：<code>JWT</code>启用时间</li>
<li><span  class="math">\(iat\)</span>：<code>JWT</code>签发时间</li>
<li><span  class="math">\(jti\)</span>：<code>JWT</code>的唯一身份标识，可以用作一次性<code>token</code></li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Payload$ 中还可以添加自定义声明，如上例的 <span  class="math">\(loggedInAs\)</span>。</p>

<h3 id="3-signature">3. Signature</h3>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">signature</span> <span class="o">=</span> <span class="nx">HMAC</span><span class="o">-</span><span class="nx">SHA256</span><span class="p">(</span>
    <span class="nx">base64urlEncoding</span><span class="p">(</span><span class="nx">header</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nx">base64urlEncoding</span><span class="p">(</span><span class="nx">payload</span><span class="p">),</span>
    <span class="s1">&#39;secret&#39;</span>
<span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Signature\)</span> 用于安全地验证<code>token</code>。使用 <span  class="math">\(Base64urlEncoding\)</span> 对 <span  class="math">\(header\)</span> 和 <span  class="math">\(payload\)</span> 进行编码，再使用句点隔开，可以计算出签名。<span  class="math">\(secret\)</span>保存在服务器中，在使用指定算法生成签名的时候使用，生成哈希，确保数据不被篡改。然后再通过指定的算法，在此例中为 <code>HMAC-SHA256</code>， 进行加密。<span  class="math">\(Base64url\)</span> 编码类似于 <code>base64</code>。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终得到的<code>JWT</code>如下</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">token</span> <span class="o">=</span> <span class="nx">base64urlEncoding</span><span class="p">(</span><span class="nx">header</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nx">base64urlEncoding</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="nx">base64urlEncoding</span><span class="p">(</span><span class="nx">signature</span><span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后在请求头中加入</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">Authorization</span><span class="o">:</span> <span class="sb">`Bearer&#39; + token
</span></code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2020 Aug 4 16:41</span> <a href="/post/jwt%E7%AE%80%E4%BB%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></h1>
            </center>
            <div class="post-content">
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计模式常用的七大原则：</p>

<ol>
<li>单一职责原则——一个类应该只负责一项职责。</li>
<li>接口隔离原则——一个类对应另一个类的依赖应该建立在最小的接口上。</li>
<li>依赖倒转原则

<ol>
<li>高层模块不应依赖于低层模块</li>
<li>抽象不应该依赖于细节</li>
<li>面向接口编程（中心思想）</li>
</ol></li>
<li>里氏替换原则——所有引用基类的地方必须能透明的使用子类。</li>
<li>开闭原则——软件实体对扩展开放，对修改关闭，用抽象构建框架，用实现扩展细节。</li>
<li>迪米特法则——一个类应该将逻辑封装在内部，不对外泄露。</li>
<li>合成复用原则——尽量使用合成/聚合方式</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;23种设计模式的三种类型：</p>

<ol>
<li>创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式；</li>
<li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式；</li>
<li>行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式（责任链模式）。</li>
</ol>

<h2 id="1-单例模式">1 单例模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式，即采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（通常为静态方法）。单例模式有八种方式：</p>

<ol>
<li>饿汉式（静态常量）</li>
<li>饿汉式（静态代码块）</li>
<li>懒汉式（线程不安全）</li>
<li>懒汉式（线程安全，同步方法）</li>
<li>懒汉式（线程安全，同步代码块）</li>
<li>双重检查</li>
<li>静态内部类</li>
<li>枚举</li>
</ol>

<h3 id="11-饿汉式静态常量">1.1 饿汉式（静态常量）</h3>

<ol>
<li>构造器私有化（即不能通过 <span  class="math">\(new\)</span> 创建实例）</li>
<li>类内部创建对象</li>
<li>向外暴露一个静态公共方法</li>
<li>代码实现</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
  
  <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p><strong>优点</strong>：写法简单，在类装载时实例化，避免了线程同步问题。<br>
<strong>缺点</strong>：不是懒加载，可能存在内存资源的浪费。</p>

<h3 id="12-饿汉式静态代码块">1.2 饿汉式（静态代码块）</h3>

<ol>
<li>构造器私有化</li>
<li>类内部声明私有静态成员</li>
<li>静态代码块内实例化</li>
<li><span  class="math">\(getInstance\)</span> 公共静态方法实现</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Singleton2</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton2</span> <span class="n">instance</span><span class="o">;</span>

  <span class="kd">static</span> <span class="o">{</span>
    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton2</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="nf">Singleton2</span><span class="o">()</span> <span class="o">{}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton2</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p><strong>优缺点</strong>同上。</p>

<h3 id="13-懒汉式线程不安全">1.3 懒汉式（线程不安全）</h3>

<ol>
<li>构造器私有化</li>
<li>声明静态私有成员</li>
<li>实现 <span  class="math">\(getInstance\)</span> 方法，只有使用时才创建对象</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Singleton3</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton3</span> <span class="n">instance</span><span class="o">;</span>

  <span class="kd">private</span> <span class="nf">Singleton3</span><span class="o">()</span> <span class="o">{}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton3</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton3</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p><strong>优点</strong>：懒加载。<br>
<strong>缺点</strong>：线程不安全，因为使用 <span  class="math">\(if\)</span> 判断，如果多个线程同时进入，可能会创建多个实例。<br>
<strong>结论</strong>：实际开发中不能使用。</p>

<h3 id="14-懒汉式线程安全同步方法">1.4 懒汉式（线程安全，同步方法）</h3>

<p>在线程不安全的基础上，在 <span  class="math">\(getInstance\)</span> 方法上添加 <span  class="math">\(synchronized\)</span> 关键字。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Singleton4</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton4</span> <span class="n">instance</span><span class="o">;</span>

  <span class="kd">private</span> <span class="nf">Singleton4</span><span class="o">()</span> <span class="o">{}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="n">Singleton4</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton4</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p><strong>优点</strong>：懒加载，线程安全<br>
<strong>缺点</strong>：每个线程都要执行一次 <span  class="math">\(getInstance\)</span> 方法，但实际上只需执行一次即可。<br>
<strong>结论</strong>：实际开发中不推荐使用</p>

<h3 id="15-懒汉式线程安全同步代码块">1.5 懒汉式（线程安全，同步代码块）</h3>

<p>将创建实例的过程移入同步代码块中</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Singleton5</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton5</span> <span class="n">instance</span><span class="o">;</span>

  <span class="kd">private</span> <span class="nf">Singleton5</span><span class="o">()</span> <span class="o">{}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton5</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">synchronized</span> <span class="o">(</span><span class="n">Singleton5</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton5</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>虽然使用了同步代码块，但是仍然处于线程不安全的状态。因为可能存在多个线程进入 <span  class="math">\(if\)</span> 块中，这时还是会产生多个实例。<br>
<strong>结论</strong>：实际开发中不能使用</p>

<h3 id="16-双重检查">1.6 双重检查</h3>

<p>使用 <span  class="math">\(volatile\)</span> 修饰私有静态成员，在同步代码块内再进行一次空判断。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Singleton6</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="n">Singleton6</span> <span class="n">instance</span><span class="o">;</span>

  <span class="kd">private</span> <span class="nf">Singleton6</span><span class="o">()</span> <span class="o">{}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton6</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">synchronized</span> <span class="o">(</span><span class="n">Singleton6</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton6</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p><strong>优点</strong>：同时解决了懒加载和线程安全问题<br>
<strong>结论</strong>：在实际开发中推荐使用</p>

<h3 id="17-静态内部类">1.7 静态内部类</h3>

<p>在外部类进行类装载时，静态内部类不会被装载。同时类装载也是线程安全的。因此可以将创建实例的过程放在静态内部类中实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Singleton7</span><span class="o">{</span>
  <span class="kd">private</span> <span class="nf">Singleton7</span><span class="o">()</span> <span class="o">{}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton7</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Singleton7Instance</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Singleton7Instance</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Singleton7</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton7</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p><strong>优点</strong>：利用<code>JVM</code>的特性保证了线程安全，同时实现了懒加载<br>
<strong>结论</strong>：在实际开发中推荐使用</p>

<h3 id="18-枚举">1.8 枚举</h3>

<p>通过枚举实现单例模式。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">enum</span> <span class="n">Singleton8</span> <span class="o">{</span>
  <span class="n">INSTANCE</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span></code></pre></div>
<p><strong>优点</strong>：避免了多次创建对象和线程问题<br>
<strong>结论</strong>：推荐使用</p>

<h3 id="19-jdk中的单例模式">1.9 JDK中的单例模式</h3>

<p><span  class="math">\(java.lang.Runtime\)</span> 类，使用的是饿汉式</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Runtime</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Runtime</span> <span class="n">currentRuntime</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Runtime</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Runtime</span> <span class="nf">getRuntime</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">currentRuntime</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">Runtime</span><span class="o">()</span> <span class="o">{}</span>

    <span class="c1">// ...
</span><span class="c1"></span><span class="o">}</span></code></pre></div>
<h3 id="110-注意事项">1.10 注意事项</h3>

<ol>
<li>单例模式保证内存中只存在一个对应的对象。对于一些需要频繁创建和销毁的对象，使用单例模式可以提高性能。</li>
<li>实例化单例类，不能使用 <span  class="math">\(new\)</span> ，只能使用相应的获取对象的方法。</li>
<li>使用场景：

<ol>
<li>需要频繁创建和销毁的对象</li>
<li>创建时会消耗过多时间或者资源的对象</li>
<li>频繁访问或使用的工具类、数据库或文件对象</li>
</ol></li>
</ol>

<h2 id="2-工厂模式">2. 工厂模式</h2>

<h3 id="21-简单工厂模式">2.1 简单工厂模式</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单工厂模式是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪种产品类的实例。即定义一个创建对象的类，由这个类来进行封装实例化对象的行为。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimplePizzaFactory</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Pizza</span> <span class="nf">createPizza</span><span class="o">(</span><span class="n">String</span> <span class="n">orderType</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Pizza</span> <span class="n">pizza</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;SimplePizzaFactory&#34;</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">orderType</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;greek&#34;</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">pizza</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GreekPizza</span><span class="o">();</span>
      <span class="n">pizza</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;GreekPizza&#34;</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">orderType</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;cheese&#34;</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">pizza</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CheesePizza</span><span class="o">();</span>
      <span class="n">pizza</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;ChessePizza&#34;</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">orderType</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;pepper&#34;</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">pizza</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PepperPizza</span><span class="o">();</span>
      <span class="n">pizza</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;PepperPizza&#34;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">pizza</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p><figure><img src="/image/2020-07-10-01.png" alt="SimplePizzaFactory"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单工厂模式也叫静态工厂模式，其工厂类内部的 <span  class="math">\(create\)</span> 方法可以设置为静态方法。</p>

<h3 id="22-工厂方法模式">2.2 工厂方法模式</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂方法模式定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类进行。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">OrderPizza</span> <span class="o">{</span>
  <span class="kd">abstract</span> <span class="n">Pizza</span> <span class="nf">createPizza</span><span class="o">(</span><span class="n">String</span> <span class="n">orderType</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>
<p><figure><img src="/image/2020-07-10-02.png" alt="FactoryMethodPizza"></figure></p>

<h3 id="23-抽象工厂模式">2.3 抽象工厂模式</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象工厂模式定义了一个接口用于创建相关或存在依赖的对象集合。从设计层面上看，可以理解为是对简单工厂模式的改进。抽象工厂模式将工厂抽象为两层，抽象工厂和具体实现的工厂子类，即将单个简单工厂扩展为一个工厂集合。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AbsFactory</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Pizza</span> <span class="nf">createPizza</span><span class="o">(</span><span class="n">String</span> <span class="n">orderType</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>
<p><figure><img src="/image/2020-07-10-03.png" alt="AbstractFactoryPizza"></figure></p>

<h3 id="24-jdk应用举例">2.4 JDK应用举例</h3>

<p><span  class="math">\(java.util.Calendar\)</span> 类使用了简单工厂模式</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Calendar</span> <span class="kd">implements</span> <span class="n">Serializable</span><span class="o">,</span> <span class="n">Cloneable</span><span class="o">,</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Calendar</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Calendar</span> <span class="nf">getInstance</span><span class="o">()</span>
        <span class="o">{</span>
            <span class="k">return</span> <span class="n">createCalendar</span><span class="o">(</span><span class="n">TimeZone</span><span class="o">.</span><span class="na">getDefault</span><span class="o">(),</span> <span class="n">Locale</span><span class="o">.</span><span class="na">getDefault</span><span class="o">(</span><span class="n">Locale</span><span class="o">.</span><span class="na">Category</span><span class="o">.</span><span class="na">FORMAT</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂模式将实例化对象的代码提取出来，放到一个类中进行统一管理，达到依赖关系解耦的目的，从而提高了扩展性和可维护性。在使用工厂模时，创建对象实例不直接使用 <span  class="math">\(new\)</span> ，而是在工厂方法中使用 <span  class="math">\(new\)</span> 。相对应的工厂类不应实现具体类，而应实现抽象类或者接口，不要覆盖基类中已经实现的方法。</p>

<h2 id="3-原型模式">3. 原型模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Java</code>的 <span  class="math">\(Object\)</span> 类提供了一个 <span  class="math">\(clone\)</span> 方法，可以复制一个对象。如果一个类需要实现 <span  class="math">\(clone\)</span> 方法，必须要实现 <span  class="math">\(Cloneable\)</span> 接口。原型模式是指用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新对象。新的对象通过调用原型对象的 <span  class="math">\(clone\)</span> 方法进行创建。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Sheep</span> <span class="kd">implements</span> <span class="n">Cloneable</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="n">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">CloneNotSupportedException</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<h3 id="31-spring源码示例">3.1 Spring源码示例</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Spring</code>框架中配置<code>bean</code>时可以指定 <span  class="math">\(scope\)</span> 的值为 <span  class="math">\(prototype\)</span> ，代表通过原型模式创建。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span><span class="o">.</span><span class="na">isPrototype</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">var11</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    
      <span class="n">Object</span> <span class="n">prototypeInstance</span><span class="o">;</span>
      <span class="k">try</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">beforePrototypeCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="n">prototypeInstance</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">createBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
      <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">afterPrototypeCreation</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="c1">// ...
</span><span class="c1"></span><span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(AbstractBeanFactory\)</span> 类中的 <span  class="math">\(doGetBean\)</span> 方法用于获取容器中的 <span  class="math">\(bean\)</span> 。如果先前设置 <span  class="math">\(scope = prototype\)</span> ，那么就会进入该 <span  class="math">\(if\)</span> 块中。块中的 <span  class="math">\(createBean\)</span> 方法通过原型模式创建对象实例。</p>

<h3 id="32-深拷贝">3.2 深拷贝</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(clone\)</span> 方法默认是浅拷贝，也就代表如果成员为对象，那么只会复制对象的引用值。在实际开发中，存在着两种实现深拷贝的方式：重写 <span  class="math">\(clone\)</span> 或者对象序列化。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeepPrototype</span> <span class="kd">implements</span> <span class="n">Serializable</span><span class="o">,</span> <span class="n">Cloneable</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
  <span class="kd">public</span> <span class="n">DeepCloneableTarget</span> <span class="n">deepCloneableTarget</span><span class="o">;</span>

  <span class="c1">//  1. 重写clone
</span><span class="c1"></span>  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="n">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">CloneNotSupportedException</span> <span class="o">{</span>
    <span class="n">Object</span> <span class="n">deep</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">deep</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
    <span class="n">DeepPrototype</span> <span class="n">deepPrototype</span> <span class="o">=</span> <span class="o">(</span><span class="n">DeepPrototype</span><span class="o">)</span> <span class="n">deep</span><span class="o">;</span>
    <span class="n">deepPrototype</span><span class="o">.</span><span class="na">deepCloneableTarget</span> <span class="o">=</span> <span class="o">(</span><span class="n">DeepCloneableTarget</span><span class="o">)</span> <span class="n">deepCloneableTarget</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">deepPrototype</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">//  2. 对象序列化（推荐）
</span><span class="c1"></span>  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">deepClone</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">DeepPrototype</span> <span class="n">ret</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">(</span><span class="n">ByteArrayOutputStream</span> <span class="n">baos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayOutputStream</span><span class="o">();</span>
        <span class="n">ObjectOutputStream</span> <span class="n">oos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectOutputStream</span><span class="o">(</span><span class="n">baos</span><span class="o">);</span> <span class="o">)</span> <span class="o">{</span>
      <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
      <span class="k">try</span> <span class="o">(</span><span class="n">ByteArrayInputStream</span> <span class="n">bais</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ByteArrayInputStream</span><span class="o">(</span><span class="n">baos</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">());</span>
          <span class="n">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectInputStream</span><span class="o">(</span><span class="n">bais</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">(</span><span class="n">DeepPrototype</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e1</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p><strong>优点</strong>：当创建的新对象比较复杂时，可以使用原型模式。不需要重新初始化对象，而且当对象发生变化时，不需要修改。<br>
<strong>缺点</strong>：需要给每个类都实现一个克隆方法。当对类进行改造时，可能需要修改源码，违反了<code>ocp</code>原则。</p>

<h2 id="4-建造者模式">4. 建造者模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建造者模式，又叫生成器模式。它将复杂对象的建造过程抽象，这个抽象过程的不同实现方法可以构造出不同表现的对象。通过建造者模式，用户不需要知道内部细节，只需要通过指定类型和内容即可构造出复杂对象。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建造者模式包含四个角色：</p>

<ol>
<li><span  class="math">\(Product\)</span> ：即产品角色，指一个具体的产品对象</li>
<li><span  class="math">\(Builder\)</span> ：即抽象建造者，创建产品对象各个部件的接口（抽象类）</li>
<li><span  class="math">\(ConcreteBuilder\)</span> ：即具体建造者，是实现接口的对象</li>
<li><span  class="math">\(Director\)</span> ：即指挥者，使用接口的对象</li>
</ol>

<p><figure><img src="/image/2020-07-10-03.png" alt="BuilderPattern"></figure></p>

<h3 id="41-jdk源码示例">4.1 JDK源码示例</h3>

<p><span  class="math">\(java.lang.StringBuilder\)</span> 中使用了建造者模式</p>

<p><figure><img src="/image/2020-07-10-04.png" alt="StringBuilder"></figure></p>

<ol>
<li><span  class="math">\(Appendable\)</span> 接口定义了多个 <span  class="math">\(append\)</span> 方法，均为抽象方法。因此可以将 <span  class="math">\(Appendable\)</span> 视为 <span  class="math">\(Builder\)</span> 。</li>
<li><span  class="math">\(AbstractStringBuilder\)</span> 实现了 <span  class="math">\(Appendable\)</span> 中的方法，可以视为 <span  class="math">\(ConcreteBuilder\)</span> ，即使不能实例化。</li>
<li><span  class="math">\(StringBuilder\)</span> 既是 <span  class="math">\(Director\)</span> ，也是 <span  class="math">\(ConcreteBuilder\)</span> 。建造方法是在 <span  class="math">\(AbstractStringBuilder\)</span> 中实现的。</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用了建造者模式，用户不需要了解内部实现即可根据类型和需求创建出不同的对象。对象创建的过程分为多个方法，使创建过程更加清晰，也能更方便的控制。在建造者模式的基础上，添加新的具体建造者无需修改原有代码，符合开闭原则。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一些差异很大的对象，不适宜使用建造者模式。如果一个对象十分复杂，需要多个建造者。那么如果继续使用建造者模式，会导致系统庞大。因此在这种情况下不应继续使用建造者模式。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与抽象工厂模式对比，抽象工厂模式不需要关注建造的过程，关注的是由哪个工厂建造；而建造者模式主要关注点就在过程。</p>

<h2 id="5-适配器模式">5. 适配器模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适配器，又叫包装器，用于将某个类的接口转换成客户端期望的另一个接口表示，主要的目的是兼容，让原本不匹配的两个类能够一起工作。适配器模式主要有三类：类适配器模式、对象适配器模式、接口适配器模式。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户不能直观地感受到适配器的存在。适配器转换目标对象，用户通过调用经适配器转换后的对象的接口方法，可以间接调用原目标对象的相应方法。被适配的对象称为 <span  class="math">\(src\)</span> 类，适配后的对象称为 <span  class="math">\(dst\)</span> 类。</p>

<h3 id="51-类适配器模式">5.1 类适配器模式</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适配器为 <span  class="math">\(Adapter\)</span> 类，通过继承 <span  class="math">\(src\)</span> 类，实现 <span  class="math">\(dst\)</span> 类接口，从而完成适配。</p>

<p><figure><img src="/image/2020-07-10-05.png" alt="ClassAdapter"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于<code>Java</code>实行的是单继承机制，因此要求 <span  class="math">\(dst\)</span> 必须为接口，存在一定的局限性。此外，<span  class="math">\(src\)</span> 类中的方法都会在 <span  class="math">\(Adapter\)</span> 类中暴露，增加了一定的成本。但反过来，由于方法暴露，因此也可以重写一部分方法，增加灵活性。</p>

<h3 id="52-对象适配器模式">5.2 对象适配器模式</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在类适配器模式的基础上加以修改。<span  class="math">\(Adapter\)</span> 类不再继承 <span  class="math">\(src\)</span> 类，而是持有 <span  class="math">\(src\)</span> 类实例。对象适配器模式是适配器模式中常用的一种。</p>

<p><figure><img src="/image/2020-07-10-06.png" alt="ObjectAdapter"></figure></p>

<h3 id="53-接口适配器模式">5.3 接口适配器模式</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口适配器模式，也称为适配器模式或缺省适配器模式。当不需要全部实现接口提供的方法的时候，可以设计一个抽象类实现该接口，并为方法提供空实现。</p>

<p><figure><img src="/image/2020-07-10-07.png" alt="InterfaceAdapter"></figure></p>

<h3 id="54-spring-mvc源码示例">5.4 Spring MVC源码示例</h3>

<p><span  class="math">\(HandlerAdapter\)</span> 使用了适配器模式</p>

<p><code>Spring MVC</code> 流程：</p>

<ol>
<li>请求发送给 <span  class="math">\(DispatcherServlet\)</span>,</li>
<li><span  class="math">\(HandlerMapping\)</span> 处理，找到对应的 <span  class="math">\(Handler\)</span>,</li>
<li><span  class="math">\(HandlerMapping\)</span> 返回一个 <span  class="math">\(ModelAndView\)</span> 对象,</li>
<li><span  class="math">\(InternalResourceViewResolve\)</span> 解析对象，找到指定的资源,</li>
<li><code>Tomcat</code>包装结果，返回给浏览器.</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Dispatcher\)</span> 的 <span  class="math">\(doDispatch\)</span> 方法获取对应的 <span  class="math">\(Adapter\)</span> ，再通过 <span  class="math">\(Adapter\)</span> 处理相应的 <span  class="math">\(Controller\)</span> 。</p>

<h2 id="6-桥接模式">6. 桥接模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;桥接模式将实现与抽象分到两个层次中，可以独立改变。桥接模式基于类的最小设计原则，主要特点是把抽象和实现分离。</p>

<p><figure><img src="/image/2020-07-10-08.png" alt="Bridge"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Phone\)</span> 为抽象类，<span  class="math">\(Brand\)</span> 为接口，是 <span  class="math">\(Phone\)</span> 的成员。<span  class="math">\(Phone\)</span> 和 <span  class="math">\(Brand\)</span> 分别有对应的实现类。</p>

<h3 id="61-jdbc源码示例">6.1 JDBC源码示例</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从桥接模式的角度，<span  class="math">\(Driver\)</span> 就是一个接口，下面的实现类可以是<code>MySQL</code>的，也可以是<code>Oracle</code>的。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Driver\)</span> 使用 <span  class="math">\(DriverManager\)</span> 注册。<span  class="math">\(DriverManager\)</span> 通过 <span  class="math">\(getConnection\)</span> 方法获取 <span  class="math">\(Connection\)</span> 。<span  class="math">\(Connection\)</span> 有多个实现，由不同的数据库提供商决定。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用了桥接模式后，高层部分只需要知道抽象部分和实现部分的接口即可，其余部分由具体业务实现。但同时，桥接模式的引入提高了设计和理解的难度。由于聚合发生在抽象层，因此开发者需要针对抽象层进行设计和编程。桥接模式的使用要求识别出系统变化的两个维度，具有一定局限性。</p>

<h2 id="7-装饰者模式">7. 装饰者模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;装饰者模式可以将新功能动态地附加到对象上。装饰者模式的主体( <span  class="math">\(Component\)</span> ) ，也就是被装饰的对象。装饰者模式的包装( <span  class="math">\(Decorator\)</span> ) ，也就是装饰者。后者继承和聚合前者，中间也可以添加接口作为缓冲层。</p>

<p><figure><img src="/image/2020-07-10-09.png" alt="Decorator"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用如上模式之后，购买一份咖啡只需要 <span  class="math">\(new\)</span> 一个咖啡对象。在咖啡对象的基础上，如果要添加调料，只需要 <span  class="math">\(new\)</span> 一个调料对象，并传入原有咖啡对象即可。在这个过程中，由于咖啡和调料都继承了 <span  class="math">\(Drink\)</span> ，因此不需要重新声明。在包装的过程中，可以通过重写方法来返回不同的描述和价格。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeBar</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Drink</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LongBlack</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;order description=&#34;</span> <span class="o">+</span> <span class="n">order</span><span class="o">.</span><span class="na">getDescription</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;, cost=&#34;</span> <span class="o">+</span> <span class="n">order</span><span class="o">.</span><span class="na">cost</span><span class="o">());</span>
    <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Milk</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;order description=&#34;</span> <span class="o">+</span> <span class="n">order</span><span class="o">.</span><span class="na">getDescription</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34;, cost=&#34;</span> <span class="o">+</span> <span class="n">order</span><span class="o">.</span><span class="na">cost</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<h3 id="71-jdk源码示例">7.1 JDK源码示例</h3>

<p><span  class="math">\(FilterInputStream\)</span> 类就是一个装饰者</p>

<ol>
<li><span  class="math">\(InputStream\)</span> 是被装饰的对象</li>
<li><span  class="math">\(FilterInputStream\)</span> 是装饰者，其内部包含一个 <span  class="math">\(InputStream\)</span> 类型的成员</li>
</ol>

<h2 id="8-组合模式">8. 组合模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;组合模式又叫部分整体模式，它将对象组合成树状结构来表示整体和部分的层次关系。通过组合模式，用户能够以一致的方式处理单个对象以及组合对象。<span  class="math">\(Component\)</span> 是组合中对象声明接口，包含所有类共有的默认行为，用于访问和管理子部件。<span  class="math">\(Leaf\)</span> 是继承了 <span  class="math">\(Component\)</span> 的叶子节点。<span  class="math">\(Composite\)</span> 是继承了 <span  class="math">\(Component\)</span> 的非叶子节点，实现操作子部件的相关方法，用于存储子部件。</p>

<p><figure><img src="/image/2020-07-10-10.png" alt="Composite"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Department\)</span> 是 <span  class="math">\(Leaf\)</span> ，<span  class="math">\(University\)</span> 和 <span  class="math">\(College\)</span> 是 <span  class="math">\(Composite\)</span> 。</p>

<h3 id="81-jdk源码示例">8.1 JDK源码示例</h3>

<p><span  class="math">\(HashMap\)</span> 使用了组合模式</p>

<p><figure><img src="/image/2020-07-10-11.png" alt="HashMapComposite"></figure></p>

<ol>
<li><span  class="math">\(Map\)</span> 是一个接口，可以视为 <span  class="math">\(Composite\)</span>,</li>
<li><span  class="math">\(HashMap\)</span> 实现了 <span  class="math">\(Map\)</span> ，可以视为 <span  class="math">\(Component\)</span>,</li>
<li><span  class="math">\(Node\)</span> 是 <span  class="math">\(HashMap\)</span> 的内部类，可以视为 <span  class="math">\(Leaf\)</span>.</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;组合模式能简化操作，用户只需要面对一致的对象而不需要考虑内部结构。组合模式具有较强的扩展性，用户可以随意添加节点。树形结构使得组合模式的遍历十分方便，但反过来如果节点间差异较大，则不适用于组合模式。</p>

<h2 id="9-外观模式">9. 外观模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观模式定义了一个高层接口，为子系统中的一组接口提供了一个一致的界面。调用端只需跟该高层接口交互，不需要了解其子系统的内部细节。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Facade\)</span> 即外观类，提供统一调用接口，负责将请求代理给适当的子系统对象。<span  class="math">\(Client\)</span> 即调用者，调用外观接口。子系统集合处理 <span  class="math">\(Facade\)</span> 指定的请求。</p>

<p><figure><img src="/image/2020-07-10-12.png" alt="Facade"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;影院中的每个设备都有对应的操作方法，在影片放映的不同过程中需要分别调用对应的方法，可以使用 <span  class="math">\(Facade\)</span> 来进行统一调度。</p>

<h3 id="91-mybatis源码示例">9.1 MyBatis源码示例</h3>

<p>在<code>MyBatis</code>中的 <span  class="math">\(Configuration\)</span> 创建 <span  class="math">\(MetaObject\)</span> 的过程中使用了外观模式</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">MetaObject</span> <span class="nf">newMetaObject</span><span class="o">(</span><span class="n">Object</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">MetaObject</span><span class="o">.</span><span class="na">forObject</span><span class="o">(</span><span class="n">object</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">objectFactory</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">objectWrapperFactory</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">reflectorFactory</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外观模式降低了用户对子系统复杂性的感受，使子系统更容易维护。当需要分层设计时，可以使用外观模式来更好的划分层次。但是也不能滥用外观模式，要以利于维护为目的。</p>

<h2 id="10-享元模式">10. 享元模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;享元模式也叫蝇量模式，是运用共享技术有效地支持大量细粒度对象的模式。享元模式常用于底层开发，如数据库连接池等，能够解决重复对象造成的内存浪费问题。享元模式将对象的信息分为内部状态和外部状态两部分。 内部状态是存储在享元对象内且不会因环境而改变的信息，是对象共享的信息。外部状态是对象依赖的信息，会随环境变化而改变。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(FlyWeight\)</span> 是抽象的享元类，定义对象的内部状态和外部状态。<span  class="math">\(ConcreteFlyWeight\)</span> 是具体的享元类，实现具体业务。<span  class="math">\(UnSharedConcreteFlyWeight\)</span> 是不可共享的角色，虽然继承 <span  class="math">\(FlyWeight\)</span> ，但不会出现在享元工厂。<span  class="math">\(FlyWeightFactory\)</span> 是享元工厂类，作为池容器，负责创建和返回享元类。</p>

<p><figure><img src="/image/2020-07-10-13.png" alt="FlyWeight"></figure></p>

<h3 id="101-jdk源码示例">10.1 JDK源码示例</h3>

<p><span  class="math">\(java.lang.Integer\)</span> 类中使用了享元模式</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Integer</span> <span class="nf">valueOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">IntegerCache</span><span class="o">.</span><span class="na">low</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">IntegerCache</span><span class="o">.</span><span class="na">high</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">IntegerCache</span><span class="o">.</span><span class="na">cache</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="o">(-</span><span class="n">IntegerCache</span><span class="o">.</span><span class="na">low</span><span class="o">)];</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Integer.valueOf\)</span> 方法，在 <span  class="math">\(-128 \sim 127\)</span> 之间使用享元模式创建。也即代表使用 <span  class="math">\(valueOf\)</span> 创建的所有处于 <span  class="math">\(-128 \sim 127\)</span> 的同一大小的对象都是同一引用。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在系统中的大部分对象状态可以外部化时，可以使用享元模式。如果对象在内存中存在着唯一标识码，可以使用 <span  class="math">\(HashMap\)</span> 或 <span  class="math">\(HashTable\)</span> 存储。要注意的是，使用享元模式要分离内部状态和外部状态，还需要一个工厂类加以控制。</p>

<h2 id="11-代理模式">11. 代理模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代理模式为对象提供一个代理对象，控制对该对象的访问。其他对象可以通过访问代理对象的方式访问目标对象。被代理的对象可以是远程对象、创建开销大的对象或者需要安全控制的对象。代理模式主要有三种形式：静态代理、动态代理和<code>Cglib</code>代理。</p>

<h3 id="111-静态代理">11.1 静态代理</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义一个接口或者父类，然后令被代理对象与代理对象一起实现相同接口或者继承相同父类。</p>

<p><figure><img src="/image/2020-07-10-14.png" alt="StaticProxy"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过静态代理，我们能够在不修改源对象的情况下对其进行扩展，但是由于要求实现同一接口，因此一旦接口改变，就需要同时修改两个对象，增加了维护难度。</p>

<h3 id="112-动态代理">11.2 动态代理</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态代理对象不需要实现接口，但是目标对象需要实现接口。动态代理通过<code>JDK</code>提供的<code>API</code>实现，动态地在内存中构建代理对象。动态代理也叫<code>JDK</code>代理、接口代理。</p>

<p><figure><img src="/image/2020-07-10-15.png" alt="DynamicProxy"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(ProxyFactory.getProxyInstance\)</span> 接受一个对象，利用反射机制返回一个代理对象，再通过该代理对象调用目标对象方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProxyFactory</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">Object</span> <span class="n">target</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">ProxyFactory</span><span class="o">(</span><span class="n">Object</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getProxyInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>
        <span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span>
        <span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">(),</span>
        <span class="k">new</span> <span class="n">InvocationHandler</span><span class="o">()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">});</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p><span  class="math">\(public static Object newProxyInstance(ClassLoader loader, Class<?>[\ ] interfaces, InvocationHandler h)\)</span> :</p>

<ol>
<li><span  class="math">\(loader\)</span> 为目标对象使用的类加载器，有固定获取方法</li>
<li><span  class="math">\(interfaces\)</span> 为目标对象实现的接口类型，使用泛型方式确定</li>
<li><span  class="math">\(h\)</span> 为事件处理类，当执行目标对象方法时，会触发事件处理器方法，即将当前事件方法作为参数传入</li>
</ol>

<h3 id="113-cglib代理">11.3 Cglib代理</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态代理和动态代理都要求目标对象实现一个接口，而当目标对象没有实现接口时，<code>Cglib</code>代理允许你通过其子类实现代理，因此也被叫做子类代理。<code>Cglib</code>代理可以在运行期扩展以及实现<code>Java</code>接口，被许多<code>AOP</code>框架所使用，其底层通过字节码处理框架<code>ASM</code>来转换字节码并生成新的类。使用<code>Cglib</code>代理时，要注意目标类不能为 <span  class="math">\(final\)</span> 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProxyFactory</span> <span class="kd">implements</span> <span class="n">MethodInterceptor</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">Object</span> <span class="n">target</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">ProxyFactory</span><span class="o">(</span><span class="n">Object</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getProxyInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Enhancer</span> <span class="n">enhancer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Enhancer</span><span class="o">();</span>
    <span class="n">enhancer</span><span class="o">.</span><span class="na">setSuperclass</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
    <span class="n">enhancer</span><span class="o">.</span><span class="na">setCallback</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">enhancer</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Object</span> <span class="nf">intercept</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">objects</span><span class="o">,</span> <span class="n">MethodProxy</span> <span class="n">methodProxy</span><span class="o">)</span>
      <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">objects</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(getProxyInstance\)</span> 方法为 <span  class="math">\(target\)</span> 创建一个代理。<span  class="math">\(Enhancer\)</span> 为一个工具类，设置目标对象为其父类，动态构建子类对象。重写 <span  class="math">\(intecept\)</span> 方法实现被代理对象的方法调用。</p>

<h3 id="114-代理模式的变体">11.4 代理模式的变体</h3>

<ol>
<li>防火墙代理——内网通过代理穿透防火墙访问公网</li>
<li>缓存代理——请求资源时先检查代理，如果代理没有再从数据库获取</li>
<li>远程代理——可以将远程对象当作本地对象使用</li>
<li>同步代理——在多线程中负责同步工作</li>
</ol>

<h2 id="12-模板方法模式">12. 模板方法模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板方法模式又叫模板模式，在一个抽象类中公开定义了模板方法，其子类可以重写一些方法，但调用应按照抽象类中定义的方法进行。</p>

<p><figure><img src="/image/2020-07-10-16.png" alt="TemplateMethod"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在模板方法模式的父类中，我们可以定义一个方法，称为钩子，默认为空，子类可以视情况覆盖。</p>

<h3 id="121-spring源码示例">12.1 Spring源码示例</h3>

<p><code>Spring IOC</code>容器初始化时用到模板方法模式</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(AbstractApplicationContext.refresh\)</span> 方法是一个模板方法，其内部间接调用抽象方法 <span  class="math">\(refreshBeanFactory\)</span> 和 <span  class="math">\(getBeanFactory\)</span> ，其子类继承并实现抽象方法。<span  class="math">\(PostProcessBeanFactory\)</span> 和 <span  class="math">\(onRefresh\)</span> 是钩子方法，在父类中为空实现。</p>

<h2 id="13-命令模式">13. 命令模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在软件设计中，我们经常需要发送请求，但是并不知道请求的接收者和被请求的操作，这时只需要在程序运行时指定即可。命令模式允许我们消除请求发送者和接收者间的耦合，实现更灵活的调用。在命令模式中，请求被封装为一个对象，表示不同的请求。命令模式支持撤销操作。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Invoker\)</span> 是调用者，<span  class="math">\(Receiver\)</span> 是被调用者，<span  class="math">\(ConcreteCommand\)</span> 实现了 <span  class="math">\(Command\)</span> 接口，持有接受对象。</p>

<p><figure><img src="/image/2020-07-10-17.png" alt="Command"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(LightReceiver\)</span> 负责控制灯的开关，<span  class="math">\(Command\)</span> 持有 <span  class="math">\(LightReceiver\)</span> ，调用其方法，<span  class="math">\(RemoteController\)</span> 通过 <span  class="math">\(Command\)</span> 实现对灯的控制。</p>

<h3 id="131-spring源码示例">13.1 Spring源码示例</h3>

<p><span  class="math">\(JdbcTemplate\)</span> 中使用了命令模式</p>

<ol>
<li><span  class="math">\(JdbcTemplate\)</span> 类中存在 <span  class="math">\(query\)</span> 方法,</li>
<li><span  class="math">\(query\)</span> 方法中定义了一内部类 <span  class="math">\(QueryStatementCallback\)</span>,</li>
<li><span  class="math">\(QueryStatementCallback\)</span> 实现了 <span  class="math">\(StatementCallback\)</span> 接口,</li>
<li>在 <span  class="math">\(query\)</span> 方法结束时调用了 <span  class="math">\(execute\)</span> 方法并传入了 <span  class="math">\((StatementCallback)new QueryStatementCallback\)</span>.</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(JdbcTemplate\)</span> 通过 <span  class="math">\(query\)</span> 方法，使其成为了 <span  class="math">\(Invoker\)</span> 。<span  class="math">\(StatementCallback\)</span> 和 <span  class="math">\(QueryStatementCallback\)</span> 是 <span  class="math">\(Command\)</span> 和 <span  class="math">\(ConcreteCommand\)</span> 的关系，同时也充当着 <span  class="math">\(Receiver\)</span>。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令模式将请求对象与被请求对象解耦，请求者和被请求者不需要知道对方是谁即可调用。通过命令队列，可以轻松的实现多线程调用。但是对于有很多的命令的操作，容易产生过多的命令类，增加复杂度。命令模式的使用还可以方便实现命令的撤销。通过引入空命令，可以省去判空语句。</p>

<h2 id="14-访问者模式">14. 访问者模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;访问者模式封装一些作用于某种结构的元素的操作，可以在不改变数据结构的前提下定义新操作。访问者模式将数据结构与数据操作进行分离，解决其耦合性问题。访问者模式通过向被访问类里添加一个供外部访问的接口。当需要对一个结构进行很多种不同的操作，又要避免对结构造成很大影响时，可以使用访问者模式。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Visitor\)</span> 是一个抽象类，<span  class="math">\(ConcreteVisitor\)</span> 是其实现。<span  class="math">\(ObjectStructure\)</span> 是一数据结构，可以枚举其元素，提供一高层接口，使访问者可以访问其元素。<span  class="math">\(Element\)</span> 为接口，定义了一 <span  class="math">\(accept\)</span> 方法，接受一访问者对象，<span  class="math">\(ConcreteElement\)</span> 是其实现。</p>

<p><figure><img src="/image/2020-07-10-18.png" alt="Visitor"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双分派的使用使得无论两种类怎么变化都不会影响另一种类，例如我们要添加新的动作时只需要创建新的 <span  class="math">\(Action\)</span> 的实现即可，要细化 <span  class="math">\(Person\)</span> 时也只需要修改其实现类即可。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;访问者模式的使用使得程序的灵活性更高，适用于结构稳定，功能统一的系统。但是由于具体元素向访问公开细节，是迪米特法则所不推荐的。同时访问类也违反了依赖倒转原则，抽象类依赖于具体元素。</p>

<h2 id="15-迭代器模式">15. 迭代器模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;迭代器模式提供一种遍历结合模式的接口，允许通过一个一致的方法，在不需要暴露内部结构的情况下对集合进行遍历。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Iterator\)</span> 是一个接口，提供了 <span  class="math">\(hasNext\)</span>, <span  class="math">\(next\)</span>, <span  class="math">\(remove\)</span> 方法，<span  class="math">\(ConcreteIterator\)</span> 实现了 <span  class="math">\(Iterator\)</span> 。<span  class="math">\(Aggregate\)</span> 是一个聚合接口，将其实现和客户端解耦，<span  class="math">\(ConcreteAggregate\)</span> 是其具体实现，持有对象的集合。</p>

<p><figure><img src="/image/2020-07-10-19.png" alt="Iterator"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(College\)</span> 接口中声明了 <span  class="math">\(iterator\)</span> 方法，通过调用该方法即可获得对应的迭代器。<span  class="math">\(Iterator\)</span> 的实现中持有对应的集合，通过对不同的类创建不同的实现，可以做到在不暴露内部实现的情况下实现对集合的遍历。</p>

<h3 id="151-jdk源码示例">15.1 JDK源码示例</h3>

<ol>
<li><span  class="math">\(List\)</span> 接口声明了 <span  class="math">\(iterator\)</span> 方法</li>
<li><span  class="math">\(ArrayList\)</span> 实现了 <span  class="math">\(List\)</span> 接口，<span  class="math">\(iterator\)</span> 方法返回一个 <span  class="math">\(Itr\)</span> 对象</li>
<li><span  class="math">\(Itr\)</span> 实现了 <span  class="math">\(Iterator\)</span> 接口</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;迭代器模式的使用使得客户端不需要知道内部细节即可实现对集合的遍历。迭代器的使用将管理对象集合和遍历对象集合的功能分开，满足了单一职责原则。但是如果存在很多聚合类时，每个类都需要声明一个对应的迭代器实现类，增加了复杂度。</p>

<h2 id="16-观察者模式">16. 观察者模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;观察者模式定义了一个 <span  class="math">\(Subject\)</span> 接口，接口中的 <span  class="math">\(registerObserver\)</span> 方法可以注册新的观察者，<span  class="math">\(removeObserver\)</span> 方法移除观察者，<span  class="math">\(notifyObservers\)</span> 方法通知所有观察者，且可以根据需要改变推送策略。<span  class="math">\(Observer\)</span> 接口内有一个 <span  class="math">\(update\)</span> 方法，用于更新数据。观察者模式是对象间多对一依赖的一种设计模式，被依赖的对象是 <span  class="math">\(Subject\)</span> ，依赖对象是 <span  class="math">\(Observer\)</span> ，<span  class="math">\(Observer\)</span> 通过 <span  class="math">\(Subject\)</span> 通知的数据进行更新。</p>

<p><figure><img src="/image/2020-07-10-20.png" alt="Observer"></figure></p>

<h3 id="161-jdk源码示例">16.1 JDK源码示例</h3>

<p><span  class="math">\(Observable\)</span> 类使用了观察者模式</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Observable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Observer</span><span class="o">&gt;</span> <span class="n">obs</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Observable</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">addObserver</span><span class="o">(</span><span class="n">Observer</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">obs</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">o</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">obs</span><span class="o">.</span><span class="na">addElement</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">deleteObserver</span><span class="o">(</span><span class="n">Observer</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">obs</span><span class="o">.</span><span class="na">removeElement</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">notifyObservers</span><span class="o">(</span><span class="n">Object</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Object</span><span class="o">[]</span> <span class="n">arrLocal</span><span class="o">;</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">changed</span><span class="o">)</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="n">arrLocal</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>
            <span class="n">clearChanged</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">arrLocal</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span>
            <span class="o">((</span><span class="n">Observer</span><span class="o">)</span><span class="n">arrLocal</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">update</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">arg</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// ...
</span><span class="c1"></span><span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Observer</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">Observable</span> <span class="n">o</span><span class="o">,</span> <span class="n">Object</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Observable\)</span> 并没有使用接口，而是直接声明一个具体类，在类中存在着注册、移除和通知观察者的方法，是 <span  class="math">\(Subject\)</span> 的角色。<span  class="math">\(Observer\)</span> 接口及其实现充当观察者的角色，提供了 <span  class="math">\(update\)</span> 方法。</p>

<h2 id="17-中介者模式">17. 中介者模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中介者模式是用一个中介对象封装一系列对象间的交互。在中介者模式下，交互的对象间不需要显式地相互作用，起到了松耦合作用，从而使代码更容易维护。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Colleague\)</span> 是抽象同事类，<span  class="math">\(ConcreteColleague\)</span> 是其实现。同事类之间互不了解，只需要依赖中介者对象即可。<span  class="math">\(Mediator\)</span> 是抽象中介者，<span  class="math">\(ConcreteMediator\)</span> 是其实现。中介者对象通过一个集合来接受同事的消息，并完成指定操作。</p>

<p><figure><img src="/image/2020-07-10-21.png" alt="Mediator"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Colleague\)</span> 中持有 <span  class="math">\(Mediator\)</span> 对象，可以通过 <span  class="math">\(Mediator.register\)</span> 方法将本身注册到中介者内。$Mediator<span  class="math">\( 内使用 \)</span>HashMap<span  class="math">\( 实现对 \)</span>Colleague<span  class="math">\( 的管理。当接受到消息时，\)</span>Mediator$$ 类中对应的方法会根据消息的类型进行不同的操作。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用中介者模式，可以将原先多个类相互耦合形成的网状结构分解成星型结构，减少了类间的依赖和耦合，符合迪米特原则。但要注意的是，在中介者模式中，中介者承担了很多责任，一旦中介者出现了问题，整个系统都会受到影响，如果设计不当，中介者很复杂，那么整个系统都会受到影响。</p>

<h2 id="18-备忘录模式">18. 备忘录模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;备忘录模式可以在不破坏封装性的情况下捕获并记录一个对象的内部状态。通过备忘录模式，一个对象可以恢复到一个以前的状态。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Originator</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">String</span> <span class="n">state</span><span class="o">;</span>

  <span class="kd">public</span> <span class="n">Memento</span> <span class="nf">saveState</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Memento</span><span class="o">(</span><span class="n">state</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">readState</span><span class="o">(</span><span class="n">Memento</span> <span class="n">memento</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">memento</span><span class="o">.</span><span class="na">getState</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">state</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setState</span><span class="o">(</span><span class="n">String</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Memento</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">String</span> <span class="n">state</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">Memento</span><span class="o">(</span><span class="n">String</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">state</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Caretaker</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Memento</span><span class="o">&gt;</span> <span class="n">mementos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">Memento</span> <span class="n">memento</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">mementos</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">memento</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Memento</span> <span class="n">memento</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">mementos</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">memento</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">Memento</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">mementos</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Originator\)</span> 是待保存的对象，<span  class="math">\(Mementor\)</span> 是备忘录对象，<span  class="math">\(Caretaker\)</span> 管理备忘录对象。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;备忘录提供了一种可以恢复之前状态的机制，实现了信息的封装，用户在恢复时不需要关注状态的细节。但是如果类内成员过多，那么每次备份都会消耗大量时间，还存在着资源浪费。为了节约内存，备忘录模式也可以与原型模式一起使用。</p>

<h2 id="19-解释器模式">19. 解释器模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解释器模式对于给定的表达式，定义了其文法的一种表示，利用一个解释器来对表达式进行解释。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Context\)</span> 是环境角色，包含解释器之外的全局信息。<span  class="math">\(AbstractExpression\)</span> 是抽象表达式，声明一个抽象的解释操作，为抽象语法树中所有节点所共享。<span  class="math">\(TerminalExpression\)</span> 实现 <span  class="math">\(AbstractExpression\)</span> 为终结符表达式，实现与终结符相关的解释操作。<span  class="math">\(NonTerminalExpression\)</span> 实现 <span  class="math">\(AbstractExpression\)</span> 为非终结符表达式，实现与非终结符相关的解释操作。</p>

<p><figure><img src="/image/2020-07-10-22.png" alt="Interpreter"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Expression\)</span> 是一个抽象解释器，内包含一个 <span  class="math">\(interpreter\)</span> 方法，其实现类分别用于解释不同的字符：数字和加减号。</p>

<h3 id="191-spring源码示例">19.1 Spring源码示例</h3>

<p><span  class="math">\(SpelExpressionParser\)</span> 类中使用了解释器模式</p>

<ol>
<li><span  class="math">\(Expression\)</span> 接口内包含 <span  class="math">\(getValue\)</span> 方法,</li>
<li><span  class="math">\(SpelExpressionParser\)</span> 间接实现了 <span  class="math">\(ExpressionParser\)</span>,</li>
<li><span  class="math">\(ExpressionParser.parseExpression\)</span> 方法会根据不同的情况返回相应的 <span  class="math">\(Expression\)</span>.</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当需要解释执行一个语言时，如果可以用语法树表示句子，那么就可以使用解释器模式。解释器模式相比一般模式具有良好的扩展性，但由于其采用递归调用方法，可能会导致调试复杂，效率降低。</p>

<h2 id="20-状态模式">20. 状态模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态模式用于多种状态转换时对外输出不同的问题。状态间可以相互转换，行为与状态一一对应。当对象的状态改变时，其行为也跟着改变，从外部来看类似于变为另一个类。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Context\)</span> 为环境角色，维护状态实例。<span  class="math">\(State\)</span> 为接口，封装与 <span  class="math">\(Context\)</span> 的一个特定接口相关的操作，<span  class="math">\(ConcreteState\)</span> 为其实现。</p>

<p><figure><img src="/image/2020-07-10-23.png" alt="State"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Activity\)</span> 和 <span  class="math">\(State\)</span> 之间互相持有，<span  class="math">\(Activity\)</span> 内的方法调用 <span  class="math">\(State\)</span> 的方法进行状态对应的行为，<span  class="math">\(State\)</span> 内的方法调用 <span  class="math">\(Activity\)</span> 的方法进行状态切换。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态模式具有很强的可读性，将状态和行为封装在一起，方便扩展，而且避免了 <span  class="math">\(if-else\)</span> 带来的问题，符合开闭原则。但相对应的，由于每个状态都对应者一个类，可能会产生很多个状态类，从而增加了维护难度。</p>

<h2 id="21-策略模式">21. 策略模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;策略模式定义了一些算法，分别封装起来，算法间可以互相替换。</p>

<p><figure><img src="/image/2020-07-10-24.png" alt="Strategy"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Duck\)</span> 持有 <span  class="math">\(FlyBehavior\)</span> ，其子类继承 <span  class="math">\(Duck\)</span> 时通过设置 <span  class="math">\(FlyBehavior\)</span> ，可以做出不同的行为。</p>

<h3 id="211-jdk源码示例">21.1 JDK源码示例</h3>

<p><span  class="math">\(Arrays\)</span> 类中使用了策略模式</p>

<p><span  class="math">\(Arrays.sort\)</span> 方法可以选择传入 <span  class="math">\(Comparator\)</span> 类来指定排序策略</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;策略模式多用组合，少用继承，使用行为类进行组合而不是行为继承，符合开闭原则。</p>

<h2 id="22-职责链模式">22. 职责链模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;职责链模式，又叫责任链模式，为请求创建了一个接收者对象的链，对请求的发送者和接收者进行解耦。在职责链模式中，通常每个接收者都包含对另一个接收者的引用，在当前接收者不能处理时，会将请求传递给下一个接收者。</p>

<p><figure><img src="/image/2020-07-10-25.png" alt="ResponsibilityChain"></figure></p>

<h3 id="221-springmvc源码示例">22.1 SpringMVC源码示例</h3>

<p><span  class="math">\(HandlerInterceptor\)</span> 类中使用了职责链模式</p>

<ol>
<li><span  class="math">\(DispatcherServlet.doDispatch\)</span> 方法中获取 <span  class="math">\(HandlerExecutionChain\)</span> 对象,</li>
<li><span  class="math">\(HandlerExecutionChain.applyPreHandle\)</span> 方法获取 <span  class="math">\(HandlerInterceptor\)</span>,</li>
<li><span  class="math">\(HandlerInterceptor.preHandler\)</span> 方法被调用,</li>
<li><span  class="math">\(applyPreHandler\)</span> 方法中调用了 <span  class="math">\(triggerAfterCompletion\)</span> 方法,</li>
<li><span  class="math">\(triggerAfterCompletion\)</span> 方法调用了 <span  class="math">\(HandlerInterceptor.afterCompletion\)</span> 方法,</li>
<li><span  class="math">\(HandlerExecutionChain.applyPostHandle\)</span> 方法再次获取 <span  class="math">\(HandlerInterceptor\)</span>,</li>
<li><span  class="math">\(HandlerInterceptor.postHandler\)</span> 方法被调用.</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;职责链模式将请求和处理分开，实现了解耦，提高了系统的灵活性。但是性能会受到影响，特别是如果链很长，因此最好设置一个最大节点数加以限制。由于采用了类似于递归的方式，因此也不利于调试。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Jul 10 16:57</span> <a href="/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">数据库系统（9）：事务管理</a></h1>
            </center>
            <div class="post-content">
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DBMS</code>应该具备的功能中，有三个密切相关的功能，用以保证数据库的可靠性和一致性，即事务支持、并发控制服务和恢复服务。它们之间是相互依赖的。并发控制和恢复主要用于保护数据库，避免数据库发生数据不一致或者数据丢失。许多<code>DBMS</code>都允许用户对数据库进行并发操作。如果对这些操作不加控制，对数据库的访问将互相干扰，使得数据库出现不一致的情况。为了解决这个问题，<code>DBMS</code>实现了<strong>并发控制</strong> ( <span  class="math">\(concurrency\;control\)</span> ) 协议，来阻止数据库访问之间的相互干扰。<strong>数据库恢复</strong> ( <span  class="math">\(Database\;recovery\)</span> ) 是指在故障以后将数据库还原到正确状态的过程。</p>

<h2 id="1-支持事务处理">1. 支持事务处理</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>事务</strong> ( <span  class="math">\(Transaction\)</span> ) 是由单个用户或者应用程序执行的，完成读取或者更新数据库内容的一个或者一串操作。事务是数据库的<strong>逻辑操作单位</strong> ( <span  class="math">\(logical\;unit\;of\;work\)</span> ) 。它可以是整个程序、部分程序或者一条命令，也可以是涉及数据库的任意多个操作。从数据库的角度来看，应用程序的一次执行就是一个事务或者多个事务，若看成多个事务，在事务与事务之间只会出现非数据库操作。复杂的事务由很多操作构成。若并非所有操作都被执行，那么可能会出现<strong>不一致状态</strong> ( <span  class="math">\(inconsistent\;state\)</span> ) 。在事务处理过程中，尽管我们允许数据库的一致性遭到暂时破坏，但是事务应该总是能将数据库从一种一致的状态转移到另一种一致的状态。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务可能有以下两种结果中的一种。如果执行成功，也就是说事务最终被<strong>提交</strong> ( <span  class="math">\(committed\)</span> )，数据库也将到达一种新的一致状态。另一种情况下，事务没有执行成功，则会被<strong>撤销</strong> ( <span  class="math">\(aborted\)</span> )。如果事务被撤销，则数据库必须要还原到事务开始之前的一致的状态。我们称这样的事务被<strong>回滚</strong> ( <span  class="math">\(rolled\;back\)</span> ) /<strong>撤销</strong> ( <span  class="math">\(undone\)</span> )。已经提交的事务无法撤销。如果发现已提交的事务存在错误，必须执行另一个<strong>补偿事务</strong> ( <span  class="math">\(compensating\;transaction\)</span> ) 来消除该事务已经产生的影响。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DBMS</code>无法得知哪些更新操作将被组合在一起以构成一个独立的逻辑事务。因此很多数据操作语言中都使用关键字 <span  class="math">\(BEGIN\)</span>, <span  class="math">\(TRANSACTION\)</span>, <span  class="math">\(COMMIT\)</span>, <span  class="math">\(ROLLBACK\)</span> 来划定界限。如果不使用，通常会将整个程序视为一个事务。</p>

<p><figure><img src="/image/2020-06-13-1.png" alt="事务的状态转移图"></figure></p>

<h3 id="11-事务的性质">1.1 事务的性质</h3>

<ol>
<li><strong>原子性</strong> ( <span  class="math">\(Atomicity\)</span> )：事务是一个不可分割的单元，要么全执行，要么全不执行。事务的原子性由<code>DBMS</code>的恢复子系统负责保证。</li>
<li><strong>一致性</strong> ( <span  class="math">\(Consistency\)</span> )：事务必须将数据库从一种一致的状态转换到另一种一致的状态。事务的一致性是由<code>DBMS</code>和应用程序的开发者共同保证的。<code>DBMS</code>可以通过强制实施所有在数据库模式中定义的约束（如完整性约束和企业自定义约束）来保证一致性。</li>
<li><strong>隔离性</strong> ( <span  class="math">\(Isolation\)</span> )：事务的执行是相互独立的，即未完成事务的中间结果对其他事务来说应该是不可见的。事务的隔离性由并发控制子系统负责保证。</li>
<li><strong>持久性</strong> ( <span  class="math">\(Durability\)</span> )：成功完成的事务的结果要永久地记录在数据库中。事务的持久性由恢复子系统负责保证。</li>
</ol>

<h3 id="12-数据库体系结构">1.2 数据库体系结构</h3>

<p><figure><img src="/image/2020-06-13-2.png" alt="DBMS事务子系统"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>事务管理器</strong> ( <span  class="math">\(Transaction\;manager\)</span> ) 代表应用程序协调事务的处理。事务管理器与<strong>调度</strong> ( <span  class="math">\(scheduler\)</span> ) 模块进行通信，后者负责实现某种并发控制策略。如果并发控制协议指的是基于锁机制的并发控制协议，则调度程序有时候也被看成是<strong>锁管理器</strong> ( <span  class="math">\(lock\;manager\)</span> )。调度程序的目标是在不允许并发事务互相干扰的前提下最大限度地提高事务的并发度，当然要牺牲一些完整性或一致性。如果事务在处理过程中发生故障，<strong>恢复管理器</strong> ( <span  class="math">\(recovery\;manager\)</span> ) 负责将数据库恢复到事务开始前的状态，使得数据库重新处于一致状态。最后，<strong>缓冲区管理器</strong> ( <span  class="math">\(buffer\;manager\)</span> ) 负责在磁盘存储器和主存间高效地传输数据。</p>

<h2 id="2-并发控制">2. 并发控制</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>并发控制</strong> ( <span  class="math">\(Concurrency\;control\)</span> ) 是管理数据库上的并发操作以使之互不冲突的过程。</p>

<h3 id="21-并发控制的必要性">2.1 并发控制的必要性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并发数据库的一个主要目标就是使得多个用户能够并发地访问共享数据。这个目标和多用户计算机系统的目标类似。系统执行第一个事务，进行到<code>I/O</code>操作时，<code>CPU</code>挂起第一个事务并开始执行第二个事务的操作，此时第一个事务的<code>I/O</code>操作由子系统执行。当第二个事务也进行到<code>I/O</code>操作时，<code>CPU</code>控制返回第一个事务，从之前被挂起的地方起执行，如此重复。通过这种方法，两个事务的操作<strong>互相重叠</strong> ( <span  class="math">\(interleaved\)</span> )，并发执行，提高了系统<strong>吞吐量</strong> ( <span  class="math">\(throughput\)</span> ) ，即在给定时间间隔内完成的工作量。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然两个事务各自执行时是完全正确的，但是这种重叠方式却可能产生不正确的结果。可能导致三种问题：<strong>丢失更新问题</strong> ( <span  class="math">\(lost\;update\;problem\)</span> )、<strong>未提交依赖问题</strong> ( <span  class="math">\(uncommitted\;dependency\;problem\)</span> ) 和<strong>不一致分析问题</strong> ( <span  class="math">\(inconsistent\;analysis\;problem\)</span> )。</p>

<h4 id="211-丢失更新问题">2.1.1 丢失更新问题</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一位用户的更新操作已经完成，结果却被另一位用户取代了，这就是丢失更新问题。假设存在两个事务，这两个事务都对 <span  class="math">\(A\)</span> 执行读写操作。<span  class="math">\(T_1\)</span>, <span  class="math">\(T_2\)</span> 在读取 <span  class="math">\(A\)</span> 之后进行了一系列操作，最终依次写入。但实际上最终 <span  class="math">\(A\)</span> 的值是只经过了后者操作的值，即 <span  class="math">\(T_1\)</span> 的操作被忽略了。该问题可以通过锁机制避免。</p>

<h4 id="212-未提交依赖问题">2.1.2 未提交依赖问题</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果允许一个事务看到另外一个未提交事务的中间结果，就会出现未提交依赖问题。假设存在两个事务，前者被撤销，但是在被撤销之前，后者读取到了前者中间过程的数据，就会产生未提交依赖问题。读取到的数据被称为<em>脏数据</em> ( <span  class="math">\(dirty\;data\)</span> )，该问题也因此被称为<em>污读问题</em> ( <span  class="math">\(dirty\;read\;problem\)</span> )。</p>

<h4 id="213-不一致分析问题">2.1.3 不一致分析问题</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述两个问题都发生在事务试图更新数据库，并且它们在操作上互相干扰的情况。然而即使是对数据库进行只读操作的事务也可能产生不正确的结果。当某事务从数据库中读取多个数据的值时，另一个事务在读取过程中修改了某些数据的值，就会出现不一致分析问题。这个问题有时也被称为<strong>不可重</strong> ( <span  class="math">\(nonrepeatable\)</span> )/<strong>模糊</strong> ( <span  class="math">\(fuzzy\)</span> ) <strong>读</strong>问题。还有一种类似问题，如果事务执行某一次查询，稍后再执行这次查询，却发现这次查询的集合中包含了其他<strong>幻象</strong> ( <span  class="math">\(phantom\)</span> ) 元组，即另一个事务插入的元组。这个问题有时也被称为<strong>幻读</strong> ( <span  class="math">\(phantom\;read\)</span> )。</p>

<h3 id="22-可串行性与可恢复性">2.2 可串行性与可恢复性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并发控制协议的目标就是以一种避免事务之间相互干扰的方式对事务进行调度，从而防止前一节讲述的各种问题的发生。<strong>调度</strong> ( <span  class="math">\(Schedule\)</span> ) 是一组并发事务操作的序列，对于其中每个事务来说，该序列保留了该事务的所有操作的先后次序。调度 <span  class="math">\(S\)</span> 由 <span  class="math">\(n\)</span> 个事务组成，对于其中的每一个事务来说，其操作的先后次序与它们出现在 <span  class="math">\(S\)</span> 的先后次序一样。<strong>串行调度</strong> ( <span  class="math">\(Serial\;schedule\)</span> ) 每一个事务的操作都按顺序执行且各事务之间的操作没有任何交叉的调度。<strong>非串行调度</strong> ( <span  class="math">\(Nonserial\;schedule\)</span> ) 是一组并发事务的操作相互交叉执行的调度。串行执行能够避免以上三个问题的出现。不管先择哪一种串行调度，都不会使数据库出现不一致状态。所有的串行执行都被认为是正确的。<strong>可串行性</strong> ( <span  class="math">\(serializability\)</span> ) 的目标就是寻找既能使事务并发执行又互不干扰的非串行调度，从而产生一个能由串行执行产生的数据库状态。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一组事务并发执行，当且仅当（非串行）调度能够产生和某些串行执行相同的结果时，调度才是正确的，这样的调度就被称为<strong>可串行化</strong> ( <span  class="math">\(serializable\)</span> ) 的。为了避免由事务相互冲突产生的不一致性，必须保证并发事务的可串行化。在可串行化问题中，读写操作的次序非常重要：</p>

<ul>
<li>如果两个事务都只是读取某一数据项，它们之间不会相互冲突</li>
<li>如果两个事务要读写的数据项完全没有交集，它们之间不会相互冲突</li>
<li>如果一个事务写某个数据项的同时，另一个事务要读或写同一个数据项，它们之间可能会产生冲突</li>
</ul>

<p><figure><img src="/image/2020-06-13-3.png" alt="等价调度"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调度 <span  class="math">\(S_3\)</span> 是串行调度，而 <span  class="math">\(S_1\)</span>, <span  class="math">\(S_2\)</span> 与 <span  class="math">\(S_3\)</span> 等价，所以它们都是可串行化的调度。这种类型的可串行化被称为<strong>冲突可串行化</strong> ( <span  class="math">\(conflict\;serializability\)</span> ) 。冲突可串行调度中所有冲突操作的执行次序与其在某些串行调度中的执行次序相同。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;冲突可串行化的检测，在限定写规则下，总能产生一个<strong>优先图</strong> ( <span  class="math">\(precedence\;graph\)</span> ) 或称<strong>串行化图</strong> ( <span  class="math">\(serialization\;graph\)</span> )，用于检测调度是否为冲突可串行的。对于调度 <span  class="math">\(S\)</span> ，其优先图是一个有向图 <span  class="math">\(G = (N, E)\)</span>，<span  class="math">\(G\)</span> 由节点的集合 <span  class="math">\(N\)</span> 和有向边的集合 <span  class="math">\(E\)</span> 构成，构造方法如下：</p>

<ul>
<li>为每个事务创建一个节点,</li>
<li>如果 <span  class="math">\(T_j\)</span> 读取了由 <span  class="math">\(T_i\)</span> 修改的数据项的值，则创建有向边 <span  class="math">\(T_i \rightarrow T_j\)</span>,</li>
<li>如果 <span  class="math">\(T_j\)</span> 对 <span  class="math">\(T_i\)</span> 已经读取的数据项执行写操作，则创建有向边 <span  class="math">\(T_i \rightarrow T_j\)</span>,</li>
<li>如果 <span  class="math">\(T_j\)</span> 对 <span  class="math">\(T_i\)</span> 已经修改的数据项执行了写操作，则创建有向边 <span  class="math">\(T_i \rightarrow T_j\)</span>.</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果存在 <span  class="math">\(T_i \rightarrow T_j\)</span> 的边，则在任何与 <span  class="math">\(S\)</span> 等价的串行调度中， <span  class="math">\(T_i\)</span> 都必须出现在 <span  class="math">\(T$_j\)</span> 之前。如果 <span  class="math">\(S\)</span> 中有环存在，则调度非冲突可串行。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设调度中每一个事务都不失败，则可串行化就标识出那些能够维护数据库一致性的调度。从另一方面看，我们还需对调度中的事务的可恢复性进行分析。如果事务失败，事务的原子性要求我们必须撤销事务对数据库造成的所有影响。而持久性要求一旦提交后，事务对数据库的所有修改不能被撤销。<strong>可恢复调度</strong> ( <span  class="math">\(Recoverable\;schedule\)</span> ) 指的是如果 <span  class="math">\(T_j\)</span> 读取了由 <span  class="math">\(T_i\)</span> 修改过的数据项，那么事务 <span  class="math">\(T_i\)</span> 的提交操作应该在事务 <span  class="math">\(T_j\)</span> 的提交操作之前。若调度中的每一对事务 <span  class="math">\(T_i\)</span> 和 <span  class="math">\(T_j\)</span> 都能满足上述要求，则该调度称为可恢复调度。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;串行化可以通过多种方法实现。允许事务安全地并发执行并且满足某些约束的并发控制技术主要有两种：加锁和时间戳方法。这两个方法本质上是<strong>保守</strong> ( <span  class="math">\(conservative\)</span> )/<strong>悲观</strong> ( <span  class="math">\(pessimistic\)</span> ) 方法。相反的，也存在<strong>乐观</strong> ( <span  class="math">\(optimistic\)</span> ) 方法，但都基于冲突出现的概率很小的前提下。</p>

<h3 id="23-加锁方法">2.3 加锁方法</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>加锁</strong> ( <span  class="math">\(Locking\)</span> ) 用来控制并发访问数据的过程。当一个事务正在访问数据库时，可以用锁拒绝其他事务的访问请求，从而避免产生不正确的结果。加锁是使用最广泛的、能够保证并发事务可串行化的方法。基本特征是在事务对数据库进行读写操作时必须获取一个<strong>共享</strong> ( <span  class="math">\(shared\)</span> ) （读）锁或者<strong>互斥</strong> ( <span  class="math">\(exclusive\)</span> ) （写）锁。<strong>锁</strong> ( <span  class="math">\(Lock\)</span> ) 可以阻止其他事务修改该事务正在操作的数据项。如果在数据上加了共享锁，则事务只能读不能写。如果事务在数据项上加了互斥锁，则事务可以读写。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有的数据项，包括数据库，都能被加锁。数据项的范围决定了锁的细度，即<strong>粒度</strong> ( <span  class="math">\(granularity\)</span> )。多个事务可以同时拥有同一数据项的共享锁。但当一个事务拥有了互斥锁时，其他事务都无法对数据进行读写。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了保证可串行化，必须遵循<strong>两段锁</strong> ( <span  class="math">\(two-Phase\;phase\)</span>, <span  class="math">\(2PL\)</span> ) 协议。<code>2PL</code>要求事务中所有的加锁操作都出现在第一个解锁操作之前。根据该规则，每个事务可以分为两个阶段：<strong>扩展阶段</strong> ( <span  class="math">\(growing\;phase\)</span> ) 和<strong>收缩阶段</strong> ( <span  class="math">\(shrinking\;phase\)</span> )。在扩展阶段，事务可以获取全部需要的锁，不能释放锁。在收缩阶段，事务可以释放所有锁，不能获取锁。从共享锁<strong>升级</strong> ( <span  class="math">\(upgrade\)</span> ) 为互斥锁必须进行在扩展阶段，从互斥锁<strong>降级</strong> ( <span  class="math">\(downgrade\)</span> ) 为共享锁必须进行在收缩阶段。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当存在多个事务之间互相相关，即之前事务中修改的某个值要用于之后的事务时，由于一个事务引发的一连串回滚的现象被称为<strong>级联回滚</strong> ( <span  class="math">\(cascading\;rollback\)</span> )。级联回滚意味着大量的工作被撤销，因此需要设计一种协议进行避免。在<code>2PL</code>中，可以通过将收缩阶段放在事务的最后，这种方式称为<strong>严格</strong> ( <span  class="math">\(rigorous\)</span> ) <code>2PL</code>。若事务遵循严格<code>2PL</code>，则事务按其提交的顺序被串行化。<strong>弱严格</strong> ( <span  class="math">\(Strict\)</span> ) <code>2PL</code>是<code>2PL</code>的另一种变形，只要求互斥锁在最后释放。大多数数据库系统实现的是这两种中的一种。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一种与加锁机制有关的问题即<strong>死锁</strong> ( <span  class="math">\(deadlock\)</span> ) 问题。如果两个事务互相等待对方持有的数据项上的锁，则会产生死锁问题。事务也可能处于<strong>活锁</strong> ( <span  class="math">\(livelock\)</span> ) 状态，即未出现死锁仍无限等待的状态。这时等待算法不公平产生的问题，可以通过优化优先级系统解决。</p>

<h3 id="24-死锁">2.4 死锁</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;死锁是两个（或多个）事务互相等待对方释放自己已经占有的锁。一旦发生死锁，相关应用程序并不能解决。唯一一种打破死锁的方法就是撤销其中一个或者多个事务。常用的死锁处理技术有三种：超时、死锁预防与死锁检测和修复。</p>

<h4 id="241-超时">2.4.1 超时</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>超时</strong> ( <span  class="math">\(Timeouts\)</span> ) 是指每个请求加锁的事务的等待时间都有一个上限。如果在这个上限时间内没有获得锁，则请求超时，事务会被撤销，并自动重启。</p>

<h4 id="242-死锁预防">2.4.2 死锁预防</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>死锁预防</strong> ( <span  class="math">\(Deadlock\;prevention\)</span> ) 是指<code>DBMS</code>总是提前判断是否有事务会引发死锁，与其他方法相比，它的难度要大得多。这种方法为每个事务加上了时间戳。有两种死锁预防算法。第一种为 <span  class="math">\(Wait-Die\)</span> ，它只允许一个较老的事务等待一个较新的事务，否则事务被撤销，以相同的时间戳启动。最终该事务会变成最老的事务，并且不会再被撤销。第二种算法是 <span  class="math">\(Wound-Wait\)</span> ，它只允许一个较新的事务等待一个较老的事务，否则新事物会被撤销。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>保守的</strong> ( <span  class="math">\(conservative\)</span> ) <code>2PL</code>也能预防死锁。事务在开始时必须获得全部锁，否则就进入等待状态。但问题是事务在启动前并不能知道要获取哪些锁，因此该协议没有得到应用。</p>

<h4 id="243-死锁检测">2.4.3 死锁检测</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>死锁检测</strong> ( <span  class="math">\(Deadlock\;detection\)</span> ) 是指<code>DBMS</code>允许死锁，但是能够发现和打破死锁。死锁检测通常通过构造显示事务之间依赖关系的<strong>等待图</strong> ( <span  class="math">\(Wait-For\;Graph\)</span>, <span  class="math">\(WFG\)</span> ) 进行。<code>WFG</code>是一个有向图 <span  class="math">\(G = (N, E)\)</span> ，由一组节点和一组有向边构成。构造规则如下：</p>

<ul>
<li>为每个事务创建一个节点</li>
<li>如果事务 <span  class="math">\(T_i\)</span> 等待对某数据项加锁，而该数据项当前已被 <span  class="math">\(T_j\)</span> 加锁，则创建一条有向边 <span  class="math">\(T_i \rightarrow T_j\)</span> 。</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当且仅当<code>WFG</code>中有环时才会发生死锁。死锁检测算法可以周期性地生成等待图并检测环的存在。周期可以固定，也可以动态设置：当未检测到死锁时，周期增大，反之减小。</p>

<h3 id="25-数据项的粒度">2.5 数据项的粒度</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;粒度指的是受到保护的数据项的大小，是并发控制协议中受到保护的基本单位。粗粒度是指较大数据项，细粒度是指比较小的数据项。数据项的粒度越粗，并发程度越低。另一方面，粒度越细，则锁的信息越多。最佳大小应根据事务性质决定。</p>

<h4 id="251-粒度的层次">2.5.1 粒度的层次</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以用层次结构表示锁的粒度。</p>

<p><figure><img src="/image/2020-06-13-4.png" alt="加锁的层次图"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个节点代表一种数据项的大小，根节点代表整个数据库。当一个节点被加锁时，其所有子节点都被锁住。通过层次图，<code>DBMS</code>可以清除地知道能不能满足某一事务的加锁请求。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了减少对子孙节点加锁情况的搜索，<code>DBMS</code>采用另外一种称为<strong>多粒度加锁</strong> ( <span  class="math">\(multiple-granularity\;locking\)</span> ) 的专门的加锁策略。该策略使用了<strong>意向锁</strong> ( <span  class="math">\(intention\;lock\)</span> )。当一个节点被加锁时，该节点的所有祖先节点就都被加了意向锁。意向锁可以是共享的或者互斥的。另外，事务也可以拥有共享意向互斥锁，这与同时拥有一个共享锁和一个意向互斥锁在逻辑上是等价的，与所有共享锁和意向互斥锁冲突的锁冲突。</p>

<h2 id="3-数据库恢复">3. 数据库恢复</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>数据库恢复</strong> ( <span  class="math">\(Database\;recovery\)</span> ) 指的是在发生故障时，将数据库还原到正确状态的过程。</p>

<h3 id="31-恢复的必要性">3.1 恢复的必要性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常有四种存储介质：主存、磁盘、磁带和光盘。主存是<strong>易失性</strong> ( <span  class="math">\(volatile\)</span> ) 存储器，若系统崩溃，则数据会丢失。磁盘属于<strong>联机非易失</strong> ( <span  class="math">\(online\;nonvolatile\)</span> ) 存储器。但是与主存相比，速度要慢。磁带是一种<strong>非联机非易失</strong> ( <span  class="math">\(offline\;nonvolatile\)</span> ) 存储介质，但只能串行访问。光盘比磁带更可靠，而且能随机访问。主存通常被称为<strong>一级存储器</strong> ( <span  class="math">\(primary\;storage\)</span> )，磁盘和磁带通常被称为<strong>二级存储器</strong> ( <span  class="math">\(secondary\;storage\)</span> )。<strong>稳定存储</strong> ( <span  class="math">\(Stable\;storage\)</span> ) 是指已被复制到许多非易失的、具有独立故障模式的存储介质（通常指磁盘）上的信息。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;影响数据库处理的故障有许多种，每一种故障的处理方法都不同。故障的原因包括：</p>

<ul>
<li><strong>系统崩溃</strong> ( <span  class="math">\(System\;crashes\)</span> )。由于硬件或软件错误产生的系统崩溃将导致主存中的数据丢失。</li>
<li><strong>介质故障</strong> ( <span  class="math">\(Media\;failures\)</span> )。比如磁头损坏盘片或者介质不可读。介质故障将导致二级存储器的数据丢失。</li>
<li><strong>应用软件错误</strong> ( <span  class="math">\(application\;software\;errors\)</span> )。比如访问数据库的程序中的逻辑错误。这一类错误将导致一个或者多个事务失败。</li>
<li><strong>自然物理灾害</strong> ( <span  class="math">\(natural\;physical\;disasters\)</span> )。</li>
<li><strong>疏忽</strong> ( <span  class="math">\(carelessness\)</span> )。操作人员或者用户无心造成的数据或者设备的破坏。</li>
<li><strong>蓄意破坏</strong> ( <span  class="math">\(sabotage\)</span> )。</li>
</ul>

<h3 id="32-事务和恢复">3.2 事务和恢复</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务是数据库系统进行恢复的基本单位。故障发生时，由恢复管理器负责保证事务 <code>ACID</code> 特性中的原子性和持久性。恢复管理器必须保证在故障恢复之后，某事务的操作要么全部都被永久记录，要么全部不记。由于写非原子操作，因此可能会出现事务已经提交但未记录的情况。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库缓冲区位于内存，用于在内存和二级存储器之间传输数据。只有缓冲区的数据被<strong>刷新</strong> ( <span  class="math">\(flushed\)</span> ) 到二级存储器中，更新操作才被视为是永久性的。缓冲区到二级存储器的显示写被称为<strong>强制写</strong> ( <span  class="math">\(force-writing\)</span> )。如果在写缓冲区和将缓冲区数据写到二级存储器之间发生了故障，恢复管理器必须确定当前正在执行写操作事务的状态。如果事务已提交，则为了持久性，恢复管理器必须<strong>重做</strong> ( <span  class="math">\(redo\)</span> ) 该事务对数据的所有修改操作，也称为<strong>向前滚</strong> ( <span  class="math">\(rollforward\)</span> )。另一方面，如果事务未提交，则恢复管理器必须<strong>撤销</strong> ( <span  class="math">\(undo\)</span> ) 即<strong>回滚</strong> ( <span  class="math">\(rollback\)</span> ) 该事务已做的修改，以保证事务的原子性。如果只有一个事务需要撤销，则称为<strong>部分撤销</strong> ( <span  class="math">\(partial\;undo\)</span> )。当所有活跃的事务都必须被撤销时，称为<strong>全局撤销</strong> ( <span  class="math">\(global\;undo\)</span> )。</p>

<h3 id="33-恢复机制">3.3 恢复机制</h3>

<ul>
<li>备份机制：周期性地对数据库进行备份</li>
<li>日志机制：跟踪当前事务的状态与数据库的变化</li>
<li>检查点机制：能够保证正在进行的对数据库的更新操作的永久性</li>
<li>恢复管理器：能够使得数据库在故障以后仍能恢复到一个一致的状态。</li>
</ul>

<h4 id="331-备份机制">3.3.1 备份机制</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库的备份可以在数据库被损坏或者被毁坏时使用。备份可以是对整个数据库的复制，也可以是递增备份，只包含最近一次完全备份或者递增备份以后被修改的数据。</p>

<h4 id="332-日志文件">3.3.2 日志文件</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>日志</strong> ( <span  class="math">\(Log\)</span> )，也称为<strong>日记</strong> ( <span  class="math">\(journal\)</span> ) 或<strong>流水账</strong>，其中记录了对数据库的所有更新信息。日志可能包含下列数据：</p>

<ul>
<li><strong>事务记录</strong> ( <span  class="math">\(Transaction\;record\)</span> )

<ul>
<li>事务标识符</li>
<li>日志记录的类型（事务开始、插入、更新、删除、撤销、提交）</li>
<li>对数据库的操作所影响到的数据项的标识符</li>
<li>数据项的<strong>前像</strong> ( <span  class="math">\(before-image\)</span> )，即数据项被修改之前的值（更新和删除操作）</li>
<li>数据项的<strong>后像</strong> ( <span  class="math">\(after-image\)</span> )，即数据项被修改以后的值（插入和更新操作）</li>
<li>日志管理信息，比如指向某事务的前一条或下一条日志记录的指针</li>
</ul></li>
<li><strong>检查点记录</strong> ( <span  class="math">\(Checkpoint\;record\)</span> )</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了帮助系统进行恢复以外，日志还可以用于性能监测和审计。在这种情况下，需要在日志文件中添加额外信息（数据库读、用户登录、注销等）。</p>

<p><figure><img src="/image/2020-06-13-5.png" alt="某日志文件的一段"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于事务的日志文件的重要性，日志需要成倍的复制。在某些情况下，每天会产生大量的日志信息，因此不可能总是将所有日志信息都联机保存。对于较小的故障恢复，可以将日志联机保存。对于较大的故障，需要访问大量日志文件，可以等待脱机存储介质的日志文件读到联机存储介质上。一种处理日志文件脱机存储的方法是，将联机的日志文件分成两个独立的随机访问文件。日志记录被写入第一个文件，直到某个上限，比如总信息量的 $70\%$ 。然后打开第二个文件，将新事务的所有日志记录都写入该文件，并写到脱机存储介质上。这种方法简化了对单个事务恢复的处理，该事务的所有日志记录要么都在联机存储介质上，要么都在脱机存储介质上。写日志文件的速度对于整个数据库系统的性能至关重要。</p>

<h4 id="333-检查点">3.3.3 检查点</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据日志文件中的信息，在数据库发生故障时进行恢复。在应用这种机制时的一个难点是：当故障发生时，我们不知道在日志文件中向前搜索多远才可以不用重做那些已经安全地写到数据库的事务。为了限制搜索范围以及对日志文件进行后续处理的工作量，我们采用了一种称为<strong>检查点</strong> ( <span  class="math">\(checkpointing\)</span> ) 的技术。检查点是数据库与事务日志文件之间的同步点，在该点上所有的缓冲区都被强制写到二级存储器。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DBMS</code>在预定义的时刻设置检查点，并执行以下操作：</p>

<ul>
<li>将内存中的所有日志记录写到二级存储器。</li>
<li>将数据库缓冲区中所有被修改过的块写到二级存储器。</li>
<li>将一个检查点记录写到日志文件。该记录包含所有在检查点时刻活跃事务的标识符。</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若事务串行执行，当故障发生时，检查日志文件，找到在最近一个检查点前启动的最后一个事务。之后，重做在检查点时刻活跃以及在该事务之后启动并且其开始和提交记录都出现在日志中的那些事务。如果当故障发生时，一个事务仍处于活跃状态，则该事务必须被撤销。如果事务并发执行，那么应该重做所有在最近检查点以后提交的事务，并且撤销所有在故障发生时仍处于活跃状态的事务。</p>

<h3 id="34-恢复技术">3.4 恢复技术</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恢复程序的执行依赖于数据库受损的程度。有两种情况：</p>

<ul>
<li>如果数据库遭到了很严重损毁，比如磁头损坏，则除了近期副本之外，还要利用日志文件重做更新操作。</li>
<li>如果数据库没有受到物理损坏，但是处于不一致状态，比如在事务执行过程中系统崩溃，则必须撤销引发不一致的修改操作。可能还有必要重做某些事物，以确保这些事务的更新操作都能被存储到二级存储器。在这里，无需使用副本，只需要使用日志文件中的前像和后像即可。</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对第二种情况的技术有两种：<strong>延迟修改</strong> ( <span  class="math">\(deferred\;update\)</span> ) 和<strong>立即修改</strong> ( <span  class="math">\(immediate\;update\)</span> )。此外还有一种称为<strong>影像页</strong> ( <span  class="math">\(shadow\;paging\)</span> ) 的技术。</p>

<h4 id="341-采用延迟修改的恢复技术">3.4.1 采用延迟修改的恢复技术</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用延迟修改恢复协议时，直到事务提交以后，修改结果才会被写到数据库。然而，对已提交事务的修改操作有必要重做，因为这些修改可能还未被写入数据库。在这种情况下，按下述方式可利用日志文件恢复系统故障：</p>

<ul>
<li>当事务启动时，写入事务开始</li>
<li>执行任何一个写操作时，先写日志记录，包括之前说过的日志数据。此时修改结果并未写入缓冲区或者数据库。</li>
<li>当事务提交时，写入事务提交，先将所有日志记录写到磁盘，然后提交。</li>
<li>当事务撤销时，不写入事务记录。</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当故障发生时，需要检查日志文件，找到故障发生时正在执行的所有事务。从最后一项开始回溯到最近一个检查点记录：</p>

<ul>
<li>重做所有出现了事务开始和事务提交的事务。</li>
<li>对所有出现了事务开始和事务撤销的事务，不执行任何操作。</li>
</ul>

<h4 id="342-影像页技术">3.4.2 影像页技术</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;影像页在事务的生存期中维持了两张页表：当前页表和影像页表。当事务启动时，两张页表相同。此后，影像页表不再变化，用于在系统故障时恢复数据库。在事务执行过程中，当前页表记录数据库的更新，完成后转化为影像页表。与日志相比，它不用维持日志文件，无需撤销或者重做，而且恢复速度也很快。然而它也有缺点，比如数据分裂以及需要周期性地进行无用单元回收，以回收那些不再被访问的块。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Jun 13 17:55</span> <a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F9%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/">数据库系统（8）：规范化</a></h1>
            </center>
            <div class="post-content">
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>规范化</strong> ( <span  class="math">\(Normalization\)</span> ) 是一种数据库设计技术，从分析属性之间的联系入手。规范化使用一系列测试，描述为<strong>范式</strong> ( <span  class="math">\(normal\;forms\)</span> ) 帮助我们确定这些属性的最佳组合，最终生成一组适当关系。</p>

<h2 id="1-目的">1. 目的</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规范化的目的是确定一组合适的关系以支持企业的数据需求。该关系具有以下性质：</p>

<ul>
<li>属性的个数最少，且是必需的</li>
<li>具有紧密逻辑联系，描述为<strong>函数依赖</strong> ( <span  class="math">\(functional\;dependency\)</span> ) 的所有属性均在一个关系中</li>
<li>最少的冗余，即每个属性仅出现一次，除了作为外键的属性，因为连接相关关系必须用到外键</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具有一组合适的关系，数据库会易于用户访问，数据易于维护，在计算机上也会占有较小的存储空间。</p>

<h2 id="2-支持">2. 支持</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规范化有两种使用方法。方法 $1$ 将规范化视为一种<strong>自下而上</strong> ( <span  class="math">\(bottom-up\)</span> ) 的独立的数据库设计技术。方法 <span  class="math">\(2\)</span> 将规范化作为一种确认技术使用，即用规范化检验关系的结构，而这些关系的建立可能采用自上而下的方法，如<code>ER</code>建模等。</p>

<h2 id="3-数据冗余与更新异常">3. 数据冗余与更新异常</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系数据库设计的一个目的就是将属性组合成关系时保证最少的数据冗余。当然，关系数据库的运行也依赖于一定的数据冗余的存在，一般是以主键或者候选键的多个副本的形式出现，作为外键表示数据间联系。存在冗余数据的关系可能存在一些问题，如<strong>更新异常</strong> ( <span  class="math">\(update\;anomalies\)</span> )。更新异常又可分为插入异常、删除异常和修改异常。</p>

<p><figure><img src="/image/2020-05-22-1.png" alt="存在数据冗余的表"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Staff\)</span> 和 <span  class="math">\(Branch\)</span> 是不存在数据冗余的两个表。<span  class="math">\(StaffBranch\)</span> 是将上两个表合起来的存在数据冗余的表，同一个分公司的信息会重复出现。</p>

<h3 id="31-插入异常">3.1 插入异常</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入异常主要有两类：</p>

<ul>
<li>在向 <span  class="math">\(StaffBranch\)</span> 中插入新员工时，若同一家分公司信息不同，则会产生一致性问题；</li>
<li>在向 <span  class="math">\(StaffBranch\)</span> 中插入新的分公司时，由于没有员工，因此员工信息都应设为 <span  class="math">\(null\)</span> 。但是主键 <span  class="math">\(staffNo\)</span> 不能为空，否则会违反实体完整性约束。</li>
</ul>

<h3 id="32-删除异常">3.2 删除异常</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 <span  class="math">\(StaffBranch\)</span> 中删除元组时，若该元组中的员工信息是某个分公司的最后的员工，则该分公司的信息也会被删除。</p>

<h3 id="33-修改异常">3.3 修改异常</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当要修改 <span  class="math">\(StaffBranch\)</span> 中某个分公司的属性值时，必须依次修改所有包含该分公司信息的元组。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述的所有问题都可以通过将 <span  class="math">\(StaffBranch\)</span> 分为 <span  class="math">\(Staff\)</span> 和 <span  class="math">\(Branch\)</span> 来解决，即把较大的关系分为较小的关系。这时有两个重要特性：</p>

<ul>
<li><strong>无损连接</strong> ( <span  class="math">\(lossless-join\)</span> ) ：该特性确保了原关系的任意实例信息能够通过较小关系的对应实例确定；</li>
<li><strong>依赖保持</strong> ( <span  class="math">\(dependency\;preservation\)</span> ) ：该特性确保了只需简单地在较小的关系上支持约束，就可以继续支持原关系的约束。即不需要连接操作就可以判断是否符合原关系的约束。</li>
</ul>

<h2 id="4-函数依赖">4. 函数依赖</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数依赖描述了属性之间的联系。</p>

<h3 id="41-特征">4.1 特征</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有一关系模式，具有属性 (<span  class="math">\(A\)</span>, <span  class="math">\(B\)</span>, <span  class="math">\(C\)</span>,..., <span  class="math">\(Z\)</span>) ，我们使用<strong>全域关系</strong> ( <span  class="math">\(universal\;relation\)</span> ) <span  class="math">\(R\)</span> = ( <span  class="math">\(A\)</span>, <span  class="math">\(B\)</span>, <span  class="math">\(C\)</span>,..., <span  class="math">\(Z\)</span> ) 来描述数据库。函数依赖描述一个关系中属性之间的联系，若 <span  class="math">\(A\)</span> 的每个值都和 <span  class="math">\(B\)</span> 中的一个唯一的值相对应，则称 <span  class="math">\(B\)</span> 函数依赖于 <span  class="math">\(A\)</span> ，记为 <span  class="math">\(A \rightarrow B\)</span> ( <span  class="math">\(A\)</span>, <span  class="math">\(B\)</span> 可能由一个或者多个属性组成 )。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数依赖是属性在关系中的一种语义特性，表明属性和属性之间是如何关联起来的。当存在某一函数依赖时，这个依赖就被视为属性之间的一种约束。当 <span  class="math">\(B\)</span> 函数依赖于 <span  class="math">\(A\)</span> 时，对于 <span  class="math">\(A\)</span> 的每一个值，都有唯一的 <span  class="math">\(B\)</span> 的值与之对应。因此当两个元组 <span  class="math">\(A\)</span> 的值相等时，它们 <span  class="math">\(B\)</span> 的值也一定相等。但是反过来，当它们 <span  class="math">\(B\)</span> 的值相等时，<span  class="math">\(A\)</span> 的值却不一定相等，因为不同的 <span  class="math">\(A\)</span> 的值可以对应同一个 <span  class="math">\(B\)</span> 的值。因此也可以把 <span  class="math">\(B\)</span> 函数依赖于 <span  class="math">\(A\)</span> 称为 <span  class="math">\(A\)</span> 函数决定 <span  class="math">\(B\)</span> ，<span  class="math">\(A\)</span> 称为<strong>决定方</strong> ( <span  class="math">\(determinant\)</span> )。</p>

<p><figure><img src="/image/2020-05-22-2.png" alt="函数依赖和函数决定"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在确定一个关系中属性之间的函数依赖时，必须明确它是仅当属性取某一特定值时成立还是属性取集合中任意值时成立，即函数依赖是关系模式的性质还是某个实例的性质，如果是前者，称为<strong>恒成立</strong> ( <span  class="math">\(holds\;for\;all\;time\)</span> ) 函数依赖 。当决定方具有的属性是保证右边属性的函数依赖于它所必不可少的属性时，我们称之为<strong>完全函数依赖</strong> ( <span  class="math">\(full\;functional\;dependency\)</span> )。否则，称为部分函数依赖。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规范化时要用到的函数依赖具有下列性质：</p>

<ul>
<li>函数依赖左边的属性与右边属性是一对一的联系（反过来可以是一对一，也可以是一对多）；</li>
<li>恒成立</li>
<li>完全函数依赖</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，还有一种函数依赖称为<strong>传递依赖</strong> ( <span  class="math">\(transitive\;dependency\)</span> )。若 <span  class="math">\(A \rightarrow B\)</span>，<span  class="math">\(B \rightarrow C\)</span> ，则 <span  class="math">\(C\)</span> 通过 <span  class="math">\(B\)</span> 传递依赖于 <span  class="math">\(A\)</span> （假设 <span  class="math">\(A\)</span> 并不函数依赖于 <span  class="math">\(B\)</span> 或 <span  class="math">\(C\)</span> ）。若关系中存在传递依赖，可能引起更新异常。</p>

<h3 id="42-识别">4.2 识别</h3>

<table>
<thead>
<tr>
<th align="center"><span  class="math">\(A\)</span></th>
<th align="center"><span  class="math">\(B\)</span></th>
<th align="center"><span  class="math">\(C\)</span></th>
<th align="center"><span  class="math">\(D\)</span></th>
<th align="center"><span  class="math">\(E\)</span></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><span  class="math">\(a\)</span></td>
<td align="center"><span  class="math">\(b\)</span></td>
<td align="center"><span  class="math">\(z\)</span></td>
<td align="center"><span  class="math">\(w\)</span></td>
<td align="center"><span  class="math">\(q\)</span></td>
</tr>

<tr>
<td align="center"><span  class="math">\(e\)</span></td>
<td align="center"><span  class="math">\(b\)</span></td>
<td align="center"><span  class="math">\(r\)</span></td>
<td align="center"><span  class="math">\(w\)</span></td>
<td align="center"><span  class="math">\(p\)</span></td>
</tr>

<tr>
<td align="center"><span  class="math">\(a\)</span></td>
<td align="center"><span  class="math">\(d\)</span></td>
<td align="center"><span  class="math">\(z\)</span></td>
<td align="center"><span  class="math">\(w\)</span></td>
<td align="center"><span  class="math">\(t\)</span></td>
</tr>

<tr>
<td align="center"><span  class="math">\(e\)</span></td>
<td align="center"><span  class="math">\(d\)</span></td>
<td align="center"><span  class="math">\(r\)</span></td>
<td align="center"><span  class="math">\(w\)</span></td>
<td align="center"><span  class="math">\(q\)</span></td>
</tr>

<tr>
<td align="center"><span  class="math">\(a\)</span></td>
<td align="center"><span  class="math">\(f\)</span></td>
<td align="center"><span  class="math">\(z\)</span></td>
<td align="center"><span  class="math">\(s\)</span></td>
<td align="center"><span  class="math">\(t\)</span></td>
</tr>

<tr>
<td align="center"><span  class="math">\(e\)</span></td>
<td align="center"><span  class="math">\(f\)</span></td>
<td align="center"><span  class="math">\(r\)</span></td>
<td align="center"><span  class="math">\(s\)</span></td>
<td align="center"><span  class="math">\(t\)</span></td>
</tr>
</tbody>
</table>

<ol>
<li>当 <span  class="math">\(A\)</span> 为 <span  class="math">\(a\)</span> 时，<span  class="math">\(C\)</span> 就为 <span  class="math">\(z\)</span> ；当 <span  class="math">\(A\)</span> 为 <span  class="math">\(e\)</span> 时，<span  class="math">\(C\)</span> 就为 <span  class="math">\(r\)</span> 。因此 <span  class="math">\(A \rightarrow C\)</span> ，也可以说 <span  class="math">\(C \rightarrow A\)</span> ；</li>
<li>同理，<span  class="math">\(B \rightarrow D\)</span> ， 但是不能说 <span  class="math">\(D \rightarrow B\)</span> ，因为当 <span  class="math">\(D\)</span> 为 <span  class="math">\(w\)</span> 时对应多个 <span  class="math">\(B\)</span> 的值，即 <span  class="math">\(D\)</span> 与 <span  class="math">\(B\)</span> 之间是一对多的联系；</li>
<li><span  class="math">\(E\)</span> 与其他属性的变化都不一致，因此不能函数决定其他属性。但是当 <span  class="math">\(A\)</span> 和 <span  class="math">\(B\)</span> 的取值固定时，<span  class="math">\(E\)</span> 的取值也固定，因此可以说 <span  class="math">\(A, B \rightarrow E\)</span> 。同理 <span  class="math">\(B, C \rightarrow E\)</span> 。</li>
</ol>

<h3 id="43-利用函数依赖确定主键">4.3 利用函数依赖确定主键</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定函数依赖的主要目的时确定该关系必须满足的完整性约束集。首先要考虑的就是候选键。上述的关系的决定方有 <span  class="math">\(A\)</span>, <span  class="math">\(B\)</span>, <span  class="math">\(C\)</span>, <span  class="math">\((A, B)\)</span>, <span  class="math">\((B, C)\)</span> 。综合来看，只有 <span  class="math">\((A, B)\)</span> 和 <span  class="math">\((B, C)\)</span> 能够决定其他所有属性，因此它们都是候选键。由于长度一样，因此都可以作为主键。</p>

<h2 id="5-过程">5. 过程</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;规范化的过程包括一系列步骤，每一步都对应着某种具有已知性质的特定范式。最早提出的三个范式为<strong>第一范式</strong> ( <span  class="math">\(1NF\)</span> ) 、<strong>第二范式</strong> ( <span  class="math">\(2NF\)</span> ) 和<strong>第三范式</strong> ( <span  class="math">\(3NF\)</span> ) ，后来又提出了一种增强的第三范式，称为 <span  class="math">\(Boyce-Codd\)</span> <strong>范式</strong> ( <span  class="math">\(BCNF\)</span> ) 。也存在更高层的<strong>第四范式</strong> ( <span  class="math">\(4NF\)</span> ) 和<strong>第五范式</strong> ( <span  class="math">\(5NF\)</span> ) ，但是需要用到的情况相当少。除了第一范式外，这些范式都是基于关系的属性间函数依赖的。对于关系数据模型，在建立关系时只有满足 <span  class="math">\(1NF\)</span> 的需求是必须的，后面其他范式都是可选的。但是为了避免更新异常，通常建议将规范化至少进行到 <span  class="math">\(3NF\)</span> 。</p>

<p><figure><img src="/image/2020-05-22-3.png" alt="范式之间的联系"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>非范式</strong> ( <span  class="math">\(Unnormalized\;Form\)</span>, <span  class="math">\(UNF\)</span> ) 是包含一个或者多个重复组的表。非范式的表格称为<strong>非规范化的表</strong> ( <span  class="math">\(unnormalized\;table\)</span> ) 。在使用范式之前，我们需要将需求先转化为非范式表的形式，然后将其逐渐分解直至满足每一种范式的要求。规范化过程通过使用一系列的关系代数投影对原始关系进行分解，这是一种<strong>无损连接</strong> ( <span  class="math">\(lossless-join\)</span> ) 分解，也称为<em>无损耗</em> ( <span  class="math">\(nonloss-\)</span> ) /<em>无附加</em> ( <span  class="math">\(nonadditive-\)</span> ) 连接分解，即反向使用自然连接操作就可以得到原关系。</p>

<h2 id="6-第一范式">6. 第一范式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属于第一范式的关系的每一行和每一列相交的位置有且仅有一个值。为了将非规范化的表转化为第一范式，我们需要确定并删除表中的重复组。重复组可以是一个属性或者一组属性，包含表中对应关键属性的一个实例时可能出现多个值的属性。通常有两种方法：</p>

<ol>
<li>在含有重复数据的那些行的空白列上输入合适的数据。这种方法通常被看作是对表的<em>平板化</em> ( <span  class="math">\(flattening\)</span> ) 处理；</li>
<li>将重复数据单独移到一个新的关系中，同时也将原来关系中的关键属性复制到这个关系中。</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两种方法都是可行的。但是第一种方法引入了较多的冗余，可能会导致更新异常；第二种方法则创建了更多的关系，降低了冗余，但是需要更多工作。</p>

<h2 id="7-第二范式">7. 第二范式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二范式是满足第一范式的要求并且每个非主键属性都完全函数依赖于主键的关系。第二范式基于完全函数依赖的概念，使用于具有合成键的关系，即主键由两个或两个以上的属性组成。主键仅包含一个属性的关系已经至少是 <span  class="math">\(2NF\)</span> 的。如果存在部分依赖，就要将部分依赖的属性从原关系移到一个新的关系中去，包括这些属性的决定方。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 <span  class="math">\(1NF\)</span> 转化为 <span  class="math">\(2NF\)</span> ，需要先找出所有的函数依赖，利用这些函数依赖来确定主键。再通过确定主键上是否存在部分依赖来验证该关系是否是 <span  class="math">\(2NF\)</span> 。如果非 <span  class="math">\(2NF\)</span> ，则要创建新关系，将存在部份依赖的非主键属性移至其中。</p>

<h2 id="8-第三范式">8. 第三范式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管 <span  class="math">\(2NF\)</span> 的关系比 <span  class="math">\(1NF\)</span> 关系的数据冗余度低，但是仍然存在更新异常的问题，此时的更新异常是由传递依赖引起的。第三范式满足第一范式和第二范式的要求并且所有非主键属性都不传递依赖于主键的关系，即消除 <span  class="math">\(2NF\)</span> 中的传递依赖。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果关系中的所有非主键属性都完全函数依赖于它们的主键，则它们已经是 <span  class="math">\(3NF\)</span> 。而如果除了主键之外还传递依赖于其他属性，那么就要通过分解关系来消除该依赖。</p>

<h2 id="9-一般化定义">9. 一般化定义</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对 <span  class="math">\(2NF\)</span> 和 <span  class="math">\(3NF\)</span> 更一般化的定义中，我们规定：属于任何一个候选键的属性都叫做<em>主属性</em> ( <span  class="math">\(candidate-key\;attribute\)</span> )；提到部份依赖、完全依赖和传递依赖时不仅仅是基于主键，而是基于所有候选键。</p>

<ul>
<li>第二范式是满足第一范式的要求并且每个非主属性都完全函数依赖于任何一个候选键的关系。</li>
<li>第三范式是满足第一范式和第二范式的要求并且没有一个非主属性传递依赖于任何一个候选键的关系。</li>
</ul>

<h2 id="10-bcnf">10. <code>BCNF</code></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Boyce-Codd\)</span> 范式是每个函数依赖的决定方都是候选键的关系。<span  class="math">\(BCNF\)</span> 与 <span  class="math">\(3NF\)</span> 的区别表现在对于一个函数依赖 <span  class="math">\(A \rightarrow B\)</span> ，<span  class="math">\(3NF\)</span> 允许 <span  class="math">\(B\)</span> 是主键属性而 <span  class="math">\(A\)</span> 非候选键。一般情况下 <span  class="math">\(3NF\)</span> 都是 <span  class="math">\(BCNF\)</span> ，但是在一些特殊性情况下会违反，这些情况有：</p>

<ul>
<li>关系中包含两个（或更多个）合成候选键</li>
<li>候选键互相重叠，通常至少都包含一个相同属性</li>
</ul>

<table>
<thead>
<tr>
<th align="left"><span  class="math">\(clientNo\)</span></th>
<th align="left"><span  class="math">\(interviewDate\)</span></th>
<th align="left"><span  class="math">\(interviewTime\)</span></th>
<th align="left"><span  class="math">\(staffNo\)</span></th>
<th align="left"><span  class="math">\(roomNo\)</span></th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><span  class="math">\(CR76\)</span></td>
<td align="left"><span  class="math">\(13-May-14\)</span></td>
<td align="left"><span  class="math">\(10.30\)</span></td>
<td align="left"><span  class="math">\(SG5\)</span></td>
<td align="left"><span  class="math">\(G101\)</span></td>
</tr>

<tr>
<td align="left"><span  class="math">\(CR56\)</span></td>
<td align="left"><span  class="math">\(13-May-14\)</span></td>
<td align="left"><span  class="math">\(12.00\)</span></td>
<td align="left"><span  class="math">\(SG5\)</span></td>
<td align="left"><span  class="math">\(G101\)</span></td>
</tr>

<tr>
<td align="left"><span  class="math">\(CR74\)</span></td>
<td align="left"><span  class="math">\(13-May-14\)</span></td>
<td align="left"><span  class="math">\(12.00\)</span></td>
<td align="left"><span  class="math">\(SG37\)</span></td>
<td align="left"><span  class="math">\(G102\)</span></td>
</tr>

<tr>
<td align="left"><span  class="math">\(CR56\)</span></td>
<td align="left"><span  class="math">\(1-Jul-14\)</span></td>
<td align="left"><span  class="math">\(10.30\)</span></td>
<td align="left"><span  class="math">\(SG5\)</span></td>
<td align="left"><span  class="math">\(G102\)</span></td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系 <span  class="math">\(ClientInterview\)</span> 中有三个候选键 ( <span  class="math">\(clientNo\)</span>, <span  class="math">\(interviewDate\)</span> ), ( <span  class="math">\(staffNo\)</span>, <span  class="math">\(interviewDate\)</span>, <span  class="math">\(interviewTime\)</span> ), ( <span  class="math">\(roomNo\)</span>, <span  class="math">\(interviewDate\)</span>, <span  class="math">\(interviewTime\)</span> ) ，选择 ( <span  class="math">\(clientNo\)</span>, <span  class="math">\(interviewDate\)</span> ) 作为主键，则函数依赖如下所示：</p>

<p><span  class="math">\[
\begin{aligned}
&fd1\quad clientNo, interviewDate \rightarrow interviewTime, staffNo, roomNo\quad\text{(主键)}\\
&fd2\quad staffNo, interviewDate, interviewTime \rightarrow clientNo\quad\text{(候选键)}\\
&fd3\quad roomNo, interviewDate, interviewTime \rightarrow staffNo, clientNo\quad\text{(候选键)}\\
&fd4\quad staffNo, interviewDate \rightarrow roomNo\quad
\end{aligned}
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(fd1\)</span>, <span  class="math">\(fd2\)</span>, <span  class="math">\(fd3\)</span> 都是候选键，而 <span  class="math">\(fd4\)</span> 不是。因此这个关系是 <span  class="math">\(3NF\)</span> ，而非 <span  class="math">\(BCNF\)</span> 。在非 <span  class="math">\(BCNF\)</span> 的关系中可能会出现更新异常。例如当我们要更新 <span  class="math">\(interviewDate\)</span> 为 <span  class="math">\(13-May-14\)</span> ，<span  class="math">\(staffNo\)</span> 为 <span  class="math">\(SG5\)</span> 的行的 <span  class="math">\(roomNo\)</span> 属性时，要同时更新两行，否则就会导致不一致问题。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 <span  class="math">\(3NF\)</span> 转化为 <span  class="math">\(BCNF\)</span> ，必须消除不满足 <span  class="math">\(BCNF\)</span> 的函数依赖。为此，我们可以分解关系，如下：</p>

<table>
<thead>
<tr>
<th align="left"><span  class="math">\(clientNo\)</span></th>
<th align="left"><span  class="math">\(interviewDate\)</span></th>
<th align="left"><span  class="math">\(interviewTime\)</span></th>
<th align="left"><span  class="math">\(staffNo\)</span></th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><span  class="math">\(CR76\)</span></td>
<td align="left"><span  class="math">\(13-May-14\)</span></td>
<td align="left"><span  class="math">\(10.30\)</span></td>
<td align="left"><span  class="math">\(SG5\)</span></td>
</tr>

<tr>
<td align="left"><span  class="math">\(CR56\)</span></td>
<td align="left"><span  class="math">\(13-May-14\)</span></td>
<td align="left"><span  class="math">\(12.00\)</span></td>
<td align="left"><span  class="math">\(SG5\)</span></td>
</tr>

<tr>
<td align="left"><span  class="math">\(CR74\)</span></td>
<td align="left"><span  class="math">\(13-May-14\)</span></td>
<td align="left"><span  class="math">\(12.00\)</span></td>
<td align="left"><span  class="math">\(SG37\)</span></td>
</tr>

<tr>
<td align="left"><span  class="math">\(CR56\)</span></td>
<td align="left"><span  class="math">\(1-Jul-14\)</span></td>
<td align="left"><span  class="math">\(10.30\)</span></td>
<td align="left"><span  class="math">\(SG5\)</span></td>
</tr>
</tbody>
</table>

<p><br/></p>

<table>
<thead>
<tr>
<th align="left"><span  class="math">\(staffNo\)</span></th>
<th align="left"><span  class="math">\(interviewDate\)</span></th>
<th align="left"><span  class="math">\(roomNo\)</span></th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><span  class="math">\(SG5\)</span></td>
<td align="left"><span  class="math">\(13-May-14\)</span></td>
<td align="left"><span  class="math">\(G101\)</span></td>
</tr>

<tr>
<td align="left"><span  class="math">\(SG37\)</span></td>
<td align="left"><span  class="math">\(13-May-14\)</span></td>
<td align="left"><span  class="math">\(G102\)</span></td>
</tr>

<tr>
<td align="left"><span  class="math">\(SG5\)</span></td>
<td align="left"><span  class="math">\(1-Jul-14\)</span></td>
<td align="left"><span  class="math">\(G102\)</span></td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 <span  class="math">\(3NF\)</span> 通过关系分解的形式转化为 <span  class="math">\(BCNF\)</span> 的过程中会丢失某个函数依赖，在上例中是 <span  class="math">\(fd3\)</span> 。如果这并非我们想要的，那么只需要将规范化进行到 <span  class="math">\(3NF\)</span> 即可。是否将关系规范化到 <span  class="math">\(BCNF\)</span> ，取决于是 <span  class="math">\(fd4\)</span> 的数据冗余带来的影响更大还是 <span  class="math">\(fd3\)</span> 丢失带来的影响更大。</p>

            </div>
            <div class="meta post-footer"> <span>2020 May 22 16:13</span> <a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F8%E8%A7%84%E8%8C%83%E5%8C%96/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/">数据库系统（7）：ER模型</a></h1>
            </center>
            <div class="post-content">
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ER</code>模型是一种<strong>自上而下</strong> ( <span  class="math">\(top-down\)</span> ) 的数据库设计方法，该方法首先确定那些被称为实体的重要数据和这些数据之间的联系，实体和联系时<code>ER</code>模式中必备的元素。然后添加更多的细节信息，如属性、约束等。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>统一建模语言</strong> ( <span  class="math">\(Unified\;Modeling\;Language\)</span>, <span  class="math">\(UML\)</span> ) 是软件工程项目的工业标准建模语言，我们使用<code>UML</code>的符号集来绘制<code>ER</code>模型。</p>

<h2 id="1-实体类型">1 实体类型</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>实体类型</strong> ( <span  class="math">\(Entity\;types\)</span> ) 是被企事业单位认可的、能够独立存在的一组具有相同属性的对象，是<code>ER</code>模型的基本概念。实体类型既可以是物理 ( 真实 ) 存在的，也可以是概念 ( 抽象 ) 存在的对象。<strong>实体出现</strong> ( <span  class="math">\(entity\;occurrence\)</span> ) 是实体类型中可唯一标识的一个对象。在没有歧义的时候，实体类型和实体出现都可以直接简称为实体。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>UML</code>中，实体类型通过一个标有名字的矩形标识，每个实体名字的首字母是大写的。</p>

<p><figure><img src="/image/2020-05-21-1.png" alt="实体"></figure></p>

<h2 id="2-联系类型">2. 联系类型</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>联系类型</strong> ( <span  class="math">\(Relationship\;types\)</span> ) 是实体类型间一组有意义的关联。每个联系类型都被赋予一个能够描述其功能的名字。<strong>联系出现</strong> ( <span  class="math">\(Relationship\;occurrence\)</span> ) 是由参与该联系的各个实体类型的一个出现组成的可被唯一标识的关联。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>UML</code>中，每个联系类型都表现为用线将相关的实体类型联系起来，并在线上标上联系的名字，通常使用一个动词或者动词短语命名。同样的，首字母也应该大写。一个联系还要标识方向，意味着这个联系仅在一个方向上有意义。可以在名字旁边添加一个箭头符号，如 <span  class="math">\(\blacktriangleleft\)</span> 来标识方向。当我们要表示 <span  class="math">\(A\;Has\;B\)</span> ( <span  class="math">\(A\)</span>，<span  class="math">\(B\)</span> 为实体，<span  class="math">\(Has\)</span> 为联系类型 ) 时可以用如下方法：</p>

<p><figure><img src="/image/2020-05-21-2.png" alt="联系"></figure></p>

<h3 id="21-联系类型的度">2.1 联系类型的度</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;联系类型的<strong>度</strong> ( <span  class="math">\(degree\)</span> ) 是指参与联系的实体类型的个数。包含在某个联系类型中的实体被看作<strong>参与者</strong> ( <span  class="math">\(participants\)</span> )，参与者的数目就是度。度为 <span  class="math">\(2\)</span> 的联系称为二元联系。上例中的 <span  class="math">\(Has\)</span> 就是一个典型的<strong>二元</strong> ( <span  class="math">\(binary\)</span> ) 联系，该联系的参与者是 <span  class="math">\(A\)</span> 和 <span  class="math">\(B\)</span> 。同理，度为 <span  class="math">\(3\)</span> 的联系称为<strong>三元</strong> ( <span  class="math">\(ternary\)</span> ) 联系。度大于 <span  class="math">\(2\)</span> 的联系称为复杂联系。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在复杂联系中，联系使用一个菱形符号表示，箭头可以省略。</p>

<p><figure><img src="/image/2020-05-21-3.png" alt="复杂联系"></figure></p>

<h3 id="22-递归联系">2.2 递归联系</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>递归联系</strong> ( <span  class="math">\(Recursive\;relationship\)</span> ) 是指同一个实体类型以不同的角色多次参与了同一个联系类型。递归联系有时也叫做<em>一元</em> ( <span  class="math">\(unary\)</span> ) 联系。<strong>角色名称</strong> ( <span  class="math">\(Role\;names\)</span> ) 可以添加在联系上，用于表示每个实体类型在联系中的意义。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实体 <span  class="math">\(Staff\)</span> 表示公司员工，一个主管负责监视员工的同时，他也是公司员工，因此该主管需要自己“监视”自己。第一次参与时的角色名称是 <span  class="math">\(Supervisor\)</span> ，第二次参与时的角色名称是 <span  class="math">\(Supervisee\)</span> 。如下所示：</p>

<p><figure><img src="/image/2020-05-21-4.png" alt="递归联系"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;角色名称并不限于递归联系。如果两个实体间存在多余一种联系时也可以使用角色名称。</p>

<p><figure><img src="/image/2020-05-21-5.png" alt="二元联系中使用角色名称"></figure></p>

<h2 id="3-属性">3. 属性</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性是实体或联系类型所具有的某一特性。<strong>属性域</strong> ( <span  class="math">\(Attribute\;domain\)</span> ) 是单个属性或者多个属性所允许的取值集合。多个属性可以共享一个域。属性可以分为：<em>简单</em> ( <span  class="math">\(simple\)</span> ) 属性和<em>组合</em> ( <span  class="math">\(composite\)</span> ) 属性；<em>单值</em> ( <span  class="math">\(single-valued\)</span> ) 属性和<em>多值</em> ( <span  class="math">\(multi-valued\)</span> ) 属性；<em>导出</em> ( <span  class="math">\(derived\)</span> ) 属性。</p>

<h3 id="31-简单属性和组合属性">3.1 简单属性和组合属性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单属性是指由独立存在的单个部分组成的属性，不能再被划分为更小的部分。简单属性有时也可以称为<em>原子</em> ( <span  class="math">\(atomic\)</span> ) 属性。组合属性是指由多个部分组成的属性，每个部分都可以单独存在。</p>

<h3 id="32-单值属性和多值属性">3.2 单值属性和多值属性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单值属性是在实体类型的每个实例出现中都只取一个单值的属性。多值属性是在实体类型的某些实例出现中可能取多个值的属性。</p>

<h3 id="33-导出属性">3.3 导出属性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;导出属性的属性值是从相关的一个或者一组属性（不一定来自同一个实体类型）的值导出来的属性。</p>

<h3 id="34-键">3.4 键</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;候选键是能够唯一标识每个实体的实例出现的最小属性组。主键是被指定的用于唯一标识每个实体类型的每个实例出现的候选键。合成键是指包含两个或两个以上属性的候选键。</p>

<p><figure><img src="/image/2020-05-21-6.png" alt="属性的图形化表示"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>UML</code>中属性使用驼峰命名法。在属性组里，列出的第一个属性应该是主键，使用 <span  class="math">\(\{PK\}\)</span> 标识。对于合成主键，使用 <span  class="math">\(\{PPK\}\)</span> 标识。可替换键则使用 <span  class="math">\(\{AK\}\)</span> 标识。对于一些复杂数据库系统，把每个实体类型的所有属性都列出来是不可能的。因此只需要列出每个实体的主键，这时可以省略 <span  class="math">\(\{PK\}\)</span> 标识。组合属性需要在下方向右缩进列出子属性名。多值属性要明确属性取值个数的范围，可以使用 <span  class="math">\(*\)</span> 表示 <span  class="math">\(1\)</span> 个或者多个取值。导出属性需要在属性名前加上 <span  class="math">\(/\)</span> 。</p>

<h2 id="4-强实体类型和弱实体类型">4. 强实体类型和弱实体类型</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>强实体类型</strong> ( <span  class="math">\(Strong\;entity\;type\)</span> ) 指存在不依赖于其他类型的实体类型。有时也被称为<em>父</em> ( <span  class="math">\(father\)</span> ) 实体、<em>所有者</em> ( <span  class="math">\(owner\)</span> ) 实体或<em>支配</em> ( <span  class="math">\(dominant\)</span> ) 实体。 相反，<strong>弱实体类型</strong> ( <span  class="math">\(weak\;entity\;type\)</span> ) 指存在依赖于其他类型存在的类型。有时也被称为<em>子</em> ( <span  class="math">\(child\)</span> ) 实体、<em>依赖</em> ( <span  class="math">\(dependent\)</span> ) 实体或者<em>从属</em> ( <span  class="math">\(subordinate\)</span> ) 实体。强实体类型的一个特征是可以使用该实体类型的主键唯一标识每个实体的实例出现，而弱实体类型不能。</p>

<p><figure><img src="/image/2020-05-21-7.png" alt="强实体类型和弱实体类型"></figure></p>

<h2 id="5-联系的属性">5. 联系的属性</h2>

<p><figure><img src="/image/2020-05-21-8.png" alt="联系的属性"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在表示带有属性的联系时，使用虚线连接矩形和联系。一个联系如果拥有一个或者多个属性，那么该联系可能隐蔽着一个未标识的实体类型。</p>

<h2 id="6-结构化约束">6. 结构化约束</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>多重性</strong> ( <span  class="math">\(multiplicity\)</span> ) 指一个参与实体类型通过某一联系与另一个参与实体类型的某个出现发生关联的出现数目，是联系上的主要约束。多重性约束了实体间关联的方式，是用户或企业建立的策略的一种表现方式。最常见的联系的度是二元的，二元又可以分为一对一、一对多和多对多。</p>

<h3 id="61-一对一联系">6.1 一对一联系</h3>

<p><figure><img src="/image/2020-05-21-9.png" alt="一对一联系"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(1..1\)</span> 和 <span  class="math">\(0..1\)</span> 是多重性的体现，分别表示一个 <span  class="math">\(Entity2\)</span> 与一个 <span  class="math">\(Entity1\)</span> 有联系，一个 <span  class="math">\(Entity1\)</span> 可以与零至一个 <span  class="math">\(Entity2\)</span> 有联系。</p>

<h3 id="62-一对多联系">6.2 一对多联系</h3>

<p><figure><img src="/image/2020-05-21-10.png" alt="一对多联系"></figure></p>

<h3 id="63-多对多联系">6.3 多对多联系</h3>

<p><figure><img src="/image/2020-05-21-11.png" alt="多对多联系"></figure></p>

<h3 id="64-复杂联系的多重性">6.4 复杂联系的多重性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复杂联系的多重性是指在一个 <span  class="math">\(n\)</span> 元联系中，其他 <span  class="math">\(n - 1\)</span> 个实体类型的值固定之后，另外一个实体类型可能参与联系的实例出现的个数。如一个三元联系的多重性表示当联系中的某两个参与实体类型的值确定后，剩下的那个参与实体的实例出现可能的个数。</p>

<p><figure><img src="/image/2020-05-21-12.png" alt="复杂联系的多重性"></figure></p>

<table>
<thead>
<tr>
<th align="center">多重性约束的表示方法</th>
<th align="left">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><span  class="math">\(0..3\)</span></td>
<td align="left"><span  class="math">\(0\)</span> 个到 <span  class="math">\(3\)</span> 个实体出现</td>
</tr>

<tr>
<td align="center"><span  class="math">\(0..*\)</span></td>
<td align="left"><span  class="math">\(0\)</span> 个或者多个实体出现</td>
</tr>

<tr>
<td align="center"><span  class="math">\(0\)</span>, <span  class="math">\(3\)</span>, <span  class="math">\(6-8\)</span></td>
<td align="left"><span  class="math">\(0\)</span> 个、<span  class="math">\(3\)</span> 个或者 <span  class="math">\(6\)</span> 到 <span  class="math">\(8\)</span> 个实体出现</td>
</tr>
</tbody>
</table>

<h3 id="65-基数约束和参与性约束">6.5 基数约束和参与性约束</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多重性由两个独立约束组成，<em>基数</em> ( <span  class="math">\(cardinality\)</span> ) 约束和<em>参与性</em> ( <span  class="math">\(participation\)</span> ) 约束。基数是在指定的联系类型中一个实体可能参与的联系出现的最大数目。一个二元联系的基数就是一对一、一对多和多对多。参与性说明所有实体出现是否都参与了联系。对于所有实体出现都参与的，称为<strong>强制</strong> ( <span  class="math">\(mandatory\)</span> ) 参与。否则，称为<strong>可选</strong> ( <span  class="math">\(optional\)</span> ) 参与。实体的参与性实际上就是联系的每一个参与实体的多重性范围的最小值，为 <span  class="math">\(0\)</span> 时就是可选参与，为 <span  class="math">\(1\)</span> 时就是强制参与。</p>

<h2 id="7-er模型的问题">7. <code>ER</code>模型的问题</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建<code>ER</code>模型时可能产生的问题称为<strong>连接陷阱</strong> ( <span  class="math">\(connection\;trap\)</span> )，通常是由于错误地理解了联系的意义引起的。</p>

<h3 id="71-扇形陷阱">7.1 扇形陷阱</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>扇形陷阱</strong> ( <span  class="math">\(fan\;trap\)</span> ) 是指模型给出了两实体类型之间的一种联系，但是在某些实体出现之间存在着多条<em>通路</em> ( <span  class="math">\(pathway\)</span> )。当一个实体有两个或者更多的 <span  class="math">\(1:*\)</span> 的联系时，就存在着扇形陷阱。</p>

<p><figure><img src="/image/2020-05-21-13.png" alt="扇形陷阱示例"></figure>
<figure><img src="/image/2020-05-21-14.png" alt="扇形陷阱示例语义网表示"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图为一个扇形陷阱的例子。在该图中，我们能很简单的找到每个 <span  class="math">\(Staff\)</span> 的实体出现对应的 <span  class="math">\(Division\)</span> ，但是无法找到其对应的 <span  class="math">\(Branch\)</span> 。而为了消除该扇形陷阱，我们需要对该<code>ER</code>模型进行重构。</p>

<p><figure><img src="/image/2020-05-21-15.png" alt="重构消除扇形陷阱"></figure></p>

<h3 id="72-断层陷阱">7.2 断层陷阱</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>断层陷阱</strong> ( <span  class="math">\(chasm\;trap\)</span> ) 指模型表明某些实体类型之间存在联系，但在某些实体出现之间不存在通路的情况。当相关实体的路径上存在着一个或者多个多重性最小值为零的联系时，就会出现断层陷阱。</p>

<p><figure><img src="/image/2020-05-21-16.png" alt="断层陷阱示例"></figure>
<figure><img src="/image/2020-05-21-17.png" alt="示例语义网"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然对于 <span  class="math">\(PropertyForRent\)</span> 中的实体出现 <span  class="math">\(PA14\)</span> ，无法找到对应的 <span  class="math">\(Branch\)</span> 的实体出现。解决方法是添加新联系。</p>

<p><figure><img src="/image/2020-05-21-18.png" alt="重构消除断层陷阱"></figure></p>

            </div>
            <div class="meta post-footer"> <span>2020 May 21 15:51</span> <a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7er%E6%A8%A1%E5%9E%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/">数据库系统（6）：SQL数据定义</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-数据类型">1. 数据类型</h2>

<h3 id="11-标识符">1.1 标识符</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>SQL</code><strong>标识符</strong> ( <span  class="math">\(identifier\)</span> ) 用于表示数据库中的对象，如表名、列名、视图名等。用户定义标识符所用的字符必须是<strong>字符集</strong> ( <span  class="math">\(character\;set\)</span> ) 中存在的。默认的字符集包括 <span  class="math">\(A-Z\)</span>, <span  class="math">\(a-z\)</span> 和 <span  class="math">\(\_\)</span> ，也可以另外指定其他字符集。标识符的限制有：</p>

<ul>
<li>不能长于 <span  class="math">\(128\)</span> 个字符（在一些方言中会更短）</li>
<li>必须以字母开头</li>
<li>不能有空格</li>
</ul>

<h3 id="12-数据类型">1.2 数据类型</h3>

<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">声明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">布尔型</td>
<td align="left"><span  class="math">\(BOOLEAN\)</span></td>
</tr>

<tr>
<td align="left">字符型</td>
<td align="left"><span  class="math">\(CHAR\)</span>, <span  class="math">\(VARCHAR\)</span></td>
</tr>

<tr>
<td align="left">位类型</td>
<td align="left"><span  class="math">\(BIT\)</span>, <span  class="math">\(BIT\;VARYING\)</span></td>
</tr>

<tr>
<td align="left">定点数型</td>
<td align="left"><span  class="math">\(NUMERIC\)</span>, <span  class="math">\(DECIMAL\)</span>, <span  class="math">\(INTEGER\)</span>, <span  class="math">\(SMALLINT\)</span>, <span  class="math">\(BIGINT\)</span></td>
</tr>

<tr>
<td align="left">浮点数型</td>
<td align="left"><span  class="math">\(FLOAT\)</span>, <span  class="math">\(REAL\)</span>, <span  class="math">\(DOUBLE\;PRECISION\)</span></td>
</tr>

<tr>
<td align="left">日期时间型</td>
<td align="left"><span  class="math">\(DATE\)</span>, <span  class="math">\(TIME\)</span>, <span  class="math">\(TIMESTAMP\)</span></td>
</tr>

<tr>
<td align="left">间隔型</td>
<td align="left"><span  class="math">\(INTERVAL\)</span></td>
</tr>

<tr>
<td align="left">大对象型</td>
<td align="left"><span  class="math">\(CHARACTER\;LARGE\;OBJECT\)</span>, <span  class="math">\(BINARY\;LARGE\;OBJECT\)</span></td>
</tr>
</tbody>
</table>

<h4 id="121-布尔型">1.2.1 布尔型</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔型包括 <span  class="math">\(TRUE\)</span> / <span  class="math">\(FALSE\)</span> 两个值，如果没有 <span  class="math">\(NOT\;NULL\)</span> 约束，也可以为 <span  class="math">\(NULL\)</span> 。<span  class="math">\(TRUE\)</span> 大于 <span  class="math">\(FALSE\)</span> ，对于涉及 <span  class="math">\(NULL\)</span> 的比较，结果都是 <span  class="math">\(UNKNOWN\)</span> 。</p>

<h4 id="122-字符型">1.2.2 字符型</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符型数据是由字符集中的字符组成的序列，由方言供应商提供。<span  class="math">\(CHAR\)</span> 为固定长度，当输入字符串小于指定长度时会使用空格补足。<span  class="math">\(VARCHAR\)</span> 为变化长度，只会存储输入的字符，不会补足。</p>

<h4 id="123-位类型">1.2.3 位类型</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;位类型用于定义位字符串，即二进制序列。为了操作方便，有时候会将字符型和位类型合称为字符串型。</p>

<h4 id="124-定点数型">1.2.4 定点数型</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定点数据类型用于定义准确表示的数值。对于 <span  class="math">\(NUMERIC\)</span> 和 <span  class="math">\(DECIMAL\)</span> ，应指定<strong>精度</strong> ( <span  class="math">\(precision\)</span> ) 和 <strong>小数位</strong> ( <span  class="math">\(scale\)</span> ) 。精度为全部位数，小数位为小数部分的位数。</p>

<h4 id="125-浮点数型">1.2.5 浮点数型</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浮点数据类型用于定义非精确的数字，如实数，采用类似于科学计数法的表示方式。为了操作方便，有时会将定点数型和浮点数型合称为数值数据类型。对于 <span  class="math">\(FLOAT\)</span> ，需要指定精度。而 <span  class="math">\(REAL\)</span> 和 <span  class="math">\(DOUBLE\;PRECISION\)</span> 的精度则依赖于具体实现。</p>

<h4 id="126-日期时间型">1.2.6 日期时间型</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日期时间类型用于定义一定精度的时间。<code>ISO</code>标准将日期时间类型分为 <span  class="math">\(YEAR\)</span>, <span  class="math">\(MONTH\)</span>, <span  class="math">\(DAY\)</span>, <span  class="math">\(HOUR\)</span>, <span  class="math">\(MINUTE\)</span>, <span  class="math">\(SECOND\)</span>, <span  class="math">\(TIMEZONE\_HOUR\)</span> 和 <span  class="math">\(TIMEZONE\_MINUTE\)</span> 。后面两个字段指定从<code>GMT</code>时区偏移的小时数和分钟数。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(DATE\)</span> 用于存储 <span  class="math">\(YEAR\)</span>, <span  class="math">\(MONTH\)</span>, <span  class="math">\(DAY\)</span> 。<span  class="math">\(TIME\)</span> 用于存储 <span  class="math">\(HOUR\)</span>, <span  class="math">\(MINUTE\)</span>, <span  class="math">\(SECOND\)</span> 。<span  class="math">\(TIMESTAMP\)</span> 用于存储上述全部。对于 <span  class="math">\(TIME\)</span> 和 <span  class="math">\(TIMESTAMP\)</span> ，需要指定时间精度，即秒的精度。在 <span  class="math">\(TIME\)</span> 和 <span  class="math">\(TIMESTAMP\)</span> 最后可以声明 <span  class="math">\(WITH\;TIME\;ZONE\)</span> ，用于指定 <span  class="math">\(TIMEZONE\_HOUR\)</span> 和 <span  class="math">\(TIMEZONE\_MINUTE\)</span> 。</p>

<h4 id="127-间隔型">1.2.7 间隔型</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;间隔数据类型表示一段时间。每个间隔类型由下列字段的一个连续子集构成：<span  class="math">\(YEAR\)</span>, <span  class="math">\(MONTH\)</span>, <span  class="math">\(DAY\)</span>, <span  class="math">\(HOUR\)</span>, <span  class="math">\(MINUTE\)</span>, <span  class="math">\(SECOND\)</span> 。间隔数据类型分为年-月间隔和天-时间间隔，前者只能包括 <span  class="math">\(YEAR\)</span> 和 <span  class="math">\(MONTH\)</span> ，后者可以从 <span  class="math">\(DAY\)</span>, <span  class="math">\(HOUR\)</span>, <span  class="math">\(MINUTE\)</span>, <span  class="math">\(SECOND\)</span> 中选择连续的一段。声明格式如下</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="nb">INTERVAL</span> <span class="err">{{</span><span class="n">startField</span> <span class="k">TO</span> <span class="n">endField</span><span class="err">}</span> <span class="n">singleDatetimeField</span><span class="err">}</span>

<span class="n">startField</span> <span class="o">=</span> <span class="k">YEAR</span> <span class="o">|</span> <span class="k">MONTH</span> <span class="o">|</span> <span class="k">DAY</span> <span class="o">|</span> <span class="n">HOUR</span> <span class="o">|</span> <span class="k">MINUTE</span> <span class="p">[(</span><span class="n">intervalLeadingFieldPrecision</span><span class="p">)]</span>
<span class="n">endField</span> <span class="o">=</span> <span class="k">YEAR</span> <span class="o">|</span> <span class="k">MONTH</span> <span class="o">|</span> <span class="k">DAY</span> <span class="o">|</span> <span class="n">HOUR</span> <span class="o">|</span> <span class="k">MINUTE</span> <span class="o">|</span> <span class="k">SECOND</span> <span class="p">[(</span><span class="n">fractionalSecondsPrecision</span><span class="p">)]</span>
<span class="n">singleDatetimeField</span> <span class="o">=</span> <span class="n">startField</span> <span class="o">|</span> <span class="k">SECOND</span> <span class="p">[(</span><span class="n">intervalLeadingFieldPrecision</span><span class="p">[,</span> <span class="n">fractionalSecondsPrecision</span><span class="p">])]</span></code></pre></div>
<h4 id="128-大对象型">1.2.8 大对象型</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大对象数据类型用于表示大量数据。<code>SQL</code>可定义三类大对象数据类型：二进制大对象 ( <span  class="math">\(BLOB\)</span> )、字符大对象 ( <span  class="math">\(CLOB\)</span> ) 和自然字符大对象 ( <span  class="math">\(NCLOB\)</span> )，前者为二进制串，后两者都是字符串。</p>

<h2 id="2-完整性增强特性">2. 完整性增强特性</h2>

<p>完整性约束有五种类型：</p>

<ul>
<li>必须有值的数据</li>
<li>域约束</li>
<li>实体完整性</li>
<li>引用完整性</li>
<li>一般性约束</li>
</ul>

<h3 id="21-必须有值的数据">2.1 必须有值的数据</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某些的列的值不允许为空，可以通过 <span  class="math">\(NOT\;NULL\)</span> 指定。若不指定或者指定为 <span  class="math">\(NULL\)</span> ，则接受空。<code>ISO</code>的默认值为 <span  class="math">\(NULL\)</span> 。</p>

<h3 id="22-域约束">2.2 域约束</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一列都有一个域，即合法值的集合。<code>ISO</code>标准在 <span  class="math">\(CREATE\)</span> 和 <span  class="math">\(ALTER\;TABLE\)</span> 中可以使用 <span  class="math">\(CHECK\)</span> 子句对列或者整个表进行约束。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">sex</span> <span class="nb">CHAR</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">CHECK</span><span class="p">(</span><span class="n">sex</span> <span class="k">IN</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">))</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以使用 <span  class="math">\(CREATE\;DOMAIN\)</span> 定义域。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">DOMAIN</span> <span class="n">DomainName</span> <span class="p">[</span><span class="k">AS</span><span class="p">]</span> <span class="n">dateType</span>
<span class="p">[</span><span class="k">DEFAULT</span> <span class="n">defaultOption</span><span class="p">]</span>
<span class="p">[</span><span class="k">CHECK</span> <span class="p">(</span><span class="n">searchCondition</span><span class="p">)]</span>

<span class="k">DROP</span> <span class="k">DOMAIN</span> <span class="n">DomainName</span> <span class="p">[</span><span class="k">RESTRICT</span><span class="o">|</span><span class="k">CASCADE</span><span class="p">]</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(DROP\;DOMAIN\)</span> 用于删除。<span  class="math">\(RESTRICT\)</span> 或 <span  class="math">\(CASCADE\)</span> 指出如果域正在被使用时应采取的行为，<span  class="math">\(RESTRICTION\)</span> 是只有当域未被使用时才能删除，<span  class="math">\(CASCADE\)</span> 则将列的域变为基类型定义。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">DOMAIN</span> <span class="n">SexType</span> <span class="k">AS</span> <span class="nb">CHAR</span>
    <span class="k">DEFAULT</span> <span class="s1">&#39;M&#39;</span>
    <span class="k">CHECK</span><span class="p">(</span><span class="n">VALUE</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">));</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在创建表时进行使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">sex</span> <span class="n">SexType</span> <span class="k">NOT</span> <span class="k">NULL</span></code></pre></div>
<h3 id="23-实体完整性">2.3 实体完整性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表中每一行的主键必须是唯一非空值。<code>ISO</code>标准在 <span  class="math">\(CREATE\)</span> / <span  class="math">\(ALTER\;TABLE\)</span> 中使用 <span  class="math">\(PRIMARY\;KEY\)</span> 支持实体完整性。对于非主键的列，如果要支持唯一性，可以使用 <span  class="math">\(UNIQUE\)</span> 指定。</p>

<h3 id="24-引用完整性">2.4 引用完整性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外键是某个列或者列集合，把包含外键的子表中的每个元组与父表中包含候选键的元组关联起来。外键必须是父表中已存在的有效元组。<code>ISO</code>标准可以在 <span  class="math">\(CREATE\)</span> / <span  class="math">\(ALTER\;TABLE\)</span> 中使用 <span  class="math">\(FOREIGN\;KEY\)</span> 定义外键。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="n">columnList</span><span class="p">)</span>
<span class="k">REFERENCES</span> <span class="n">tableName</span> <span class="p">[</span><span class="k">ON</span> <span class="err">{</span><span class="k">DELETE</span> <span class="o">|</span> <span class="k">UPDATE</span><span class="err">}</span> <span class="err">{</span><span class="k">CASCADE</span> <span class="o">|</span> <span class="k">SET</span> <span class="k">NULL</span> <span class="o">|</span> <span class="k">SET</span> <span class="k">DEFAULT</span> <span class="o">|</span> <span class="k">NO</span> <span class="n">ACTION</span><span class="err">}</span><span class="p">]</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在子表中，如果试图使用 <span  class="math">\(INSERT\)</span> / <span  class="math">\(UPDATE\)</span> 创建与父表的候选键不匹配的外键，则会被拒绝。<span  class="math">\(ON\;DELETE\)</span> / <span  class="math">\(UPDATE\)</span> 子句决定在父表中进行 <span  class="math">\(DELETE\)</span> / <span  class="math">\(UPDATE\)</span> 操作时子表的行为：</p>

<ul>
<li><span  class="math">\(CASCADE\)</span> ：删除/更新父表中的行时会自动删除/更新子表中的列。如果列中的候选键是其他的表的外键，那么会触发级联删除/更新；</li>
<li><span  class="math">\(SET\;NULL\)</span> ：删除/更新父表中的行时会自动设置子表中外键的值为 <span  class="math">\(NULL\)</span> ，但要求外键未指定 <span  class="math">\(NOT\;NULL\)</span> ；</li>
<li><span  class="math">\(SET\;DEFAULT\)</span> ：删除/更新父表中的行时会自动设置子表中外键的值为默认值，但要求外键指定 <span  class="math">\(DEFAULT\)</span> ；</li>
<li><span  class="math">\(NO\;ACTION\)</span> ：拒绝对父表进行删除/更新操作，是 默认规则。</li>
</ul>

<h3 id="25-一般性约束">2.5 一般性约束</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对表的更新可能受到的企业规则的约束。<code>ISO</code>允许使用 <span  class="math">\(CREATE\)</span> / <span  class="math">\(ALTER\;TABLE\)</span> 中的 <span  class="math">\(CHECK\)</span> / <span  class="math">\(UNIQUE\)</span> 以及 <span  class="math">\(CREATE\;ASSERTION\)</span> 指定一般性约束。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">ASSERTION</span> <span class="n">assertionName</span>
<span class="k">CHECK</span><span class="p">(</span><span class="n">searchCondition</span><span class="p">)</span></code></pre></div>
<h2 id="3-数据定义">3. 数据定义</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DDL</code>允许创建和删除数据库对象。主要的数据定义语句为：</p>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">$CREATE$</th>
<th align="center">$ALTER$</th>
<th align="center">$DROP$</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">$SCHEMA$</td>
<td align="center">$\surd$</td>
<td align="center"></td>
<td align="center">$\surd$</td>
</tr>

<tr>
<td align="center">$DOMAIN$</td>
<td align="center">$\surd$</td>
<td align="center">$\surd$</td>
<td align="center">$\surd$</td>
</tr>

<tr>
<td align="center">$TABLE$</td>
<td align="center">$\surd$</td>
<td align="center">$\surd$</td>
<td align="center">$\surd$</td>
</tr>

<tr>
<td align="center">$VIEW$</td>
<td align="center">$\surd$</td>
<td align="center"></td>
<td align="center">$\surd$</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外虽然许多<code>DBMS</code>支持 <span  class="math">\(CREATE\)</span> / <span  class="math">\(DROP\;INDEX\)</span> ，但是<code>SQL</code>标准并不支持。</p>

<h3 id="31-数据库">3.1 数据库</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据<code>ISO</code>标准，关系和其他的数据库对象都存在于某个<strong>环境</strong> ( <span  class="math">\(environment\)</span> ) 中，每个环境含有一个或多个<strong>目录</strong> ( <span  class="math">\(catalogs\)</span> )，每个目录包括一组<strong>模式</strong> ( <span  class="math">\(schemas\)</span> )。模式是一组数据库对象的明明集合，该集合中的对象以某种方式相互关连。对象可以是表、视图、域、字符集等，具有相同的所有者并且共享若干的默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">SCHEMA</span> <span class="p">[</span><span class="n">Name</span> <span class="o">|</span> <span class="k">AUTHORIZATION</span> <span class="n">creatorIdentifier</span><span class="p">]</span>

<span class="k">DROP</span> <span class="k">SCHEMA</span> <span class="n">Name</span> <span class="p">[</span><span class="k">RESTRICT</span> <span class="o">|</span> <span class="k">CASCADE</span><span class="p">]</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(AUTHORIZATION\)</span> 指定模式的创建者。<span  class="math">\(RESTRICT\)</span> 限制只有模式为空时才能删除，<span  class="math">\(CASCADE\)</span> 则会级联删除所有与该模式相关的对象。</p>

<h3 id="32-表">3.2 表</h3>

<h4 id="321-创建">3.2.1 创建</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">tableName</span>
    <span class="err">{</span><span class="p">(</span><span class="n">columnName</span> <span class="n">dateType</span> <span class="p">[</span><span class="k">NOT</span> <span class="k">NULL</span><span class="p">]</span> <span class="p">[</span><span class="k">UNIQUE</span><span class="p">]</span> <span class="p">[</span><span class="k">DEFAULT</span> <span class="n">defaultOption</span><span class="p">]</span> <span class="p">[</span><span class="k">CHECK</span><span class="p">(</span><span class="n">searchCondition</span><span class="p">)]</span>
    <span class="p">[,...])</span><span class="err">}</span>
    <span class="p">[</span><span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="n">columnList</span><span class="p">)]</span>
    <span class="err">{</span><span class="p">[</span><span class="k">UNIQUE</span><span class="p">(</span><span class="n">columnList</span><span class="p">)[,...]]</span><span class="err">}</span>
    <span class="err">{</span><span class="p">[</span><span class="k">FOREIGN</span> <span class="k">KEY</span><span class="p">(</span><span class="n">columnList</span><span class="p">)</span>
    <span class="k">REFERENCES</span> <span class="n">tableName</span><span class="p">[(</span><span class="n">columnList</span><span class="p">)]]</span>
        <span class="p">[</span><span class="k">MATCH</span> <span class="err">{</span><span class="k">PARTIAL</span> <span class="o">|</span> <span class="k">FULL</span><span class="err">}</span>
        <span class="p">[</span><span class="k">ON</span> <span class="k">UPDATE</span> <span class="n">referentialAction</span><span class="p">]</span>
        <span class="p">[</span><span class="k">ON</span> <span class="k">DELETE</span> <span class="n">referentialAction</span><span class="p">]][,...]</span><span class="err">}</span>
    <span class="err">{</span><span class="p">[</span><span class="k">CHECK</span><span class="p">(</span><span class="n">searchCondition</span><span class="p">)][,...]</span><span class="err">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(PRIMARY\;KEY\)</span> 及之后的子句统称为表约束，可以选择下列句子作为前缀：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CONSTRAINT</span> <span class="n">constraintName</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这种方式，之后可以使用 <span  class="math">\(ALTER\;TABLE\)</span> 删除约束。外键中的 <span  class="math">\(MATCH\)</span> 选项对外键中存在空的情况施加另外限制。如果指定为 <span  class="math">\(FULL\)</span> ，则外键全为空或全不为空。如果指定为 <span  class="math">\(PARTIAL\)</span> ，则外键各列或者全为空，或者说当为空的列被代入时，父表中至少有有一行能满足约束。</p>

<h4 id="322-修改">3.2.2 修改</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">tableName</span>
<span class="p">[</span><span class="k">ADD</span> <span class="p">[</span><span class="k">COLUMN</span><span class="p">]</span> <span class="n">columnName</span> <span class="n">dataType</span> <span class="p">[</span><span class="k">NOT</span> <span class="k">NULL</span><span class="p">]</span> <span class="p">[</span><span class="k">UNIQUE</span><span class="p">]</span>
<span class="p">[</span><span class="k">DEFAULT</span> <span class="n">defaultOption</span><span class="p">]</span>
<span class="p">[</span><span class="k">CHECK</span><span class="p">(</span><span class="n">searchCondition</span><span class="p">)]]</span>
<span class="p">[</span><span class="k">DROP</span> <span class="p">[</span><span class="k">COLUMN</span><span class="p">]</span> <span class="n">columnName</span> <span class="p">[</span><span class="k">RESTRICT</span> <span class="o">|</span> <span class="k">CASCADE</span><span class="p">]]</span>
<span class="p">[</span><span class="k">ADD</span> <span class="p">[</span><span class="k">CONSTRAINT</span> <span class="p">[</span><span class="n">constraintName</span><span class="p">]]</span> <span class="n">tableConstraintDefinition</span><span class="p">]</span>
<span class="p">[</span><span class="k">DROP</span> <span class="k">CONSTRAINT</span> <span class="n">constraintName</span> <span class="p">[</span><span class="k">RESTRICT</span> <span class="o">|</span> <span class="k">CASCADE</span><span class="p">]]</span>
<span class="p">[</span><span class="k">ALTER</span> <span class="p">[</span><span class="k">COLUMN</span><span class="p">]</span> <span class="k">SET</span> <span class="k">DEFAULT</span> <span class="n">defaultOption</span><span class="p">]</span>
<span class="p">[</span><span class="k">ALTER</span> <span class="p">[</span><span class="k">COLUMN</span><span class="p">]</span> <span class="k">DROP</span> <span class="k">DEFAULT</span><span class="p">]</span></code></pre></div>
<h4 id="323-删除">3.2.3 删除</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">tableName</span> <span class="p">[</span><span class="k">RESTRICT</span> <span class="o">|</span> <span class="k">CASCADE</span><span class="p">]</span></code></pre></div>
<h3 id="33-索引">3.3 索引</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;索引是一种结构，提供了一个或多个列值得快速访问表中元组的方法。索引极大地提高了查询的性能。然而，由于每更新一次基本关系时都可能会更新索引，所以可能会导致额外的开销。<code>SQL</code>并未创建索引的标准，但大多数实现可以支持下列语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="p">[</span><span class="k">UNIQUE</span><span class="p">]</span> <span class="k">INDEX</span> <span class="n">indexName</span>
<span class="k">ON</span> <span class="n">tableName</span><span class="p">(</span><span class="n">columnName</span> <span class="p">[</span><span class="k">ASC</span> <span class="o">|</span> <span class="k">DESC</span><span class="p">][,...])</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定的列构成索引关键字，按照从主到次的顺序排列。索引只能基于基表建立，不能基于视图。</p>

<h2 id="4-视图">4. 视图</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;视图是为了得到另一个关系而对基关系进行一次或多次关系操作所得到的动态结果。视图是虚关系，只在需要时根据特定用户的要求临时生成。对于用户来说，视图像真实表一样。<code>DBMS</code>只存储视图的定义，当遇到视图引用时，再将请求转换为对源表的等价请求。这个转换过程称为<strong>视图分解</strong> ( <span  class="math">\(view\;resolution\)</span> )。也可以通过<strong>视图物化</strong> ( <span  class="math">\(view\;materialization\)</span> ) 实现，即把视图存储在数据库的临时表中，并在基表变化时更新临时表。</p>

<h3 id="41-创建">4.1 创建</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">VIEW</span> <span class="n">viewName</span> <span class="p">[(</span><span class="n">newColumnName</span><span class="p">[,...])]</span>
<span class="k">AS</span> <span class="n">subselect</span> <span class="p">[</span><span class="k">WITH</span> <span class="p">[</span><span class="k">CASCADE</span> <span class="o">|</span> <span class="k">LOCAL</span><span class="p">]</span> <span class="k">CHECK</span> <span class="k">OPTION</span><span class="p">]</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(subselect\)</span> 称为<strong>定义查询</strong> ( <span  class="math">\(defining\;query\)</span> ) 。在定义查询中使用 <span  class="math">\(ORDER\;BY\)</span> 子句的视图称为分组视图，如果使用了 <span  class="math">\(JOIN\)</span> 子句的视图称为连接视图。如果指定 <span  class="math">\(WITH\;CHECK\;OPTION\)</span> ，那么哪些不满足定义查询中 <span  class="math">\(WHERE\)</span> 子句的行不会添加到视图的基表中。</p>

<h3 id="42-删除">4.2 删除</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DROP</span> <span class="k">VIEW</span> <span class="n">viewName</span> <span class="p">[</span><span class="k">RESTRICT</span> <span class="o">|</span> <span class="k">CASCADE</span><span class="p">]</span></code></pre></div>
<h3 id="43-视图的局限性">4.3 视图的局限性</h3>

<ol>
<li>如果视图中的某个列基于聚合函数，那么在访问它语句中，该列只能出现在 <span  class="math">\(SELECT\)</span> / <span  class="math">\(ORDER\;BY\)</span> 子句中</li>
<li>分组视图不能与基表或者视图连接</li>
</ol>

<h3 id="44-视图的可更新性">4.4 视图的可更新性</h3>

<ol>
<li>没有指定 <span  class="math">\(DISTINCT\)</span> ，即未删除重复元组</li>
<li>定义查询中 <span  class="math">\(SELECT\)</span> 列表的每个元素都是列名，即非常量、表达式或者聚合函数，且每个列名最多出现一次</li>
<li><span  class="math">\(FROM\)</span> 只指定一个表，并且用户对该表具有一定的权限</li>
<li><span  class="math">\(WHERE\)</span> 子句不能包括任何引用了 <span  class="math">\(FROM\)</span> 子句中的表的嵌套 <span  class="math">\(SELECT\)</span> 操作</li>
<li>定义查询中不能有 <span  class="math">\(GROUP\;BY\)</span> 或者 <span  class="math">\(HAVING\)</span> 子句</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些限制的蕴含为：对于任何一个行或者列，<code>DBMS</code>必须能追溯到其源表中相应的行或者列。</p>

<h3 id="45-with-check-option">4.5 WITH CHECK OPTION</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;视图中的行均满足定义查询中 <span  class="math">\(WHERE\)</span> 子句的条件。如果某行经过修改后不满足，则应该将其从视图中移除。相应的，如果某行在修改后满足，则应移入视图中。对于发生这种改变的行，我们称之为<strong>迁移行</strong> ( <span  class="math">\(migrating\;rows\)</span> )。<span  class="math">\(WITH\;CHECK\;OPTION\)</span> 子句用于禁止行迁移出视图。<span  class="math">\(LOCAL\)</span> 修饰词在该视图或者其导出视图上进行插入或者更新操作时，禁止行迁移出视图，除非该行也从底层视图或者表中迁移出。<span  class="math">\(CASCADED\)</span> 修饰词是默认设置，在该视图或者其导出视图上进行插入或者更新操作时，禁止所有行迁移出视图。</p>

<h3 id="46-视图的优缺点">4.6 视图的优缺点</h3>

<h4 id="461-优点">4.6.1 优点</h4>

<ol>
<li>数据独立性。即使底层源发生了变化，只要不影响到视图所需的列，那么视图的定义就不需要改变；</li>
<li>实时性。对基表的任何改变都会立即反映到视图上；</li>
<li>提高安全性。用户只能访问可以访问的视图；</li>
<li>降低复杂性。将多表查询转换为单表查询；</li>
<li>方便。只需要提供用户想看到的内容；</li>
<li>用户化。同一个表可以被不同用户以不同方式查看；</li>
<li>数据完整性。通过 <span  class="math">\(WITH\;CHECK\;OPTION\)</span> ，任何不满足定义查询中 <span  class="math">\(WHERE\)</span> 子句的行不会通过视图加入基表，确保了视图的完整性。</li>
</ol>

<h4 id="462-缺点">4.6.2 缺点</h4>

<ol>
<li>更新局限性。在某些情况下视图无法更新；</li>
<li>结构局限性。一旦视图被定义，那么后续无法修改其查询语句；</li>
<li>性能开销。使用视图会带来一定的性能开销。</li>
</ol>

<h2 id="5-事务">5. 事务</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务是由一个或者多个<code>SQL</code>语句组成的逻辑工作单元，通过恢复机制可以保证其原子性。当用户或者程序执行事务初始化语句，如 <span  class="math">\(SELECT\)</span>, <span  class="math">\(INSERT\)</span>, <span  class="math">\(UPDATE\)</span> 等，<code>SQL</code>事务自动开始。结束事务有四种方式：</p>

<ul>
<li><span  class="math">\(COMMIT\)</span> ，提交事务并持久化数据库</li>
<li><span  class="math">\(ROLLBACK\)</span> ，撤销事务并回退至事务执行之前</li>
<li>终止程序。对于程序式<code>SQL</code>，这意味着提交事务。对于非程序式<code>SQL</code>，这意味着撤销事务。</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(SET\;TRANSACTION\)</span> 语句允许用户配置事务的某些特性：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SET</span> <span class="k">TRANSACTION</span>
<span class="p">[</span><span class="k">READ</span> <span class="k">ONLY</span> <span class="o">|</span> <span class="k">READ</span> <span class="k">WRITE</span><span class="p">]</span> <span class="o">|</span>
<span class="p">[</span><span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="k">READ</span> <span class="k">UNCOMMITTED</span> <span class="o">|</span> <span class="k">READ</span> <span class="k">COMMITTED</span> <span class="o">|</span> <span class="k">REPEATABLE</span> <span class="k">READ</span> <span class="o">|</span> <span class="k">SERIALIZABLE</span><span class="p">]</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(READ\;ONLY/WRITE\)</span> 表示事务的读写型，默认为可读写。隔离级表示事务执行过程中允许的与其他事务的交互程度。</p>

<h2 id="6-自主访问控制">6. 自主访问控制</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DBMS</code>通常提供一种或两种授权机制：<em>自主访问控制</em> ( <span  class="math">\(discretionary\;access\;control\)</span> ) 和<em>强制访问控制</em> ( <span  class="math">\(mandatory\;access\;control\)</span> ) 。在自主访问控制中，每个用户会被授予对特定数据库对象的适当的访问权限。在强制访问控制中，每个数据库对象会被分级。<code>SQL</code>通过 <span  class="math">\(GRANT\)</span> 和 <span  class="math">\(REVOKE\)</span> 语句来支持自主访问控制，基于<em>授权标识符</em> ( <span  class="math">\(authorization\;identifiers\)</span> ) ，<em>所有权</em> ( <span  class="math">\(ownership\)</span> ) 和<em>权限</em> ( <span  class="math">\(privileges\)</span> ) 。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;授权标识符是<code>SQL</code>用于辨别用户的一般标识符，每个用户都由数据库管理员分配一个授权标识符。通常这个标识符都与一个密码相关联。可以用授权标识符确定用户可以访问哪些对象，能对对象进行哪些操作。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>SQL</code>中的每个对象都有一个所有者，即创建该对象所属模式时 <span  class="math">\(AUTHORIZATION\)</span> 指定的授权标识符。在最初，只有所有者知道对象存在，并能对其进行任何操作。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;权限是指允许用户对指定基表或视图进行的操作，包括：</p>

<ul>
<li><span  class="math">\(SELECT\)</span> ：查询表中数据</li>
<li><span  class="math">\(INSERT\)</span> ：向表中插入数据，可以限制到指定列</li>
<li><span  class="math">\(UPDATE\)</span> ：更新表中数据，可以限制到指定列</li>
<li><span  class="math">\(DELETE\)</span> ：删除表中数据</li>
<li><span  class="math">\(REFERENCES\)</span> ：完整性约束中引用指定表中列</li>
<li><span  class="math">\(USAGE\)</span> ：使用域、序列、字符集和转变规则</li>
</ul>

<h3 id="61-授予权限">6.1 授予权限</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">GRANT</span> <span class="err">{</span><span class="n">privilegeList</span> <span class="o">|</span> <span class="k">ALL</span> <span class="k">PRIVILEGES</span><span class="err">}</span>
<span class="k">ON</span> <span class="n">objectName</span>
<span class="k">TO</span> <span class="err">{</span><span class="n">authorizationIdList</span> <span class="o">|</span> <span class="k">PUBLIC</span><span class="err">}</span>
<span class="p">[</span><span class="k">WITH</span> <span class="k">GRANT</span> <span class="k">OPTION</span><span class="p">]</span></code></pre></div>
<h3 id="62-撤销权限">6.2 撤销权限</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">REVOKE</span> <span class="p">[</span><span class="k">GRANT</span> <span class="k">OPTION</span> <span class="k">FOR</span><span class="p">]</span> <span class="err">{</span><span class="n">privilegeList</span> <span class="o">|</span> <span class="k">ALL</span> <span class="k">PRIVILEGES</span><span class="err">}</span>
<span class="k">ON</span> <span class="n">objectName</span>
<span class="k">FROM</span> <span class="err">{</span><span class="n">authorizationIdList</span> <span class="o">|</span> <span class="k">PUBLIC</span><span class="err">}</span> <span class="p">[</span><span class="k">RESTRICT</span> <span class="o">|</span> <span class="k">CASCADE</span><span class="p">]</span></code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2020 May 20 16:46</span> <a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/">数据库系统（5）：SQL数据操作</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-sql简介">1. <code>SQL</code>简介</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>SQL</code>是关系模型发展过程中出现的一种特殊语言，已经成为了标准的关系数据库语言。<code>SQL</code>是<strong>面向转换语言</strong> ( <span  class="math">\(transform-oriented\;language\)</span> ) 的例子，将输入关系转换为所需的输出关系，包括两个主要部分：<code>DML</code>和<code>DDL</code>。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>SQL</code>具有许多实现版本，每个实现称为<strong>方言</strong> ( <span  class="math">\(dialect\)</span> ) ，供应商在标准之外提供的特性称为<strong>扩展</strong> ( <span  class="math">\(extensions\)</span> )。</p>

<h3 id="11-优点">1.1 优点</h3>

<ol>
<li>满足数据库语言的思想</li>
<li>易于学习</li>
<li>结构简洁、轻便</li>
<li>存在<code>SQL</code>标准</li>
<li>可以通过终端或者嵌入式访问</li>
<li>所有人都可以使用</li>
</ol>

<h3 id="12-缺点">1.2 缺点</h3>

<ol>
<li>混合了编程规范和嵌入式访问</li>
<li>缺乏正交性，有多种表达方式</li>
<li>语言越来越复杂和庞大</li>
<li>聚合函数中对空的处理问题</li>
<li>结果表中可以有重复元组，对表中的行和列都强加了一个顺序</li>
</ol>

<h2 id="2-sql命令">2. <code>SQL</code>命令</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>SQL</code>语言包括<strong>保留字</strong> ( <span  class="math">\(reserved\;words\)</span> ) 和<strong>用户自定义字</strong> ( <span  class="math">\(user-defined\;words\)</span> ) 。保留字是<code>SQL</code>语言的固定部分，有固定含义。用户自定义字由用户定义，用于表示表、列、视图和索引等数据库对象的名称。虽然标准并没有要求，但是<code>SQL</code>的许多实现版本要求用句子终结符来表示<code>SQL</code>语句的结束。<code>SQL</code>语句的多数组成部分是不区分大小写的，除了字符数据常量外。</p>

<h3 id="21-数据操作">2.1 数据操作</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DML</code>语句有以下几种：</p>

<ul>
<li><span  class="math">\(SELECT\)</span>,</li>
<li><span  class="math">\(INSERT\)</span>,</li>
<li><span  class="math">\(UPDATE\)</span>,</li>
<li><span  class="math">\(DELETE\)</span>.</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>常量</strong> ( <span  class="math">\(Literals\)</span> ) 是指<code>SQL</code>语句中的<strong>不变量</strong> ( <span  class="math">\(constants\)</span> )。不同的数据具有不同的常量形式，所有的非数值型数据必须使用引号，而所有的非数值型数据不能使用引号。</p>

<h3 id="22-查询">2.2 查询</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="p">[</span><span class="k">DISTINCT</span><span class="o">|</span><span class="k">ALL</span><span class="p">]</span> <span class="err">{</span><span class="o">*|</span><span class="p">[</span><span class="n">columnExpression</span> <span class="p">[</span><span class="k">AS</span> <span class="n">newName</span><span class="p">]][...]</span><span class="err">}</span>
<span class="k">FROM</span> <span class="n">TableName</span> <span class="p">[</span><span class="k">alias</span><span class="p">][...]</span>
<span class="p">[</span><span class="k">WHERE</span> <span class="n">condition</span><span class="p">]</span>
<span class="p">[</span><span class="k">GROUP</span> <span class="k">BY</span> <span class="n">coulumnList</span><span class="p">]</span>
<span class="p">[</span><span class="k">HAVING</span> <span class="n">condition</span><span class="p">]</span>
<span class="p">[</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">columnList</span><span class="p">]</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理顺序：</p>

<ol>
<li><span  class="math">\(FROM\)</span> :<br>
指定所用的表，<span  class="math">\(alias\)</span> 是可选的表的别名</li>
<li><span  class="math">\(WHERE\)</span> :<br>
过滤满足条件的行</li>
<li><span  class="math">\(GROUP\;BY\)</span> :<br>
分组</li>
<li><span  class="math">\(HAVING\)</span> :<br>
过滤满足条件的组</li>
<li><span  class="math">\(ORDER\;BY\)</span> :<br>
指定查询结果的顺序</li>
</ol>

<h4 id="221-行选择">2.2.1 行选择</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;逻辑运算符：<span  class="math">\(AND/OR/NOT\)</span>,</p>

<table>
<thead>
<tr>
<th align="center">比较运算符</th>
<th align="center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">=</td>
<td align="center">等于</td>
</tr>

<tr>
<td align="center">&lt;&gt;</td>
<td align="center">不等于</td>
</tr>

<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>

<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>

<tr>
<td align="center">&lt;=</td>
<td align="center">小于等于</td>
</tr>

<tr>
<td align="center">&gt;=</td>
<td align="center">大于等于</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在某些方言中，不等于也可以表示为 <span  class="math">\(!=\)</span>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;范围条件查找：<span  class="math">\([NOT]\;BETWEEN\)</span>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集合成员查找：<span  class="math">\([NOT]\;IN\)</span>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模式匹配查找：<span  class="math">\([NOT]\;LIKE\)</span> 。<code>SQL</code>有两种模式匹配符号：</p>

<ul>
<li><span  class="math">\(\%\)</span> 代表零个或多个字符</li>
<li><span  class="math">\(\_\)</span> 代表任意单个字符</li>
<li><span  class="math">\(\#\)</span> 为转义字符</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;空条件查找：<span  class="math">\(IS\;[NOT]\;NULL\)</span>.</p>

<h4 id="222-排序">2.2.2 排序</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(ORDER\;BY\)</span> 子句包括所需排序的<strong>列标识符</strong> ( <span  class="math">\(column\;identifiers\)</span> ) 列表，用逗号分开。在之后使用 <span  class="math">\(ASC/DESC\)</span> 指定升序和降序排列，默认为升序排列。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <span  class="math">\(ORDER\;BY\)</span> 子句的多个关键字中，第一个关键字称为<strong>主排序关键字</strong> ( <span  class="math">\(major\;sort\;key\)</span> ) 。在主排序关键字非唯一时，之后的<strong>次排序关键字</strong> ( <span  class="math">\(minor\;sort\;key\)</span> ) 则会决定相同关键字的行的顺序。</p>

<h4 id="223-聚合函数">2.2.3 聚合函数</h4>

<ul>
<li><span  class="math">\(COUNT\)</span>,</li>
<li><span  class="math">\(SUM\)</span>,</li>
<li><span  class="math">\(AVG\)</span>,</li>
<li><span  class="math">\(MIN\)</span>,</li>
<li><span  class="math">\(MAX\)</span>.</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了 <span  class="math">\(COUNT(*)\)</span> 以外，每一个函数都要去掉空，再计算非空值。<span  class="math">\(COUNT(DISTINCT)\)</span> 语句可以计算所有非重复项。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聚合函数只能用于 <span  class="math">\(SELECT\)</span> 列表和 <span  class="math">\(HAVING\)</span> 子句中。如果 <span  class="math">\(SELECT\)</span> 列表包括聚合函数，却没有使用 <span  class="math">\(GROUP\;BY\)</span> 分组，那么 <span  class="math">\(SELECT\)</span> 列表的任何项都不能引用列。</p>

<h4 id="224-分组">2.2.4 分组</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(GROUP\;BY\)</span> 子句的列名又称为<strong>组列名</strong> ( <span  class="math">\(grouping\;columns\)</span> )。当使用 <span  class="math">\(GROUP\;BY\)</span> 时，<span  class="math">\(SELECT\)</span> 列表中的项必须每组都有一个单一的值。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(HAVING\)</span> 子句设计用于与 <span  class="math">\(GROUP\;BY\)</span> 子句一起使用，用于过滤分组。实际上，<span  class="math">\(HAVING\)</span> 子句的条件运算至少要包含一个聚合函数，否则就可以将其条件判断转移到 <span  class="math">\(WHERE\)</span> 中。</p>

<h3 id="23-子查询">2.3 子查询</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个 <span  class="math">\(SELECT\)</span> 语句内部嵌套另一个 <span  class="math">\(SELECT\)</span> 语句时，内部的 <span  class="math">\(SELECT\)</span> 语句称为<strong>子查询</strong> ( <span  class="math">\(subquery\)</span> ) /<strong>嵌套查询</strong> ( <span  class="math">\(nested\;query\)</span> ) 。子查询可以用于外部 <span  class="math">\(SELECT\)</span> 语句的 <span  class="math">\(WHERE/HAVING\)</span> 子句中。子查询也可以用于 <span  class="math">\(INSERT\)</span>, <span  class="math">\(UPDATE\)</span>, <span  class="math">\(DELETE\)</span> 语句中，有三种类型：</p>

<ul>
<li><em>标量子查询</em> ( <span  class="math">\(Scalar\;subquery\)</span> ) 返回单个值，即单行单列的表</li>
<li><em>行子查询</em> ( <span  class="math">\(Row\;subquery\)</span> ) 返回一个单行的表</li>
<li><em>表子查询</em> ( <span  class="math">\(Table\;subquery\)</span> ) 返回多行多列的表</li>
</ul>

<h4 id="231-anyall">2.3.1 <code>ANY</code>/<code>ALL</code></h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(ANY\)</span> 和 <span  class="math">\(ALL\)</span> 用于产生单个列的子查询中。若子查询前缀关键字 <span  class="math">\(ALL\)</span> ，那么仅当子查询的所有值都满足条件时才为真。若前缀关键词为 <span  class="math">\(ANY\)</span>/ <span  class="math">\(SOME\)</span> 时，那么只要有一个值满足条件就为真。对于空，<span  class="math">\(ALL\)</span> 返回真，<span  class="math">\(ANY\)</span>/ <span  class="math">\(SOME\)</span> 返回假。</p>

<h4 id="232-exists">2.3.2 <code>EXISTS</code></h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(EXISTS\)</span> 用于子查询中，返回真或假。当子查询的结果表至少存在一行时，返回真。$$NOT\;EXISTS$ 则相反。</p>

<h3 id="24-连接">2.4 连接</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>连接</strong> ( <span  class="math">\(Join\)</span> ) 用于组合多个表的结果。<code>SQL</code>连接通过配对相关行来合并表，而配对行指的是对应表的匹配列上具有相同的值。</p>

<h4 id="241-简单连接内连接">2.4.1 简单连接/内连接</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="n">col1</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">col2</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">col3</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">col1</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">col2</span>
<span class="k">FROM</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">col3</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">col3</span><span class="p">;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在查询条件中指定相等的两个列称为<strong>匹配列</strong> ( <span  class="math">\(matching\;columns\)</span> )。也可以改写为：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">FROM</span> <span class="n">a</span> <span class="k">JOIN</span> <span class="n">b</span>
    <span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">col</span><span class="p">;</span>

<span class="k">FROM</span> <span class="n">a</span> <span class="k">JOIN</span> <span class="n">b</span>
    <span class="k">USING</span> <span class="n">col</span><span class="p">;</span>

<span class="k">FROM</span> <span class="n">a</span> <span class="k">NATURAL</span> <span class="k">JOIN</span> <span class="n">b</span><span class="p">;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种方式产生表有两个相同的 <span  class="math">\(col\)</span> 列，而后两者没有。</p>

<h4 id="242-交叉连接">2.4.2 交叉连接</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;连接操作是更一般的两表合并，是笛卡尔乘积的子集。<code>SQL</code>中有特殊的笛卡尔乘积的表示形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">FROM</span> <span class="n">a</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">b</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从概念上看，使用连接的 <span  class="math">\(SELECT\)</span> 语句的查询过程为：</p>

<ol>
<li>形成 <span  class="math">\(FROM\)</span> 中指定的笛卡尔乘积</li>
<li>执行 <span  class="math">\(WHERE\)</span> 子句，即对笛卡尔乘积进行<strong>限制</strong> ( <span  class="math">\(restriction\)</span> )</li>
<li>确定 <span  class="math">\(SELECT\)</span> 列表中每一项的值，形成查询结果表的每一行</li>
<li>如果指定了 <span  class="math">\(DISTINCT\)</span> ，消除重复行</li>
<li>执行 <span  class="math">\(ORDER\;BY\)</span> 语句</li>
</ol>

<h4 id="243-外连接">2.4.3 外连接</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在内连接中，如果表中的某一行在另一个表中没有匹配的行，那么将会被删除。而<strong>外连接</strong> ( <span  class="math">\(outer\;join\)</span> ) 会保留。外连接有三种类型：左外连接、右外连接和全外连接。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">FROM</span> <span class="n">a</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">b</span>
    <span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">col</span>

<span class="k">FROM</span> <span class="n">a</span> <span class="k">RIGHT</span> <span class="k">JOIN</span> <span class="n">b</span>
    <span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">col</span>

<span class="k">FROM</span> <span class="n">a</span> <span class="k">FULL</span> <span class="k">JOIN</span> <span class="n">b</span>
    <span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">col</span></code></pre></div>
<h3 id="25-合并">2.5 合并</h3>

<ul>
<li><span  class="math">\(UNION\)</span>,</li>
<li><span  class="math">\(INTERSECT\)</span>,</li>
<li><span  class="math">\(EXCEPT\)</span>.</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行操作要求两个表具有并相容性。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="err">{</span><span class="k">UNION</span><span class="o">|</span><span class="k">INTERSECT</span><span class="o">|</span><span class="k">EXCEPT</span><span class="err">}</span> <span class="p">[</span><span class="k">ALL</span><span class="p">]</span> <span class="p">[</span><span class="n">CORRESPONDING</span> <span class="p">[</span><span class="k">BY</span> <span class="err">{</span><span class="n">column1</span><span class="p">[,...]</span><span class="err">}</span><span class="p">]]</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果指定了 <span  class="math">\(CORRESPONDING\;BY\)</span> ，那么集合操作就会在指定的列上进行。在一些<code>SQL</code>版本中并不支持 <span  class="math">\(INTERSECT/EXCEPT\)</span> ，也有一些使用 <span  class="math">\(MINUS\)</span> 代替 <span  class="math">\(EXCEPT\)</span> 。</p>

<h3 id="26-更新">2.6 更新</h3>

<h4 id="261-插入">2.6.1 插入</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">TableName</span> <span class="p">[(</span><span class="n">columnList</span><span class="p">)]</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="n">dataValueList</span><span class="p">)</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(columnList\)</span> 是列名列表，如果省略，则会按照创建时的列序进行插入。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">TableName</span> <span class="p">[(</span><span class="n">columnList</span><span class="p">)]</span>
<span class="k">SELECT</span> <span class="p">...</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合 <span  class="math">\(SELECT\)</span> 语句，<span  class="math">\(INSERT\;INTO\)</span> 可以把表中行插入另一个表中。</p>

<h4 id="262-更新">2.6.2 更新</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">UPDATE</span> <span class="n">TableName</span>
<span class="k">SET</span> <span class="n">columnName1</span> <span class="o">=</span> <span class="n">dataValue1</span> <span class="p">[,</span> <span class="n">columnuName2</span> <span class="o">=</span> <span class="n">dataValue2</span><span class="p">...]</span>
<span class="p">[</span><span class="k">WHERE</span> <span class="n">searchCodition</span><span class="p">]</span></code></pre></div>
<h4 id="263-删除">2.6.3 删除</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">TableName</span>
<span class="p">[</span><span class="k">WHERE</span> <span class="n">searchCondition</span><span class="p">]</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不指定 <span  class="math">\(WHERE\)</span> ，则会删除表中的所有信息。</p>

            </div>
            <div class="meta post-footer"> <span>2020 May 20 14:17</span> <a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5sql%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/">数据库系统（4）：关系代数</a></h1>
            </center>
            <div class="post-content">
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>关系代数</strong> ( <span  class="math">\(Relational\;Algebra\)</span> ) 可以看成一种过程式语言，可用于构造新关系。关系代数是一种纯理论语言，它定义了一些操作，运用这些操作可以从一个或多个关系中得到另一个关系而不改变原关系。关系代数的一个表达式可以嵌套另一个表达式，这种性质称为<strong>闭包</strong> ( <span  class="math">\(closure\)</span> )，即关系在关系代数下是封闭的。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系代数是一种每次一关系/集合的语言，即用一条不带循环的语句处理，结果也是由所有元组组成的整个关系。关系代数中包含了许多运算，其中五个基本运算是<strong>选择</strong> ( <span  class="math">\(Selection\)</span> ) 、<strong>投影</strong> ( <span  class="math">\(Projection\)</span> ) 、<strong>笛卡尔乘积</strong> ( <span  class="math">\(Cartesian\;product\)</span> ) 、<strong>集合并</strong> ( <span  class="math">\(Union\)</span> ) 、<strong>集合差</strong> ( <span  class="math">\(Set\;difference\)</span> ) 。选择和投影都是一元运算，其他的运算则是二元运算。除此之外，还有<strong>连接</strong> ( <span  class="math">\(Join\)</span> ) 、<strong>集合交</strong> ( <span  class="math">\(Intersection\)</span> ) 、<strong>除</strong> ( <span  class="math">\(Division\)</span> ) 等，它们都能通过五个基本运算表示。</p>

<h2 id="1-一元运算">1. 一元运算</h2>

<h3 id="11-选择">1.1 选择</h3>

<p><span  class="math">\[
\sigma_{predicate}(R)
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用于单个关系 <span  class="math">\(R\)</span> ，得到一个新关系，该关系由满足谓词 <span  class="math">\(predicate\)</span> 的元组组成。可以理解为从表中选出符合条件的行构成一个新表。</p>

<h3 id="12-投影">1.2 投影</h3>

<p><span  class="math">\[
\prod\nolimits_{a_1,a_2,...,a_n}(R)
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用于单个关系 <span  class="math">\(R\)</span> ，得到一个由 <span  class="math">\(R\)</span> 的垂直子集构成的新关系，该子集抽取 <span  class="math">\(R\)</span> 中指定属性上的值并去掉重复元组。可以理解为从表中选出指定的列构成一个新表。</p>

<h2 id="2-集合运算">2. 集合运算</h2>

<h3 id="21-并">2.1 并</h3>

<p><span  class="math">\[
R \cup S
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用于两个关系 <span  class="math">\(R\)</span> 和 <span  class="math">\(S\)</span>，定义了一个包含了 <span  class="math">\(R\)</span> 和 <span  class="math">\(S\)</span> 中所有不同元组的新关系，其中 <span  class="math">\(R\)</span> 和 <span  class="math">\(S\)</span> 具有并相容性，即具有同样多的属性，并且对应属性具有相同的域。</p>

<h3 id="22-差">2.2 差</h3>

<p><span  class="math">\[
R - S
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用于两个关系 <span  class="math">\(R\)</span> 和 <span  class="math">\(S\)</span>，定义了一个由所有属于 <span  class="math">\(R\)</span> 但不属于 <span  class="math">\(S\)</span> 的元组组成的新关系，<span  class="math">\(R\)</span> 和 <span  class="math">\(S\)</span> 必须具有并相容性。</p>

<h3 id="23-交">2.3 交</h3>

<p><span  class="math">\[
R \cap S
\]</span></p>

<p>也可以用差运算表示交运算</p>

<p><span  class="math">\[
R \cap S = R - (R - S)
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用于两个关系 <span  class="math">\(R\)</span> 和 <span  class="math">\(S\)</span>，定义了一个由所有既属于 <span  class="math">\(R\)</span> 又属于 <span  class="math">\(S\)</span> 的元组组成的新关系， <span  class="math">\(R\)</span> 和 <span  class="math">\(S\)</span> 必须具有并相容性。</p>

<h3 id="24-笛卡尔乘积">2.4 笛卡尔乘积</h3>

<p><span  class="math">\[
R \times S
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义了一个新关系，由 <span  class="math">\(R\)</span> 和 <span  class="math">\(S\)</span> 中的每个元组并联得到。如果关系 <span  class="math">\(R\)</span> 具有 <span  class="math">\(I\)</span> 个元组和 <span  class="math">\(N\)</span> 个属性，而 <span  class="math">\(S\)</span> 具有 <span  class="math">\(J\)</span> 个元组，<span  class="math">\(M\)</span> 个属性，那么 <span  class="math">\(R \times S\)</span> 将具有 <span  class="math">\(I \times J\)</span> 个元组，<span  class="math">\(N + M\)</span> 个属性。如果 <span  class="math">\(R\)</span> 和 <span  class="math">\(S\)</span> 中具有同名属性，可以使用关系名作为前缀，从而保证属性名的唯一性。</p>

<h3 id="25-表达式重命名">2.5 表达式重命名</h3>

<p><span  class="math">\[
\rho_{S_{(a_1,a_2,...,a_n)}}(E)
\]</span></p>

<p>为表达式 <span  class="math">\(E\)</span> 提供一个新名称 <span  class="math">\(S\)</span>，并将 <span  class="math">\(S\)</span> 中的属性名替换为 <span  class="math">\(a_1\)</span>, <span  class="math">\(a_2\)</span>,..., <span  class="math">\(a_n\)</span>。</p>

<h2 id="3-连接">3. 连接</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在大部分时候，我们只需要满足特定条件的笛卡尔乘积的结合，因此一般采用连接代替笛卡尔乘积。连接是关系代数中一种重要的运算，由笛卡尔乘积导出，相当于把连接谓词看成条件，对笛卡尔乘积进行一次选择运算。</p>

<h3 id="31-theta-连接">3.1 <code>theta</code> 连接</h3>

<p><span  class="math">\[
R \Join_F S
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(\theta\)</span> 连接定义了一个包含 <span  class="math">\(R\)</span> 和 <span  class="math">\(S\)</span> 的笛卡尔乘积中所有满足谓词 <span  class="math">\(F\)</span> 的元组组成的关系。其中 <span  class="math">\(\theta\)</span> 为 <span  class="math">\(<, \le, >, \ge, =, \ne\)</span> 中的一个，<span  class="math">\(F\)</span> 的格式为 <span  class="math">\(R.a_i\;\theta\;S.b_i\)</span>。当 <span  class="math">\(F\)</span> 仅包含等号的情况下，可以称 <span  class="math">\(\theta\)</span> 连接为<strong>等接</strong> ( <span  class="math">\(Equijoin\)</span> )。</p>

<h3 id="32-自然连接">3.2 自然连接</h3>

<p><span  class="math">\[
R \Join S
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自然连接是 <span  class="math">\(R\)</span> 和 <span  class="math">\(S\)</span> 在所有公共属性上的等接，但是每个公共属性只保留一个。即将两个表连接起来，但删去所有重复的属性。</p>

<h3 id="33-外连接">3.3 外连接</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;左外连接可以表示为 <span  class="math">\(R\)</span> ⟕ <span  class="math">\(S\)</span> 。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（左）外连接将 <span  class="math">\(R\)</span> 中所有元组都保留在新关系中，包括 <span  class="math">\(S\)</span> 中不存在属性，这些属性会在新关系中取空。除了左外连接之外，还有右外连接，保留所有右边关系的元组。以及全外连接，保留左右关系的元组。</p>

<h3 id="34-半连接">3.4 半连接</h3>

<p><span  class="math">\[
R \rhd_F S
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以用投影和连接表示为( <span  class="math">\(A\)</span> 为 <span  class="math">\(R\)</span> 中所有属性的集合 )</p>

<p><span  class="math">\[
R \rhd_F S = \prod\nolimits_A(R\Join_FS)
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;半连接在执行了两个关系的连接之后，将结果投影到 <span  class="math">\(R\)</span> 的所有属性上。</p>

<h2 id="4-除">4. 除</h2>

<p><span  class="math">\[
R \div S
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将其用基本运算表示为</p>

<p><span  class="math">\[
T_1 \leftarrow \prod\nolimits_c(R)\\
T_2 \leftarrow \prod\nolimits_c((T_1 \times S) - R)\\
T \leftarrow T_1 - T_2
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除定义了一个关系，该关系中的元组与 <span  class="math">\(S\)</span> 的每个元组的组合都能在 <span  class="math">\(R\)</span> 中找到匹配元组。</p>

<h2 id="5-聚合运算和分组运算">5. 聚合运算和分组运算</h2>

<h3 id="51-聚合运算">5.1 聚合运算</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聚合运算用于将数据进行汇总。常用的聚合函数有：</p>

<ul>
<li><span  class="math">\(COUNT\)</span>：返回相关联属性值的个数</li>
<li><span  class="math">\(SUM\)</span>：返回相关联属性值的总和</li>
<li><span  class="math">\(AVG\)</span>：返回相关联属性值的平均值</li>
<li><span  class="math">\(MIN\)</span>：返回相关联属性值的最小值</li>
<li><span  class="math">\(MAX\)</span>：返回相关联属性值的最大值</li>
</ul>

<h3 id="52-分组运算">5.2 分组运算</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分组运算用于将数据进行分组。分组运算要与聚合函数结合，得到的结果包含分组属性和每个聚合函数的结果。</p>

            </div>
            <div class="meta post-footer"> <span>2020 May 17 16:05</span> <a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/">数据库系统（3）：关系模型</a></h1>
            </center>
            <div class="post-content">
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在目前使用的数据处理软件中，<strong>关系数据库管理系统</strong> ( <span  class="math">\(Relational\;Database\;Management\;System\)</span>, <span  class="math">\(RDBMS\)</span> ) 占据了统治地位。<code>RDBMS</code>基于关系数据模型。在关系模型中，所有数据逻辑上被组织成关系（表）结构。</p>

<h2 id="1-基本术语">1. 基本术语</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系模型基于数学中的<strong>关系</strong> ( <span  class="math">\(relation\)</span> )。</p>

<h3 id="11-关系数据结构">1.1 关系数据结构</h3>

<h4 id="111-关系">1.1.1 关系</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系是由行和列组成的表。在关系模型中，用关系保存数据库所描述对象的信息，关系用二维表表示。用户主要接触的就是表，但这只限于逻辑结构，即外部层和概念层。对于物理结构，由于是通过多种存储结构实现的，因此并不适用。</p>

<h4 id="112-属性">1.1.2 属性</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>属性</strong> ( <span  class="math">\(Attribute\)</span> ) 是关系中命名的列。在关系的二维表中，每一行对应一个单独的记录，每一列则对应一个属性。</p>

<h4 id="113-域">1.1.3 域</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>域</strong> ( <span  class="math">\(Domain\)</span> ) 是一个或多个属性的取值集合，必须给每一个属性定义一个域。不同属性的域可以互不相同，也可以共用。通过使用域，用户可以集中定义属性的取值范围和含义。</p>

<h4 id="114-元组">1.1.4 元组</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>元组</strong> ( <span  class="math">\(Tuple\)</span> ) 是关系中的行。关系的结构、域说明以及所有取值约束统称为关系的<strong>内涵</strong> ( <span  class="math">\(intension\)</span> )。它通常是固定的，除非关系的意义改变，需要加入新的属性。元组的集合称为<strong>外延</strong> ( <span  class="math">\(extension\)</span> ) /<strong>状态</strong> ( <span  class="math">\(state\)</span> )，它经常发生改变。</p>

<h4 id="115-维数">1.1.5 维数</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>维数</strong> ( <span  class="math">\(Degree\)</span> ) 是关系所包含的属性个数。只有一个属性的关系称为一元关系或者一元组，两个属性的关系称为二元关系，以此类推，<span  class="math">\(n\)</span> 个属性的关系称为 <span  class="math">\(n\)</span> 元组。维数是内含的性质之一。</p>

<h4 id="116-基数">1.1.6 基数</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>基数</strong> ( <span  class="math">\(Cardinality\)</span> ) 是关系所包含的元组的个数。基数是外延的性质之一。</p>

<h4 id="117-关系数据库">1.1.7 关系数据库</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系数据库是具有不同关系名的规范化的关系的集合。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实上，关系模型的术语并不统一，下表为常见的关系术语的别名及其对应的正式术语。</p>

<table>
<thead>
<tr>
<th align="center">正式术语</th>
<th align="center">可选术语</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">关系</td>
<td align="center">表、文件</td>
</tr>

<tr>
<td align="center">元组</td>
<td align="center">行、记录</td>
</tr>

<tr>
<td align="center">属性</td>
<td align="center">列、字段</td>
</tr>
</tbody>
</table>

<h3 id="12-数据库中的关系">1.2 数据库中的关系</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>关系模式</strong> ( <span  class="math">\(Relation\;schema\)</span> ) 是用一组属性和域的名词对定义的具有名字的关系。设属性 <span  class="math">\(A_1\)</span>, <span  class="math">\(A_2\)</span>,..., <span  class="math">\(A_n\)</span> 对应的域分别为 <span  class="math">\(D_1\)</span>, <span  class="math">\(A_2\)</span>,..., <span  class="math">\(A_n\)</span>，那么集合 {<span  class="math">\(A_1\)</span>: <span  class="math">\(D_1\)</span>, <span  class="math">\(A_2\)</span>: <span  class="math">\(D_2\)</span>,..., <span  class="math">\(A_n\)</span>: <span  class="math">\(D_n\)</span>} 就是一个关系模式。由关系模式 <span  class="math">\(S\)</span> 定义的关系 <span  class="math">\(R\)</span> 是一组从属性到域的映射。因此关系 <span  class="math">\(R\)</span> 就是如下 <span  class="math">\(n\)</span> 元组的集合：</p>

<p><span  class="math">\[
(A_1:d_1,A_2:d_2,...,A_n:d_n),d_1\in{D_1},d_2\in{D_2},...,d_n\in{D_n}
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(n\)</span> 元组的每个元素都由一个属性和该属性的一个取值组成。通常会把属性名作为列标题，元组作为行。关系中属性和元组对应的集合称为<strong>关系实例</strong> ( <span  class="math">\(relation\;instance\)</span> )。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系数据库也具有模式。<strong>关系数据库模式</strong> ( <span  class="math">\(Relational\;database\;schema\)</span> ) 是关系模式的结合，在集合中每个关系都有不同的名字。</p>

<h3 id="13-关系的性质">1.3 关系的性质</h3>

<ol>
<li>在同一关系模式中，关系之间不能重名</li>
<li>关系的每一个单元格都包含一个原子（单个）值</li>
<li>关系中的属性不能重名</li>
<li>同一属性中的值都来自相同的域</li>
<li>关系中元组间互不相同</li>
<li>属性顺序并不重要</li>
<li>元组顺序也并不重要，但改变元组的顺序可能会影响访问效率</li>
</ol>

<h3 id="14-键">1.4 键</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;元组之间不会重复，因此可以通过一个或多个属性来唯一标识元组。</p>

<h4 id="141-超键">1.4.1 超键</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>超键</strong> ( <span  class="math">\(Superkey\)</span> ) 是一个属性或者属性的集合，能唯一标识关系中的每个元组。但是超键中可能包含多余的属性。</p>

<h4 id="142-候选键">1.4.2 候选键</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>候选键</strong> ( <span  class="math">\(Candidate\;key\)</span> ) 是超键，但是其任何真子集都不是超键。候选键是唯一标识每个元组的最小属性集合，具有如下性质：</p>

<ol>
<li><em>唯一性</em>，即可以唯一的标识每个元组</li>
<li><em>不可约性</em>，即每个真子集都不具有唯一性</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个关系可能有多个候选键。当一个键中包含多个属性时，就称为<strong>合成键</strong> ( <span  class="math">\(composite\;key\)</span> )。</p>

<h4 id="143-主键">1.4.3 主键</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>主键</strong> ( <span  class="math">\(Primary\;key\)</span> ) 是用于唯一标识关系中元组的候选键。一个关系可以有多个候选键，但这些候选键中只能选出一个作为主键，没有被选为主键的候选键称为<strong>可替换键</strong> ( <span  class="math">\(alternate\;key\)</span> )。</p>

<h4 id="144-外键">1.4.4 外键</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>外键</strong> ( <span  class="math">\(Foreign\;key\)</span> ) 是关系中与另一个关系的候选键相匹配的属性或者属性集合。</p>

<h2 id="2-完整性约束">2. 完整性约束</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系数据模型是数据模型的结构部分。数据模型还包括操作部分和完整性约束。在上述部分中我们谈到的<strong>域约束</strong> ( <span  class="math">\(domain\;constraint\)</span> )，用于限定关系中属性的取值集合。此外还有<strong>实体完整性</strong> ( <span  class="math">\(entity\;integrity\)</span> ) 和<strong>引用完整性</strong> ( <span  class="math">\(referential\;integrity\)</span> )。其他的完整性约束还有<strong>多样性</strong> ( <span  class="math">\(multiplicity\)</span> ) 和<strong>一般性约束</strong> ( <span  class="math">\(general\;constraint\)</span> )。而在这之前，我们需要先了解<strong>空</strong> ( <span  class="math">\(null\)</span> )。</p>

<h3 id="21-空">2.1 空</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;空代表对一个元组当前取值还不知道或者是不可用的属性值。空并不是一个值，只是没有值的一种表示。空可能会导致执行问题，因为关系模型是基于一阶谓词演算的，而谓词演算只支持 <span  class="math">\(true\)</span> 和 <span  class="math">\(false\)</span> 两个值，而如果要允许空存在，则需要采用多值逻辑。</p>

<h3 id="22-实体完整性">2.2 实体完整性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实体完整性是指在基本关系中主键的属性不能为空。主键是能唯一标识元组的最小属性集合。如果内部存在空，就说明并不是所有属性都是唯一标识元组所必须的。这与主键的定义相悖。</p>

<h3 id="23-引用完整性">2.3 引用完整性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用完整性是指如果关系中存在外键，则它的值与主关系中某个元组的候选键取值相等，或者全部为空。</p>

<h3 id="24-一般性约束">2.4 一般性约束</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般性约束是由用户或者管理员指定的附加性规则，用于在某些方面进行约束。例如为某个属性的值添加上限等。</p>

<h2 id="3-视图">3. 视图</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系模型中的视图与<code>ANSI-SPARC</code>三层结构中的视图有所不同，它不完全是用户看到的外部模型，而是一个<strong>虚</strong> ( <span  class="math">\(virtual\)</span> ) /<strong>导出</strong> ( <span  class="math">\(derived\)</span> ) <strong>关系</strong>，即无需单独存在，在必要时从一个或多个基本关系中动态导出。一个外部模型可由基本关系（概念级）和基本关系的导出视图组成。</p>

<h3 id="31-术语">3.1 术语</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>基本关系</strong> ( <span  class="math">\(Base\;relation\)</span> ) 是一个与概念模式中的实体相对应的具有名字的关系，它的元组都存储在数据库的物理结构中。根据基本关系，我们可以定义视图。<strong>视图</strong>是对一个或多个基本关系进行关系操作得到的动态结果，是一个无需存在于数据库中，但却可以在需要时生成的虚关系。视图不存在存储器中，但其定义存储在系统目录中。对视图所做出的任何操作都会被自动转换称为对导出其的关系的操作。又由于视图是动态的，因此操作可以立即反映到基本关系上。</p>

<h3 id="32-作用">3.2 作用</h3>

<ol>
<li>对特定用户只显示特定的信息，提供了一个强大灵活的安全机制</li>
<li>允许用户自定义访问方法</li>
<li>简化复杂操作</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;视图的这些作用也提供了<em>逻辑数据独立性</em>。视图的引入也使我们能够进行概念模式的重构。只要通过重新定义视图，就可以在不影响到用户的情况下重组关系。</p>

<h3 id="33-更新">3.3 更新</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上所说，对视图所进行的操作会立即反映到关系中。同样的，对关系所进行的操作也会立即反映到视图中。但是这种方法存在约束：</p>

<ol>
<li>如果视图是由一个基本关系的简单查询生成，并且包含了主键或者候选键，那么就可以对其进行更新操作</li>
<li>如果视图涉及多个基本关系，那么就不可以对其进行更新操作</li>
<li>如果视图的生成中涉及了聚集或者分组操作，那么就不可以对其进行更新</li>
</ol>

            </div>
            <div class="meta post-footer"> <span>2020 May 15 13:08</span> <a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/">数据库系统（2）：数据库环境</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-ansisparc三层体系结构">1. <code>ANSI-SPARC</code>三层体系结构</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>三层体系结构</strong> ( <span  class="math">\(Three\;Level\;Architecture\)</span> )，包括<strong>外部层</strong> ( <span  class="math">\(External\)</span> )、<strong>概念层</strong> ( <span  class="math">\(Conceptual\)</span> ) 和<strong>内部层</strong> ( <span  class="math">\(Internal\)</span> )。用户从外部层观察数据，<code>DBMS</code>和操作系统从内部层观察数据。在内部层，数据使用定义的数据结构和文件组织方法进行存储。概念层则提供内部层和外部层的<strong>映射</strong> ( <span  class="math">\(Mapping\)</span> ) 以及必要的<strong>独立性</strong> ( <span  class="math">\(Independence\)</span> )。三层体系结构的目的是将用户的数据库视图与数据库的物理描述分离。</p>

<h3 id="11-外部层">1.1 外部层</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外部层是数据库的用户视图，这一层描述数据库中与用户相关的部分。对于每一个用户，数据库中都存储着其对用的视图。并且对于同一个数据，在不同的视图中可能有着不同的表达方式。</p>

<h3 id="12-概念层">1.2 概念层</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;概念层是数据库的整体视图，这一层描述哪些数据存储在数据库中，以及这些数据之间的联系。概念层描述：</p>

<ol>
<li>所有的实体、实体的属性和实体间的联系</li>
<li>数据的约束</li>
<li>数据的语义信息</li>
<li>安全性和完整性信息</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;概念层支持每一个外部视图，凡是用户可访问的数据必定包含在概念层或者由概念层导出。</p>

<h3 id="13-内部层">1.3 内部层</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内部层是数据库在计算机上的物理表示，这一层描述数据是如何存储在数据库中的。内部层与如下工作相关：</p>

<ol>
<li>数据和索引的存储空间分配</li>
<li>存储记录的描述</li>
<li>存储记录</li>
<li>数据压缩和加密</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在内部层之下是<strong>物理层</strong> ( <span  class="math">\(Physical\;Level\)</span> ) ，物理层可能在<code>DBMS</code>的指导下受操作系统的控制。</p>

<h3 id="14-模式映射和实例">1.4 模式、映射和实例</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对数据库的整体描述称为<strong>数据库模式</strong> ( <span  class="math">\(Database\;Schema\)</span> ) 。在数据库中存在三种不同类型的，在外部层有若干<strong>外部模式</strong> ( <span  class="math">\(External\;Schema\)</span> ) /<strong>子模式</strong> ( <span  class="math">\(Subschema\)</span> )，与不同的数据视图对应。在概念层有<strong><em>概念模式</em></strong> ( <span  class="math">\(Conceptual\;Schema\)</span> )，描述所有实体、属性和联系及其之间的完整性约束。在内部层，有<strong>内部模式</strong> ( <span  class="math">\(Internal\;Schema\)</span> )，是内部模型的完整描述，包括存储记录的定义、表示方法、数据域，必要时还有所使用的索引和散列方案。一个数据库可以有多个外部模式，但只能有一个概念模式和内部模式。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，对于一个数据库，其内部存储两张表 <span  class="math">\(A\)</span>, <span  class="math">\(B\)</span> ，这是其概念模式；而 <span  class="math">\(A\)</span>, <span  class="math">\(B\)</span> 内部行列的定义以及约束等是其内部模式；查询 <span  class="math">\(A\)</span>, <span  class="math">\(B\)</span> 所使用的视图 <span  class="math">\(V1\)</span>, <span  class="math">\(V2...\)</span> 是其外部模式。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DBMS</code>负责着三类模式之间的映射。概念模式通过概念层到内部层的映射与内部模式关联，每一个外部模式通过外部层到概念层的映射与概念模式关联。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库模式是在数据库设计过程中定义的，不会轻易改变。数据库中的数据是一个<strong>数据库实例</strong> ( <span  class="math">\(Database\;Instance\)</span> )，许多数据库实例可以与相同的数据库模式对应。模式有时称为数据库的<strong>内含</strong> ( <span  class="math">\(Intension\)</span> )，实例称为数据库的<strong>外延</strong> ( <span  class="math">\(Extension\)</span> ) /<strong>状态</strong> ( <span  class="math">\(State\)</span> )。</p>

<h3 id="15-数据库独立性">1.5 数据库独立性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三层体系结构的一个主要目的是保证数据独立性，即低层的修改不会影响高层。数据独立性分为<strong>逻辑数据独立性</strong> ( <span  class="math">\(Logical\;Data\;Independence\)</span> ) 和<strong>物理数据独立性</strong> ( <span  class="math">\(Physical\;Data\;Independence\)</span> )。逻辑数据独立性指的是外部模式不受概念模式的变化的影响。物理数据独立性指的是概念模式不受内部模式的变化的影响。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然两段映射可能降低效率，但提高了数据独立性。为了高效地映射，<code>ANSI-SPARC</code>模式也允许外部模式直接映射到内部模式，忽略概念模式。当然这降低了数据独立性。</p>

<h2 id="2-数据库语言">2. 数据库语言</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库语言包括<strong>数据定义语言</strong> ( <span  class="math">\(DDL\)</span> ) 和<strong>数据操作语言</strong> ( <span  class="math">\(DML\)</span> )。<code>DDL</code>用于说明数据库模式，<code>DML</code>用于读取和更新数据库。这些语言称为<em>数据子语言</em> ( <span  class="math">\(Data\;Sublanguages\)</span> )，因为它们不包括所有计算所需的成分。</p>

<h3 id="21-数据定义语言ddl">2.1 数据定义语言/<code>DDL</code></h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DDL</code>是一种供<code>DBA</code>或用户描述和命名应用所需实体、属性和联系及其相关的完整性约束和安全约束的语言。数据库模式是<code>DDL</code>表达的一组定义。虽然<code>DDL</code>可以用于定义或修改模式，但不能用于操作数据。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DDL</code>的编译结果是一组表格，存储在称为<strong>系统目录</strong>/<strong>数据字典</strong>/<strong>数据目录</strong>的特殊文件中。<strong>元数据</strong>存储在系统目录中，用于描述数据库中的对象。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理论上，<code>DDL</code>可以分为外部模式<code>DDL</code>、概念模式<code>DDL</code>和内部模式<code>DDL</code>，区分用于不同层中的<code>DDL</code>。但实际上只需提供一个足以说明外部模式和概念模式的<code>DDL</code>即可。</p>

<h3 id="22-数据操作语言dml">2.2 数据操作语言/<code>DML</code></h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DML</code>提供了一组基本操作，支持对数据库中存储数据进行各种处理操作，通常是增删改查，其中涉及数据检索的部分称为<strong>查询语言</strong>。查询语言被定义为一个高级的、具有特殊用途的语言，用于满足检索需要。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据检索机制，可以将<code>DML</code>分为<strong>过程化</strong> ( <span  class="math">\(Procedural\)</span> ) 的和<strong>非过程化</strong> ( <span  class="math">\(Nonprocedural\)</span> ) 的。过程化<code>DML</code>要求用于既告诉系统需要什么数据又要说明如何检索这些数据，通常用于<strong>网状</strong> ( <span  class="math">\(Network\)</span> ) /<strong>层次</strong> ( <span  class="math">\(Hierarchical\)</span> ) 数据库。而非过程化语言只需要用户告诉系统需要哪些数据，不需要说明如何检索它们，也称为<em>说明性语言</em> ( <span  class="math">\(Declarative\;Languages\)</span> )，通常用于<strong>关系</strong> ( <span  class="math">\(Relational\)</span> ) 数据库。典型的例子是，过程化语言单个处理记录，非过程化语言成组处理记录。</p>

<h3 id="23-第四代语言">2.3 第四代语言</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>第四代语言</strong> ( <span  class="math">\(4GL\)</span> ) 的组成目前并没有统一的认识，它实际上是一种快捷的编程语言，可以极大程度上减少操作。与过程化<code>3GL</code>相比，<code>4GL</code>一般是非过程化的。</p>

<h2 id="3-数据模型">3. 数据模型</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模式一般用某种<code>DDL</code>描述，实际上它一定是使用某个具体<code>DBMS</code>的<code>DDL</code>编写的。但是，这种方式不能被用户广泛理解，因此我们需要更高层次的模式描述，即<strong>数据模型</strong> ( <span  class="math">\(Data\;Model\)</span> )。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据模型是一组集成概念，用于描述和操作数据、数据间的联系以及对数据的约束。数据模型包含下列三个组件：</p>

<ol>
<li>结构部分，由创建数据库的规则组成；</li>
<li>操纵部分，定义允许对数据进行的操作的种类；</li>
<li>一组完整性约束，确保数据的准确性。</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据模型的目的是表示数据，并让其更容易理解。结合<code>ANSI-SPARC</code>体系结构，可以发现三种数据模型：</p>

<ol>
<li>外部数据模型，表示每一个用户的视图，有时称为<strong>论域</strong> ( <span  class="math">\(Universe\;of\;Discoures,\;UoD\)</span> )；</li>
<li>概念数据模型，表示独立于<code>DBMS</code>的逻辑/整体视图；</li>
<li>内部数据模型，表示<code>DBMS</code>能理解的概念模式。</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将数据模型划分为三类：<strong>基于对象的</strong> ( <span  class="math">\(Object-based\)</span> ) 、<strong>基于记录的</strong> ( <span  class="math">\(Record-based\)</span> ) 和<strong>物理的</strong> ( <span  class="math">\(Physical\)</span> ) ，前两者用于在概念层和外部层描述数据，最后一个在内部层描述数据。</p>

<h3 id="31-基于对象的数据模型">3.1 基于对象的数据模型</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于对象的数据模型用到实体、属性和联系等概念。<strong>实体</strong>是可区分的对象，在数据库中被描述；<strong>属性</strong>是对象的性质，描述对象的某个方面；<strong>联系</strong>是实体之间的关联。常见的基于对象的数据模型有：</p>

<ul>
<li>实体-联系 ( <span  class="math">\(ER\)</span> ) 模型</li>
<li>语义 ( <span  class="math">\(Semantic\)</span> ) 模型</li>
<li>函数模型</li>
<li>面向对象模型</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ER</code>模型已经是数据库设计的重要技术之一。面向对象的数据模型扩展了实体的定义，不仅包含了描述对象<strong>状态</strong>的属性，还包含了对象相关的动作/<strong>行为</strong> ( <span  class="math">\(behavior\)</span> )。对象被认为同时包含状态和行为。</p>

<h3 id="32-基于记录的数据模型">3.2 基于记录的数据模型</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在基于记录的数据模型中，数据库由若干不同类型的固定格式记录组成。每个记录类型有固定数量的字段，每个字段字段有固定的长度。基于记录的逻辑数据模型基本有三类：<strong>关系</strong>/<strong>网状</strong>/<strong>层次</strong>数据模型。现代商业系统大多数是基于关系模型的，早期的数据库系统是基于网状或者层次数据模型的。前者提供了较好的数据独立性，后两者要求用户了解物理数据库。因此关系系统采用<strong>说明性</strong> ( <span  class="math">\(declarative\)</span> ) 方法，即只需说明要检索的数据。网状和层次系统采用<strong>导航</strong> ( <span  class="math">\(Navigational\)</span> ) 方法，即要说明如何检索数据。</p>

<h4 id="321-关系数据模型">3.2.1 关系数据模型</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系数据模型基于数学上关系的概念。在关系模型中数据和联系均以表格的形式表示，每个表格有若干具有唯一名称的列。关系数据模型要求用户将数据库只看做表格，然而这种方式只适用于外部层和概念层，不适用于内部层。</p>

<h4 id="322-网状数据模型">3.2.2 网状数据模型</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在网状数据模型中，数据被表示成一组<strong>记录</strong>，联系被表示成<strong>络</strong> ( <span  class="math">\(Set\)</span> )。与关系数据模型相比更能体现联系，一般使用指针实现。记录被组织成图结构，记录是图的<strong>节点</strong> ( <span  class="math">\(Node\)</span> ) /段 ( <span  class="math">\(Segment\)</span> )，络是图的<strong>边</strong> ( <span  class="math">\(Edge\)</span> )。</p>

<p><figure><img src="/image/2020-5-14-1.png" alt="网状模式实例"></figure></p>

<h4 id="323-层次数据模型">3.2.3 层次数据模型</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;层次数据模型是网状数据模型的一种受限形式。数据被表示成一组记录，联系被表示成络。层次数据模型被表示为树形结构。记录作为节点，络作为边。</p>

<p><figure><img src="/image/2020-5-14-2.png" alt="层次模式实例"></figure></p>

<h3 id="33-物理数据模型">3.3 物理数据模型</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;物理数据模型描述数据如何存储在计算机中，涉及记录结构、记录顺序和访问路径等。最常见的是<em>统一模型</em> ( <span  class="math">\(Unifying\;Model\)</span> ) 和<em>帧存储</em> ( <span  class="math">\(Frame\;Memory\)</span> )。</p>

<h2 id="4-dbms的功能">4. <code>DBMS</code>的功能</h2>

<ol>
<li>数据存储、检索和更新</li>
<li>用户访问目录<br>
<code>ANSI-SPARC</code>体系结构提供了一个集成的系统目录，存储元数据，对于用户和<code>DBMS</code>都是可访问的。通常情况下，系统目录存储的元数据包括：

<ul>
<li>数据项的名字、类型和大小</li>
<li>联系的名字</li>
<li>数据的完整性约束</li>
<li>授权访问的用户</li>
<li>用户能访问的数据以及课执行的操作</li>
<li>外部、概念和内部模式及模式间映射</li>
<li>统计量，如访问频率和次数等<br>
<code>DBMS</code>系统目录是系统的基本组件，使用系统目录的优点有：</li>
<li>集中存放数据的信息，有助于控制数据资源</li>
<li>帮助用户了解数据的用途</li>
<li>简化信息通信，还可以确定用户权限</li>
<li>数据集成，减少冗余和不一致性</li>
<li>记录修改</li>
<li>可以在修改进行前确定其可能的影响</li>
<li>提高安全性</li>
<li>保证完整性</li>
<li>提供审计信息</li>
</ul></li>
<li>事务支持<br>
事务是由用户或者应用程序进行的一系列动作，这些动作将访问或者修改数据。<code>DBMS</code>提供了一个机制，用于确保事务内的所有操作全部进行或者不进行。</li>
<li>并发控制服务<br>
并发是使用<code>DBMS</code>的一个目的。<code>DBMS</code>必须保证多用户并行更新数据库时的同步。</li>
<li>恢复服务</li>
<li>授权服务</li>
<li>数据通信<br>
大多数用户是通过工作站访问数据库的。<code>DBMS</code>需要提供与通信软件集成的功能，能够以通信消息的方式接受和回复请求。对于用户远程访问数据库的行为，一般称为<em>分布式处理结构</em> ( <span  class="math">\(distributed\;processing\)</span> )。</li>
<li>完整性服务<br>
完整性即存储数据的正确性和一致性，通常以约束的形式实现。</li>
<li>提高数据独立性</li>
<li>实用服务程序<br>
使用程序能帮助<code>DBA</code>更加高效地管理数据库。<code>DBMS</code>应该提供一组实用服务程序，例如输入机制、监控机制、统计分析程序等。</li>
</ol>

<h2 id="5-多用户dbms结构">5. 多用户<code>DBMS</code>结构</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多用户<code>DBMS</code>常见结构包括远程处理 ( <span  class="math">\(teleprocessing\)</span> ) 、文件-服务器 ( <span  class="math">\(file-server\)</span> ) 和客户-服务器 ( <span  class="math">\(client-server\)</span> ) 结构。</p>

<h3 id="51-远程处理">5.1 远程处理</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;远程处理是传统的多用户系统结构。在该类系统中有一台由单个<code>CPU</code>和若干终端组成的计算机。所有的处理都交由该计算机进行，用户终端无处理能力，通过线缆连接，轮流使用<code>DBMS</code>服务。显然在这种结构下中央计算机将会有很大压力。</p>

<p><figure><img src="/image/2020-5-14-3.png" alt="远程处理的拓扑结构"></figure></p>

<h3 id="52-文件服务器结构">5.2 文件服务器结构</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>文件服务器</strong>是一台在网络上的计算机，主要用于提供共享存储服务。在文件服务器环境中，数据处理通常在局域网 ( <span  class="math">\(LAN\)</span> ) 上分布进行，文件服务器负责保管应用程序和<code>DBMS</code>所需的文件。应用程序和<code>DBMS</code>运行在各个工作站点上，必要时向文件服务器请求文件。文件服务器指示扮演了一个共享硬盘驱动器的角色。</p>

<p><figure><img src="/image/2020-5-14-4.png" alt="文件服务器结构"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件服务器结构的缺点：</p>

<ol>
<li>造成网络拥塞 ( <span  class="math">\(traffic\)</span> )</li>
<li>每台工作站上都要求有一个<code>DBMS</code>的副本</li>
<li>并发、恢复和完整性控制变得复杂，因为多个<code>DBMS</code>可以访问同一个文件</li>
</ol>

<h3 id="53-传统的两层客户服务器结构">5.3 传统的两层客户-服务器结构</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户-服务器指的是软组件相互作用形成系统的一种方式。客户是一个请求资源的进程，服务器提供资源。通常，服务器位于<code>LAN</code>的一个站点，而客户位于另外一些站点。</p>

<p><figure><img src="/image/2020-5-14-5.png" alt="客户-服务器结构"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据密集型的业务应用程序一般由四个主要部分组成：数据库、事务逻辑、业务及数据应用逻辑和用户界面。在传统的两层客户-服务器结构中，客户端（第一层）主要负责针对用户的数据<em>表示</em>，服务器端（第二层）主要负责为客户端提供<em>数据服务</em>。表示服务负责处理用户交互活动和主要的业务及数据应用逻辑。数据服务负责提供优先的业务应用逻辑。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端和服务器之间交互的典型过程是，客户端接收用户的请求，产生数据库请求，然后将其传递给服务器。服务器接收和处理数据库请求，并将结果回传给客户端。客户端将响应格式化并传递给终端用户。</p>

<table>
<thead>
<tr>
<th align="center">客户端</th>
<th align="center">服务器</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">管理用户界面</td>
<td align="center">接受和处理来自客户端的数据库请求</td>
</tr>

<tr>
<td align="center">接受和检查用户输入的语法</td>
<td align="center">检查授权</td>
</tr>

<tr>
<td align="center">处理应用逻辑</td>
<td align="center">确保不违反完整性约束</td>
</tr>

<tr>
<td align="center">产生数据库请求并传递给服务器</td>
<td align="center">执行查询/更新操作并将结果返回给客户端</td>
</tr>

<tr>
<td align="center">将结果返回给用户</td>
<td align="center">维护系统目录</td>
</tr>

<tr>
<td align="center"></td>
<td align="center">提供并发的数据库访问</td>
</tr>

<tr>
<td align="center"></td>
<td align="center">提供恢复控制</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种结构具有许多优点：</p>

<ol>
<li>广泛支持对现存数据库的访问</li>
<li>增强性能，<code>CPU</code>可以并行处理应用程序</li>
<li>降低硬件费用，服务器只需要提供一定的存储空间和处理能力来管理数据库</li>
<li>降低通信费用，只有数据库访问请求需要传递</li>
<li>增强一致性，服务器可以处理完整性检查，无需在每个客户端进行</li>
<li>能自然地映射到开放系统结构上</li>
</ol>

<h3 id="54-三层客户服务器结构">5.4 三层客户-服务器结构</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着应用程序越来越复杂，传统的两层客户-服务器结构已经不能满足需求。因此三层客户-服务器结构出现了。三层分别是：</p>

<ol>
<li>用户界面层，运行在终端用户的计算机上（客户端）</li>
<li>业务逻辑和数据处理层，运行在服务器上，通常称之为<em>应用服务器</em></li>
<li><code>DBMS</code>层，存储中间层所需的数据，通常运行在<em>数据库服务器</em>上</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在三层结构中，客户端仅仅负责应用程序的用户界面和一些简单的业务逻辑。应用程序的核心业务逻辑分离出来，处于一个单独的层上，通过<code>LAN</code>或者<code>WAN</code> (广域网) 物理连接到客户端和数据库服务器。一个应用服务器可以为多个客户端提供服务。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与传统的两层和单层相比，三层的优点有：</p>

<ol>
<li>降低对硬件设备的需求</li>
<li>业务逻辑转移到专门的服务器上使得维护可以集中进行</li>
<li>修改一层并不会影响其他层</li>
<li>核心业务逻辑和数据库功能的分离使得负载均衡更容易进行</li>
</ol>

<h3 id="55-n层客户服务器结构">5.5 N层客户-服务器结构</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过扩展，三层结构可以升级为 <span  class="math">\(N\)</span> 层结构，进一步提高灵活性和可伸缩性。扩展主要是在中间层上，可以将原来的应用服务器扩展为<code>Web</code>服务器和应用服务器。在高流量的环境下，单个<code>Web</code>服务器可以进一步扩展为一组<code>Web</code>服务器，提供更加高效的负载均衡。</p>

            </div>
            <div class="meta post-footer"> <span>2020 May 14 11:09</span> <a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/">数据库系统（1）：数据库简介</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-基于文件的系统">1. 基于文件的系统</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>基于文件的系统</strong> ( <span  class="math">\(Traditional\;File-Based\;Systems\)</span> ) 是一组为终端用户提供服务的应用程序，每一个程序定义和管理它自己的数据。相较于使用纸质文件进行管理的手工文件系统，基于文件的系统更加高效。但是它未能集中存储组织机构的运行数据，而是采用了分散的方法，即每一个部门在<strong>数据处理</strong> ( <span  class="math">\(DP\)</span> ) 人员的帮助下存储和控制它们的数据。通过编写应用程序来管理和查询数据，具有<strong>程序-数据依赖性</strong> ( <span  class="math">\(Program-data\;Dependence\)</span> ) 。</p>

<h3 id="11-术语">1.1 术语</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>文件</strong> ( <span  class="math">\(File\)</span> ) 是一些<strong>记录</strong> ( <span  class="math">\(Records\)</span> ) 的简单集合，这些记录中包含逻辑上相关的数据。每一条记录包含一组逻辑上相关的一个或多个<strong>数据项/域</strong> ( <span  class="math">\(Fields\)</span> ) 。</p>

<h3 id="12-局限性">1.2 局限性</h3>

<ol>
<li><strong>数据被分离和孤立</strong><br>
数据被孤立在分离的文件中，如果要访问处于不同文件之间的数据，需要创建一个临时文件。</li>
<li><strong>数据存在冗余</strong><br>
由于文件间的分离，有时需要重复记录一些数据。</li>
<li><strong>数据存在依赖性</strong><br>
数据文件的物理结构和存储方式是由应用程序定义的，很难做出改变，也即程序-数据依赖性。</li>
<li><strong>文件格式不相容</strong><br>
文件结构嵌入应用程序，因此由应用程序语言决定。难以兼容其他使用不同语言的文件结构。</li>
<li><strong>需要不断更改应用程序</strong><br>
完全依赖于开发人员，要求开发人员以编程方式实现所有查询和表。如果查询需求发生了变化，需要重新编写程序或更改文件。</li>
</ol>

<h2 id="2-数据库方法">2. 数据库方法</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于文件的系统存在许多问题，总结原因是：</p>

<ol>
<li>数据内嵌应用程序</li>
<li>无法实现程序规定之外的操作</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此我们需要一种更加高效的方法，<strong>数据库</strong> ( <span  class="math">\(Database\)</span> ) 和 <strong>数据库管理系统</strong> ( <span  class="math">\(Database\;Management\;System,\;DBMS\)</span> ) 应运而生。</p>

<h3 id="21-数据库">2.1 数据库</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库是为满足某个组织机构的信息要求而设计的一个逻辑相关数据及其描述的共享集合。在数据库内，所有的数据项都被集中起来，具有很少的冗余，为所有部门共享的资源。在其内部不仅含有组织的运行数据，还含有对这些数据的描述。因此，有时数据库也被定义为<em>一组集成记录的自描述的集合</em>。</p>

<h4 id="211-术语">2.1.1 术语</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对数据的描述称为<strong>系统目录</strong> ( <span  class="math">\(system\;catalog\)</span> ) /<strong>数据字典</strong> ( <span  class="math">\(Data\;Dictionary\)</span> ) /<strong>元数据</strong> ( <span  class="math">\(Metadata\)</span> ) 。也正是因为该功能，数据库具有<strong>程序-数据独立性</strong> ( <span  class="math">\(Program-data\;Independence\)</span> ) 。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库系统采用数据的定义与程序分离的方法，对象使用者只能看到对象的外部定义，不能看到其内部工作原理。以此，我们可以任意更改其内部定义而不影响到外部定义，这个优点称为<strong>数据抽象</strong> ( <span  class="math">\(Data\;Abstraction\)</span> ) 。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>实体</strong> ( <span  class="math">\(Entity\)</span> ) 是一个独立的、将要在数据库中体现出来的对象。<strong>属性</strong> ( <span  class="math">\(Attribute\)</span> ) 描述我们想要记录的对象的某一方面的特性。<strong>联系</strong> ( <span  class="math">\(Relationship\)</span> ) 描述实体之间的关联。</p>

<h3 id="22-数据库管理系统">2.2 数据库管理系统</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DBMS</code>是一个支持用户对数据库进行定义、创建、维护及控制访问的软件系统。与基于文件的系统相比，数据的物理结构和存储结构是由<code>DBMS</code>定义的。</p>

<h4 id="221-功能">2.2.1 功能</h4>

<ol>
<li>通过使用<strong>数据定义语言</strong> ( <span  class="math">\(Data\;Definition\;Language\)</span>, <span  class="math">\(DDL\)</span> ) ，用户可以指定数据类型、数据结构以及被存储到数据库中的数据的约束；</li>
<li>通过使用<strong>数据操作语言</strong> ( <span  class="math">\(Data\;Manipulation\;Language\)</span>, <span  class="math">\(DML\)</span> ) ，用户可以在数据库中进行增删改查操作。由于集中存放所有的数据和数据描述，因此允许<code>DML</code>提供给一个对这些数据进行一般查询的机制，称为<strong>查询语言</strong> ( <span  class="math">\(Query\;Language\)</span> ) ，最常见的查询语言是<strong>结构化查询语言</strong> ( <span  class="math">\(Structured\;Query\;Language\)</span>, <span  class="math">\(SQL\)</span> ) ；</li>
<li>提供数据库的受控访问。<br>

<ol>
<li>安全系统，禁止未授权的用户访问数据库</li>
<li>完整性系统，保持所有数据一致性</li>
<li>并发控制系统，允许数据库的共享访问</li>
<li>恢复控制系统，能够将数据库恢复到故障前的状态</li>
<li>用户访问目录，描述数据库中的数据</li>
</ol></li>
</ol>

<h3 id="23-数据库应用程序">2.3 数据库应用程序</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库应用程序是通过向<code>DBMS</code>提出请求来与数据库交互的程序。</p>

<h4 id="231-视图">2.3.1 视图</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;视图 ( <span  class="math">\(View\)</span> ) 是数据库的一个子集，用于查看数据。使用视图的优点：</p>

<ol>
<li>提供保密级别，可以将一些用户不能查看的数据排除在外</li>
<li>提供一个自定义数据库外观的机制</li>
<li>动态，当数据库改变时仍可以查询数据，有助于提高程序-数据独立性。</li>
</ol>

<h2 id="3-dbms环境的组成部分">3. <code>DBMS</code>环境的组成部分</h2>

<ol>
<li>硬件<br>
<code>DBMS</code>和应用程序的运行要求硬件支撑，可以是一台个人计算器或者是计算机连接的网络，有些<code>DBMS</code>只能在特定的系统上运行。一般<code>DBMS</code>都对内存和外存具有一个最低要求。</li>
<li>软件<br>
软件包含<code>DBMS</code>、<code>DBMS</code>应用程序和操作系统，如果是在网络中使用，还包括网络软件。</li>
<li>数据<br>
从用户的观点来看，数据是<code>DBMS</code>环境中最重要的部分，在机器和人之间起到了桥梁的作用。数据库结构称为<strong>模式</strong> ( <span  class="math">\(Schema\)</span> ) ，模式包含四个文件/<strong>表</strong> ( <span  class="math">\(Table\)</span> ) ，表中存储字段/<strong>属性</strong>。</li>
<li>过程<br>
过程是对数据库的设计和使用进行控制的一组命令和规则。系统用户和数据库管理人员要求提供使用和运行<code>DBMS</code>的文档形式的过程说明。</li>
<li>人

<ol>
<li>管理数据资源的<strong>数据管理员</strong> ( <span  class="math">\(DA\)</span> )；</li>
<li>负责数据库的物理实现的<strong>数据库管理员</strong> ( <span  class="math">\(DBA\)</span> )；</li>
<li>负责标识数据、数据之间联系以及对存储到数据库的数据的约束/<strong>业务规则</strong> ( <span  class="math">\(Business\;Rules\)</span> ) 的<strong>逻辑数据库设计人员</strong> ( <span  class="math">\(Logical\;Database\;Designer\)</span> )；决定逻辑数据库的设计如何以武力的形式实现的<strong>物理数据库设计人员</strong> ( <span  class="math">\(Physical\;Database\;Designer\)</span> )。两者统称为<strong>数据库设计人员</strong>；</li>
<li><strong>应用开发人员</strong> ( <span  class="math">\(Application\;Developers\)</span> ) 开发满足终端用户功能需求的应用程序；</li>
<li><strong>终端用户</strong> ( <span  class="math">\(End-Users\)</span> ) ，包括不了解<code>DBMS</code>的<strong>简单用户</strong> ( <span  class="math">\(Naive\;User\)</span> ) 和对数据库结构与<code>DBMS</code>相当熟悉的<strong>熟练用户</strong> ( <span  class="math">\(Sophisticated\;Users\)</span> )。</li>
</ol></li>
</ol>

<h2 id="4-dbms的优点和缺点">4. <code>DBMS</code>的优点和缺点</h2>

<h3 id="41-优点">4.1 优点</h3>

<ol>
<li>受控的数据冗余；</li>
<li>数据一致性；</li>
<li>相同数据量表示更多信息；</li>
<li>数据共享；</li>
<li>增强的数据完整性；<br>
完整性指的是数据的有效性和一致性，通常使用完整约束进行表达，约束指的是数据库不能违反的一致性规则。</li>
<li>增强的安全性；</li>
<li>强制执行标准；</li>
<li>经济合算的规模；</li>
<li>平衡各种需求冲突；</li>
<li>增强的数据可访问性和响应性；</li>
<li>提高生产率；</li>
<li>通过数据独立性增强可维护性；<br>
<code>DBMS</code>将数据从应用程序中分离出来，使数据描述的改变不再影响应用程序，这就是<strong>数据独立性</strong> ( <span  class="math">\(Data-Independence\)</span> )。</li>
<li>提高并发性；</li>
<li>增强的备份和恢复服务。</li>
</ol>

<h3 id="42-缺点">4.2 缺点</h3>

<ol>
<li>复杂；</li>
<li>体积大；</li>
<li>昂贵；</li>
<li>需要附加的硬件专门用于存储和运行；</li>
<li>转化费用高。与其将现有应用转为可在<code>DBMS</code>和硬件上运行的应用，不如购买新的<code>DBMS</code>和硬件；</li>
<li>性能低。<code>DBMS</code>需要满足不同用途因而性能较低；</li>
<li>增加了系统的脆弱性，任何组成部分的故障都可能导致停止运行。</li>
</ol>

            </div>
            <div class="meta post-footer"> <span>2020 May 13 14:23</span> <a href="/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/redis%E7%AC%94%E8%AE%B0/">Redis笔记</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-redis简介">1. <code>Redis</code>简介</h2>

<p><code>NoSQL</code>即 <span  class="math">\(Not-Only\;SQL\)</span> ，是<code>RDBMS</code>的补充。<br>
<code>Redis</code>是一种<code>NoSQL</code>数据库，是一个使用<code>C</code>语言开发的开源的高性能键值对数据库，内部使用单线程机制进行工作。</p>

<ol>
<li><span  class="math">\(set\;[key]\;[value]\)</span>&nbsp;&nbsp;添加信息,</li>
<li><span  class="math">\(get\;[key]\)</span> &nbsp;&nbsp; 查询信息，为空返回 <span  class="math">\(nil\)</span> ,</li>
<li><span  class="math">\(del\;[key]\)</span>&nbsp;&nbsp;删除信息，<span  class="math">\(1\)</span> 代表删除成功,</li>
<li><span  class="math">\(clear\)</span>&nbsp;&nbsp;清屏,</li>
<li><span  class="math">\(help\;[op]\)</span>&nbsp;&nbsp;帮助,</li>
<li><span  class="math">\(time\)</span>&nbsp;&nbsp;获取时间.</li>
</ol>

<h2 id="2-数据类型">2. 数据类型</h2>

<p><code>Redis</code>采用键值对的方式存储，<span  class="math">\(key\)</span> 为字符串，<span  class="math">\(value\)</span> 则允许多种类型。</p>

<h3 id="21-string">2.1 <code>string</code></h3>

<p>最简单的数据类型，最大存储量 <span  class="math">\(512MB\)</span> ，
可以作为数字使用，最大值为 <span  class="math">\(java.lang.Long\)</span> 类型的最大值，
允许以<code>JSON</code>对象的方式存储数据，值中间不能有空白符</p>

<ol>
<li><span  class="math">\(mset/mget\)</span>&nbsp;&nbsp;获取多个数据</li>
<li><span  class="math">\(strlen\)</span>&nbsp;&nbsp;获取字符个数</li>
<li><span  class="math">\(append\)</span>&nbsp;&nbsp;追加，返回总长度，也可以用于添加信息</li>
<li><span  class="math">\(incr/incrby/incrbyfloat\)</span>&nbsp;&nbsp;指定数据增加指定值，允许负数，返回数值</li>
<li><span  class="math">\(decr/decrby\)</span>&nbsp;&nbsp;指定数据减少指定的值，允许负数，返回数值</li>
<li><span  class="math">\(setex/psetex\)</span>&nbsp;&nbsp;设定数据周期，秒/毫秒</li>
</ol>

<h3 id="22-hash">2.2 <code>hash</code></h3>

<p><code>hash</code> 属于 <span  class="math">\(value\)</span> ，其中包含多组键值对，键称为 <span  class="math">\(field\)</span> ，键值对较少时为类数组结构，较多时为 <span  class="math">\(HashMap\)</span> 结构，<span  class="math">\(value\)</span> 只能为 <code>string</code> ，且最多只能有 <span  class="math">\(2^{32} - 1\)</span> 组。</p>

<ol>
<li><span  class="math">\(hset/hmset\)</span> ,</li>
<li><span  class="math">\(hget/hmget/hgetall\)</span> ,</li>
<li><span  class="math">\(hdel\)</span> ,</li>
<li><span  class="math">\(hlen\)</span>&nbsp;&nbsp;字段数量,</li>
<li><span  class="math">\(hexists\)</span>&nbsp;&nbsp;字段存在,</li>
<li><span  class="math">\(hkeys\)</span>&nbsp;&nbsp;获取所有 <span  class="math">\(key\)</span> ,</li>
<li><span  class="math">\(hvals\)</span>&nbsp;&nbsp;获取所有 <span  class="math">\(value\)</span> ,</li>
<li><span  class="math">\(hincrby/hincrbyfloat\)</span> ,</li>
<li><span  class="math">\(hsetnx\)</span>&nbsp;&nbsp;当前 <span  class="math">\(key\)</span> 的 <span  class="math">\(field\)</span> 不存在时才设置.</li>
</ol>

<h3 id="23-list">2.3 <code>list</code></h3>

<p>保存多个数据，底层使用双向链表实现<br>
内部数据都是<code>string</code>类型，可以进行索引操作，最多保存 <span  class="math">\(2^{32} - 1\)</span> 个元素</p>

<ol>
<li><span  class="math">\(lpush/rpush\)</span>&nbsp;&nbsp;添加</li>
<li><span  class="math">\(lrange/lindex\)</span>&nbsp;&nbsp;获取，可以通过 <span  class="math">\(0\;-1\)</span> 查询全部数据</li>
<li><span  class="math">\(llen\)</span>&nbsp;&nbsp;长度</li>
<li><span  class="math">\(lpop/rpop\)</span>&nbsp;&nbsp;删除</li>
<li><span  class="math">\(blpop/brpop\)</span>&nbsp;&nbsp;周期内等待获取并删除（阻塞)</li>
<li><span  class="math">\(lrem\)</span>&nbsp;&nbsp;移除指定数据，<span  class="math">\(count\)</span> 可以指定删除个数</li>
</ol>

<h3 id="24-set">2.4 <code>set</code></h3>

<p>用于存储大量数据，拥有高效的查询机制。<br>
<code>set</code>与<code>hash</code>结构相同，但仅使用 <span  class="math">\(field\)</span> ，<span  class="math">\(value\)</span> 为 <span  class="math">\(nil\)</span></p>

<ol>
<li><span  class="math">\(sadd\)</span>&nbsp;&nbsp;添加</li>
<li><span  class="math">\(smembers\)</span>&nbsp;&nbsp;获取全部</li>
<li><span  class="math">\(srem\)</span>&nbsp;&nbsp;删除</li>
<li><span  class="math">\(scard\)</span>&nbsp;&nbsp;个数</li>
<li><span  class="math">\(sismember\)</span>&nbsp;&nbsp;存在</li>
<li><span  class="math">\(srandmember\)</span>&nbsp;&nbsp;随机</li>
<li><span  class="math">\(spop\)</span>&nbsp;&nbsp;随机并移除</li>
<li><span  class="math">\(sinter/sunion/sdiff\)</span>&nbsp;&nbsp;交并差，差具有方向</li>
<li><span  class="math">\(sinterstore/sunionstore/sdiffstore\)</span>&nbsp;&nbsp;交并差并存储</li>
<li><span  class="math">\(smove\)</span>&nbsp;&nbsp;移动</li>
</ol>

<h3 id="25-sortedsetzset">2.5 <code>sorted_set</code>/<code>zset</code></h3>

<p>保存可排序的数据，在<code>set</code>的基础上添加可排序字段，称为 <span  class="math">\(score\)</span>。<br>
保存的数据空间是 <span  class="math">\(64\)</span> 位，可以是一个 <span  class="math">\(double\)</span> 值。</p>

<ol>
<li><span  class="math">\(zadd\)</span> ,</li>
<li><span  class="math">\(zrange/zrevrange\)</span>&nbsp;&nbsp;升序/降序，最后添加 <span  class="math">\(withscores\)</span> 可以显示 <span  class="math">\(score\)</span> ,</li>
<li><span  class="math">\(zrem\)</span> ,</li>
<li><span  class="math">\(zrangebyscore/zrevrangebyscore\)</span>&nbsp;&nbsp;条件查询,</li>
<li><span  class="math">\(zremrangebyrank/zremrangebyscore\)</span>&nbsp;&nbsp;条件删除,</li>
<li><span  class="math">\(zcard/zcount\)</span> ,</li>
<li><span  class="math">\(zinterstore/zunionstore\)</span>&nbsp;&nbsp;可以通过 <span  class="math">\(aggregate\)</span> 指定 <span  class="math">\(score\)</span> 值得处理方式,</li>
<li><span  class="math">\(zrank/zrevrank\)</span>&nbsp;&nbsp;获取排位,</li>
<li><span  class="math">\(zscore/zincrby\)</span> <span  class="math">\(score\)</span>&nbsp;&nbsp;设置.</li>
</ol>

<h2 id="3-通用命令">3. 通用命令</h2>

<h3 id="31-key">3.1 <code>key</code></h3>

<ol>
<li><span  class="math">\(del/exists/type\)</span>&nbsp;&nbsp;删除/存在/类型,</li>
<li><span  class="math">\(expire/pexpire/expireat/pexpireat\)</span>&nbsp;&nbsp;设置周期，后两者指定 <span  class="math">\(timestamp\)</span> ,</li>
<li><span  class="math">\(ttl/pttl\)</span>&nbsp;&nbsp;获取周期，<span  class="math">\(-2/-1\)</span> 分别代表不存在和永久,</li>
<li><span  class="math">\(persist\)</span>&nbsp;&nbsp;转换为永久,</li>
<li><span  class="math">\(keys\)</span>&nbsp;&nbsp;查询,</li>
<li><span  class="math">\(rename/renamenx\)</span>&nbsp;&nbsp;重命名，后者只有不存在时才会执行,</li>
<li><span  class="math">\(sort\)</span> ,</li>
<li><span  class="math">\(help\;@generic\)</span>&nbsp;&nbsp;查询所有相关命令,</li>
</ol>

<h3 id="32-db">3.2 <code>db</code></h3>

<p><code>Redis</code>为每个服务提供了 <span  class="math">\(16\)</span> 个数据库，相互独立。</p>

<ol>
<li><span  class="math">\(select\)</span>&nbsp;&nbsp;切换,</li>
<li><span  class="math">\(ping\)</span>&nbsp;&nbsp;测试服务器连接,</li>
<li><span  class="math">\(echo\)</span> ,</li>
<li><span  class="math">\(move\)</span>&nbsp;&nbsp;如果指定数据库包含同名 <span  class="math">\(key\)</span> ，则不会移动,</li>
<li><span  class="math">\(flushdb/flushall\)</span>&nbsp;&nbsp;清除,</li>
<li><span  class="math">\(dbsize\)</span>&nbsp;&nbsp;当前数据库大小查询.</li>
</ol>

<h2 id="4-jedis">4. <code>Jedis</code></h2>

<p><code>Redis</code>中的指令名称与<code>Jedis</code>中的方法名相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//  连接
</span><span class="c1"></span>    <span class="n">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Jedis</span><span class="o">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="o">,</span> <span class="n">6379</span><span class="o">);</span>
<span class="c1">//  操作
</span><span class="c1"></span>    <span class="n">jedis</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">,</span> <span class="s">&#34;example&#34;</span><span class="o">);</span>
<span class="c1">//  关闭
</span><span class="c1"></span>    <span class="n">jedis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span></code></pre></div>
<p><span  class="math">\(JedisPool\)</span> 对象<br/></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JedisUtils</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="n">JedisPool</span> <span class="n">jedisPool</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">host</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">port</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">maxTotal</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">maxIdle</span><span class="o">;</span>

  <span class="kd">static</span> <span class="o">{</span>
    <span class="n">ResourceBundle</span> <span class="n">resourceBundle</span> <span class="o">=</span> <span class="n">ResourceBundle</span><span class="o">.</span><span class="na">getBundle</span><span class="o">(</span><span class="s">&#34;redis&#34;</span><span class="o">);</span>
    <span class="n">host</span> <span class="o">=</span> <span class="n">resourceBundle</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">&#34;redis.host&#34;</span><span class="o">);</span>
    <span class="n">port</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">resourceBundle</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">&#34;redis.port&#34;</span><span class="o">));</span>
    <span class="n">maxTotal</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">resourceBundle</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">&#34;redis.maxTotal&#34;</span><span class="o">));</span>
    <span class="n">maxIdle</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">resourceBundle</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">&#34;redis.maxIdle&#34;</span><span class="o">));</span>
    <span class="n">JedisPoolConfig</span> <span class="n">jedisPoolConfig</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JedisPoolConfig</span><span class="o">();</span>
    <span class="n">jedisPoolConfig</span><span class="o">.</span><span class="na">setMaxTotal</span><span class="o">(</span><span class="n">maxTotal</span><span class="o">);</span>
    <span class="n">jedisPoolConfig</span><span class="o">.</span><span class="na">setMaxIdle</span><span class="o">(</span><span class="n">maxIdle</span><span class="o">);</span>
    <span class="n">jedisPool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JedisPool</span><span class="o">(</span><span class="n">jedisPoolConfig</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Jedis</span> <span class="nf">getJedis</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">jedisPool</span><span class="o">.</span><span class="na">getResource</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<h2 id="5-linux下的redis操作">5. <code>Linux</code>下的<code>Redis</code>操作</h2>

<ol>
<li><span  class="math">\(redis-server\;--port\)</span>&nbsp;&nbsp;更改端口,</li>
<li><span  class="math">\(redis-cli\;-h\;-p\)</span>&nbsp;&nbsp;设置主机和端口,</li>
<li><span  class="math">\(redis.conf\)</span> .</li>
</ol>
<pre><code class="language-conf" data-lang="conf"># 端口
port 6379
# 保护模式，开启后只能通过本地访问
protected-mode no
# 以守护进程方式启动, docker 环境下启动需设置为 no
daemonize no
# 日志文件名
logfile &#34;6379.log&#34;
# 日志文件路径
dir /data</code></pre>
<h2 id="6-持久化">6. 持久化</h2>

<p>利用永久性存储介质保存数据，用于防止数据意外丢失。</p>

<ol>
<li><code>RDB</code> 保存当前数据，速度较快，但是不能保证实时性，且当数据较多时会明显变慢，快照形式,</li>
<li><code>AOF</code> 保存操作，能够实现实时性，日志形式.</li>
</ol>

<h3 id="61-rdb指令">6.1 <code>RDB</code>指令</h3>

<h4 id="611-save">6.1.1 save</h4>

<p>通过<code>RDB</code>模式进行持久化，文件默认保存在 <span  class="math">\(/data/dump.rdb\)</span> 中。执行过程中会阻塞服务器，直到<code>RDB</code>过程完成，不建议在线上环境中使用。</p>
<pre><code class="language-conf" data-lang="conf"># 文件名
dbfilename &#34;dump-6379.rdb&#34;
# 文件路径
dir /data
# 是否压缩（LZF压缩）
rdbcompression no
# 是否进行数据校验
rdbchecksum no</code></pre>
<h4 id="622-bgsave">6.2.2 bgsave</h4>

<p>后台进行持久化，会调用 <span  class="math">\(fork\)</span> 函数生成一个子进程，可以在日志文件中查询记录。</p>
<pre><code class="language-conf" data-lang="conf"># 后台保存出错时是否停止操作，默认开启
stop-writes-on-bgsave-error yes</code></pre>
<h4 id="623-自动">6.2.3 自动</h4>
<pre><code class="language-conf" data-lang="conf"># 如果在10秒内有2个key改变，就执行bgsave
bgsave 10 2</code></pre>
<h3 id="62-rdb特殊启动模式">6.2 <code>RDB</code>特殊启动模式</h3>

<ol>
<li>全量复制</li>
<li><span  class="math">\(debug\;reload\)</span>&nbsp;&nbsp;服务器运行过程中重启,</li>
<li><span  class="math">\(shutdown\;save\)</span>&nbsp;&nbsp;关闭服务器时保存.</li>
</ol>

<h3 id="63-aof">6.3 <code>AOF</code></h3>

<p>写指令会先被发送到<code>AOF</code>写命令刷新缓冲区，生成 <span  class="math">\(.aof\)</span> 文件。</p>
<pre><code class="language-conf" data-lang="conf"># 开启AOF
appendonly yes
# AOF策略，always/everysec/no
appendfsync everysec
# 文件名
appendfilename &#34;appendonly-6379.aof&#34;
# 路径
dir /data</code></pre>
<p><code>AOF</code>策略：</p>

<ol>
<li><span  class="math">\(always\)</span>&nbsp;&nbsp;每次，通过 <span  class="math">\(fork\)</span> 生成子进程进行,</li>
<li><span  class="math">\(everysec\)</span>&nbsp;&nbsp;每秒，通过 <span  class="math">\(fork\)</span> 生成子进程，将操作存储在<code>AOF</code>缓存区中，如果是重写，还会有<code>aof</code>重写缓存区，时间到达后写入,</li>
<li><span  class="math">\(no\)</span>&nbsp;&nbsp;系统控制.</li>
</ol>

<h3 id="64-aof重写">6.4 <code>AOF</code>重写</h3>

<ol>
<li><span  class="math">\(bgrewriteaof\)</span>&nbsp;&nbsp;后台重写,</li>
<li>自动<br>

<ol>
<li><span  class="math">\(auto-aof-rewrite-min-size\)</span>  最小重写大小,</li>
<li><span  class="math">\(auto-aof-rewirte-percentage\)</span> 自动重写百分比.</li>
</ol></li>
</ol>

<p>执行 <span  class="math">\(info\;Persistence\)</span> 指令可以查询持久化信息。<br>
当</p>

<p><span  class="math">\(aof_-current_-size>auto-aof-rewrite-min-size\\
\Large\frac{aof_-current_-size-aof_-base_-size}{aof_-base_-size}\normalsize>=auto-aof-rewrite-percentage\)</span>,</p>

<p>时触发自动重写。</p>

<h3 id="65-对比">6.5 对比</h3>

<table>
<thead>
<tr>
<th align="center">&nbsp;</th>
<th align="center"><code>RDB</code></th>
<th align="center"><code>AOF</code></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">占用存储空间</td>
<td align="center">小（压缩）</td>
<td align="center">大（重写）</td>
</tr>

<tr>
<td align="center">存储速度</td>
<td align="center">慢</td>
<td align="center">快</td>
</tr>

<tr>
<td align="center">恢复速度</td>
<td align="center">快</td>
<td align="center">慢</td>
</tr>

<tr>
<td align="center">数据安全性</td>
<td align="center">会丢失</td>
<td align="center">依据策略</td>
</tr>

<tr>
<td align="center">资源消耗</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>

<tr>
<td align="center">启动优先级</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
</tbody>
</table>

<h2 id="7-事务">7. 事务</h2>

<p>类似于<code>DBMS</code>中的事务，命令在事务内并不会立即执行。</p>

<ol>
<li><span  class="math">\(multi\)</span>&nbsp;&nbsp;开启事务,</li>
<li><span  class="math">\(exec\)</span>&nbsp;&nbsp;执行事务,</li>
<li><span  class="math">\(discard\)</span>&nbsp;&nbsp;取消事务.</li>
</ol>

<h3 id="71-流程">7.1 流程</h3>

<ol>
<li>服务器接收到指令后会判断是否处于事务状态,</li>
<li>接收到 <span  class="math">\(multi\)</span> 指令后会创建队列，转换为事务状态,</li>
<li>之后再接收指令时，会把指令加入队列,</li>
<li>接收到 <span  class="math">\(exec\)</span> 指令时，依次执行队列中的指令,</li>
<li>如果接收到 <span  class="math">\(discard\)</span> 指令，销毁队列.</li>
</ol>

<p>如果命令中存在语法错误，则整个事务都会被销毁。</p>

<h3 id="72-锁">7.2 锁</h3>

<ol>
<li><span  class="math">\(watch\)</span>&nbsp;&nbsp;添加监视锁，如果在 <span  class="math">\(exec\)</span> 之前发生了变化则终止事务执行(<span  class="math">\(exec\)</span> 返回 <span  class="math">\(nil\)</span>)，监视锁要在开启事务之前设置,</li>
<li><span  class="math">\(unwatch\)</span>&nbsp;&nbsp;取消全部监视锁,</li>
<li><span  class="math">\(setnx\)</span>&nbsp;&nbsp;添加公共锁，若有返回值则设置失败,</li>
<li><span  class="math">\(del\)</span>&nbsp;&nbsp;删除公共锁,</li>
<li><span  class="math">\(expire/pexpire\)</span>&nbsp;&nbsp;为锁添加时效，防止长时间被占用.</li>
</ol>

<h2 id="8-删除策略">8. 删除策略</h2>

<p>在使用 <span  class="math">\(expire\)</span> 等操作设置数据周期时，会将数据地址和过期时间以哈希键值对的方式存储在 <span  class="math">\(expires\)</span> 块中，<code>Redis</code>的每个数据库都有一个 <span  class="math">\(expires\)</span> 区域。</p>

<ol>
<li>定时删除,<br>
到达指定时间后同时删除存储区和 <span  class="math">\(expires\)</span> 区中的数据，对<code>CPU</code>负担较大，会抢占当前线程.</li>
<li>惰性删除,<br>
到达指定时间后不删除，下次访问时再进行删除。采取此种策略时，每个访问都要调用一次 <span  class="math">\(expireIfNeeded()\)</span> 函数，用于判断数据是否过期。占用较多内存.</li>
<li>定期删除,

<ol>
<li>使用 <span  class="math">\(info Server\)</span> 命令可以得到一个 <span  class="math">\(hz\)</span> 值，代表每秒执行的 <span  class="math">\(serverCron()\)</span> 函数的次数，轮询服务器,</li>
<li>该函数调用 <span  class="math">\(databaseCron()\)</span> 函数，轮询 <span  class="math">\(expires\)</span>,</li>
<li>在这些块内调用 <span  class="math">\(activeExpireCycle()\)</span> 函数，每次执行 <span  class="math">\(\Large\frac{250}{hz}\normalsize ms\)</span>,</li>
<li>随机挑选 <span  class="math">\(W\)</span> 个 <span  class="math">\(key\)</span> 进行检测并删除超时数据，如果删除的数量 <span  class="math">\(>\Large\frac{W}{4}\)</span> ，循环,</li>
<li>通过 <span  class="math">\(active\_expire\_cycle\_lookups\_per\_loop\)</span>配置可以设置 <span  class="math">\(W\)</span> 的值，<span  class="math">\(current\_db\)</span> 记录当前轮询的<span  class="math">\(expires\)</span> 块.</li>
</ol></li>
</ol>

<h3 id="81-逐出算法">8.1 逐出算法</h3>

<p><code>Redis</code>在执行命令前会调用 <span  class="math">\(freeMemoryIfNeeded()\)</span> 函数，用于检测内存是否充足，如果不足，则会删除一些数据，而清理过程中使用的算法称为逐出算法。当逐出算法失败时，会抛出错误信息。</p>

<ol>
<li><span  class="math">\(maxmemory\)</span>&nbsp;&nbsp;设置<code>Redis</code>的最大可支配内存，默认为全部,</li>
<li><span  class="math">\(maxmemory-samples\)</span>&nbsp;&nbsp;随机获取数据时每次获取的个数,</li>
<li><span  class="math">\(maxmemory-policy\)</span>&nbsp;&nbsp;挑选删除数据的策略,

<ol>
<li>检测易失数据（<span  class="math">\(expires\)</span>）,

<ol>
<li><span  class="math">\(volatile-lru\)</span>&nbsp;&nbsp;最近最久未使用,</li>
<li><span  class="math">\(volatile-lfu\)</span>&nbsp;&nbsp;最近最少次数使用,</li>
<li><span  class="math">\(volatile-ttl\)</span>&nbsp;&nbsp;最接近过期,</li>
<li><span  class="math">\(volatile-random\)</span>&nbsp;&nbsp;随机,</li>
</ol></li>
<li>全库数据,

<ol>
<li><span  class="math">\(allkeys-lru\)</span>,</li>
<li><span  class="math">\(allkeys-lfu\)</span>,</li>
<li><span  class="math">\(allkeys-random\)</span>,</li>
</ol></li>
<li>不驱逐 <span  class="math">\(no-enviction\)</span>.</li>
</ol></li>
</ol>

<p>通过 <span  class="math">\(info\)</span> 命令中的 <span  class="math">\(keyspace\)</span>_<span  class="math">\(hits\)</span> 和 <span  class="math">\(keyspace\)</span>_<span  class="math">\(misses\)</span> 可以得到命中率。</p>

<h2 id="9-服务器配置">9. 服务器配置</h2>

<ol>
<li><span  class="math">\(daemonize\)</span>&nbsp;&nbsp;守护进程，<code>Docker</code>中要设为 <span  class="math">\(no\)</span>,</li>
<li><span  class="math">\(bind\)</span>&nbsp;&nbsp;绑定主机地址，绑定之后只能通过该地址访问,</li>
<li><span  class="math">\(port\)</span>&nbsp;&nbsp;端口号,</li>
<li><span  class="math">\(database\)</span>&nbsp;&nbsp;数据库数量,</li>
<li><span  class="math">\(loglevel\;[debug|verbose|notice|warning]\)</span>&nbsp;&nbsp;日志记录级别，默认为 <span  class="math">\(verbose\)</span> ，生产环境中可以设为 <span  class="math">\(notice\)</span>,</li>
<li><span  class="math">\(logfile\)</span>&nbsp;&nbsp;日志文件名,</li>
<li><span  class="math">\(maxclients\)</span>&nbsp;&nbsp;最大客户端连接数，默认为无限,</li>
<li><span  class="math">\(timeout\)</span>&nbsp;&nbsp;最大闲置时间，<span  class="math">\(0\)</span> 为关闭该功能,</li>
<li><span  class="math">\(include\)</span>&nbsp;&nbsp;导入其他配置.</li>
</ol>

<h2 id="10-高级数据类型">10. 高级数据类型</h2>

<h3 id="101-bitmaps">10.1 <code>Bitmaps</code></h3>

<p><code>Bitmaps</code>相当于对<code>string</code>类型进行二进制操作的一个接口。</p>

<ol>
<li><span  class="math">\(getbit\)</span>&nbsp;&nbsp;获取指定偏移量上的<code>bit</code>值,</li>
<li><span  class="math">\(setbit\)</span>&nbsp;&nbsp;设置,</li>
<li><span  class="math">\(bitop\)</span>&nbsp;&nbsp;对 <span  class="math">\(key\)</span> 之间进行 <span  class="math">\(and/or/not/xor\)</span> 操作并保存到指定 <span  class="math">\(key\)</span> 中,</li>
<li><span  class="math">\(bitcount\)</span>&nbsp;&nbsp;统计指定范围内<code>bit</code>为 <span  class="math">\(1\)</span> 的数量.</li>
</ol>

<h3 id="102-hyperloglog">10.2 <code>HyperLogLog</code></h3>

<p>统计不重复的数据数，运用了<code>LogLog</code>算法，是一个估算算法，在大量数据时存在误差，估计结果是一个带有 <span  class="math">\(0.81\%\)</span> 标准错误的近似值。每个 <span  class="math">\(HyperLogLog key\)</span> 只占用最多 <span  class="math">\(12K\)</span> 内存用于标基数。</p>

<ol>
<li><span  class="math">\(pfadd\)</span>&nbsp;&nbsp;添加,</li>
<li><span  class="math">\(pfcount\)</span>&nbsp;&nbsp;统计,</li>
<li><span  class="math">\(pfmerge\)</span>&nbsp;&nbsp;合并.</li>
</ol>

<h3 id="103-geo">10.3 <code>GEO</code></h3>

<p>计算坐标点之间的距离</p>

<ol>
<li><span  class="math">\(geoadd\)</span>&nbsp;&nbsp;添加，通过经纬度的方式添加,</li>
<li><span  class="math">\(geopos\)</span>&nbsp;&nbsp;获取,</li>
<li><span  class="math">\(geodist\)</span>&nbsp;&nbsp;计算，可以指定单位,</li>
<li><span  class="math">\(georadius\)</span>&nbsp;&nbsp;获取指定范围内符合条件的坐标,</li>
<li><span  class="math">\(georadiusbymember\)</span>,</li>
<li><span  class="math">\(geohash\)</span>&nbsp;&nbsp;获取对应坐标哈希.</li>
</ol>

<h2 id="11-主从复制">11. 主从复制</h2>

<p>主服务器为 <span  class="math">\(master\)</span> ，收集数据（写数据），提供给多台服务器，称为 <span  class="math">\(slave\)</span> ，用于提供数据（读数据）。一个 <span  class="math">\(master\)</span> 可以对应多个 <span  class="math">\(slave\)</span> ，而一个 <span  class="math">\(slave\)</span> 只能对应一个 <span  class="math">\(master\)</span> ，一个服务器可以既是 <span  class="math">\(slave\)</span> 也是 <span  class="math">\(master\)</span>。主从复制即将 <span  class="math">\(master\)</span> 的数据即时有效的复制到 <span  class="math">\(slave\)</span> 中。</p>

<h3 id="111-连接">11.1 连接</h3>

<p><span  class="math">\(slave\)</span> 连接 <span  class="math">\(master\)</span> 。</p>

<ol>
<li><span  class="math">\(slaveof\;[ip]\;[port]\)</span>&nbsp;&nbsp;可以添加在配置文件中,</li>
<li>发送指令后 <span  class="math">\(master\)</span> 响应,</li>
<li>保存 <span  class="math">\(masterhost\)</span> 和 <span  class="math">\(masterport\)</span>,</li>
<li>根据保存的信息创建 <span  class="math">\(socket\)</span>,</li>
<li>周期性地发送 <span  class="math">\(ping-pong\)</span> 消息,</li>
<li><span  class="math">\(auth\;password\)</span> 验证授权,</li>
<li><span  class="math">\(replconflistening-port\;[port]\)</span> 发送监听端口到 <span  class="math">\(master\)</span>,</li>
<li><span  class="math">\(master\)</span> 保存监听端口,</li>
<li><span  class="math">\(slaveof no one\)</span> 断开连接.</li>
</ol>

<h4 id="1111-授权访问">11.1.1 授权访问</h4>

<ol>
<li><span  class="math">\(master\)</span> 配置文件中设置密码 <span  class="math">\(requirepass\;[password]\)</span>,</li>
<li><span  class="math">\(master\)</span> 客户端发送命令设置密码 <span  class="math">\(config\;set\;requirepass\;[password]/config\;get\;requirepass\)</span>,</li>
<li><span  class="math">\(slave\)</span> 配置文件设置密码 <span  class="math">\(masterauth\;[password]\)</span>,</li>
<li><span  class="math">\(slave\)</span> 客户端发送命令设置密码 <span  class="math">\(auth\;[password]\)</span>,</li>
<li>启动客户端设置密码 <span  class="math">\(redis-cli\;-a\;[password]\)</span>.</li>
</ol>

<h3 id="112-数据同步">11.2 数据同步</h3>

<ol>
<li><span  class="math">\(slave\)</span> 发送 <span  class="math">\(psync2\)</span> 请求同步,</li>
<li><span  class="math">\(master\)</span> 执行 <span  class="math">\(bgsave\)</span> ，在第一个 <span  class="math">\(slave\)</span> 连接时，创建一个命令缓冲区，用于以<code>AOF</code>形式缓冲<code>RDB</code>过程中添加的新命令,</li>
<li>生成<code>RDB</code>文件，通过 <span  class="math">\(socket\)</span> 发送给 <span  class="math">\(slave\)</span>,</li>
<li><span  class="math">\(slave\)</span> 接收<code>RDB</code>，清空数据并执行<code>RDB</code>恢复,</li>
<li>发送消息通知恢复完成，请求部分同步,</li>
<li><span  class="math">\(master\)</span> 复制缓冲区信息，以<code>AOF</code>形式发送,</li>
<li><span  class="math">\(slave\)</span> 执行 <span  class="math">\(bgrewriteaof\)</span> 恢复部分同步数据.</li>
</ol>

<p><span  class="math">\(1-4\)</span> 称为全量复制，<span  class="math">\(5-7\)</span> 称为部分复制，复制完成后 <span  class="math">\(slave\)</span> 端保有 <span  class="math">\(master\)</span> 端的全部数据以及复制过程接收的数据，<span  class="math">\(master\)</span> 保有 <span  class="math">\(slave\)</span> 当前同步的位置。<br>
在进行全量复制时，如果数据量过大，时间过长导致缓冲区中数据溢出，则必须重新进行全量复制，可以通过在配置文件中设置 <span  class="math">\(repl-backlog-size\)</span> 改变缓冲区大小。<br>
设置 <span  class="math">\(repl-backlog-size\)</span> 的流程：</p>

<ol>
<li>测算 <span  class="math">\(master\)</span> 和 <span  class="math">\(slave\)</span> 的重连时长 <span  class="math">\(second\)</span>,</li>
<li>获取 <span  class="math">\(master\)</span> 的 <span  class="math">\(write\_size\_per\_second\)</span>,</li>
<li><span  class="math">\(repl-backlog-size = 2 \times second \times write\_size\_per\_second\)</span>.</li>
</ol>

<p>在复制过程中，通过设置 <span  class="math">\(slave-serve-stale-data\)</span> 来令 <span  class="math">\(slave\)</span> 关闭对外服务。如果 <span  class="math">\(slave\)</span> 过多导致 <span  class="math">\(master\)</span> 带宽不足，应调整结构，最好为树状结构。</p>

<h3 id="113-命令传播">11.3 命令传播</h3>

<p>在 <span  class="math">\(master\)</span> 和 <span  class="math">\(slave\)</span> 建立连接后，应实时保持数据同步。在该阶段内如果发生短时间网络中断，就要进行部分复制，同步短时间内的改变。</p>

<h4 id="1131-部分复制的核心要素">11.3.1 部分复制的核心要素</h4>

<ol>
<li>服务器运行<code>id</code><br>
服务器运行时的身份识别码，在多次运行中可以生成多个，是一个由 <span  class="math">\(40\)</span> 位字符组成的随机十六进制字符串，用于身份识别。使用 <span  class="math">\(info Server\)</span> 内可以查询到运行<code>id</code> <span  class="math">\(run_-id\)</span> 。</li>
<li><span  class="math">\(master\)</span> 的复制缓冲区<br>
命令发送给 <span  class="math">\(master\)</span> ，<span  class="math">\(master\)</span> 在将命令同步到 <span  class="math">\(slave\)</span> 时，还会把命令发送到复制缓冲区中。复制缓冲区是一个队列，由偏移量和字节值组成，每台服务器启动时，如果开启了<code>AOF</code>或者成为 <span  class="math">\(master\)</span> ，都要创建复制缓冲区。</li>
<li><span  class="math">\(master\)</span> 和 <span  class="math">\(slave\)</span> 间的复制偏移量<br>
<span  class="math">\(master\)</span> 通过 <span  class="math">\(offset\)</span> 记录不同 <span  class="math">\(slave\)</span> 间传播数据的量。<span  class="math">\(offset\)</span> 既记录在 <span  class="math">\(master\)</span> 中，也记录在 <span  class="math">\(slave\)</span> 中，在每次发送时记录，用于断线后恢复（部分复制）。</li>
</ol>

<h4 id="1132-流程">11.3.2 流程</h4>

<ol>
<li><span  class="math">\(slave\)</span> 发送 <span  class="math">\(psync2\;[run_-id]\;[offset]\)</span> ，在首次连接时通过发送 <span  class="math">\(psync2\;?\;-1\)</span> 获取<code>id</code>和偏移量,</li>
<li><span  class="math">\(master\)</span> 执行 <span  class="math">\(bgsave\)</span> 记录偏移量,</li>
<li>发送 <span  class="math">\(+FULLRESYNC\;[run_-id]\;[offset]\)</span> 进行全量复制，再通过 <span  class="math">\(socket\)</span> 发送<code>RDB</code>文件,</li>
<li><span  class="math">\(slave\)</span> 接收到<code>id</code>和偏移量，进行全量复制,</li>
<li><span  class="math">\(slave\)</span> 发送 <span  class="math">\(psync2\;[run_-id]\;[offset]\)</span>,</li>
<li><span  class="math">\(master\)</span> 判断<code>id</code>是否匹配，偏移量是否存在于复制缓冲区中，若不存在，重新进行全量复制,</li>
<li>如果接收到的偏移量与存储的偏移量相同则忽略，不同则发送 <span  class="math">\(+CONTINUE\;[offset]\)</span> ，再通过 <span  class="math">\(socket\)</span> 发送复制缓冲区中新增的数据,</li>
<li><span  class="math">\(slave\)</span> 接收到部分复制的消息，更新偏移量，执行 <span  class="math">\(bgrewriteaof\)</span> 恢复数据.</li>
</ol>

<h3 id="114-心跳机制">11.4 心跳机制</h3>

<ol>
<li><span  class="math">\(master\)</span> 心跳指令 <span  class="math">\(PING\)</span> ，判断 <span  class="math">\(slave\)</span> 是否在线，默认周期 <span  class="math">\(10\)</span> 秒，可以通过设置 <span  class="math">\(repl-ping-slave-period\)</span> 改变，查询 <span  class="math">\(info replication\)</span> 可以获取最后一次连接时间间隔,</li>
<li><span  class="math">\(slave\)</span> 心跳指令 <span  class="math">\(REPLCONF\;ACK\;[offset]\)</span>，默认周期 <span  class="math">\(1\)</span> 秒，用于汇报偏移量和判断 <span  class="math">\(master\)</span> 是否在线.</li>
</ol>

<p><span  class="math">\(min-slaves-to-write\)</span> 最小写数量，小于就不再写数据,<br>
<span  class="math">\(min-slaves-max-lag\)</span> 最长延迟时间，若超过这个时间，不再写数据,<br>
<span  class="math">\(slave-serve-stale-data\)</span> 如果 <span  class="math">\(slave\)</span> 延迟过大，是否暂时屏蔽程序对 <span  class="math">\(slave\)</span> 的数据访问,<br>
<span  class="math">\(slave\)</span> 的数量和延迟由 <span  class="math">\(REPLCONF ACK\)</span> 命令得到。</p>

<h4 id="1141-流程">11.4.1 流程</h4>

<p>接上，命令传播阶段，在该过程中 <span  class="math">\(master\)</span> 也会发送 <span  class="math">\(PING\)</span> 指令。</p>

<ol>
<li>发送 <span  class="math">\(REPLCONF\;ACK\;[offset]\)</span>,</li>
<li><span  class="math">\(master\)</span> 判断是否处于缓冲区,</li>
<li>执行全量复制/部分复制,</li>
<li><span  class="math">\(slave\)</span> 执行复制.</li>
</ol>

<h3 id="115-内部优化">11.5 内部优化</h3>

<p>当数据过多时，每次重启都要进行一次全量复制，内部优化机制可以缓解问题。</p>

<ol>
<li><span  class="math">\(master\)</span> 创建 <span  class="math">\(mater\_replid\)</span> ，使用 <span  class="math">\(run\_id\)</span> 生成，发送给所有 <span  class="math">\(slave\)</span>,</li>
<li><span  class="math">\(master\)</span> 关闭时执行 <span  class="math">\(shutdown\;save\)</span> ，将 <span  class="math">\(run\)</span>_<span  class="math">\(id\)</span> 和 <span  class="math">\(offset\)</span> 保存到<code>RDB</code>文件中，使用 <span  class="math">\(redis-check-rdb\;[*.rdb]\)</span> 可以查看 <span  class="math">\(repl-id\)</span> 和 <span  class="math">\(repl-offset\)</span>,</li>
<li><span  class="math">\(master\)</span> 重启后加载<code>RDB</code>，同时加载 <span  class="math">\(repl-id\)</span> 和 <span  class="math">\(repl-offset\)</span> ，通过 <span  class="math">\(info\)</span> 可以查看 <span  class="math">\(master\_repl\_id\)</span> 和 <span  class="math">\(master\_repl\_offset\)</span>.</li>
</ol>

<h2 id="12-哨兵模式">12. 哨兵模式</h2>

<p>如果当前 <span  class="math">\(master\)</span> 宕机，需要一个 <span  class="math">\(slave\)</span> 作为新的 <span  class="math">\(master\)</span> ，这时需要通知所有 <span  class="math">\(slave\)</span> 。哨兵( <span  class="math">\(sentinel\)</span> ) 是一个分布式系统，也是一台<code>Redis</code>服务器，用于监控主从结构中得每台服务器，并通过投票机制选出新的 <span  class="math">\(master\)</span> ，通常配置奇数个哨兵。</p>

<ol>
<li>监控 <span  class="math">\(master\)</span> 和 <span  class="math">\(slave\)</span> 是否正常运行,</li>
<li>如果服务器出现问题，向其他哨兵和客户端发送通知,</li>
<li>断开 <span  class="math">\(mater\)</span> 和 <span  class="math">\(slave\)</span> 的连接，选择一个 <span  class="math">\(slave\)</span> 作为新的 <span  class="math">\(master\)</span> ，将其他 <span  class="math">\(slave\)</span> 连接到新的 <span  class="math">\(master\)</span> ，并通知客户端新的服务器地址。</li>
</ol>

<p><span  class="math">\(redis-sentinel\;[*.conf]\)</span> 启动哨兵，指定配置文件。哨兵在启动后会在配置文件中添加 <span  class="math">\(myid\)</span> 以及一些主从配置信息，并且会随着状态更新信息。<br>
设置哨兵后可以通过 <span  class="math">\(redis-cli\;-p\;[port]\)</span> 连接哨兵服务器，但是不能进行 <span  class="math">\(get/set\)</span> 等操作，只能进行哨兵的指令，通过 <span  class="math">\(info\)</span> 的 <span  class="math">\(Sentinel\)</span> 下可以获取相关信息。</p>

<h3 id="121-配置">12.1 配置</h3>
<pre><code class="language-conf" data-lang="conf"># 端口
port 26379
# 守护进程模式
daemonize no
# 日志文件名
logfile &#34;26379.log&#34;
# 日志路径
dir /data
# 监控的 master，2 代表当存在 2 台哨兵认为宕机时即判断该
# master 已经宕机，通常设置为哨兵数的一半加一
sentinel monitor mymaster 127.0.0.1 6379 2
# master 多久未响应即为宕机, ms
sentinel down-after-milliseconds mymaster 30000
# 新的 master 的并行同步数
sentinel parallel-syncs mymaster 1
# 同步的最长时间，ms
sentinel failover-timeout mymaster 180000</code></pre>
<h3 id="122-原理">12.2 原理</h3>

<h4 id="1221-监控">12.2.1 监控</h4>

<ol>
<li>连接 <span  class="math">\(master\)</span> ，通过 <span  class="math">\(INFO\)</span> 获取 <span  class="math">\(run_-id\)</span> 和 <span  class="math">\(role\)</span> 以及各个 <span  class="math">\(slave\)</span> 和 <span  class="math">\(sentinel\)</span> 的信息，建立一个<code>CMD</code>连接,</li>
<li>获取 <span  class="math">\(sentinel\)</span> 的状态，通过 <span  class="math">\(PING\)</span> ，建立起一个通道，用于相互之间传输信息，在之后也会不断发送 <span  class="math">\(PING\)</span> 用于确认是否在线,</li>
<li>获取 <span  class="math">\(slave\)</span> 的信息，通过 <span  class="math">\(INFO\)</span> ，获取 <span  class="math">\(run\_id,role,master\_host,master\_port,offest\)</span> 等，同样建立起<code>CMD</code>连接.</li>
</ol>

<h4 id="1222-通知">12.2.2 通知</h4>

<p><span  class="math">\(sentinel\)</span> 周期性的给各个服务器发送信息，确认其是否在线，再将取得的信息发送给其他 <span  class="math">\(sentinel\)</span>。</p>

<h4 id="1223-故障转移">12.2.3 故障转移</h4>

<ol>
<li>如果一个 <span  class="math">\(master\)</span> 没有及时响应，<span  class="math">\(sentinel\)</span> 会通知其他 <span  class="math">\(sentinel\)</span> ，将其标志为 <span  class="math">\(SRI\_S\_DOWN\)</span> ，即主观下线。</li>
<li>其他 <span  class="math">\(sentinel\)</span> 也会发送信息给该 <span  class="math">\(master\)</span> ，如果有达到数量的 <span  class="math">\(sentinel\)</span> 标记其为 <span  class="math">\(SRI\_S\_DOWN\)</span> ，那么它就会被标记为 <span  class="math">\(SRI\_O\_DOWN\)</span> ，即客观下线。</li>
<li><span  class="math">\(sentinel\)</span> 发送自己的信息，并通过投票机制（接收到信息的先后顺序），直到获得半数以上的票数后，选出的 <span  class="math">\(sentinel\)</span> 负责选出新的 <span  class="math">\(master\)</span> 。</li>
<li><span  class="math">\(sentinel\)</span> 根据响应速度和与之前 <span  class="math">\(master\)</span> 断开时间，再通过优先原则（优先级、偏移量和 <span  class="math">\(run_-id\)</span> 大小）决出新的 <span  class="math">\(master\)</span> 。</li>
<li><span  class="math">\(sentinel\)</span> 通知新的 <span  class="math">\(master\)</span> 和其他 <span  class="math">\(slave\;master\)</span> 改变的信息。</li>
</ol>

<h2 id="13-集群">13. 集群</h2>

<p><code>Redis</code>服务器将所有的存储空间计划切割成 <span  class="math">\(16384\)</span> 个槽（ <span  class="math">\(slot\)</span> ），每台主机均保存部分槽，在进行 <span  class="math">\(key\)</span> 存储时，要先计算出其存储的槽。如果在后续有增加主机，则从现有的主机中每台选出部分槽存储在新主机上。<br>
在集群内部，各个数据库之间相互通信，保存各个库中槽的编号数据。当未命中时，数据库可以通过保存的数据给出要查找的 <span  class="math">\(key\)</span> 所在的数据库。<br>
在集群模式中，如果 <span  class="math">\(slave\)</span> 下线，不会影响集群，下线 <span  class="math">\(slave\)</span> 的 <span  class="math">\(master\)</span> 会将下线状态发送给其他 <span  class="math">\(master\)</span> 。当 <span  class="math">\(slave\)</span> 重新上线后，会清除自己和其他 <span  class="math">\(master\)</span> 的下线状态。<br>
如果 <span  class="math">\(master\)</span> 下线，<span  class="math">\(slave\)</span> 会重复连接( 周期为 <span  class="math">\(1s\)</span> )直到超时，超时后会选出 <span  class="math">\(slave\)</span> 成为新的 <span  class="math">\(master\)</span> 。<span  class="math">\(master\)</span> 重新连接后，新的 <span  class="math">\(master\)</span> 清除掉下线状态，将其作为 <span  class="math">\(slave\)</span> 同步。</p>

<h3 id="131-配置">13.1 配置</h3>

<p>使用集群前要更改配置，添加在 <span  class="math">\(redis.conf\)</span> 文件内。</p>
<pre><code class="language-conf" data-lang="conf"># 启动集群
cluster-enabled yes
# 集群配置文件，集群开启后会生成在 dir 指定的路径
cluster-config-file node-6379.conf
# 集群超时时间, ms
cluster-node-timeout 30000
# master 连接的 slave 的最小数量
# cluster-migration-barrier 1</code></pre>
<h3 id="132-启动">13.2 启动</h3>

<p><span  class="math">\(redis-cli\;--cluster\;create\;--replicas\;[num]\;[master\_host:ip]...\;[slave\_host:ip]\)</span> 开启集群，可以通过 <span  class="math">\(--replicas\)</span> 指定内部结构，<span  class="math">\(num\)</span> 代表一台 <span  class="math">\(master\)</span> 有 <span  class="math">\(num\)</span> 台 <span  class="math">\(slave\)</span> ，后续输入的主从地址要符合结构，先输入所有的 <span  class="math">\(master\)</span> ，再按序输入所有的 <span  class="math">\(slave\)</span> 。<br>
在连接集群服务器时，使用 <span  class="math">\(redis-cli\;-c\)</span> ，会将不属于当前服务器管理的槽的数据自动转到其他服务器或者从其他服务器取出当前服务器管理的槽的数据。</p>

<h3 id="133-操作">13.3 操作</h3>

<ol>
<li><span  class="math">\(cluster\;nodes\)</span>&nbsp;&nbsp;查看节点信息,</li>
<li><span  class="math">\(cluster\;replicate\;[master\_run\_id]\)</span>&nbsp;&nbsp;切换一个 <span  class="math">\(slave\)</span> 的 <span  class="math">\(master\)</span>,</li>
<li><span  class="math">\(cluster\;meet\;[host:ip]\)</span>&nbsp;&nbsp;为新节点添加 <span  class="math">\(master\)</span>,</li>
<li><span  class="math">\(cluster\;forget\;[run\_id]\)</span>&nbsp;&nbsp;忽略一个没有槽的节点,</li>
<li><span  class="math">\(cluster\;failover\)</span>&nbsp;&nbsp;手动故障转移.</li>
</ol>

<h2 id="14-解决方案">14. 解决方案</h2>

<h3 id="141-缓存预热">14.1 缓存预热</h3>

<p>在<code>Redis</code>服务器部署后，如果发生请求数高，吞吐量大，同步操作频繁，容易发生宕机。</p>

<h4 id="1411-解决">14.1.1 解决</h4>

<ol>
<li>前置,

<ol>
<li>统计高频数据,</li>
<li>利用<code>LRU</code>构建数据留存队列（ <span  class="math">\(storm/kafka\)</span> ）,</li>
</ol></li>
<li>准备,

<ol>
<li><code>Redis</code>优先加载高频数据,</li>
<li>利用分布式技术加快数据读取,</li>
</ol></li>
<li>实施,

<ol>
<li>使用脚本触发数据预热,</li>
<li>使用<code>CDN</code>.</li>
</ol></li>
</ol>

<h3 id="142-缓存雪崩">14.2 缓存雪崩</h3>

<p>数据库连接量激增导致 <span  class="math">\(408\)</span>, <span  class="math">\(500\)</span> 等错误页面的出现，客户反复刷新导致流量居高不下。通常是<code>Redis</code>中一个较短时间内大量 <span  class="math">\(key\)</span> 过期导致。</p>

<h4 id="1421-解决">14.2.1 解决</h4>

<ol>
<li>更多静态页面</li>
<li>多级缓存( <span  class="math">\(Nginx\)</span>, <span  class="math">\(Redis\)</span>, <span  class="math">\(Ehcache\)</span> 等)</li>
<li>优化<code>SQL</code>语句</li>
<li>监控服务器性能指标（<code>CPU</code>占用率，内存占用率，平均响应时间，线程数等）</li>
<li>限流</li>
</ol>

<p>也可以针对过期问题解决</p>

<ol>
<li>切换删除策略（<code>LRU</code>，<code>LFU</code>等）,</li>
<li>调整有效期，错峰删除（分类，增加随机时间等）,</li>
<li>对于高频数据使用永久 <span  class="math">\(key\)</span>,</li>
<li>定期维护，分析数据访问量,</li>
<li>锁.</li>
</ol>

<h3 id="143-缓存击穿">14.3 缓存击穿</h3>

<p><code>Redis</code>某个高频数据过期导致数据库访问量激增，从而使数据库崩溃。</p>

<h4 id="1431-解决">14.3.1 解决</h4>

<ol>
<li>统计高频数据</li>
<li>定时任务，在高峰期前刷新数据有效期</li>
<li>实时监控，将高频数据延长周期或设置为永久</li>
<li>错峰删除</li>
<li>锁</li>
</ol>

<h3 id="144-缓存穿透">14.4 缓存穿透</h3>

<p><code>Redis</code>命中率下降导致数据库崩溃。通常由于数据库中没有对应数据或者<code>Redis</code>未持久化 <span  class="math">\(null\)</span> 数据导致，也可能是黑客攻击导致。</p>

<h4 id="1441-解决">14.4.1 解决</h4>

<ol>
<li>缓存 <span  class="math">\(null\)</span> ，设置短时限</li>
<li>拦截异常访问/布隆过滤器</li>
<li>监控<code>Redis</code>命中率，使用黑名单进行防控</li>
<li>启动防灾业务 <span  class="math">\(key\)</span> ，如设置加密 <span  class="math">\(key\)</span> ，拦截不符合规则的访问</li>
</ol>

<h3 id="145-监控">14.5 监控</h3>

<p>监控工具：</p>

<ol>
<li><span  class="math">\(Cloud\;Insight\;Redis\)</span>,</li>
<li><span  class="math">\(Prometheus\)</span>,</li>
<li><span  class="math">\(Redis-stat\)</span>,</li>
<li><span  class="math">\(Redis-faina\)</span>,</li>
<li><span  class="math">\(RedisLive\)</span>,</li>
<li><span  class="math">\(zabbix\)</span>.</li>
</ol>

<p>监控命令：</p>

<ol>
<li><span  class="math">\(redis-benchmark\;-h\;[host]\;-p\;[port]\;-c\;[connect]\;-n[request]\)</span>,<br>
<span  class="math">\(-c\)</span> 指定连接数，<span  class="math">\(-n\)</span> 指定请求数.</li>
<li><span  class="math">\(redis-cli\)</span>,

<ol>
<li><span  class="math">\(monitor\)</span>,<br>
开启监控.</li>
<li><span  class="math">\(slowlog\;get/len/reset\)</span>,<br>
获取慢日志/获取慢日志条目/重置慢日志，
相关配置:<br>

<ol>
<li><span  class="math">\(slowlog-log-slower-than\)</span> 慢查询时间下限，微秒,</li>
<li><span  class="math">\(slowlog-max-len\)</span> 慢查询日志长度.</li>
</ol></li>
</ol></li>
</ol>

<h4 id="1451-性能">14.5.1 性能</h4>

<ol>
<li><span  class="math">\(latency\)</span>&nbsp;&nbsp;响应延迟,</li>
<li><span  class="math">\(instantaneous\_ops\_per\_sec\)</span>&nbsp;&nbsp;每秒处理请求数,</li>
<li><span  class="math">\(hit\;rate\)</span>&nbsp;&nbsp;命中率.</li>
</ol>

<h4 id="1452-内存">14.5.2 内存</h4>

<ol>
<li><span  class="math">\(used_-memory\)</span>&nbsp;&nbsp;内存占用,</li>
<li><span  class="math">\(mem\_fragmentation\_ratio\)</span>&nbsp;&nbsp;碎片率,</li>
<li><span  class="math">\(evicted_-keys\)</span>&nbsp;&nbsp;由于内存限制而移除的 <span  class="math">\(key\)</span> 的数量,</li>
<li><span  class="math">\(blocked_-clients\)</span>&nbsp;&nbsp;由于阻塞操作（ <span  class="math">\(blpop,brpop\)</span> 等）而阻塞的客户端数量.</li>
</ol>

<h4 id="1453-活动">14.5.3 活动</h4>

<ol>
<li><span  class="math">\(connected_-clients\)</span>&nbsp;&nbsp;客户端连接数,</li>
<li><span  class="math">\(connected_-slaves\)</span>&nbsp;&nbsp;连接的<span  class="math">\(slave\)</span> 数,</li>
<li><span  class="math">\(master\_last\_io\_second\_ago\)</span>&nbsp;&nbsp;最近一次交互距今,</li>
<li><span  class="math">\(keyspace\)</span>&nbsp;&nbsp;数据库中 <span  class="math">\(key\)</span> 的数量.</li>
</ol>

<h4 id="1454-持久化">14.5.4 持久化</h4>

<ol>
<li><span  class="math">\(rdb\_last\_save\_time\)</span>&nbsp;&nbsp;最近一次<code>RDB</code>时间</li>
<li><span  class="math">\(rdb\_changes\_since\_last\_save\)</span>&nbsp;&nbsp;最近一次<code>RDB</code>至今改变的数据量</li>
</ol>

<h4 id="1455-错误">14.5.5 错误</h4>

<ol>
<li><span  class="math">\(rejected_-connections\)</span>&nbsp;&nbsp;客户端数量达到上限后拒绝的连接数</li>
<li><span  class="math">\(keyspace_-misses\)</span>&nbsp;&nbsp;未命中次数</li>
<li><span  class="math">\(master\_link\_down\_since\_seconds\)</span>&nbsp;&nbsp;主从断连持续时间</li>
</ol>

            </div>
            <div class="meta post-footer"> <span>2020 May 10 17:20</span> <a href="/post/redis%E7%AC%94%E8%AE%B0/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/javaweb4spring%E7%AE%80%E4%BB%8B/">JavaWeb（4）：Spring简介</a></h1>
            </center>
            <div class="post-content">
                <p><strong>参考书籍：《Pro Java for Web Apps》</strong></p>

<p><code>Maven</code>依赖</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>javax.inject<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.inject<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>compile<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>

<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>javax.annotation<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.annotation-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.3.2<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>runtime<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>

<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-webmvc<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.2.4.RELEASE<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>compile<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span></code></pre></div>
<hr>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Spring Framework</code>是一个<code>Java</code>应用程序容器，它提供了许多有用的特性，如反转控制（<code>IoC</code>）、依赖注入（<code>DI</code>）、抽象数据访问、事务管理等。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>IoC</code>是一个软件设计模式，即组装器（<code>Spring Framework</code>)在运行时才会绑定对象，也就是运行时才会实例化依赖的组件。这使得开发者可以针对接口进行编程，无需重新编译代码。<code>DI</code>是<code>IoC</code>的一种实现方式，通过<code>DI</code>，一个类可以通过声明其依赖的接口类型，然后利用组装器在运行时注入其依赖的实例。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Spring Framework</code>提供了一个<code>MVC</code>（模型-视图-控制）模式框架，利用它可以简化创建<code>Web</code>应用程序的过程，不用手动处理复杂的<code>Servlet</code>、<code>HttpServletRequest</code>等。控制器类的每个方法都被映射到了一个不同的请求<code>URL</code>、方法或请求的其他属性上，模型可以通过 <span  class="math">\(Map\)</span>&lt;<span  class="math">\(String, Object\)</span>&gt;的形式从控制器传递到视图，控制器返回的视图或视图名称将把模型转发到合适的<code>JSP</code>视图。通过这些特性，<code>Spring Framework</code>极大地简化了<code>Servlet</code>容器的工作内容。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>MVC</code>框架时，控制器类中的每个方法都可以拥有一个指向特定<code>URL</code>、请求方法、参数存在性、头的值、内容类型或期望响应类型的唯一映射。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Spring Framework</code>容器以一个或多个应用上下文的形式存在，由 <span  class="math">\(org.springframework.context.ApplicationContext\)</span> 接口表示。一个应用上下文管理着一组<code>bean</code>、执行业务逻辑的<code>Java</code>对象、执行任务等。由<code>Spring</code>管理的<code>bean</code>可以自动进行<code>DI</code>、消息通知、<code>bean</code>验证等服务。一个<code>Spring</code>程序至少需要一个应用上下文，也可以使用多个应用上下文组成层次结构。在层次结构中应用上下文间有着类似于树的父子兄弟关系，一个子应用上下文的<code>bean</code>可以访问父应用上下文的<code>bean</code>，但无法访问兄弟应用上下文的<code>bean</code>。许多类都继承了 <span  class="math">\(ApplicationContext\)</span> ，也有许多实现了它：</p>

<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><span  class="math">\(ConfigurableApplication\)</span></td>
<td align="center">可配置的应用上下文</td>
</tr>

<tr>
<td align="center"><span  class="math">\(WebApplicationContext\)</span></td>
<td align="center">用于<code>Java EE Web</code>应用程序，提供了对 <span  class="math">\(ServletContext\)</span> 和 <span  class="math">\(ServletConfig\)</span> 的访问</td>
</tr>

<tr>
<td align="center"><span  class="math">\(ConfigurableWebApplicationContext\)</span></td>
<td align="center">可配置的 <span  class="math">\(WebApplicationContext\)</span></td>
</tr>

<tr>
<td align="center"><span  class="math">\(XmlApplicationContext\)</span></td>
<td align="center">用于在<code>Java EE Web</code>应用程序中从<code>XML</code>文件加载<code>Spring</code>配置</td>
</tr>

<tr>
<td align="center"><span  class="math">\(AnnotationConfigWebApplicationContext\)</span></td>
<td align="center">用于在<code>Java EE Web</code>应用程序中以编程方式配置<code>Spring</code></td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Spring</code>使用 <span  class="math">\(DispatcherServlet\)</span> 处理<code>Web</code>请求，该<code>Servlet</code>将请求委托给合适的控制器，并按需求对请求和响应实体进行转换。在<code>Web</code>应用程序中，我们可以使用任意数量的 <span  class="math">\(DispatcherServlet\)</span> 。每个 <span  class="math">\(DispatcherServlet\)</span> 类都有自己的应用上下文，包含了对<code>Web</code>应用程序的 <span  class="math">\(ServletContext\)</span> 和自己的 <span  class="math">\(ServletConfig\)</span> 的引用。</p>

<hr>

<h2 id="启动spring-framework">启动<code>Spring Framework</code></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置和启动<code>Spring framework</code>是不同的，且相互独立，都可以用多种方式实现。在<code>Java SE</code>中只能通过在应用程序的 <span  class="math">\(main\)</span> 方法中以编程方式启动。而在<code>Java EE</code>中，可以使用<code>XML</code>创建部署描述符（ <span  class="math">\(web.xml\)</span> ）或者在 <span  class="math">\(javax.servlet.ServletContainerInitializer\)</span> 中通过编程方式启动。</p>

<h3 id="部署描述符方式">部署描述符方式</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传统的<code>Spring Framework</code>应用程序总是通过部署描述符启动。以部署描述符方式启动要求在配置文件中创建 <span  class="math">\(DispatcherServlet\)</span> 实例，然后以 <span  class="math">\(contextConfigLocation\)</span> 启动参数的形式为它提供配置文件，并指示<code>Spring</code>在启动时加载。</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;context_param&gt;</span>
    <span class="nt">&lt;param-name&gt;</span>contextConfigLocation<span class="nt">&lt;/param-name&gt;</span>
    <span class="nt">&lt;param-value&gt;</span>/WEB-INF/rootContext.xml<span class="nt">&lt;/param-value&gt;</span>
<span class="nt">&lt;/context-param&gt;</span>
<span class="nt">&lt;listener&gt;</span>
    <span class="nt">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="nt">&lt;/listener-class&gt;</span>
<span class="nt">&lt;/listener&gt;</span>

<span class="nt">&lt;servlet&gt;</span>
    <span class="nt">&lt;servlet-name&gt;</span>springDispatcher<span class="nt">&lt;/servlet-name&gt;</span>
    <span class="nt">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="nt">&lt;/servlet-class&gt;</span>
    <span class="nt">&lt;init-param&gt;</span>
        <span class="nt">&lt;param-name&gt;</span>contextConfigLocation<span class="nt">&lt;/param-name&gt;</span>
        <span class="nt">&lt;param-value&gt;</span>/WEB-INF/servletContext.xml<span class="nt">&lt;/param-value&gt;</span>
    <span class="nt">&lt;/init-param&gt;</span>
    <span class="nt">&lt;load-on-startup&gt;</span>1<span class="nt">&lt;/load-on-startup&gt;</span>
<span class="nt">&lt;/servlet&gt;</span>
<span class="nt">&lt;servlet-mapping&gt;</span>
    <span class="nt">&lt;servlet-name&gt;</span>springDispatcher<span class="nt">&lt;/servlet-name&gt;</span>
    <span class="nt">&lt;url-pattern&gt;</span>/<span class="nt">&lt;/url-pattern&gt;</span>
<span class="nt">&lt;/servlet-mapping&gt;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ContextLoaderListener$ 将在<code>Web</code>应用程序启动时初始化，然后从 <span  class="math">\(contextConfigLocation\)</span> 中指定的 <span  class="math">\(rootContext.xml\)</span> 中加载根应用上下文并启动。同样的，<span  class="math">\(springDispatcher\)</span> 也从指定的 <span  class="math">\(servletContext.xml\)</span> 中加载应用上下文。</p>

<h3 id="编程方式">编程方式</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Java EE 6</code>提供了一个新接口 <span  class="math">\(ServletContainerInitializer\)</span> ，实现其的类将在应用程序开始时启动，并在所有监听器启动之前调用它们的 <span  class="math">\(onStartup\)</span> 方法。要使用该接口，需要在 <span  class="math">\(/META-INF/services/javax.servlet.ServletContainerInitializer\)</span> 文件中列出实现它的类。<code>Spring Framework</code>提供了一个桥接口，简化了这一步：<span  class="math">\(org.springframework.web.SpringServletContainerInitializer\)</span> 类实现了 <span  class="math">\(ServletContainerInitializer\)</span> 接口，然后该类会扫描程序并寻找 <span  class="math">\(org.framework.web.WebApplicationInitializer\)</span> 接口的实现，调用其 <span  class="math">\(onStartup\)</span> 方法。因此我们可以在 <span  class="math">\(WebApplicationInitializer\)</span> 实现类中以编程方式配置监听器、<code>Servlet</code>和过滤器。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bootstrap</span> <span class="kd">implements</span> <span class="n">WebApplicationInitializer</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStartup</span><span class="o">(</span><span class="n">ServletContext</span> <span class="n">container</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">AnnotationConfigWebApplicationContext</span> <span class="n">rootContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnnotationConfigWebApplicationContext</span><span class="o">();</span>
        <span class="n">rootContext</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">RootContextConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">container</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">ContextLoaderListener</span><span class="o">(</span><span class="n">rootContext</span><span class="o">));</span>

        <span class="n">AnnotationConfigWebApplicationContext</span> <span class="n">servletContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnnotationConfigWebApplicationContext</span><span class="o">();</span>
        <span class="n">servletContext</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">ServletContextConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">ServletRegistration</span><span class="o">.</span><span class="na">Dynamic</span> <span class="n">dispatcher</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="na">addServlet</span><span class="o">(</span><span class="s">&#34;springDispatcher&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="n">DispatcherServlet</span><span class="o">(</span><span class="n">servletContext</span><span class="o">));</span>
        <span class="n">dispatcher</span><span class="o">.</span><span class="na">setLoadOnStartup</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
        <span class="n">dispatcher</span><span class="o">.</span><span class="na">addMapping</span><span class="o">(</span><span class="s">&#34;/&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码实现了与之前的<code>XML</code>文件一样的配置，其中 <span  class="math">\(RootContextConfiguration\)</span> 和 <span  class="math">\(ServletContextConfiguration\)</span> 是自定义的配置应用上下文的类。在此要注意的是，不要把 <span  class="math">\(DispatcherServlet\)</span> 映射到 <span  class="math">\(/\star\)</span> ，因为映射到 <span  class="math">\(/\star\)</span> 也会把内部<code>JSP</code>请求发送到该<code>Servlet</code>。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们也不必只使用一种方式配置，可以混合使用，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bootstrap</span> <span class="kd">implements</span> <span class="n">WebApplicationInitializer</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStartup</span><span class="o">(</span><span class="n">ServletContext</span> <span class="n">container</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">XmlWebApplicationContext</span> <span class="n">rootContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">XmlWebApplicationContext</span><span class="o">();</span>
        <span class="n">rootContext</span><span class="o">.</span><span class="na">setConfigLocation</span><span class="o">(</span><span class="s">&#34;/WEB-INF/rootContext.xml&#34;</span><span class="o">);</span>
        <span class="n">container</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">ContextLoaderListener</span><span class="o">(</span><span class="n">rootContext</span><span class="o">));</span>

        <span class="n">XmlWebApplicationContext</span> <span class="n">servletContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">XmlWebApplicationContext</span><span class="o">();</span>
        <span class="n">servletContext</span><span class="o">.</span><span class="na">setConfigLocation</span><span class="o">(</span><span class="s">&#34;/WEB-INF/servletContext.xml&#34;</span><span class="o">);</span>
        <span class="n">ServletRegistration</span><span class="o">.</span><span class="na">Dynamic</span> <span class="n">dispatcher</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="na">addServlet</span><span class="o">(</span><span class="s">&#34;springDispatcher&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="n">DispatcherServlet</span><span class="o">(</span><span class="n">servletContext</span><span class="o">));</span>
        <span class="n">dispatcher</span><span class="o">.</span><span class="na">setLoadOnStartup</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
        <span class="n">dispatcher</span><span class="o">.</span><span class="na">addMapping</span><span class="o">(</span><span class="s">&#34;/&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<hr>

<h2 id="配置spring-framework">配置<code>Spring Framework</code></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与启动相同，配置<code>Spring Framework</code>同样可以通过<code>XML</code>和编程方式。配置<code>Spring Framework</code>的主要步骤就是配置<code>bean</code>。<code>Spring Framework</code>本身提供了默认<code>bean</code>，在此基础上，我们需要自己再编写一些<code>bean</code>。</p>

<h3 id="xml配置方式"><code>XML</code>配置方式</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过在上面的引用的 <span  class="math">\(servletContext.xml\)</span> 文件中添加如下内容进行配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
    <span class="na">xmlns:mvc=</span><span class="s">&#34;http://www.springframework.org/schema/mvc&#34;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span><span class="s">        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
</span><span class="s">        http://www.springframework.org/schema/mvc
</span><span class="s">        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&#34;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;mvc:annotation-driven</span> <span class="nt">/&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">&#34;fooImpl&#34;</span> <span class="na">class=</span><span class="s">&#34;FooImpl&#34;</span><span class="nt">/&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">&#34;barController&#34;</span> <span class="na">class=</span><span class="s">&#34;BarController&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&#34;foo&#34;</span> <span class="na">ref=</span><span class="s">&#34;fooImpl&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;/beans&gt;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们使用 &lt;<span  class="math">\(beans\)</span>&gt; 命名空间配置<code>bean</code>。上述<code>XML</code>文件将实例化 <span  class="math">\(FooImpl\)</span> 和 <span  class="math">\(BarController\)</span> ，并将 <span  class="math">\(FooImpl\)</span> 注入 <span  class="math">\(BarController\)</span> 的 <span  class="math">\(foo\)</span> 属性中。&lt;<span  class="math">\(mvc:annotation-driven\)</span>&gt; 指示<code>Spring</code>使用 <span  class="math">\(@RequestsMapping\)</span>, <span  class="math">\(@RequestBody\)</span>, <span  class="math">\(@RequestParam\)</span>, <span  class="math">\(@PathParam\)</span>, <span  class="math">\(@ResponseBody\)</span> 这样的注解将请求映射到控制器方法上。</p>

<h3 id="混合配置方式">混合配置方式</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>XML</code>的基础上，我们可以通过使用组件扫描和注解进行配置。组件扫描将扫描所有标注了 <span  class="math">\(org.springframework.stereotype.Component\)</span> 的类，并将他们变成<code>bean</code>交由<code>Spring</code>进行管理。任何标注了 <span  class="math">\(@Component\)</span> 的注解都将变成组件注解，因此 <span  class="math">\(@Controller\)</span>, <span  class="math">\(@Repository\)</span>, <span  class="math">\(@Service\)</span> 也都是组件注解。当然，也可以创建自己的组件注解。<span  class="math">\(@org.springframework.beans.factory.annotation.Autowired\)</span> 注解，以及它的同义词 <span  class="math">\(@javax.inject.Inject\)</span> 和 <span  class="math">\(@javax.annotation.Resource\)</span> 用于声明<code>Spring</code>应该注入的依赖，可以用于标注字段、方法、方法参数或者构造器。通常<code>bean</code>应该具有无参构造器，但对于一个标注了 <span  class="math">\(@Autowired\)</span> 的构造器的类，<code>Spring</code>将注入所有构造器参数并使用该构造器构造实例。当存在多个匹配的<code>bean</code>时，可以通过使用 <span  class="math">\(@org.springframework.beans.factory.annotation.Qualifier\)</span> 或者 <span  class="math">\(@javax.inject.Named\)</span> 指定使用的<code>bean</code>的名字，或者使用 <span  class="math">\(@org.springframework.context.annotation.Primary\)</span> 标记组件指定优先使用的<code>bean</code>的名字。除了上述注解之外，还有两个特殊的用于<code>bean</code>的注解，<span  class="math">\(@javax.annotation.PostConstruct\)</span> 注解和 <span  class="math">\(@javax.annotation.PreDestroy\)</span> 注解，用于标注一个 <span  class="math">\(public\;void\)</span> 的无参方法，前者会在<code>bean</code>构造完成后调用，后者会在<code>bean</code>关闭前调用。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过使用注解，我们可以简化我们的<code>Spring</code>配置。在 <span  class="math">\(rootContext.xml\)</span> 中可以添加如下配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
    <span class="na">xmlns:mvc=</span><span class="s">&#34;http://www.springframework.org/schema/mvc&#34;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span><span class="s">        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
</span><span class="s">        http://www.springframework.org/schema/mvc
</span><span class="s">        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&#34;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;context:annotation-config/&gt;</span>
    <span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">&#34;org.example&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;context:exclude-filter</span> <span class="na">type=</span><span class="s">&#34;annotation&#34;</span> <span class="na">expression=</span><span class="s">&#34;org.springframework.stereotype.Controller&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/context:component-scan&gt;</span>

<span class="nt">&lt;/beans&gt;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;<span  class="math">\(context:annotation-config\)</span>&gt; 启用注解配置，&lt;<span  class="math">\(context:component-scan\)</span>&gt; 启用组件扫描，<span  class="math">\(base-package\)</span> 特性指定要扫描的包，在其命名空间内，我们使用了 &lt;<span  class="math">\(context:exclude-filter\)</span>&gt; 标签排除了对 <span  class="math">\(@Controller\)</span> 组件的扫描。因为在之前的 <span  class="math">\(servletContext.xml\)</span> 中我们已经配置了 <span  class="math">\(barController\)</span> ，如果不排除的话，它将会被实例化两次。或者，我们可以修改 <span  class="math">\(servletContext.xml\)</span> 配置为如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&#34;http://www.springframework.org/schema/beans&#34;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
    <span class="na">xmlns:mvc=</span><span class="s">&#34;http://www.springframework.org/schema/mvc&#34;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&#34;http://www.springframework.org/schema/beans
</span><span class="s">        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
</span><span class="s">        http://www.springframework.org/schema/mvc
</span><span class="s">        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&#34;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;mvc:annotation-driven/&gt;</span>

    <span class="nt">&lt;context:annotation-config/&gt;</span>
    <span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">&#34;org.example&#34;</span> <span class="na">use-default-filters=</span><span class="s">&#34;false&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;context:include-filter</span> <span class="na">type=</span><span class="s">&#34;annotation&#34;</span> <span class="na">expression=</span><span class="s">&#34;org.springframework.stereotype.Controller&#34;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/context:component-scan&gt;</span>

<span class="nt">&lt;/beans&gt;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 &lt;<span  class="math">\(context:include-filter\)</span>&gt; 设置应该扫描的包，注意这里使用了 <span  class="math">\(use-default-filters\)</span> 该属性表示是否使用标准扫描模式，默认为 <span  class="math">\(true\)</span> 。</p>

<h3 id="编程配置方式">编程配置方式</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用编程方式配置时，我们要创建自定义的配置类，然后为这些类标上 <span  class="math">\(@org.springframework.context.annotation.Configuration\)</span> 注解。在自定义的配置类内，我们还可以通过使用 <span  class="math">\(@org.springframework.context.annotation.Bean\)</span> 注解标注无参方法注册<code>bean</code>。不仅如此，我们在混合配置中所提到的所有注解都能在配置类内使用，而且由于 <span  class="math">\(@Configuration\)</span> 是标注了 <span  class="math">\(@Component\)</span> 的注解，因此也能被组件扫描所扫描到，但这可能产生意料之外的行为，如<code>bean</code>被实例化两次。使用配置类时，可以通过结合使用 <span  class="math">\(@org.springframework.context.annotation.Import\)</span> 注解导入其他配置类中的配置，或者使用 <span  class="math">\(@org.springframework.context.annotation.ImportResource\)</span> 注解导入<code>XML</code>配置来实现将配置分布在多个地方。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还记得我们在混合配置中保留的命名空间吗？现在我们可以使用注解来代替它们了。</p>

<table>
<thead>
<tr>
<th align="center">注解</th>
<th align="center">命名空间</th>
<th align="center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><span  class="math">\(@ComponentScan\)</span></td>
<td align="center">&lt;<span  class="math">\(context:component-scan\)</span>&gt;</td>
<td align="center">指定启用组件扫描的包</td>
</tr>

<tr>
<td align="center"><span  class="math">\(@EnableAsync\)</span></td>
<td align="center">&lt;<span  class="math">\(task:*\)</span>&gt;</td>
<td align="center">启用<code>Spring</code>的 <span  class="math">\(@Aysnc\)</span> 异步方法执行</td>
</tr>

<tr>
<td align="center"><span  class="math">\(@EnableScheduling\)</span></td>
<td align="center">&lt;<span  class="math">\(task:*\)</span>&gt;</td>
<td align="center">启用<code>Spring</code>的 <span  class="math">\(@Scheduled\)</span> 计划方法的执行</td>
</tr>

<tr>
<td align="center"><span  class="math">\(@EnableCaching\)</span></td>
<td align="center">&lt;<span  class="math">\(cache:*\)</span>&gt;</td>
<td align="center">启用<code>Spring</code>的注解驱动缓存管理特性</td>
</tr>

<tr>
<td align="center"><span  class="math">\(@EnableTransactionManagement\)</span></td>
<td align="center">&lt;<span  class="math">\(tx:annotation-driven\)</span>&gt;</td>
<td align="center">为 <span  class="math">\(@Transactional\)</span> 方法启用事务管理</td>
</tr>

<tr>
<td align="center"><span  class="math">\(@EnableWebMvc\)</span></td>
<td align="center">&lt;<span  class="math">\(mvc:annotation-driven\)</span>&gt;</td>
<td align="center">通常需要对该注解进行自定义配置，通过继承 <span  class="math">\(WebMvcConfigurerAdapter\)</span> 来自定义需要的部分</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Configuration</span>
<span class="nd">@EnableWebMvc</span>
<span class="nd">@ComponentScan</span><span class="o">(</span>
    <span class="n">basePackage</span> <span class="o">=</span> <span class="s">&#34;org.example&#34;</span><span class="o">,</span>
    <span class="n">useDefaultFilters</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span>
    <span class="n">includeFilters</span> <span class="o">=</span> <span class="nd">@ComponentScan.Filter</span><span class="o">(</span><span class="n">Controller</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServletContextConfiguration</span> <span class="o">{}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上例是一个简单的配置类，它没有包含任何<code>bean</code>，一切都通过组件扫描和 <span  class="math">\(@EnableWebMvc\)</span> 进行配置。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Apr 21 15:48</span> <a href="/post/javaweb4spring%E7%AE%80%E4%BB%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/">使用WebSocket实现的一个简单的多人聊天室</a></h1>
            </center>
            <div class="post-content">
                <p>环境：JDK1.8, tomcat-8.5.51<br>
源码可以在<code>GitHub</code>上查阅：<a href="https://github.com/z217/ChatRoom">ChatRoom</a></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WebSocket</code>最常用的地方就是聊天室，所以我用<code>Servlet</code>+<code>WebSocket</code>实现了一个简单的多人聊天室。这个多人聊天室改一改就能作为一对一的聊天室使用，毕竟实现方法都是差不多的。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是<code>maven</code>依赖，在此只展示几个要注意的依赖项：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependencies&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.projectlombok<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>lombok<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>1.18.12<span class="nt">&lt;/version&gt;</span>
            <span class="nt">&lt;scope&gt;</span>provided<span class="nt">&lt;/scope&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>

        ......
        ......

        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.core<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>jackson-databind<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>2.10.0<span class="nt">&lt;/version&gt;</span>
            <span class="nt">&lt;scope&gt;</span>compile<span class="nt">&lt;/scope&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>

        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.datatype<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>jackson-datatype-jsr310<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>2.10.0<span class="nt">&lt;/version&gt;</span>
            <span class="nt">&lt;scope&gt;</span>compile<span class="nt">&lt;/scope&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>

    <span class="nt">&lt;/dependencies&gt;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Lombok</code>简化实体的编写（虽然只有一个实体），然后<code>jackson</code>相关的依赖用于<code>Java</code>实例和<code>JSON</code>对象之间的相互转化。为了避免兼容问题，我这里选择依赖基本上都是最新版本。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后是实体，$ChatMessage$ 用于存储消息相关的信息，使用<code>lombok</code>简化了编写：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">lombok.AllArgsConstructor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">lombok.Getter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">lombok.NoArgsConstructor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">lombok.Setter</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.time.OffsetDateTime</span><span class="o">;</span>

<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@AllArgsConstructor</span>
<span class="nd">@NoArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChatMessage</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">String</span> <span class="n">username</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">String</span> <span class="n">message</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">OffsetDateTime</span> <span class="n">timestamp</span><span class="o">;</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了实体之后再建立仓库，用于存储聊天信息以及用户信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.CopyOnWriteArraySet</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChatRepository</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ChatMessage</span><span class="o">&gt;</span> <span class="n">repository</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="n">CopyOnWriteArraySet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CopyOnWriteArraySet</span><span class="o">&lt;&gt;();</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ChatMessage</span><span class="o">&gt;</span> <span class="nf">getRepository</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/*...*/</span> <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">addChat</span><span class="o">(</span><span class="n">ChatMessage</span> <span class="n">chatMessage</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">repository</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">chatMessage</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">repository</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">10</span><span class="o">)</span> <span class="n">repository</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">CopyOnWriteArraySet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">getUsers</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/*...*/</span> <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有连接数据库，因此这里使用了 <span  class="math">\(LinkedList\)</span> 在内存存储聊天记录，<span  class="math">\(addChat\)</span> 方法用于添加聊天记录，设置为只存储 <span  class="math">\(10\)</span> 条记录。要注意的是 <span  class="math">\(addChat\)</span> 方法上使用了 <span  class="math">\(synchronized\)</span> 关键字用于保证同步。不过这里有个小问题就是通过 <span  class="math">\(Getter\)</span> 获取的 <span  class="math">\(List\)</span> 的 <span  class="math">\(add\)</span> 方法并没有同步，因此可以的话还是使用阻塞容器比较好。接着我使用了同步容器 <span  class="math">\(CopyOnWriteArraySet\)</span> 用于存储用户列表。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就是<code>Servlet</code>，我把<code>Servlet</code>用于处理用户名的填写及转发，在转发完成后，就全部交予<code>WebSocket</code>服务终端进行管理了。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">javax.servlet.ServletException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.annotation.WebServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>

<span class="nd">@WebServlet</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;chatRoomServlet&#34;</span><span class="o">,</span> <span class="n">urlPatterns</span> <span class="o">=</span> <span class="s">&#34;/room&#34;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChatRoomServlet</span> <span class="kd">extends</span> <span class="n">HttpServlet</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span>
      <span class="kd">throws</span> <span class="n">ServletException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">resp</span><span class="o">.</span><span class="na">sendRedirect</span><span class="o">(</span><span class="s">&#34;/ChatRoom&#34;</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doPost</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span>
      <span class="kd">throws</span> <span class="n">ServletException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">username</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getParameter</span><span class="o">(</span><span class="s">&#34;username&#34;</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">username</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">username</span><span class="o">.</span><span class="na">trim</span><span class="o">().</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">req</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">&#34;error&#34;</span><span class="o">,</span> <span class="s">&#34;empty&#34;</span><span class="o">);</span>
      <span class="n">req</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="s">&#34;/index.jsp&#34;</span><span class="o">).</span><span class="na">forward</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">username</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="s">&#34;^[0-9a-zA-z_]+$&#34;</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">req</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">&#34;error&#34;</span><span class="o">,</span> <span class="s">&#34;illegal&#34;</span><span class="o">);</span>
      <span class="n">req</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="s">&#34;/index.jsp&#34;</span><span class="o">).</span><span class="na">forward</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">ChatRepository</span><span class="o">.</span><span class="na">getUsers</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="n">username</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">req</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">&#34;error&#34;</span><span class="o">,</span> <span class="s">&#34;duplicated&#34;</span><span class="o">);</span>
      <span class="n">req</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="s">&#34;/index.jsp&#34;</span><span class="o">).</span><span class="na">forward</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">req</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">&#34;username&#34;</span><span class="o">,</span> <span class="n">username</span><span class="o">);</span>
      <span class="n">req</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">&#34;chatRepository&#34;</span><span class="o">,</span> <span class="n">ChatRepository</span><span class="o">.</span><span class="na">getRepository</span><span class="o">());</span>
      <span class="n">req</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="s">&#34;/WEB-INF/jsp/view/chatRoom/room.jsp&#34;</span><span class="o">).</span><span class="na">forward</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我这里使用了 <span  class="math">\(index.jsp\)</span> 文件处理表单的填写和提交，在以<code>GET</code>方式访问时 <span  class="math">\(doGet\)</span> 方法将网址重定向至用户名填写的页面，也就是 <span  class="math">\(index.jsp\)</span>，由于实现逻辑比较简单，因此在这里不做展示。<span  class="math">\(doPost\)</span> 方法用于判断用户名的合法性，如果合法，就转到聊天室界面，也就是 <span  class="math">\(room.jsp\)</span> 。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实现服务终端之前，我们要先实现编码器和译码器，用于处理<code>JSON</code>对象。由于实现途径是实现接口，因此我们可以在一个类内实现编码和译码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">com.fasterxml.jackson.core.JsonGenerationException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.core.JsonGenerator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.core.JsonParseException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.databind.JsonMappingException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.databind.ObjectMapper</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.websocket.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.OutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.ByteBuffer</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChatMessageCodec</span>
    <span class="kd">implements</span> <span class="n">Encoder</span><span class="o">.</span><span class="na">BinaryStream</span><span class="o">&lt;</span><span class="n">ChatMessage</span><span class="o">&gt;,</span> <span class="n">Decoder</span><span class="o">.</span><span class="na">BinaryStream</span><span class="o">&lt;</span><span class="n">ChatMessage</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ObjectMapper</span> <span class="n">MAPPER</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectMapper</span><span class="o">();</span>

  <span class="kd">static</span> <span class="o">{</span>
    <span class="n">MAPPER</span><span class="o">.</span><span class="na">findAndRegisterModules</span><span class="o">();</span>
    <span class="n">MAPPER</span><span class="o">.</span><span class="na">configure</span><span class="o">(</span><span class="n">JsonGenerator</span><span class="o">.</span><span class="na">Feature</span><span class="o">.</span><span class="na">AUTO_CLOSE_TARGET</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">encode</span><span class="o">(</span><span class="n">ChatMessage</span> <span class="n">chatMessage</span><span class="o">,</span> <span class="n">OutputStream</span> <span class="n">outputStream</span><span class="o">)</span>
      <span class="kd">throws</span> <span class="n">EncodeException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">ChatMessageCodec</span><span class="o">.</span><span class="na">MAPPER</span><span class="o">.</span><span class="na">writeValue</span><span class="o">(</span><span class="n">outputStream</span><span class="o">,</span> <span class="n">chatMessage</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">JsonGenerationException</span> <span class="o">|</span> <span class="n">JsonMappingException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">EncodeException</span><span class="o">(</span><span class="n">chatMessage</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">ChatMessage</span> <span class="nf">decode</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">inputStream</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">DecodeException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">ChatMessageCodec</span><span class="o">.</span><span class="na">MAPPER</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">inputStream</span><span class="o">,</span> <span class="n">ChatMessage</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">JsonParseException</span> <span class="o">|</span> <span class="n">JsonMappingException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">DecodeException</span><span class="o">((</span><span class="n">ByteBuffer</span><span class="o">)</span> <span class="kc">null</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="n">EndpointConfig</span> <span class="n">endpointConfig</span><span class="o">)</span> <span class="o">{}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里使用了之前导入的依赖<code>jackson</code>包中的 <span  class="math">\(ObjectMapper\)</span> 用于处理<code>JSON</code>对象，<span  class="math">\(init\)</span> 和 <span  class="math">\(destroy\)</span> 方法都是空实现，如果需要的话也可以修改。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来是服务终端：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">javax.websocket.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.websocket.server.PathParam</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.websocket.server.ServerEndpoint</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.time.OffsetDateTime</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.CopyOnWriteArraySet</span><span class="o">;</span>

<span class="nd">@ServerEndpoint</span><span class="o">(</span>
    <span class="n">value</span> <span class="o">=</span> <span class="s">&#34;/room/{username}&#34;</span><span class="o">,</span>
    <span class="n">encoders</span> <span class="o">=</span> <span class="n">ChatMessageCodec</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
    <span class="n">decoders</span> <span class="o">=</span> <span class="n">ChatMessageCodec</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChatRoomServer</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="n">CopyOnWriteArraySet</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;</span> <span class="n">sessions</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CopyOnWriteArraySet</span><span class="o">&lt;&gt;();</span>

  <span class="nd">@OnOpen</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onOpen</span><span class="o">(</span><span class="n">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nd">@PathParam</span><span class="o">(</span><span class="s">&#34;username&#34;</span><span class="o">)</span> <span class="n">String</span> <span class="n">username</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ChatRepository</span><span class="o">.</span><span class="na">getUsers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">username</span><span class="o">);</span>
    <span class="n">ChatMessage</span> <span class="n">chatMessage</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChatMessage</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="s">&#34;加入了聊天室&#34;</span><span class="o">,</span> <span class="n">OffsetDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">Session</span> <span class="n">s</span> <span class="o">:</span> <span class="n">sessions</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">isOpen</span><span class="o">())</span> <span class="n">s</span><span class="o">.</span><span class="na">getBasicRemote</span><span class="o">().</span><span class="na">sendObject</span><span class="o">(</span><span class="n">chatMessage</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="o">|</span> <span class="n">EncodeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">onError</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">sessions</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
    <span class="n">session</span><span class="o">.</span><span class="na">getUserProperties</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">&#34;username&#34;</span><span class="o">,</span> <span class="n">username</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@OnMessage</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onMessage</span><span class="o">(</span><span class="n">Session</span> <span class="n">session</span><span class="o">,</span> <span class="n">ChatMessage</span> <span class="n">chatMessage</span><span class="o">)</span> <span class="o">{</span>
    <span class="cm">/*send message to every session*/</span>
  <span class="o">}</span>

  <span class="nd">@OnError</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Session</span> <span class="n">session</span><span class="o">,</span> <span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">username</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">session</span><span class="o">.</span><span class="na">getUserProperties</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;username&#34;</span><span class="o">);</span>
    <span class="n">ChatMessage</span> <span class="n">chatMessage</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChatMessage</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="s">&#34;因错误而断开了连接&#34;</span><span class="o">,</span> <span class="n">OffsetDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
    <span class="cm">/* send message to every session */</span>
  <span class="o">}</span>

  <span class="nd">@OnClose</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClose</span><span class="o">(</span><span class="n">Session</span> <span class="n">session</span><span class="o">,</span> <span class="n">CloseReason</span> <span class="n">closeReason</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">closeReason</span><span class="o">.</span><span class="na">getCloseCode</span><span class="o">()</span> <span class="o">==</span> <span class="n">CloseReason</span><span class="o">.</span><span class="na">CloseCodes</span><span class="o">.</span><span class="na">NORMAL_CLOSURE</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">sessions</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
      <span class="n">String</span> <span class="n">username</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">session</span><span class="o">.</span><span class="na">getUserProperties</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;username&#34;</span><span class="o">);</span>
      <span class="n">ChatRepository</span><span class="o">.</span><span class="na">getUsers</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="n">username</span><span class="o">);</span>
      <span class="n">ChatMessage</span> <span class="n">chatMessage</span> <span class="o">=</span>
          <span class="k">new</span> <span class="n">ChatMessage</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">username</span> <span class="o">+</span> <span class="s">&#34;离开了聊天室&#34;</span><span class="o">,</span> <span class="n">OffsetDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
      <span class="cm">/* send message to every session */</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先使用了 <span  class="math">\(@ServerEndpoint\)</span> 注解标出服务终端，要注意注解使用了 <span  class="math">\(encoders\)</span> 和 <span  class="math">\(decoders\)</span> 设置了编码器和解码器（也就是之前实现的 <span  class="math">\(ChatMessageCodec\)</span> 类），通过 <span  class="math">\(CopyOnWriteArraySet\)</span> 存储了所有加入聊天室的会话，由于发送消息的代码大体一致，因此我省略了之后几个方法发送消息的实现。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后就是聊天室的实现了，也就是 <span  class="math">\(room.jsp\)</span> 文件。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="err">&lt;</span>%@ taglib prefix=&#34;c&#34; uri=&#34;http://java.sun.com/jsp/jstl/core&#34; %&gt;
<span class="err">&lt;</span>%--@elvariable id=&#34;username&#34; type=&#34;java.lang.String&#34;--%&gt;
<span class="err">&lt;</span>%--@elvariable id=&#34;chatRepository&#34; type=&#34;java.util.List<span class="p">&lt;</span><span class="nt">org.example.ChatMessage</span><span class="p">&gt;</span>&#34;--%&gt;
<span class="err">&lt;</span>%@ page contentType=&#34;text/html;charset=UTF-8&#34; language=&#34;java&#34; %&gt;
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>聊天室<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://code.jquery.com/jquery-3.5.0.js&#34;</span>
            <span class="na">integrity</span><span class="o">=</span><span class="s">&#34;sha256-r/AaFHrszJtwpe+tHyNi/XCfMxYpbsRg2Uqn0x3s2zc=&#34;</span> <span class="na">crossorigin</span><span class="o">=</span><span class="s">&#34;anonymous&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;http://cdn.staticfile.org/moment.js/2.24.0/moment-with-locales.js&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>

<span class="c">&lt;!---省略---&gt;</span>

<span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/javascript&#34;</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;javascript&#34;</span><span class="p">&gt;</span>
<span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">ready</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">error</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s2">&#34;#chat-room-error&#34;</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">errorBody</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s2">&#34;#chat-room-error-body&#34;</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">waiting</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s2">&#34;#chat-room-waiting&#34;</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">waitingBody</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s2">&#34;#chat-room-waiting-body&#34;</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">messageShow</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s2">&#34;#chat-room-message-show&#34;</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">messageText</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s2">&#34;#chat-room-message-text&#34;</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">messageSendLog</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s2">&#34;#chat-room-message-send-log&#34;</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">encoder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TextEncoder</span><span class="p">(</span><span class="s2">&#34;utf-8&#34;</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">decoder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TextDecoder</span><span class="p">(</span><span class="s2">&#34;utf-8&#34;</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">server</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

        <span class="kd">let</span> <span class="nx">log</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">timestamp</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">messageShow</span>
                <span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;div&gt;&#39;</span><span class="p">)</span>
                    <span class="p">.</span><span class="nx">addClass</span><span class="p">(</span><span class="s1">&#39;chat-room-username&#39;</span><span class="p">)</span>
                    <span class="p">.</span><span class="nx">text</span><span class="p">((</span><span class="nx">username</span> <span class="o">===</span> <span class="s1">&#39;${username}&#39;</span> <span class="o">?</span> <span class="s1">&#39;你&#39;</span> <span class="o">:</span> <span class="nx">username</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; 发布于：&#39;</span> <span class="o">+</span> <span class="nx">timestamp</span><span class="p">.</span><span class="nx">toLocaleString</span><span class="p">()))</span>
                <span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;div&gt;&#39;</span><span class="p">)</span>
                    <span class="p">.</span><span class="nx">addClass</span><span class="p">(</span><span class="s1">&#39;chat-room-message&#39;</span><span class="p">)</span>
                    <span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="nx">message</span><span class="p">))</span>
                <span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;br/&gt;&#39;</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="kd">let</span> <span class="nx">sendToHome</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">button</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;input&gt;&#39;</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;submit&#39;</span><span class="p">);</span>
            <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;div&gt;&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;form&gt;&#39;</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="s1">&#39;GET&#39;</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;action&#39;</span><span class="p">,</span> <span class="s1">&#39;/ChatRoom&#39;</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">button</span><span class="p">)));</span>
            <span class="nx">button</span><span class="p">.</span><span class="nx">click</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="s2">&#34;WebSocket&#34;</span> <span class="k">in</span> <span class="nb">window</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">errorBody</span><span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="s1">&#39;WebSocket are not supported in this browser. Try to update your browser to the latest version.&#39;</span><span class="p">);</span>
            <span class="nx">error</span><span class="p">.</span><span class="nx">show</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nx">messageSendLog</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span>
        <span class="nx">error</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span>
        <span class="nx">waiting</span><span class="p">.</span><span class="nx">show</span><span class="p">();</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="nx">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="s2">&#34;ws://&#34;</span> <span class="o">+</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">host</span> <span class="o">+</span> <span class="s1">&#39;&lt;c:url value=&#34;/room/${username}&#34;/&gt;&#39;</span><span class="p">);</span>
            <span class="nx">server</span><span class="p">.</span><span class="nx">binaryType</span> <span class="o">=</span> <span class="s2">&#34;arraybuffer&#34;</span><span class="p">;</span>
            <span class="nx">waiting</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">waiting</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span>
            <span class="nx">errorBody</span><span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
            <span class="nx">error</span><span class="p">.</span><span class="nx">show</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nx">server</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">waiting</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span>
            <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;${username}&#39;</span><span class="p">,</span> <span class="s1">&#39;加入了聊天室&#39;</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="nx">server</span><span class="p">.</span><span class="nx">onclose</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">server</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;${username}&#39;</span><span class="p">,</span> <span class="s1">&#39;离开了聊天室&#39;</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="nx">server</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">event</span><span class="p">.</span><span class="nx">wasClean</span> <span class="o">||</span> <span class="nx">event</span><span class="p">.</span><span class="nx">code</span> <span class="o">!==</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">errorBody</span><span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="s1">&#39;Code &#39;</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">code</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nx">event</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
                <span class="nx">error</span><span class="p">.</span><span class="nx">show</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">server</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">errorBody</span><span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
            <span class="nx">error</span><span class="p">.</span><span class="nx">show</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="nx">server</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span> <span class="k">instanceof</span> <span class="nx">ArrayBuffer</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">decoder</span><span class="p">.</span><span class="nx">decode</span><span class="p">(</span><span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">)));</span>
                <span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">username</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nx">message</span><span class="p">,</span> <span class="nx">moment</span><span class="p">.</span><span class="nx">unix</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">timestamp</span><span class="p">).</span><span class="nx">format</span><span class="p">(</span><span class="s1">&#39;YYYY/MM/DD kk:mm:ss&#39;</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">errorBody</span><span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="s1">&#39;Unexpected data type [&#39;</span> <span class="o">+</span> <span class="k">typeof</span> <span class="nx">event</span><span class="p">.</span><span class="nx">data</span> <span class="o">+</span> <span class="s1">&#39;].&#39;</span><span class="p">);</span>
                <span class="nx">error</span><span class="p">.</span><span class="nx">show</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">sendMessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">server</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">errorBody</span><span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="s2">&#34;未连接&#34;</span><span class="p">);</span>
                <span class="nx">error</span><span class="p">.</span><span class="nx">show</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="kd">let</span> <span class="nx">text</span> <span class="o">=</span> <span class="nx">messageText</span><span class="p">.</span><span class="nx">val</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">text</span> <span class="o">===</span> <span class="s2">&#34;&#34;</span> <span class="o">||</span> <span class="nx">text</span><span class="p">.</span><span class="nx">trim</span><span class="p">().</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">messageSendLog</span><span class="p">.</span><span class="nx">show</span><span class="p">();</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="nx">messageSendLog</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span>
                <span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="nx">username</span><span class="o">:</span> <span class="s1">&#39;${username}&#39;</span><span class="p">,</span>
                    <span class="nx">message</span><span class="o">:</span> <span class="nx">text</span><span class="p">,</span>
                    <span class="nx">timestamp</span><span class="o">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span>
                <span class="p">}</span>
                <span class="k">try</span> <span class="p">{</span>
                    <span class="kd">let</span> <span class="nx">json</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
                    <span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span> <span class="nx">encoder</span><span class="p">.</span><span class="nx">encode</span><span class="p">(</span><span class="nx">json</span><span class="p">);</span>
                    <span class="nx">server</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">buffer</span><span class="p">);</span>
                    <span class="nx">messageText</span><span class="p">.</span><span class="nx">val</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">errorBody</span><span class="p">.</span><span class="nx">text</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
                    <span class="nx">error</span><span class="p">.</span><span class="nx">show</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">disconnect</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">server</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;${username}&#39;</span><span class="p">,</span> <span class="s1">&#39;离开了聊天室&#39;</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">());</span>
                <span class="nx">server</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
                <span class="nx">server</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                <span class="nx">sendToHome</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nb">window</span><span class="p">.</span><span class="nx">onbeforeunload</span> <span class="o">=</span> <span class="nx">disconnect</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(body\)</span> 标签内网页编写并不是重点，因此我在此省略。我使用了<code>jQuery</code>和<code>moment</code>框架，后者用于处理时间（也就是 <span  class="math">\(server.onmessage\)</span> 方法中出现的 <span  class="math">\(moment.unix\)</span> 方法）；<span  class="math">\(log\)</span> 方法用于向网页中添加聊天记录。在判断完浏览器支持<code>WebSocket</code>之后，我们创建 <span  class="math">\(WebSocket\)</span> 实例，并将类型设为 <span  class="math">\(arraybuffer\)</span> ，这样我们就能以 <span  class="math">\(ArrayBuffer\)</span> 的形式传输消息对象了。接下来就是定义<code>WebSocket</code>和网页的事件方法了。为了传输对象，我先将对象转换为<code>JSON</code>字符串，再将该字符串转换为 <span  class="math">\(Uint8Array\)</span> ，而处理接收到的对象的过程就是反过来。可以看到我们使用了 <span  class="math">\(TextEncoder\)</span> 和 <span  class="math">\(TextDecoder\)</span> 用于编码和译码，主要目的是防止传输中文的过程中出现的乱码，具体可以在我的上一篇博文中查看。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此聊天室实现完毕，没有写<code>CSS</code>(<del>因为懒</del>）。可以在本地部署和测试，通过打开多个浏览器的形式实现创建多个用户。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Apr 19 17:25</span> <a href="/post/%E4%BD%BF%E7%94%A8websocket%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/json%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">JSON序列化传输过程中中文乱码问题的解决方法</a></h1>
            </center>
            <div class="post-content">
                <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天在用<code>WebSocket</code>和<code>Servlet</code>写聊天室的时候发现传输中文会乱码的问题，起初以为是在用<code>jackson</code>的 <span  class="math">\(ObjectMapper\)</span> 将对象转化为字节流的时候出现的问题，但是经过检查后发现不是。又检查了一遍编码，确认了网页的编码是<code>utf-8</code>，输入的字符串也是<code>utf-8</code>，然后发现问题是出在了<code>JSON</code>对象传输的过程中。最后在 <a href="https://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript">stackoverflow</a> 上找到了解法。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的问题出在将经过<code>JSON</code>序列化之后的消息对象字符串转换为 <span  class="math">\(Uint8Array\)</span> 以及将 <span  class="math">\(Uint8Array\)</span> 转为消息对象的过程中，对此可以采用 <span  class="math">\(TextEncoder\)</span> 和 <span  class="math">\(TextDecoder\)</span> 对象。如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">encoder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TextEncoder</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">decoder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TextDecoder</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">username</span><span class="o">:</span> <span class="s1">&#39;用户&#39;</span><span class="p">,</span>
    <span class="nx">content</span><span class="o">:</span> <span class="s1">&#39;你好，世界！&#39;</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span> <span class="nx">encoder</span><span class="p">.</span><span class="nx">encode</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">message</span><span class="p">));</span>
<span class="kd">let</span> <span class="nx">newMessage</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">decoder</span><span class="p">.</span><span class="nx">decode</span><span class="p">(</span><span class="nx">array</span><span class="p">));</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上例中，我们分别使用 <span  class="math">\(TextEncoder\)</span> 和 <span  class="math">\(TextDecoder\)</span> 以<code>utf-8</code>作为编码方式创建了编码器和译码器，之后声明了一个 <span  class="math">\(message\)</span> 对象存储我们要传递的消息，使用<code>JSON</code>序列化该对象，并使用编码器进行编码，编码后得到的是可以进行传输的 <span  class="math">\(Uint8Array\)</span> 对象，而对其使用译码器进行译码可以得到另一个 <span  class="math">\(newMessage\)</span> 对象，该对象内存储的值与之前的 <span  class="math">\(message\)</span> 相同，并且没有出现中文乱码的现象。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Apr 18 22:13</span> <a href="/post/json%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/javaweb3websocket%E7%AE%80%E4%BB%8B/">JavaWeb（3）：WebSocket简介</a></h1>
            </center>
            <div class="post-content">
                <p><strong>参考书籍：《Pro Java for Web Apps》</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WebSocket</code>用于解决浏览器和服务器的通信问题。在现有体系中，如果只是简单的使用<code>Ajax</code>进行通信的话，容易出现的问题是只有浏览器发送请求时才能得到响应。也即当有新数据时，浏览器不能得知新数据的存在，也就不能及时发送请求获取新数据。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WebSocket</code>使用了<code>HTTP/1.1 升级</code>特性。该特性的使用很简单，只需要在请求中包含头名称和值 <span  class="math">\(Connection: Upgrade\)</span> ，并在额外的 <span  class="math">\(Upgrade\)</span> 头中指定一个或多个协议的列表。如果服务器接收升级请求，那么将返回 <span  class="math">\(101\;Switching\;Protocols\)</span> 。<code>HTTP升级</code>提供的最重要的特性是我们可以使用任意协议，并且在升级完成后就不再使用<code>HTTP</code>连接，我们可以用一个<code>Socket</code>来代替，由此产生了<code>WebSocket</code>协议。<code>WebSocket</code>协议将使用心跳消息（分别称为 <span  class="math">\(ping\)</span> 和 <span  class="math">\(pong\)</span> ）保持连接活跃，即周期性地发送小数据包。在连接升级为<code>WebScoket</code>协议之后，文本和二进制消息可以持续在两个方向上发送且不需要关闭和重连了；而且<code>HTTP</code>规范要求对应同一个主机名，只允许有两个并发连接，但由于我们升级为<code>WebScoket</code>连接了，因此该规范也不存在了。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>WebSocket</code>协议之前需先以<code>HTTP</code>协议向服务器发送特殊请求，访问一个特殊的<code>URL</code>，该<code>URL</code>以<code>ws</code>或者<code>wss</code>开头，分别对应<code>http</code>和<code>https</code>，并且除了 <span  class="math">\(Connection: Upgrade\)</span> 头之外，还包含一个 <span  class="math">\(Connection: websocket\)</span> 头，用于指定服务器将连接升级为 <code>WebSocket</code>协议。</p>

<hr>

<h2 id="html5javascript客户端api">HTML5(JavaScript)客户端API</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WebSocket</code>并不是只能用于浏览器和服务器的通信中，理论上可以将其应用于任何支持其的应用程序中。但如果要编写使用<code>WebSocket</code>进行连接的浏览器客户端终端，我们就要用到<code>JavaScript</code>，尽管我们使用<code>JavaScript</code>编写，但实际上<code>WebSocket</code>是<code>HTML5</code>的一部分。使用<code>JavaScript</code>创建<code>WebSocket</code>对象十分简单：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">connection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="s1">&#39;ws://www.example.com/chat&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;chat.v1&#39;</span><span class="p">,</span> <span class="s1">&#39;chat.v2&#39;</span><span class="p">});</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WebSocket</code>构造函数第一个参数为连接所使用的<code>URL</code>，第二个参数可选，为连接所使用的一个或多个协议，这些协议都是自己创建的，不受<code>WebSocket</code>管理。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>WebSocket</code>接口中包含 <span  class="math">\(readyState\)</span> 属性表示当前状态，值为 <span  class="math">\(CONNECTING\)</span>, <span  class="math">\(OPEN\)</span>, <span  class="math">\(CLOSING\)</span>, <span  class="math">\(CLOSED\)</span> 中的一个，包含四个事件：<span  class="math">\(onopen\)</span>, <span  class="math">\(onclose\)</span>, <span  class="math">\(onerror\)</span>, <span  class="math">\(onmessage\)</span> ，前两者分别在 <span  class="math">\(readyState\)</span> 由 <span  class="math">\(CLOSING\)</span> 变为 <span  class="math">\(CLOSED\)</span> 时和 <span  class="math">\(readyState\)</span> 由 <span  class="math">\(CONNECTING\)</span> 变为 <span  class="math">\(OPEN\)</span> 时触发。传入 <span  class="math">\(onclose\)</span> 方法的事件包含三个属性：<span  class="math">\(wasClean\)</span>, <span  class="math">\(code\)</span>, <span  class="math">\(reason\)</span> ，传入 <span  class="math">\(onopen\)</span> 的是普通的事件，传入 <span  class="math">\(onerror\)</span> 和 <span  class="math">\(onmessage\)</span> 的事件包含一个 <span  class="math">\(data\)</span> 属性，在前者中是错误对象，而在后者则根据消息类型转变：消息为字符串，则 <span  class="math">\(data\)</span> 也为字符串；消息为二进制数据，并且 <span  class="math">\(WebSocket.binaryType\)</span> 将被默认设置为 <span  class="math">\(blob\)</span> 时，<span  class="math">\(data\)</span> 为 <span  class="math">\(Blob\)</span> ，而 <span  class="math">\(WebSocket.binaryType\)</span> 为 <span  class="math">\(arraybuffer\)</span> 时，<span  class="math">\(data\)</span> 为 <span  class="math">\(ArrayBuffer\)</span> 。通常我们应该在实例化之后立即设置 <span  class="math">\(bianryType\)</span> 的值。<code>WebSocket</code>对象的 <span  class="math">\(send\)</span> 方法接收 <span  class="math">\(string\)</span>, <span  class="math">\(Blob\)</span>, <span  class="math">\(ArrayBuffer\)</span>, <span  class="math">\(ArrayBufferView\)</span> 中一个类型的参数，表示要传输的数据；并且在该方法的作用域内我们还可以使用 <span  class="math">\(WebSocket.bufferedAmount\)</span> 属性，该属性的值为之前的 <span  class="math">\(send\)</span> 调用还有多少需要传输到服务器的数据。<code>WebSocket</code>的 <span  class="math">\(close\)</span> 用于关闭连接，接收两个可选参数，第一个为关闭代码（默认为 <span  class="math">\(1000\)</span> ），第二个为字符串，表示原因。</p>

<hr>

<h2 id="java-websocket-api">Java WebSocket API</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Java WebSocket API</code>包含在<code>Java EE 7</code>中，包含了客户端和服务端的<code>API</code>，存储在包 <span  class="math">\(javax.websocket\)</span> 中，可以在 <a href="#https://docs.oracle.com/javaee/7/api/"><code>Java EE</code>文档</a> 中查询。</p>

<h3 id="客户端api">客户端API</h3>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><span  class="math">\(WebSocketContainer.connectToServer\)</span></td>
<td align="center">连接远程终端和初始化握手，返回一个 <span  class="math">\(Session\)</span></td>
</tr>

<tr>
<td align="center"><span  class="math">\(ContainerProvider.getWebSocketContainer(\ )\)</span></td>
<td align="center">获取底层<code>WebSocket</code>客户端的实现</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过 <span  class="math">\(@ClientEndpoint\)</span> 注解，我们可以标注出客户端终端，在客户端终端中也有四个事件，分别使用 <span  class="math">\(@OnOpen\)</span>, <span  class="math">\(@OnClose\)</span>, <span  class="math">\(@OnError\)</span>, <span  class="math">\(@OnMessage\)</span> 标注，可以在相关文档中查阅其参数。</p>

<h3 id="服务端api">服务端API</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务端终端可以使用 <span  class="math">\(@ServerEndpoint\)</span> 注解标注，该注解需提供 <span  class="math">\(value\)</span> 特性的值，用于表示该终端所在的相对<code>URL</code>，以 <span  class="math">\(/\)</span> 开头，允许模板参数，<code>Web容器</code>将在每次收到<code>WebSocket</code>连接时创建该类的实例，连接关闭后销毁。在服务端终端中同样包含四个使用 <span  class="math">\(@OnOpen\)</span>, <span  class="math">\(@OnClose\)</span>, <span  class="math">\(@OnError\)</span>, <span  class="math">\(@OnMessage\)</span> 标注出的事件，并且在这些事件中我们还可以使用 <span  class="math">\(@PathParam\)</span> 注解使用我们的模板参数。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Apr 6 14:57</span> <a href="/post/javaweb3websocket%E7%AE%80%E4%BB%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/javaweb2session%E7%AE%80%E4%BB%8B/">JavaWeb（2）：Session简介</a></h1>
            </center>
            <div class="post-content">
                <p><strong>参考书籍：《Pro Java for Web Apps》</strong><br>
注：演示所用 <code>Java</code> 版本为 <code>Java8</code> ，所用容器为 <code>Tomcat8.5.51</code></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;会话用于处理维持请求和请求之间的状态。在没有使用会话时，<code>HTTP</code>请求是无状态的，在浏览器打开第一个连接到服务器的套接字时开启，在服务器返回最后一个数据包时结束。而有些时候，我们希望保持状态，如用户登录或者在线编辑时，这时我们就要用到会话。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Web</code>中，会话是由服务器或<code>Web</code>应用程序管理的某些文件、内存片段、对象或者容器。服务器在第一次接收到请求时，会随机生成一串字符串，称为会话<code>ID</code>，并返回用户浏览器中。之后所有从该用户浏览器中发出的请求都需要包含该会话<code>ID</code>，服务器接收到会话<code>ID</code>后可以将会话与请求关联起来。<code>HTTP cookie</code>用于将会话<code>ID</code>发送到服务器，但是如果用户浏览器禁止了<code>cookie</code>，那么就需要将会话<code>ID</code>内嵌在<code>URL</code>中，很明显，这种方式使得其他人可以轻松地获得会话，因此是不安全的。不过由于如今许多网站都要求用户在访问时启用<code>cookie</code>，因此我们可以不用顾虑这点。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;会话也是有漏洞的。但是由于描述起来篇幅过长，因此不做赘述，如果感兴趣的话可以在 <a href="https://en.wikipedia.org/wiki/Session_hijacking">Session hijacking -Wikipedia</a> 中查看。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大部分情况下我们可以直接使用会话，不需要添加显式配置，但是出于安全目的，我们应该进行配置。使用&lt;<span  class="math">\(session-config\)</span>&gt;标签进行配置，同时在&lt;<span  class="math">\(session-config\)</span>&gt;标签内，我们也可以使用&lt;<span  class="math">\(cookie-config\)</span>&gt;标签进行<code>cookie</code>的配置。所有在&lt;<span  class="math">\(session-config\)</span>&gt;标签和&lt;<span  class="math">\(cookie-config\)</span>&gt;标签内的标签都是可选的。下面列出了所有的可选标签：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;session-config&gt;</span>
    <span class="nt">&lt;session-timeout&gt;</span>30<span class="nt">&lt;/session-timeout&gt;</span>
    <span class="nt">&lt;cookie-config&gt;</span>
        <span class="nt">&lt;name&gt;</span>JSESSIONID<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;domain&gt;</span>example.org<span class="nt">&lt;/domain&gt;</span>
        <span class="nt">&lt;path&gt;</span>/path<span class="nt">&lt;/path&gt;</span>
        <span class="nt">&lt;comment&gt;</span><span class="cp">&lt;! [CDATA[Keeps you logged in. See our privacy policy for more information.]]&gt;</span><span class="nt">&lt;/comment&gt;</span>
        <span class="nt">&lt;http-only&gt;</span>true<span class="nt">&lt;/http-only&gt;</span>
        <span class="nt">&lt;secure&gt;</span>false<span class="nt">&lt;/secure&gt;</span>
        <span class="nt">&lt;max-age&gt;</span>180<span class="nt">&lt;/max-age&gt;</span>
    <span class="nt">&lt;/cookie-config&gt;</span>
    <span class="nt">&lt;tracking-mode&gt;</span>COOKIE<span class="nt">&lt;/tracking-mode&gt;</span>
    <span class="nt">&lt;tracking-mode&gt;</span>URL<span class="nt">&lt;/tracking-mode&gt;</span>
    <span class="nt">&lt;tracking-mode&gt;</span>SSL<span class="nt">&lt;/tracking-mode&gt;</span>
<span class="nt">&lt;/session-config&gt;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面为每个标签的作用：</p>

<table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">&lt;<span  class="math">\(session-timeout\)</span>&gt;</td>
<td align="center">会话在无效前可以保持不活跃状态的时间，以分钟为单位，为 <span  class="math">\(0\)</span> 表示永远不过期。</td>
</tr>

<tr>
<td align="center">&lt;<span  class="math">\(tracking-mode\)</span>&gt;</td>
<td align="center">表示容器使用哪种技术追踪会话ID，可以配置多个值，按照配置顺序使用。<code>URL</code>表示容器将在<code>URL</code>中内嵌会话ID，<code>COOKIE</code>表示使用<code>cookie</code>，<code>SSL</code>表示使用<code>SSL</code>会话，但要求所有请求均是<code>HTTPS</code>请求。</td>
</tr>

<tr>
<td align="center">&lt;<span  class="math">\(name\)</span>&gt;</td>
<td align="center">可以自定义会话<code>cookie</code>的名字，通常不用设置。</td>
</tr>

<tr>
<td align="center">&lt;<span  class="math">\(domain\)</span>&gt;</td>
<td align="center">设置<code>cookie</code>的<code>Domain</code>特性，通常不用设置。</td>
</tr>

<tr>
<td align="center">&lt;<span  class="math">\(path\)</span>&gt;</td>
<td align="center">设置<code>cookie</code>的<code>Path</code>特性，通常不用设置。</td>
</tr>

<tr>
<td align="center">&lt;<span  class="math">\(comment\)</span>&gt;</td>
<td align="center">可以添加任意文本，用于解释<code>cookie</code>。</td>
</tr>

<tr>
<td align="center">&lt;<span  class="math">\(http-only\)</span>&gt;</td>
<td align="center">设置<code>cookie</code>的<code>HttpOnly</code>特性，为了提高安全性，一般都设置为 <span  class="math">\(true\)</span> 。</td>
</tr>

<tr>
<td align="center">&lt;<span  class="math">\(secure\)</span>&gt;</td>
<td align="center">设置<code>cookie</code>的<code>Secure</code>特性，如果使用的是<code>HTTPS</code>，就应设置为 <span  class="math">\(true\)</span> 。</td>
</tr>

<tr>
<td align="center">&lt;<span  class="math">\(max-age\)</span>&gt;</td>
<td align="center">设置<code>cookie</code>的<code>Max-Age</code>特性，控制<code>cookie</code>何时过期，以秒为单位，通常不用设置。</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习了如何配置会话之后，就该学习如何使用会话了。为了获取会话，我们可以调用 <span  class="math">\(HttpServletRequest.getSession(\ )\)</span> 方法。该方法不接受或者接受一个 <span  class="math">\(boolean\)</span> 类型的参数。无参或者传入 <span  class="math">\(true\)</span> 时会在没有会话时创建会话，传入 <span  class="math">\(false\)</span> 则不会创建。调用该方法后我们就得到了一个 <span  class="math">\(javax.servlet.http.HttpSession\)</span> 类型。对于该对象，常用方法如下：</p>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><span  class="math">\(getAttribute\)</span></td>
<td align="center">返回会话中储存的对象。</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getAttributeNames\)</span></td>
<td align="center">返回会话中所有特性的名字的枚举。</td>
</tr>

<tr>
<td align="center"><span  class="math">\(setAttribute\)</span></td>
<td align="center">将对象绑定到会话中。</td>
</tr>

<tr>
<td align="center"><span  class="math">\(removeAttribute\)</span></td>
<td align="center">移除会话中的特性。</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getId\)</span></td>
<td align="center">返回会话<code>ID</code>。</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getCreationTime\)</span></td>
<td align="center">返回会话对象的创建时间。</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getLastAccessedTime\)</span></td>
<td align="center">返回最后一个包含该会话<code>ID</code>的请求的时间。</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getMaxInactiveInterval\)</span></td>
<td align="center">返回&lt;<span  class="math">\(session-timeout\)</span>&gt;中设置的时间。</td>
</tr>

<tr>
<td align="center"><span  class="math">\(setMaxInactiveInterval\)</span></td>
<td align="center">设置最长不活跃状态时间。</td>
</tr>

<tr>
<td align="center"><span  class="math">\(invalidate\)</span></td>
<td align="center">销毁会话并解除所有绑定到会话的数据，常用于用户注销。</td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下为一个简单的使用会话的例子。我们首先在部署描述符中添加以下配置信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;session-config&gt;</span>
    <span class="nt">&lt;session-timeout&gt;</span>30<span class="nt">&lt;/session-timeout&gt;</span>
    <span class="nt">&lt;cookie-config&gt;</span>
        <span class="nt">&lt;http-only&gt;</span>true<span class="nt">&lt;/http-only&gt;</span>
    <span class="nt">&lt;/cookie-config&gt;</span>
    <span class="nt">&lt;tracking-mode&gt;</span>COOKIE<span class="nt">&lt;/tracking-mode&gt;</span>
<span class="nt">&lt;/session-config&gt;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后创建 <span  class="math">\(Servlet\)</span>：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@WebServlet</span> <span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;testServlet&#34;</span><span class="o">,</span> <span class="n">urlPatterns</span> <span class="o">=</span> <span class="s">&#34;/test&#34;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestServlet</span> <span class="kd">extends</span> <span class="n">HttpServlet</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hashtable</span><span class="o">&lt;&gt;();</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="s">&#34;one&#34;</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="s">&#34;two&#34;</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">3</span><span class="o">,</span> <span class="s">&#34;three&#34;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> 
        <span class="kd">throws</span> <span class="n">ServletException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">HttpSession</span> <span class="n">session</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getSession</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">session</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">&#34;map&#34;</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">session</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">&#34;map&#34;</span><span class="o">,</span> <span class="n">map</span><span class="o">);</span>
        <span class="n">request</span><span class="o">.</span><span class="na">getRequestDispatcher</span><span class="o">(</span><span class="s">&#34;/WEB-INF/jsp/view.jsp&#34;</span><span class="o">).</span><span class="na">forward</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <span  class="math">\(view.jsp\)</span> 中，我们创建如下语句：</p>
<pre><code class="language-jsp" data-lang="jsp">&lt;%--@elvariable id=&#34;map&#34; type=&#34;java.util.Map&#34;--%&gt;
&lt;%@ taglib prefix=&#34;c&#34; uri=&#34;http://java.sun.com/jsp/jstl/core&#34; %&gt;
&lt;%@ page contentType=&#34;text/html;charset=UTF-8&#34; language=&#34;java&#34; %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;c:forEach items=&#34;${map}&#34; var=&#34;map&#34;&gt;
    &lt;c:out value=&#34;key: ${map.key} value: ${map.value}&#34;/&gt;&lt;br/&gt;
&lt;/c:forEach&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上例中我们使用了 <span  class="math">\(getSession\)</span> 获取会话对象，之后使用 <span  class="math">\(getAttribute\)</span> 查询会话特性，再使用 <span  class="math">\(setAttribute\)</span> 设置会话特性，在 <span  class="math">\(view.jsp\)</span> 中，我们使用 &lt;<span  class="math">\(c:forEach\)</span>&gt; 进行遍历，&lt;<span  class="math">\(c:out\)</span>&gt;标签进行输出。因为 <span  class="math">\(session\)</span> 是<code>jsp</code>中的隐式变量，所以可以直接使用。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Mar 26 15:41</span> <a href="/post/javaweb2session%E7%AE%80%E4%BB%8B/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/javaweb1servlet%E5%85%A5%E9%97%A8/">JavaWeb（1）：Servlet入门</a></h1>
            </center>
            <div class="post-content">
                <p><strong>参考书籍：Pro Java for Web Apps</strong><br>
注：以下内容需要<code>HTTP</code>基础，演示所用<code>Java</code>版本为<code>Java8</code>，所用容器为<code>Tomcat8.5.51</code></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Servlet</code>是一个运行在<code>Web</code>服务器中的<code>Java</code>小程序，用于接收和响应来自<code>Web</code>客户端的请求，使用<code>HTTP</code>进行通信，是所有<code>Web</code>应用程序的核心类，也是唯一的既可以直接处理和响应用户请求，也可以将处理工作委托给应用中的其他部分的类。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Servlet</code>只是一个简单的接口，包含了相关的方法。大多数情况下<code>Servlet</code>都继承自 <span  class="math">\(javax.servlet.GenericServlet\)</span> 类，该类只包含一个抽象的 <span  class="math">\(service\)</span> 方法以及一些辅助方法。<span  class="math">\(service\)</span> 方法会处理所有请求，然后返回对应的响应。我们可以使用<span  class="math">\(javax.servlet.http.HttpServlet\)</span> 类用于响应<code>HTTP</code>请求，它继承自 <span  class="math">\(GenericServlet\)</span> 并实现其 <span  class="math">\(service\)</span> 方法，而对于响应<code>HTTP</code>请求的方法只是空实现。在 <span  class="math">\(HttpServlet\)</span> 类中，<code>HTTP</code>请求包括 <span  class="math">\(GET,HEAD,POST,PUT,DELETE,OPTIONS,TRACE\)</span> 对应的响应方法名称为 <span  class="math">\(do +\)</span> 首字母大写的请求名称。如 <span  class="math">\(GET\)</span> 对应 <span  class="math">\(doGet()\)</span> ，<span  class="math">\(POST\)</span> 对应 <span  class="math">\(doPost()\)</span> 等。除了响应方法之外，<code>Servlet</code>类中还包含 <span  class="math">\(init\)</span> 方法和 <span  class="math">\(destroy\)</span> 方法，分别在启用和关闭<code>Servlet</code>时调用，不过通常这些方法什么也不做。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
大多数情况下我们的<code>Servlet</code>类都是继承 <span  class="math">\(HttpServlet\)</span> 类。对于上述提到的所有方法，它们都接收两个参数，一个是 <span  class="math">\(javax.servlet.http.HttpServletRequest\)</span> 类型的参数，另一个是 <span  class="math">\(javax.servlet.http.HttpServletResponse\)</span> 类型。顾名思义，<span  class="math">\(HttpServletRequest\)</span> 指向客户端请求，对其我们有如下常用方法：</p>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><span  class="math">\(getParameter\)</span></td>
<td align="center">返回参数的单个值</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getParameterValues\)</span></td>
<td align="center">返回参数的值的数组</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getParameterMap\)</span></td>
<td align="center">返回一个包含所有参数名值对的<span  class="math">\(java.util.Map&lt;String, String[\ \ ]&gt;\)</span></td>
</tr>

<tr>
<td align="center"><span  class="math">\(getParameterNames\)</span></td>
<td align="center">返回所有可用参数的名字的枚举</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getContentLength\)</span></td>
<td align="center">返回请求正文的长度（小于 <span  class="math">\(2\)</span> GB）</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getContentLengthLong\)</span></td>
<td align="center">返回请求正文的长度（大于 <span  class="math">\(2\)</span> GB）</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getCharacterEncoding\)</span></td>
<td align="center">返回请求内容的字符编码</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getReader\)</span></td>
<td align="center">返回一个 <span  class="math">\(java.io.BufferedReader\)</span> 类，可以用于读取请求的内容</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getRequestURL\)</span></td>
<td align="center">返回客户端用于创建请求的完整<code>URL</code></td>
</tr>

<tr>
<td align="center"><span  class="math">\(getRequestURI\)</span></td>
<td align="center">返回<code>URL</code>中的服务器路径部分</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getServletPath\)</span></td>
<td align="center">返回匹配<code>Servlet</code>映射的<code>URL</code>部分</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getHeader\)</span></td>
<td align="center">返回指定名称的第一个值</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getHeaders\)</span></td>
<td align="center">返回指定名称的所有值的枚举</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getHeaderNames\)</span></td>
<td align="center">返回请求中所有头数据的名称的枚举</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getIntHeader\)</span></td>
<td align="center">返回所有值为整型的头数据的一个值</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getDateHeader\)</span></td>
<td align="center">返回可以识别为有效时间戳的头数据的时间戳</td>
</tr>
</tbody>
</table>

<p>而<span  class="math">\(HttpServletResponse\)</span> 指向服务端响应，我们有如下常用方法：</p>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><span  class="math">\(getOutputStream\)</span></td>
<td align="center">返回一个 <span  class="math">\(javax.servlet.ServletOutputStream\)</span> 类，向响应中输出二进制数据</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getWriter\)</span></td>
<td align="center">返回一个 <span  class="math">\(java.io.PrintWriter\)</span> 类，向响应中输出字符</td>
</tr>

<tr>
<td align="center"><span  class="math">\(setContentType\)</span></td>
<td align="center">设置响应正文内容的类型</td>
</tr>

<tr>
<td align="center"><span  class="math">\(setCharacterEncoding\)</span></td>
<td align="center">设置响应内容的编码格式</td>
</tr>

<tr>
<td align="center"><span  class="math">\(setHeader\)</span></td>
<td align="center">设置指定名称头数据的值</td>
</tr>

<tr>
<td align="center"><span  class="math">\(setIntHeader\)</span></td>
<td align="center">设置指定值为整型的头数据的值</td>
</tr>

<tr>
<td align="center"><span  class="math">\(setDateHeader\)</span></td>
<td align="center">设置头数据时间戳</td>
</tr>

<tr>
<td align="center"><span  class="math">\(setStatus\)</span></td>
<td align="center">设置<code>HTTP</code>响应状态码</td>
</tr>

<tr>
<td align="center"><span  class="math">\(getStatus\)</span></td>
<td align="center">判断当前响应的状态</td>
</tr>

<tr>
<td align="center"><span  class="math">\(sendError\)</span></td>
<td align="center">设置状态码，一条可选的错误消息会输出到响应数据中，重定向到<code>Web</code>容器为客户端提供的错误页面并清空缓存</td>
</tr>

<tr>
<td align="center"><span  class="math">\(sendRedirect\)</span></td>
<td align="center">重定向客户端至另一个<code>URL</code></td>
</tr>
</tbody>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过声明一个 <code>Servlet</code>类，我们的已经可以接受任何<code>HTTP</code>请求了，但由于我们并未重写空实现，因此我们无法响应请求，因此我们需要重写方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">com.wrox</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.servlet.ServletException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.annotation.WebServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServlet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.servlet.http.HttpServletResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.PrintWriter</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloServlet</span> <span class="kd">extends</span> <span class="n">HttpServlet</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ServletException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="n">resp</span><span class="o">.</span><span class="na">getWriter</span><span class="o">().</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;Hello world!&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(HttpServletResponse\)</span> 中的 <span  class="math">\(getWriter(\ \ )\)</span> 方法返回一个 <span  class="math">\(java.io.PrintWriter\)</span> 类，可以将文本输入到输出流中。通过实现了 <span  class="math">\(doGet(\ \ )\)</span> 方法，我们实现了对 <span  class="math">\(GET\)</span> 请求的响应。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然我们实现了响应请求，但是我们的程序并未部署。为了部署程序，我们要通过 <span  class="math">\(web.xml\)</span> ，这个文件定义了程序中的监听器、<code>Servlet</code>、过滤器以及应用程序的设置。在 <span  class="math">\(WEB-INF\)</span> 目录中创建 <span  class="math">\(web.xml\)</span> 文件（如果没有的话）。通常我们看到的初始的 <span  class="math">\(web.xml\)</span> 文件是这样的：
<figure><img src="/image/2020-3-14-1.png" alt="web.xml"></figure>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中标签 <span  class="math">\(&lt;web-app&gt;\)</span> 部分中的 <span  class="math">\(version\)</span> 表明了程序所使用的 <span  class="math">\(Servlet API\)</span> 版本。之后添加的内容均需要在 <span  class="math">\(&lt;web-app&gt;\)</span> 中添加。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们要创建一个 <span  class="math">\(Servlet\)</span> 实例，那么我们可以在文件添加如下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;servlet&gt;</span>
    <span class="nt">&lt;servlet-name&gt;</span>helloServlet<span class="nt">&lt;/servlet-name&gt;</span>
    <span class="nt">&lt;servlet-class&gt;</span>com.wrox.HelloServlet<span class="nt">&lt;/servlet-class&gt;</span>
    <span class="nt">&lt;load-on-startup&gt;</span>1<span class="nt">&lt;/load-on-startup&gt;</span>
<span class="nt">&lt;/servlet&gt;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现 <span  class="math">\(&lt;servlet-name&gt;\)</span> 中指定了 <span  class="math">\(Servlet\)</span> 的名称，<span  class="math">\(&lt;servlet-class&gt;\)</span> 指定了对应的类，而对于 <span  class="math">\(&lt;load-on-startup&gt;\)</span> ，我们需要先知道，默认情况下 <span  class="math">\(init\)</span> 方法是只有当接收到请求时才会调用的，而如果我们设置了 <span  class="math">\(&lt;load-on-startup&gt;\)</span> 那么 <span  class="math">\(Servlet\)</span> 将会按顺序启动 <span  class="math">\(Servlet\)</span> ，而不是接收到请求后才启动。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在部署之后，我们还需要告诉服务器我们所部署的 <span  class="math">\(Servlet\)</span> 响应哪些请求：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;servlet-mapping&gt;</span>
    <span class="nt">&lt;servlet-name&gt;</span>helloServlet<span class="nt">&lt;/servlet-name&gt;</span>
    <span class="nt">&lt;url-pattern&gt;</span>/greeting<span class="nt">&lt;/url-pattern&gt;</span>
<span class="nt">&lt;/servlet-mapping&gt;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的配置告诉程序所有 <span  class="math">\(/greeting\)</span> 的请求都由 <span  class="math">\(helloServlet\)</span> 处理。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在处理完上述步骤之后，我们就可以运行了。我们在 <span  class="math">\(/greeting\)</span> 上看到 <span  class="math">\(Hello\ \ world!\)</span> 时，就代表我们的程序运行成功了。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了上面的方法，我们还可以通过使用 <span  class="math">\(@WebServlet\)</span> 注解，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@WebServlet</span> <span class="o">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">&#34;helloServlet&#34;</span><span class="o">,</span>
    <span class="n">urlPatterns</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;/greeting&#34;</span><span class="o">},</span>
    <span class="n">loadOnStartup</span> <span class="o">=</span> <span class="n">1</span>
<span class="o">)</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用注解的缺点就是每次修改参数之后都要重新编译程序。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Mar 14 19:20</span> <a href="/post/javaweb1servlet%E5%85%A5%E9%97%A8/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">Dijkstra算法原理及其实现</a></h1>
            </center>
            <div class="post-content">
                <p><strong>参考书籍：《算法（第4版）》</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Dijkstra\)</span> 算法应用于带权有向图中求最短路径问题。通俗来讲就是不断选择权值最小的边加入集合直到所有顶点都在集合中，属于贪心算法。需要注意的是，<span  class="math">\(Dijkstra\)</span> 算法只能用于解决边权非负的图类问题。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设对于一个带权有向图 <span  class="math">\(G(V,E)\)</span> 以邻接矩阵表示，其所有边存储在一个二维整型数组 <span  class="math">\(matrix[\ \ ][\ \ ]\)</span> 中， <span  class="math">\(matrix[i][j]\)</span> 表示从顶点 <span  class="math">\(i\)</span> 到顶点 <span  class="math">\(j\)</span> 之间的边，值为边的权值，若值为 <span  class="math">\(∞\)</span> ，说明该边不存在。为了实现 <span  class="math">\(Dijkstra\)</span> 算法，我们需要一个布尔值数组 <span  class="math">\(visit[\ \ ]\)</span> ，用于判断顶点是否访问过，或者说是否在集合中；一个整型数组 <span  class="math">\(distance[\ \ ]\)</span> 用于储存原点到每个点的最短距离。定义了基本的结构，就可以实现算法了，步骤为：</p>

<ol>
<li>从 <span  class="math">\(V\)</span> 中选择一个点 <span  class="math">\(s\)</span> 作为原点，将邻接矩阵中的 <span  class="math">\(matrix[s]\)</span> 数组复制到 <span  class="math">\(distance[s]\)</span> （复制后 <span  class="math">\(distance[s]\)</span> 应为 <span  class="math">\(0\)</span> ），建立一个 <span  class="math">\(visit[\ \ ]\)</span> 数组并清零。</li>
<li>从 <span  class="math">\(V\)</span> 中选择一个顶点 <span  class="math">\(u\)</span> 加入集合，其中点 <span  class="math">\(u\)</span> 满足：<br>

<ul>
<li>之前未曾访问过点 <span  class="math">\(u\)</span> （即 <span  class="math">\(visit[u] = false\)</span> ）。</li>
<li>与 <span  class="math">\(s\)</span> 距离最短（即 <span  class="math">\(distance[u]\)</span> 的值最小）。</li>
</ul></li>
<li>以 <span  class="math">\(u\)</span> 为中心点，对于每个与 <span  class="math">\(u\)</span> 相邻的顶点 <span  class="math">\(k\)</span> ，令 <span  class="math">\(distance[k] = Min(distance[k], distance[u] + matrix[u][k])\)</span> ，这一步也称为<code>松弛</code>( <span  class="math">\(relaxation\)</span> )。</li>
<li>重复2、3直到所有顶点加入集合。</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span  class="math">\(Dijkstra\)</span> 算法类似于 <span  class="math">\(Prim\)</span> 算法，实质上都是构造了一颗树。经过以上步骤之后，我们得到了一个 <span  class="math">\(distance[\ \ ]\)</span> 数组，其中的值为从原点 <span  class="math">\(s\)</span> 到图中其他所有点的最短距离。在使用代码实现的过程中，有些情况下我们可以使用优先队列来简化寻找最小权值的这一过程。如果我们确认了一幅图是无环图，那么我们也可以不使用 <span  class="math">\(visit[\ \ ]\)</span> ，而是通过拓扑排序的顺序依次遍历顶点。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将上述过程转化为代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dijkstra</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dijkstra</span> <span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">bool</span><span class="o">[]</span> <span class="n">visit</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">distance</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
        <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">s</span><span class="o">],</span> <span class="n">0</span><span class="o">,</span> <span class="n">distance</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span> <span class="c1">// 复制邻接矩阵的值
</span><span class="c1"></span>        <span class="n">distance</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="n">visit</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// 遍历其他顶点
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
            <span class="c1">// 寻找最小权值
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visit</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">distance</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="n">visit</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="c1">// 松弛
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">visit</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">k</span><span class="o">])</span>
                    <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">distance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此我们实现了 <span  class="math">\(Dijkstra\)</span> 算法。虽然这里我们没有使用优先队列，但是使用优先队列是可行的，也可以在一定程度上加快速度。 <span  class="math">\(Dijkstra\)</span> 算法有许多种优化策略，而不同的策略对应的时间复杂度也是不同，因此在此不作过多叙述，如果感兴趣的话可以在 <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Description">Dijkstra's algorithm - Wikipedia</a> 中查看。如果我们将寻找最小权值的过程改为寻找最大权值，那么就可以由最短路径算法改为最长路径算法。</p>

<hr>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 <span  class="math">\(Dijkstra\)</span> 算法有很多题，在这里举一道题为例。</p>

<p><a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">原题地址：Problem 1334</a></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然在这道题就是一道求最短距离的算法，分别以每个城市为原点计算 <span  class="math">\(distance[\ \ ]\)</span> 数组，再遍历数组得到答案，最终输出最大值即可。我们直接将上面的 <span  class="math">\(Dijkstra\)</span> 算法的模板套进去就行了。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findTheCity</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">edges</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distanceThreshold</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 将边集转换为邻接矩阵
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">)</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span> <span class="c1">// 用最大值代表无穷
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="o">)</span> <span class="n">matrix</span><span class="o">[</span><span class="n">edge</span><span class="o">[</span><span class="n">0</span><span class="o">]][</span><span class="n">edge</span><span class="o">[</span><span class="n">1</span><span class="o">]]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="n">edge</span><span class="o">[</span><span class="n">1</span><span class="o">]][</span><span class="n">edge</span><span class="o">[</span><span class="n">0</span><span class="o">]]</span> <span class="o">=</span> <span class="n">edge</span><span class="o">[</span><span class="n">2</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">MIN</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
        <span class="c1">// 分别以每个点为原点，调用 Dijkstra算法
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">distance</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visit</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">0</span><span class="o">,</span> <span class="n">distance</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
            <span class="n">distance</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">visit</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">min</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
                        <span class="n">u</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="n">visit</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">visit</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">k</span><span class="o">])</span>
                        <span class="n">distance</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
            <span class="o">}</span>

            <span class="c1">// 计算相邻城市数
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">dist</span> <span class="o">:</span> <span class="n">distance</span><span class="o">)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">distanceThreshold</span><span class="o">)</span> <span class="n">count</span><span class="o">++;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="n">MIN</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">MIN</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2020 Mar 3 17:27</span> <a href="/post/dijkstra%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/">JavaScript中的数组</a></h1>
            </center>
            <div class="post-content">
                <p><strong>参考书籍：《JavaScript高级程序设计（第3版）》</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为一种可以说是最常用的类型，<code>EMCAScript</code>当中的数组与其他语言的数组有很大区别，例如数组元素可以是不同类型，数组长度可以动态调整等，因此我总结了一下<code>EMCAScript</code>中的数组类型，即 <span  class="math">\(Array\)</span> 类型（主要集中于与其他语言不同的地方）。</p>

<ol>
<li><a href="#2020-03-01-1">数组创建</a></li>
<li><a href="#2020-03-01-2">数组长度</a></li>
<li><a href="#2020-03-01-3">数组方法</a>

<ol>
<li><a href="#2020-03-01-3-1">判定方法</a></li>
<li><a href="#2020-03-01-3-2">转换方法</a></li>
<li><a href="#2020-03-01-3-3">栈方法</a></li>
<li><a href="#2020-03-01-3-4">队列方法</a></li>
<li><a href="#2020-03-01-3-5">排序方法</a></li>
<li><a href="#2020-03-01-3-6">操作方法</a></li>
<li><a href="#2020-03-01-3-7">位置方法</a></li>
<li><a href="#2020-03-01-3-8">迭代方法</a></li>
<li><a href="#2020-03-01-3-9">归并方法</a></li>
</ol></li>
</ol>

<h2 id="span-id2020030111-数组创建span"><span id="2020-03-01-1">1. 数组创建</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>EMCAScript</code>中数组是一个特殊的类型，有自己的构造函数，我们可以通过 <span  class="math">\(new\)</span> 运算符来调用数组的构造函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span> <span class="c1">//建立一个空数组
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，你也可以通过传参来调用带参构造函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">array1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//大小为10的数组
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">array2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">//包含1,2,3三个元素的数组
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">array2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="s2">&#34;A&#34;</span><span class="p">);</span> <span class="c1">//包含一个&#34;A&#34;的数组
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在这里要注意的是，如果你只给构造函数传一个数字，则会创建对应大小的数组,其中每一项的值都是 <span  class="math">\(undefined\)</span> ；如果传的是多个数字，则会创建包含这些数字的数组。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了调用构造函数之外，我们还可以使用字面量语法。如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">array1</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">//空数组
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">array2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">//包含一个1的数组
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">array3</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;A&#34;</span><span class="p">,</span> <span class="s2">&#34;B&#34;</span><span class="p">,</span> <span class="s2">&#34;C&#34;</span><span class="p">];</span> <span class="c1">//包含三个元素的数组
</span></code></pre></div>
<hr>

<h2 id="span-id2020030122-数组长度span"><span id="2020-03-01-2">2. 数组长度</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与其他语言相似，<code>EMCAScript</code>中的数组下标从 <span  class="math">\(0\)</span> 开始， <span  class="math">\(length - 1\)</span> 结束，要访问对应下标的值，可以通过方括号内添加下标读取或者写入数据，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;A&#34;</span><span class="p">,</span> <span class="s2">&#34;B&#34;</span><span class="p">,</span> <span class="s2">&#34;C&#34;</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// &#34;A&#34;
</span><span class="c1"></span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;D&#34;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// &#34;D&#34;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是与其他语言不同的是，如果你访问的下标超过了当前数组的长度，即 <span  class="math">\(length - 1\)</span> ，会返回 <span  class="math">\(undefined\)</span>。而你在这时写入数据的话，数组的长度会更新为你访问的下标值加一，而从原先的最大下标到新的最大下标之间的值会以 <span  class="math">\(undefined\)</span> 填充。如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;A&#34;</span><span class="p">,</span> <span class="s2">&#34;B&#34;</span><span class="p">,</span> <span class="s2">&#34;C&#34;</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span> <span class="c1">//undefined
</span><span class="c1"></span><span class="nx">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;F&#34;</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span> <span class="c1">//undefined
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span> <span class="c1">//&#34;F&#34;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>EMCAScript</code>中的数组长度还有个特点，就是它不是只读的，你可以通过设置数组长度的值直接改变数组大小，这时新增的值会以 <span  class="math">\(undefined\)</span> 填充。如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;A&#34;</span><span class="p">,</span> <span class="s2">&#34;B&#34;</span><span class="p">,</span> <span class="s2">&#34;C&#34;</span><span class="p">];</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="c1">//undefined
</span><span class="c1"></span><span class="nx">array</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="c1">//undefined
</span></code></pre></div>
<hr>

<h2 id="3-span-id202003013数组方法span">3. <span id="2020-03-01-3">数组方法</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>EMCAScript</code>中的数组方法非常有特点，它使得<code>JavaScript</code>中的数组可以代替多种结构。</p>

<hr>

<h3 id="span-id202003013131-判定方法span"><span id="2020-03-01-3-1">3.1 判定方法</span></h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于<code>JavaScript</code>是一门弱类型语言，因此如何判断一个对象为数组非常有用的，对于一个网页或者全局作用域，使用 <span  class="math">\(instanceof\)</span> 操作符即可。如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span> <span class="k">instanceof</span> <span class="nb">Array</span><span class="p">);</span> <span class="c1">//true
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但问题在于，如果存在多个框架，即多个全局作用域，这时如果你从另一个框架传入数组，由于各个框架中的数组分别有各自的构造函数，因此这时对另一个框架中的数组使用 <span  class="math">\(instanceof\)</span> 操作符时会返回 <span  class="math">\(false\)</span> 。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了避免这种情况，可以使用<code>EMCAScript5</code>中的 <span  class="math">\(Array.isArray(\ )\)</span> 方法，该方法不会受到作用域影响，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">array</span><span class="p">));</span> <span class="c1">//true
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然要注意的是，可能有的浏览器不支持该方法。</p>

<hr>

<h2 id="span-id202003013232-转换方法span"><span id="2020-03-01-3-2">3.2 转换方法</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>EMCAScript</code>中所有的对象都具有三个方法—— <span  class="math">\(toLocaleString(\ )\)</span> 、<span  class="math">\(toString(\ )\)</span> 以及 <span  class="math">\(valueOf(\ )\)</span> 方法。其中 <span  class="math">\(valueOf(\ )\)</span> 方法返回数组本身；<span  class="math">\(toString(\ )\)</span> 方法以字符串的形式返回数组中的所有元素（每个元素之间用逗号隔开）；<span  class="math">\(toLocaleString(\ )\)</span> 大部分情况下与 <span  class="math">\(toString(\ )\)</span> 返回相同的值，但是不同之处在于 <span  class="math">\(toLocaleString(\ )\)</span> 方法是调用每个元素的 <span  class="math">\(toLocaleString(\ )\)</span> 方法后再用逗号连接起来，也就是说当一个元素的 <span  class="math">\(toString(\ )\)</span> 方法与它的 <span  class="math">\(toLocaleString(\ )\)</span> 方法不同时，调用数组的 <span  class="math">\(toString(\ )\)</span> 方法和 <span  class="math">\(toLocaleString(\ )\)</span> 方法就会返回不同的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">toLocaleString</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s2">&#34;LocaleString&#34;</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">toString</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s2">&#34;String&#34;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nx">object</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span> <span class="c1">//&#34;1,String&#34;
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">toLocaleString</span><span class="p">());</span> <span class="c1">//&#34;1,LocaleString&#34;
</span></code></pre></div>
<hr>

<h2 id="span-id202003013333-栈方法span"><span id="2020-03-01-3-3">3.3 栈方法</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过<code>EMCAScript</code>中数组的栈方法，我们可以把一个数组当成栈来使用。实现栈的两个方法分别是 <span  class="math">\(Array.prototype.push(\ )\)</span> 和 <span  class="math">\(Array.prototype.pop(\ )\)</span> 。<span  class="math">\(Array.prototype.push(\ )\)</span> 方法接收一个或多个参数，将这些参数按序压入栈内，返回参数个数；<span  class="math">\(Array.prototype.pop(\ )\)</span> 方法推出栈顶元素并返回。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span> <span class="c1">// 2
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">());</span> <span class="c1">// 2
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 1
</span></code></pre></div>
<hr>

<h2 id="span-id202003013434-队列方法span"><span id="2020-03-01-3-4">3.4 队列方法</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似于栈方法，<code>EMCAScript</code>中也提供了能够让一个数组当作队列使用的方法。由于 <span  class="math">\(Array.prototype.push(\ )\)</span> 方法本身就是向末尾添加元素的方法，因此只需要另一个从数组开始删除元素的方法即可，实现这一操作的方法就是 <span  class="math">\(Array.prototype.shift(\ )\)</span> 方法，它能够删除并返回数组第一项元素。此外，<code>EMCAScript</code>还提供了一 <span  class="math">\(Array.prototype.unshift(\ )\)</span> ，即向数组开始添加元素并返回元素个数。通过结合 <span  class="math">\(Array.prototype.push(\ )\)</span> , <span  class="math">\(Array.prototype.pop(\ )\)</span> , <span  class="math">\(Array.prototype.shift(\ )\)</span> , <span  class="math">\(Array.prototype.unshift(\ )\)</span> 这四个方法，我们能够把一个数组当作双向队列使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span> <span class="c1">// 2
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">shift</span><span class="p">());</span> <span class="c1">// 3
</span></code></pre></div>
<hr>

<h2 id="span-id202003013535-排序方法span"><span id="2020-03-01-3-5">3.5 排序方法</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>EMCAScript</code>中提供了两个数组排序方法—— <span  class="math">\(Array.prototype.reverse(\ )\)</span> 和 <span  class="math">\(Array.prototype.sort(\ )\)</span> ，分别用于数组反转和排序。需要注意的是，在不传参数的情况下 <span  class="math">\(Array.prototype.sort(\ )\)</span> 方法默认会调用每个元素的 <span  class="math">\(toString(\ )\)</span> 方法，之后通过字符串比较来确定大小，得到升序数组。而通过传参，我们可以得到想要的排序数组，具体的传入参数应该是一个函数对象，类似于<code>C++</code>和<code>Java</code>中的排序方法，该函数接收两个元素，若前者需要排在后者前面，则应返回一个负数，若前者等于后者，则返回 <span  class="math">\(0\)</span> ，若前者需要排在后者后面，则返回一个正数。如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value1</span><span class="p">,</span> <span class="nx">value2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value2</span> <span class="o">-</span> <span class="nx">value1</span><span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span> <span class="c1">// &#34;6,5,4,3,1&#34;
</span></code></pre></div>
<h2 id="span-id202003013636-操作方法span"><span id="2020-03-01-3-6">3.6 操作方法</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>EMCAScript</code>提供了很多操作方法，这里选择了几个常用方法。</p>

<ul>
<li><span  class="math">\(Array.prototype.concat(\ )\)</span> 方法<br>

<ul>
<li>用于连接两个数组，或者将一个元素添加到数组末尾，若未传入参数，返回数组本身。</li>
</ul></li>
<li><span  class="math">\(Array.prototype.slice(\ )\)</span> 方法

<ul>
<li>当接收一个参数时，该参数指定一个位置，返回一个新数组，元素为之前数组的指定位置到末尾的所有元素</li>
<li>当接收两个参数时，第一个参数指定位置，第二个参数指定结束位置，返回一个新数组，元素为之前数组指定的起始位置到指定的结束位置之间的所有元素。</li>
</ul></li>
<li><span  class="math">\(Array.prototype.splice(\ )\)</span> 方法<br>

<ul>
<li>当接收两个参数时，第一个参数指定位置，第二个参数指定个数，删除数组中从起始位置开始对应个数的元素，并返回一个储存这些元素的数组</li>
<li>当接收三个或多个参数时，第一个参数指定起始位置，第二个参数指定个数，之后的参数为要插入的元素，删除数组中从指定位置开始对应个数的元素，再插入指定的元素。</li>
</ul></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span> <span class="c1">// &#34;1,2,3,4,5,6,7&#34;
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span> <span class="c1">// &#34;2&#34;
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span> <span class="c1">// &#34;2,3&#34;
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">);</span> <span class="c1">// &#34;1,3,4,5&#34;
</span></code></pre></div>
<h2 id="span-id202003013737-位置方法span"><span id="2020-03-01-3-7">3.7 位置方法</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似于<code>Java</code>，<code>EMCAScript</code>提供了 <span  class="math">\(Array.indexOf(\ )\)</span> 方法和 <span  class="math">\(Array.lastIndexOf(\ )\)</span> 。且其用法也与<code>Java</code>相似，传入要查找的元素，返回其位置，若未找到，返回 <span  class="math">\(-1\)</span> 。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">lastIndexOf</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// 1
</span></code></pre></div>
<h2 id="span-id202003013838-迭代方法span"><span id="2020-03-01-3-8">3.8 迭代方法</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;迭代方法，即遍历数组，对每个元素执行某个指定操作的函数。<code>EMCAScript</code>中提供了五个迭代方法，每个方法都接收一个或两个参数，第一个参数指定要进行操作的函数，第二个参数（可选）指定前者运行的作用域。传入的函数接收三个参数，数组元素的值、位置和数组本身。迭代方法会遍历数组，并对其中的每个元素执行指定的函数。这些迭代方法的返回值可能会受到传入的函数的影响，返回值的主要区别是：</p>

<ul>
<li><span  class="math">\(every(\ )\)</span> ：只有所有元素的返回值均为 <span  class="math">\(true\)</span> 时，返回 <span  class="math">\(true\)</span> 。</li>
<li><span  class="math">\(filter(\ )\)</span> ：返回一个由数组中返回 <span  class="math">\(true\)</span> 的元素组成的数组。</li>
<li><span  class="math">\(forEach(\ )\)</span> ：无返回值。</li>
<li><span  class="math">\(map(\ )\)</span> ：返回一个储存每次函数调用结果的数组。</li>
<li><span  class="math">\(some(\ )\)</span> ：若数组中有任何一个元素返回 <span  class="math">\(true\)</span> ，返回 <span  class="math">\(true\)</span> 。</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以 <span  class="math">\(filter(\ )\)</span> 为例，我们可以这样使用迭代方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}));</span> <span class="c1">// &#34;3,4&#34;
</span></code></pre></div>
<h2 id="span-id202003013939-归并方法span"><span id="2020-03-01-3-9">3.9 归并方法</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;归并方法用于归并数组，接收两个参数，第一个为对每个元素执行的函数，第二个参数（可选）为归并初始值。指定的函数接收四个参数——前一个元素的值，当前元素的值、位置和数组本身，返回值作为第一个参数传入下次调用。如果没有提供第二个参数，归并方法的第一次迭代将发生在数组第二项元素，第一项元素为初始值。<code>EMCAScript</code>提供了两个归并方法—— <span  class="math">\(reduce(\ )\)</span> 和 <span  class="math">\(reduceRight(\ )\)</span> ，前者正序遍历，后者逆序遍历。使用归并方法求和的程序为：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">pre</span><span class="p">,</span> <span class="nx">cur</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">pre</span> <span class="o">+</span> <span class="nx">cur</span><span class="p">;</span>
<span class="p">}));</span> <span class="c1">// 6
</span></code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2020 Mar 1 15:05</span> <a href="/post/javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/leetcode%E9%A2%98%E8%A7%A32%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/">Leetcode题解（2）：二分搜索</a></h1>
            </center>
            <div class="post-content">
                <p><strong><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">原题地址: Problem 4</a></strong><br>
<strong><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-b/">参考题解</a></strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目不用多解释，如果没有要求时间复杂度的话可以直接用双指针法遍历即可，但既然题目要求对数级的复杂度，再加上是排序数组，那么很容易就可以想到是二分法，接下来的问题就是怎么二分了。回忆下中位数的概念，中位数是一组顺序排序的数据中居于中间位置的数。也就是说，如果我们知道一组数据的中位数，我们就可以顺势以中位数为基准，将这组数据分成相同大小的两部分，其中一部分中的数总是小于（或等于）另一部分。再回到题目来，如果我们知道这两个数组的中位数，那么我们就可以将这两个数组以中位数为基准将每个数组分为两部分，如下所示：</p>

<p><figure><img src="/image/2020-02-29-1.png" alt="将每个数组分为两部分, `len1`为`nums1[]`的长度，`len2`为`nums2[]`的长度"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中左边两部分中所有的值永远小于或等于右边两部分。这时很明显中位数为</p>

<p><span  class="math">\[
median = \frac{max(nums1[i - 1], nums2[j - 1])\ +\ min(nums1[i] + nums2[j])}{2}
\]</span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样我们的目标就从找中位数变成了寻找一个 <span  class="math">\(i\)</span> 和 <span  class="math">\(j\)</span> ，满足如下条件（假设 <span  class="math">\(i\)</span> 和 <span  class="math">\(j\)</span> 总是存在）：</p>

<ol>
<li><span id="2020-02-29-1">&nbsp;<span  class="math">\(i + j = \Large\frac{nums1.length\ +\ nums2.length}{2}\normalsize;\)</span></span></li>
<li><span id="2020-02-29-2">&nbsp;<span  class="math">\(nums1[i - 1] <= nums2[j];\)</span></span></li>
<li><span id="2020-02-29-3">&nbsp;<span  class="math">\(nums2[j - 1] <= nums1[i].\)</span></span></li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据上述条件，如果我们要进行二分搜索，第一步必须先将两个数组分别二分，保证<a href="#2020-02-29-1">条件1</a>为真。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">return</span> <span class="n">findMedianSortedArrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">nums1</span><span class="o">);</span>

<span class="kt">int</span> <span class="n">len1</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span>
    <span class="n">len2</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">,</span>
    <span class="n">halfLen</span> <span class="o">=</span> <span class="o">(</span><span class="n">len1</span> <span class="o">+</span> <span class="n">len2</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">,</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">len1</span> <span class="o">/</span> <span class="n">2</span><span class="o">,</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">halfLen</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现我们在开始判断了下<span  class="math">\(nums1[\ \ ]\)</span>和<span  class="math">\(nums2[\ \ ]\)</span>的长度，确保 <span  class="math">\(nums1.length <= nums2.length\)</span> 。这是因为我们在下面确定 <span  class="math">\(j\)</span> 的值时，用到的赋值式是 <span  class="math">\(j = halfLen - i\)</span> ，如果这时不满足 <span  class="math">\(nums1.length <= nums2.length\)</span> 则会出现 <span  class="math">\(j\)</span> 为非正的情况，因此要进行此判断。在计算 <span  class="math">\(halfLen\)</span> 的时候，我们将 <span  class="math">\(Len1\)</span> 和 <span  class="math">\(Len2\)</span> 的和加一后再求平均值，目的也是保证 <span  class="math">\(halfLen - i > 0\)</span> ，即 <span  class="math">\(j\)</span> 为正数。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过上面的二分之后，我们得到了下图：</p>

<p><figure><img src="/image/2020-02-29-1.png" alt="与上面的图片不同之处在于这幅图中左部分不一定小于等于右部分"></figure></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在得到了这幅图之后，有如下几种情况：</p>

<ol>
<li>&nbsp;<span  class="math">\(nums1[i - 1] > nums2[j]\)</span>，即不满足<a href="#2020-02-29-2">条件2</a>;

<ul>
<li>说明 <span  class="math">\(i\)</span> 过大，需要减小 <span  class="math">\(i\)</span> 的值（增大 <span  class="math">\(j\)</span> 的值）。</li>
</ul></li>
<li>&nbsp;<span  class="math">\(nums2[j - 1] > nums1[i]\)</span>, 即不满足<a href="#2020-02-29-3">条件3</a>;

<ul>
<li>说明 <span  class="math">\(i\)</span> 过小，需要增加 <span  class="math">\(i\)</span> 的值（减小 <span  class="math">\(j\)</span> 的值）。</li>
</ul></li>
<li>&nbsp;<span  class="math">\(nums1[i - 1] <= nums2[j]\)</span> 且 <span  class="math">\(nums2[j - 1] <= nums1[i]\)</span>，即满足<a href="#2020-02-29-2">条件2</a>和<a href="#2020-02-29-3">条件3</a>.

<ul>
<li>说明找到了正确的 <span  class="math">\(i\)</span> （和 <span  class="math">\(j\)</span>）。</li>
</ul></li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过上面的整理之后，我们很容易就可以写出二分搜索过程中判断条件。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">return</span> <span class="n">findMedianSortedArrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">nums1</span><span class="o">);</span>

<span class="kt">int</span> <span class="n">len1</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span>
    <span class="n">len2</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">,</span>
    <span class="n">halfLen</span> <span class="o">=</span> <span class="o">(</span><span class="n">len1</span> <span class="o">+</span> <span class="n">len2</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">,</span>
    <span class="n">iMin</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span>
    <span class="n">iMax</span> <span class="o">=</span> <span class="n">len1</span><span class="o">,</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

<span class="k">while</span><span class="o">(</span><span class="n">iMin</span> <span class="o">&lt;=</span> <span class="n">iMax</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">iMin</span> <span class="o">+</span> <span class="n">iMax</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">halfLen</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len2</span> <span class="o">&amp;&amp;</span> <span class="n">nums1</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">iMax</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len1</span> <span class="o">&amp;&amp;</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="n">iMin</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">break</span><span class="o">;</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过上面的搜索过程后，我们找到了正确的 <span  class="math">\(i\)</span> 和 <span  class="math">\(j\)</span>，接下来要做的就只是特殊情况判断和返回值了。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于中位数的计算，我们可以通过两个变量分别记录左部分最大值和右部分最小值（如果需要的话），再取平均值。在此用 <span  class="math">\(left\)</span> 记录左部分最大值，<span  class="math">\(right\)</span> 记录右部分最小值。在非特殊情况下求 <span  class="math">\(left\)</span> 的值只需要令 <span  class="math">\(left = Max(nums1[i - 1],\ nums2[j - 1])\)</span> 即可。而这时显然对于左部分，会有两种特殊情况：</p>

<ol>
<li>&nbsp;<span  class="math">\(i = 0\)</span> ，说明 <span  class="math">\(nums1[\ \ ]\)</span> 被全部划入右部分，这时显然 <span  class="math">\(left = nums2[j - 1]\)</span> 。</li>
<li>&nbsp;<span  class="math">\(j = 0\)</span> ，这时由于 <span  class="math">\(len1 <= len2\)</span> ，所以当且仅当 <span  class="math">\(iMax = iMin = halfLen\)</span> 即 <span  class="math">\(len1 = len2\)</span> 时才会出现这种特殊情况，因此只需返回 <span  class="math">\(\Large\frac{nums1[i\ -\ 1]\ +\ nums2[j]}{2}\)</span> 即可。</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在取得 <span  class="math">\(left\)</span> 的值之后，如果 <span  class="math">\(len1 + len2\)</span> 为奇数，则只需返回 <span  class="math">\(left\)</span> 即可；若为偶数，则需要再处理 <span  class="math">\(right\)</span>。对于 <span  class="math">\(right\)</span> ，同理有 <span  class="math">\(right = Min(nums1[i],\ nums2[j])\)</span> ，也有两种特殊情况：</p>

<ol>
<li>&nbsp;<span  class="math">\(i = len1\)</span> ，说明 <span  class="math">\(nums1[\ ]\)</span> 被全部划入左部分，这时显然 <span  class="math">\(right = nums2[j]\)</span> 。</li>
<li>&nbsp;<span  class="math">\(j = len2\)</span> ，当且仅当 <span  class="math">\(len1 = len2\)</span> 时才会出现该情况，返回 <span  class="math">\(\Large\frac{nums1[i]\ +\ nums2[j\ -\ 1]}{2}\)</span> 即可。</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将判断条件转化为代码即为：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
<span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
    <span class="k">return</span> <span class="o">(</span><span class="kt">double</span><span class="o">)</span> <span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">/</span> <span class="n">2</span><span class="o">.</span><span class="na">0</span><span class="o">;</span>
<span class="k">else</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">],</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">]);</span>
<span class="k">if</span> <span class="o">((</span><span class="n">len1</span> <span class="o">+</span> <span class="n">len2</span><span class="o">)</span> <span class="o">%</span> <span class="n">2</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span>
    <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">len1</span><span class="o">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
<span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">len2</span><span class="o">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
<span class="k">else</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
<span class="k">return</span> <span class="o">(</span><span class="kt">double</span><span class="o">)</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">.</span><span class="na">0</span><span class="o">;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将上述代码整合后可以得到解答：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">findMedianSortedArrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">return</span> <span class="n">findMedianSortedArrays</span><span class="o">(</span><span class="n">nums2</span><span class="o">,</span> <span class="n">nums1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">len1</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span>
            <span class="n">len2</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">,</span>
            <span class="n">halfLen</span> <span class="o">=</span> <span class="o">(</span><span class="n">len1</span> <span class="o">+</span> <span class="n">len2</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">,</span>
            <span class="n">iMin</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span>
            <span class="n">iMax</span> <span class="o">=</span> <span class="n">len1</span><span class="o">,</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">iMin</span> <span class="o">&lt;=</span> <span class="n">iMax</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">iMin</span> <span class="o">+</span> <span class="n">iMax</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">halfLen</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len2</span> <span class="o">&amp;&amp;</span> <span class="n">nums1</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span>
                <span class="n">iMax</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len1</span> <span class="o">&amp;&amp;</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>
                <span class="n">iMin</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="o">(</span><span class="kt">double</span><span class="o">)</span> <span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">/</span> <span class="n">2</span><span class="o">.</span><span class="na">0</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">],</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">]);</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">len1</span> <span class="o">+</span> <span class="n">len2</span><span class="o">)</span> <span class="o">%</span> <span class="n">2</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">left</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">len1</span><span class="o">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">len2</span><span class="o">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="k">else</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums2</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">double</span><span class="o">)</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">.</span><span class="na">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度为 <span  class="math">\(O(log(Min(nums1.length,\ nums2.length)))\)</span> ，因为二分搜索为对数级复杂度，而在这道题中当我们在 <span  class="math">\(nums1[\ ]\)</span> 中搜索到正确的 <span  class="math">\(i\)</span> 时，也就意味着得到了 <span  class="math">\(j\)</span> ，因此只需取两个数组之中最短的长度即可。空间复杂度为 <span  class="math">\(O(1)\)</span> 。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Feb 29 17:23</span> <a href="/post/leetcode%E9%A2%98%E8%A7%A32%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/">JavaScript的对象构造</a></h1>
            </center>
            <div class="post-content">
                <p><strong>参考书籍：《JavaScript高级程序设计》（第3版）</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JavaScript</code>是一门面向对象的语言，即拥有类的概念。但<code>ECMAScript</code>中没有类的概念，因此它的对象与其他基于类的语言不同，我们可以把<code>ECMAScript</code>中的对象想象成散列表，由一组组键值对构成，值可以是数据或者函数。</p>

<ol>
<li><a href="#2020-02-28-1"> <span  class="math">\(object\)</span> 构造函数模式</a></li>
<li><a href="#2020-02-28-2">对象字面量</a></li>
<li><a href="#2020-02-28-3">工厂模式</a></li>
<li><a href="#2020-02-28-4">构造函数模式</a></li>
<li><a href="#2020-02-28-5">原型模式</a>

<ul>
<li><a href="#2020-02-28-5-1">什么是原型对象</a></li>
</ul></li>
<li><a href="#2020-02-28-6">寄生构造函数模式</a></li>
<li><a href="#2020-02-28-7">稳妥构造函数模式</a></li>
<li><a href="#2020-02-28-8">属性类型</a></li>
</ol>

<hr>

<h2 id="span-id--2020022811object构造函数模式span"><span id = "2020-02-28-1">1.<code>object</code>构造函数模式</span></h2>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">object</span><span class="p">();</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;A&#34;</span><span class="p">;</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上例创建了一个 <span  class="math">\(person\)</span> 对象，并为其添加了 <span  class="math">\(name\)</span> 属性和 <span  class="math">\(sayName(\ )\)</span> 方法，是最简单的构造对象的方法。</p>

<hr>

<h2 id="span-id--2020022822对象字面量span"><span id = "2020-02-28-2">2.对象字面量</span></h2>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;XiaoMing&#34;</span><span class="p">,</span>
    <span class="nx">sayName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上例创建了相同的 <span  class="math">\(person\)</span> 对象，不同之处在于它是使用对象字面量定义的。以花括号表示开始和结束，属性名+冒号+值的格式定义属性，用逗号隔开多个不同的属性。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用对象字面量时，属性名也可以使用字符串。需要注意的是，<code>JSON</code>只支持此种语法。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&#34;name&#34;</span><span class="o">:</span> <span class="s2">&#34;XiaoMing&#34;</span><span class="p">,</span>
    <span class="s2">&#34;sayName&#34;</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般情况下，由于对象字面量语法的代码量少，开发人员大多采用此种方式构造对象。</p>

<hr>

<h2 id="span-id--2020022833工厂模式span"><span id = "2020-02-28-3">3.工厂模式</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不论是使用 <span  class="math">\(object\)</span> 构造函数还是对象字面量，都有一个很明显的缺点，就是创建多个对象时会产生大量重复代码。因此人们采取了工厂模式的一个变种。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">createPerson</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">object</span><span class="p">();</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="nx">createPerson</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="nx">createPerson</span><span class="p">(</span><span class="s2">&#34;XiaoHong&#34;</span><span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数 <span  class="math">\(createPerson(\ )\)</span> 接收参数并返回一个 <span  class="math">\(person\)</span> 对象，每次调用均可以得到一个新的 <span  class="math">\(person\)</span> 对象。以此，我们可以大量创建 <span  class="math">\(person\)</span> 对象。</p>

<hr>

<h2 id="span-id--2020022844构造函数模式span"><span id = "2020-02-28-4">4.构造函数模式</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ECMAScript</code>中的构造函数可以用于创建指定类型的对象，我们可以创建自定义构造函数，从而创建自定义对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;XiaoHong&#34;</span><span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此例使用 <span  class="math">\(Person(\ )\)</span> 函数替代了 <span  class="math">\(createPerson(\ )\)</span> 函数。可以发现， <span  class="math">\(Person(\ )\)</span> 中，我们并没有显示的创建对象，而是直接将属性和方法赋予 <span  class="math">\(this\)</span> 对象，并且在最后构造函数时使用了 <span  class="math">\(new\)</span> 操作符。实际上，该操作经历了  <span  class="math">\(4\)</span>  步：</p>

<ol>
<li>创建对象</li>
<li>将构造函数作用域赋予新对象</li>
<li>执行构造函数</li>
<li>返回新对象</li>
</ol>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此例中，我们创建的对象可以通过 <span  class="math">\(instanceof\)</span> 操作符进行检验，这也正是使用构造函数模式的优点——对象实例被标识为特殊类型。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们不使用 <span  class="math">\(new\)</span> 操作符，而是直接调用构造函数，则属性会附加在 <span  class="math">\(window\)</span> 对象上。如下所示</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">);</span>
<span class="nx">windwo</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">//&#34;XiaoMing&#34;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而要避免这种情况，可以使用严格模式。这样在非严格模式下默认转换为全局对象的 <span  class="math">\(null\)</span> 或者 <span  class="math">\(undefined\)</span> 不会转换，因此上述调用会抛出错误。严格模式可以以如下方式使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="s1">&#39;use strict&#39;</span><span class="p">;</span> <span class="c1">//开启严格模式
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<hr>

<h2 id="span-id--2020022855原型模式span"><span id = "2020-02-28-5">5.原型模式</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在原型模式之前，我们可以先讨论下构造函数模式的缺点。构造函数模式的缺点就是其中每个对象的每个方法都要重新创建一遍。例如之前的 <span  class="math">\(person1\)</span> 对象和 <span  class="math">\(person2\)</span> 对象，其 <span  class="math">\(sayName(\ )\)</span> 方法不是同一个 <span  class="math">\(Function\)</span> 实例，而是两个不同的实例。当然我们可以通过以下方法解决：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="nx">sayName</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在全局作用域中定义 <span  class="math">\(sayName(\ )\)</span> 函数。这种方法确实可以做到共享同一个实例，但问题是 <span  class="math">\(sayName(\ )\)</span> 函数定义在全局作用域中，却只被 <span  class="math">\(Person\)</span> 对象调用，而且由于是全局作用域，该函数可以被随意调用，不利于封装。为解决这个问题，我们可以使用原型模式。</p>

<h3 id="span-id--2020022851什么是原型对象span"><span id = "2020-02-28-5-1">什么是原型对象</span></h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们创建的每个对象中都有一个 <span  class="math">\(prototype\)</span> 属性，该属性是一个指针，指向一个包含可以被特定实例所共享的属性和方法。对于<code>ECMAScript</code>中的引用类型而言， <span  class="math">\(prototype\)</span> 是保存所有实例方法的地方。在构造函数模式中，我们提到了创建对象过程中的  <span  class="math">\(4\)</span>  步，而 <span  class="math">\(prototype\)</span> 可以理解为第  <span  class="math">\(1\)</span>  步当中创建的对象的原型指针。无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为其创建一个 <span  class="math">\(prototype\)</span> 属性，指向函数的原型对象。创建了构造函数之后，原型对象默认取得 <span  class="math">\(constructor\)</span> 属性，这是一个指向 <span  class="math">\(prototype\)</span> 属性所在函数的指针。通过 <span  class="math">\(isPrototypeOf(\ )\)</span> 函数，我们可以判断是否是一个实例的原型对象。在<code>EMCAScript5</code>中，新增的 <span  class="math">\(Object.getPrototype(\ )\)</span> 方法可以获取对象的原型。</p>

<hr>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型对象的优点就是可以让所有对象实例共享它的属性和方法。如下例所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">()</span> <span class="p">{}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;XiaoMing&#34;</span><span class="p">;</span>
<span class="nx">Perosn</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person1</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">==</span> <span class="nx">person2</span><span class="p">.</span><span class="nx">sayName</span><span class="p">);</span> <span class="c1">//true
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现，使用原型模式后，新对象的方法是同一个方法，即实现了方法共享。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用原型模式时，当我们为实例添加了一个属性时，该属性会屏蔽原型对象中的同名属性，但不会影响到原型中的属性。如果要再访问原型属性，可以调用 <span  class="math">\(delete\)</span> 操作。判断一个属性是原型属性还是对象属性，我们可以通过 <span  class="math">\(hasOwnProperty(\ )\)</span> 函数和 <span  class="math">\(in\)</span> 操作符。 <span  class="math">\(hasOwnProperty(\ )\)</span> 函数只有当属性是对象属性时才会返回 <span  class="math">\(true\)</span> ，而 <span  class="math">\(in\)</span> 操作符无论属性是对象属性还是原型属性，都会返回 <span  class="math">\(true\)</span> 。如下例所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">()</span> <span class="p">{}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;XiaoMing&#34;</span><span class="p">,</span>
    <span class="nx">sayName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;XiaoHong&#34;</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//“XiaoHong&#34;
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">));</span> <span class="c1">// true
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="s2">&#34;name&#34;</span> <span class="k">in</span> <span class="nx">person</span><span class="p">);</span> <span class="c1">//true
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//&#34;XiaoMing&#34;
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">));</span> <span class="c1">//true
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="s2">&#34;name&#34;</span> <span class="k">in</span> <span class="nx">person</span><span class="p">);</span> <span class="c1">//true;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 <span  class="math">\(hasOWnProperty(\ )\)</span> 返回 <span  class="math">\(false\)</span> 而 <span  class="math">\(in\)</span> 返回 <span  class="math">\(true\)</span> 时，我们可以确定该属性为原型属性；而两者都返回 <span  class="math">\(true\)</span> 时，可以确定其为对象属性。在此例中，我们采用字面量语法构造 <span  class="math">\(prototype\)</span> ，相比之下，这种语法更简洁。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型模式很好的实现了共享，但显然对象中所有的属性都是共享是十分不利的，因此我们要采取构造函数模式和原型模式结合的方式构造对象。如下例所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="o">:</span> <span class="nx">Person</span><span class="p">,</span>
    <span class="nx">sayName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们重新定义了 <span  class="math">\(constructor\)</span> 的值，因为每当创建一个新函数时，就会一起创建其 <span  class="math">\(prototype\)</span> 对象和 <span  class="math">\(constructor\)</span> 属性，使用字面量语法相当于重写了 <span  class="math">\(prototype\)</span> 对象，因而使得 <span  class="math">\(constructor\)</span> 属性也改变了（指向 <span  class="math">\(Object\)</span> 构造函数），虽然用 <span  class="math">\(instanceof\)</span> 操作符测试 <span  class="math">\(Person\)</span> 依然为 <span  class="math">\(true\)</span> ，但如果测试 <span  class="math">\(constructor\)</span> 属性则就为 <span  class="math">\(false\)</span> 了。因此需要重新定义 <span  class="math">\(cosntructor\)</span> 属性，以确保通过该属性能够访问到正确的值。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过结合构造函数模式和原型模式，我们可以保证属性的独立和方法的共享。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然通过构造函数模式和原型模式的结合，我们可以很好的构造对象，但是相比起其他面向对象语言，此种构造方式很奇怪。对此，我们可以采用动态原型模式。此种模式的本质是检查某个方法是否有效来决定是否初始化原型。如下例所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="k">this</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">!=</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在动态原型模式中，我们只有在 <span  class="math">\(sayName(\ )\)</span> 方法不存在的情况下才会将起添加到原型当中，之后则不需要再修改原型。</p>

<hr>

<h2 id="span-id--2020022866寄生构造函数模式span"><span id = "2020-02-28-6">6.寄生构造函数模式</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;寄生构造函数模式，本质是创建一个函数，用于封装创建对象的代码，再返回所创建的对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">object</span><span class="p">();</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式和工厂模式几乎一样，区别只在于其使用 <span  class="math">\(new\)</span> 操作符创建对象，并且将包装函数作为构造函数。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式用于特殊情况下创建对象的构造函数。如下例所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">SpecialArray</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
    <span class="c1">//添加值
</span><span class="c1"></span>    <span class="nx">a</span><span class="p">.</span><span class="nx">push</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">valuse</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
    <span class="c1">//添加方法
</span><span class="c1"></span>    <span class="nx">a</span><span class="p">.</span><span class="nx">toPipedString</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&#34;|&#34;</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">names</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SpecialArray</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">,</span> <span class="s2">&#34;XiaoHong&#34;</span><span class="p">);</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现，通过此种模式，我们可以构造一个具有额外方法的数组。但要注意，此种模式返回的对象与构造函数及其原型没有关系，即不能通过 <span  class="math">\(instanceof\)</span> 操作符确定类型，因此，一般不推荐使用此种模式。</p>

<hr>

<h2 id="span-id--2020022877稳妥构造函数模式span"><span id = "2020-02-28-7">7.稳妥构造函数模式</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;稳妥对象(  <span  class="math">\(durable\;objects\)</span>  )，指的是没有公共属性，并且其方法也不引用 <span  class="math">\(this\)</span> 的对象，最适合在一些安全环境中使用。其遵循类似于寄生构造函数的模式，不同之处在于不引用 <span  class="math">\(this\)</span> ，不使用 <span  class="math">\(new\)</span> 操作符。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">object</span><span class="p">();</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;XiaoMing&#34;</span><span class="p">);</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">//&#34;XiaoMing&#34;;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以此种模式创建的对象，除了其本身的 <span  class="math">\(sayName(\ )\)</span> 方法外，没有其他方式访问 <span  class="math">\(name\)</span> 属性。</p>

<hr>

<h2 id="span-id--2020022888属性类型span"><span id = "2020-02-28-8">8.属性类型</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ECMAScript</code>中有两种属性——数据属性和访问器属性，用于描述属性特性。需要注意的是，并非所有浏览器都支持下述方法。</p>

<h3 id="1-数据属性">(1) 数据属性</h3>

<p>数据属性是一个数据值的位置，有  <span  class="math">\(4\)</span>  个行为特性：</p>

<ul>
<li><span  class="math">\([[Configurable]]\)</span> ：表示能否通过 <span  class="math">\(delete\)</span> 删除该属性，能否修改属性特性，能否修改为访问器属性，在上述例子中我们直接将属性定义在对象上，其 <span  class="math">\([[Configurable]]\)</span> 特性默认为 <span  class="math">\(true\)</span> 。</li>
<li><span  class="math">\([[Enumerable]]\)</span> ：表示能否通过 <span  class="math">\(for-in\)</span> 循环返回属性。与 <span  class="math">\([[Configurable]]\)</span> 相同，默认为 <span  class="math">\(true\)</span> 。</li>
<li><span  class="math">\([[Writable]]\)</span> ：表示能否修改属性的值。默认为 <span  class="math">\(true\)</span> 。</li>
<li><span  class="math">\([[Value]]\)</span> ：保存属性的值。读写属性时从该位置读写。默认为 <span  class="math">\(undefined\)</span> 。</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要修改属性的特性，需要调用<code>ECMAScript5</code>中的 <span  class="math">\(Object.defineProperty(\ )\)</span> 方法。该方法接收三个参数——属性所在对象、属性名和一个描述符对象( <span  class="math">\(configurable\)</span> ,  <span  class="math">\(enumerable\)</span> ,  <span  class="math">\(writable\)</span> 和 <span  class="math">\(value\)</span> )。在使用该方法时，如果未指定，则 <span  class="math">\(configurable\)</span> ,  <span  class="math">\(writable\)</span> 以及 <span  class="math">\(enumerable\)</span> 默认为 <span  class="math">\(false\)</span> ，除非是对已定义的属性特性的修改。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;XiaoMing&#34;</span>
<span class="p">});</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设置数据属性的值后，作出不允许行为时，非严格模式下会被忽略，严格模式下则会抛出错误。</p>

<h3 id="2访问器属性">(2)访问器属性</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;访问器属性包含 <span  class="math">\(getter\)</span> 和 <span  class="math">\(setter\)</span> 函数，分别用于读取和写入。访问器属性包含如下  <span  class="math">\(4\)</span>  个特性：</p>

<ul>
<li><span  class="math">\([[Configurable]]\)</span> ：同数据属性。</li>
<li><span  class="math">\([[Enumerable]]\)</span> ：同数据属性。</li>
<li><span  class="math">\([[Get]]\)</span> ：读取属性时调用的函数，默认为 <span  class="math">\(undefined\)</span> 。</li>
<li><span  class="math">\([[Set]]\)</span> ：写入属性时调用的函数，默认为 <span  class="math">\(undefined\)</span> 。</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与数据属性相同，定义访问器属性时也要用到 <span  class="math">\(Object.defineProperty(\ )\)</span> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">_age</span><span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&#34;age&#34;</span><span class="err">，</span> <span class="p">{</span>
    <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_age</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newAge</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">newAge</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">_age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span> <span class="c1">//8
</span><span class="c1"></span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span> <span class="c1">//18
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在非严格模式下可以不同时指定 <span  class="math">\(getter\)</span> 与 <span  class="math">\(setter\)</span> ：只指定 <span  class="math">\(getter\)</span> 则属性只读，相反只指定 <span  class="math">\(setter\)</span> 则属性只写。严格模式下必须同时指定。对于不支持该方法的浏览器，要定义 <span  class="math">\(getter\)</span> 和 <span  class="math">\(setter\)</span> 一般使用 <span  class="math">\(\_\_defineGetter\_\_(\ )\)</span> 方法和 <span  class="math">\(\_\_defineSetter(\ )\_\_\)</span> 方法。需要注意的是，在不支持 <span  class="math">\(Object.defineProperty(\ )\)</span> 的浏览器中无法修改 <span  class="math">\(configurable\)</span> 和 <span  class="math">\(enumerable\)</span> 。</p>

<h3 id="3属性类型相关方法">(3)属性类型相关方法</h3>

<h4 id="多属性定义">多属性定义</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>ECMAScript5</code>中定义了一个 <span  class="math">\(Object.defineProperties(\ )\)</span> 方法用于定义多个属性。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;XiaoMing&#34;</span>
    <span class="p">},</span>
    <span class="nx">_age</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">value</span><span class="o">:</span> <span class="mi">8</span>
    <span class="p">},</span>
    <span class="nx">age</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_age</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newAge</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">newAge</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="nx">age</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<h4 id="读取属性特性">读取属性特性</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ECMAScript5</code>中定义的 <span  class="math">\(Object.getOwnPropertyDescriptor(\ )\)</span> 方法，接收两个参数——属性所在对象和要读取的属性名，返回一个记录属性特性值的对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">//接上段代码
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s2">&#34;_age&#34;</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">//8
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">configurable</span><span class="p">);</span> <span class="c1">//false
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在大多数情况下可能没有必要使用 <span  class="math">\(Object.defineProperty(\ )\)</span> 等方法，但这对于理解<code>JavaScript</code>中的对象有所帮助。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Feb 28 12:48</span> <a href="/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/leetcode%E5%91%A8%E8%B5%9B177/">Leetcode周赛：177</a></h1>
            </center>
            <div class="post-content">
                <p><strong><a href="https://leetcode-cn.com/contest/weekly-contest-177/">第 177 场周赛</a></strong></p>

<ul>
<li><strong><a href="#1360">Problem 1360: 日期之间间隔几天</a></strong></li>
<li><strong><a href="#1361">Problem 1361: 验证二叉树</a></strong></li>
<li><strong><a href="#1362">Problem 1362: 最接近因数</a></strong></li>
<li><strong><a href="#1363">Problem 1363: 形成三的最大倍数</a></strong></li>
</ul>

<hr>

<p><span id = "1360"><strong><a href="https://leetcode-cn.com/problems/number-of-days-between-two-dates/">Problem 1360: 日期之间间隔几天</a></strong></span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接调用库函数即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kn">import</span> <span class="nn">java.time.LocalDate</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.time.temporal.ChronoUnit</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">daysBetweenDates</span><span class="o">(</span><span class="n">String</span> <span class="n">date1</span><span class="o">,</span> <span class="n">String</span> <span class="n">date2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">date1</span><span class="o">).</span><span class="na">until</span><span class="o">(</span><span class="n">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">date2</span><span class="o">),</span> <span class="n">ChronoUnit</span><span class="o">.</span><span class="na">DAYS</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <span  class="math">\(LocalDate\)</span> 类及其 <span  class="math">\(until(\ )\)</span> 方法，使用 <span  class="math">\(ChronoUnit.DAYS\)</span> 常量表明以天为单位计算。在此要注意的是<code>Leetcode</code>并没有默认导入 <span  class="math">\(java.time\)</span> 类，因此要自己导入。</p>

<hr>

<p><span id = "1361"><strong><a href="https://leetcode-cn.com/problems/validate-binary-tree-nodes/">Problem 1361: 验证二叉树</a></strong></span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用二叉树的性质可以知道，二叉树根节点外每个节点有且只有一个父节点，并且有且只有一个根节点。通过这个性质，我们可以遍历数组，找到所有的节点的父节点，再验证是否符合上述性质。</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">validateBinaryTreeNodes</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">leftChild</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">rightChild</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span> <span class="c1">//储存每个节点的父节点
</span><span class="c1"></span>        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="o">-</span><span class="n">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftChild</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">leftChild</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">==</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="n">parent</span><span class="o">[</span><span class="n">leftChild</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">//如果该节点已有父节点，则非二叉树
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">rightChild</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">rightChild</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">==</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="n">parent</span><span class="o">[</span><span class="n">rightChild</span><span class="o">[</span><span class="n">i</span><span class="o">]]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">parent</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="n">1</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">//如果有多个根节点，则非二叉树
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">cnt</span> <span class="o">==</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<hr>

<p><span id = "1362"><strong><a href="https://leetcode-cn.com/problems/closest-divisors/">Problem 1362: 最接近因数</a></strong></span></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，如果是平方数的话，题解便是其平方根。而对于非平方数，我们可以对其开方。只要知道一个因数，即可算出另一个因数，因此只需要向一个方向遍历即可。在此我采取向 <span  class="math">\(0\)</span> 遍历的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">closestDivisors</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="n">2</span><span class="o">;</span> <span class="c1">//t1, t2分别为所求目标
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t1</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">i</span><span class="o">,</span> <span class="n">t1</span> <span class="o">/</span> <span class="n">i</span><span class="o">};</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">t2</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">i</span><span class="o">,</span> <span class="n">t2</span> <span class="o">/</span> <span class="n">i</span><span class="o">};</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="n">1</span><span class="o">,</span> <span class="n">t1</span><span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<hr>

<p><span id = "1363"><strong><a href="https://leetcode-cn.com/problems/largest-multiple-of-three/">Problem 1363: 形成三的最大倍数</a></strong></span></p>

<p><a href="https://leetcode-cn.com/problems/largest-multiple-of-three/solution/xing-cheng-san-de-zui-da-bei-shu-by-leetcode-solut/">参考题解</a></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一眼看到这道题的直觉是排序然后遍历。不过这个方案立马被排除了，因为这道题要找的是最大的数，而对于数字的大小，位数比每个数字的大小更重要，因此排序并不是必要的。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再考察三的倍数的规律。一个数为三的倍数当且仅当其各个位上的数字的和为三的倍数。因此对于 <span  class="math">\(digits[\ ]\)</span> 数组，如果其和为三的倍数，我们只需要将其所有的数字从大到小排序后输出即可；如果不为三的倍数，则分两种情况，模三余一和模三余二。对于模三余一，如果数组中存在任意一个模三余一的数，只需删去该数即可；如果不存在，则需要删去两个模三余二的数；同理，对于模三余二的情况，则需要删去一个模三余二的数或者两个模三余一的数。最后在输出结果时，唯一要注意的特殊情况是为 <span  class="math">\(0\)</span> 的情况，毕竟多个 <span  class="math">\(0\)</span> 并列并不是数字。</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">largestMultipleOfThree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">digits</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">StringBuilder</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="c1">//所有数字的和
</span><span class="c1"></span>            <span class="n">mod</span> <span class="o">=</span> <span class="n">0</span><span class="o">,</span> <span class="c1">//sum % 3 的值
</span><span class="c1"></span>            <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="c1">//应该去除的余数为 mod 的数字的个数
</span><span class="c1"></span>        <span class="kt">int</span><span class="o">[]</span> <span class="n">num</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">10</span><span class="o">],</span> <span class="c1">//每个数字的个数
</span><span class="c1"></span>              <span class="n">mods</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">3</span><span class="o">];</span> <span class="c1">//每个数字余数的个数
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">digits</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span>
            <span class="n">mods</span><span class="o">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">3</span><span class="o">]++;</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">remain</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">%</span> <span class="n">3</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">remain</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mods</span><span class="o">[</span><span class="n">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//是否存在模三余一的数
</span><span class="c1"></span>                <span class="n">mod</span> <span class="o">=</span> <span class="n">count</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">//不存在模三余一的数
</span><span class="c1"></span>                <span class="n">mod</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">remain</span> <span class="o">==</span> <span class="n">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mods</span><span class="o">[</span><span class="n">2</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">mod</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">mod</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">j</span><span class="o">++)</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">mod</span> <span class="o">==</span> <span class="n">i</span> <span class="o">%</span> <span class="n">3</span><span class="o">)</span> <span class="n">count</span><span class="o">--;</span>
                <span class="k">else</span> <span class="n">res</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">res</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="o">)</span> <span class="k">return</span> <span class="s">&#34;0&#34;</span><span class="o">;</span> <span class="c1">//处理 0
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
            </div>
            <div class="meta post-footer"> <span>2020 Feb 27 11:18</span> <a href="/post/leetcode%E5%91%A8%E8%B5%9B177/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/leetcode%E9%A2%98%E8%A7%A3%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98/">Leetcode题解：一道”难“题</a></h1>
            </center>
            <div class="post-content">
                <h2 id="原题地址problem-1332httpsleetcodecncomproblemsremovepalindromicsubsequences"><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/">原题地址：Problem 1332</a></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目很直(mo)白(hu)，就是从一个字符串中删除回文子列直到字符串为空。但是我——没看示例，盯着题目描述和左上角的“简单”，陷入了长时间的思考，最终怀疑人生。毕竟如果你要找回文串的话就得遍历一遍得到子串，然后删除，再遍历，再循环……如此反复，时间复杂度很高，完全不是简单难度，毫无办法的我最终只能看向题解，然后在惊叹中一分钟提交了答案。</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removePalindromeSub</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="k">new</span> <span class="n">StringBuilder</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="na">reverse</span><span class="o">().</span><span class="na">toString</span><span class="o">()))</span> <span class="k">return</span> <span class="n">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总之这道题很沙雕，沙雕之处就在于它的子序列可以不连续。所以，如果不是空串或者回文串的话，先删掉所有的 <span  class="math">\(a\)</span> 再删掉所有的 <span  class="math">\(b\)</span> 就行了。由于让我卡了很久，专门写了一篇博客，特此留念。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Feb 17 17:44</span> <a href="/post/leetcode%E9%A2%98%E8%A7%A3%E4%B8%80%E9%81%93%E9%9A%BE%E9%A2%98/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/leetcode%E9%A2%98%E8%A7%A31%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">Leetcode题解（1）：动态规划</a></h1>
            </center>
            <div class="post-content">
                <h2 id="原题地址problem-62httpsleetcodecncomproblemsuniquepaths"><strong><a href="https://leetcode-cn.com/problems/unique-paths/">原题地址：Problem 62</a></strong></h2>

<h3 id="参考题解httpsleetcodecncomproblemsuniquepathssolutiondongtaiguihuabypowcai2"><strong><a href="https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/">参考题解</a></strong></h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一眼看到这道题就联想到了离散数学里的排列的相关知识，从而可以很容易的得出排列数为 <span  class="math">\(C(m+n-2,m-1)\)</span> 或者 <span  class="math">\(C(m+n-2,n-1)\)</span>，可以直接利用该公式进行计算。但问题是阶乘的增长量级过大，很快就产生了溢出的问题，这时可以通过使用 <span  class="math">\(BigInteger\)</span> 类型对象解决。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然问题解决了，但显然这种偏暴力方式的解法不是我们的目的，因此我们还要寻找另一种解法。通过观察题目，我们可以很明显的发现：由于只能右移或者下移，因此到达每一块方格的路径数（不包括第一行和第一列） = 到达其左边方格的路径数 + 到达其上边方格的路径数。以此规律，我们可以运用动态规划来解决该问题。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先先设</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>dp</code>数组为二维数组，储存到达每个方格的路径数。由于达到第一列和第一行中所有方格的路径数有且仅有一条，因此可以</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> </code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后仅需双循环进行赋值即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> 
        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此，无论是按行还是按列，结果都是一样的。最后 <span  class="math">\(dp[m - 1][n - 1]\)</span> 即为答案。将上述代码合并起来即为：</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">uniquePaths</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span> <span class="o">-</span> <span class="n">1</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到此为止的解法已经很好了，但仍有优化空间。我们可以从一些极端情况开始重新考虑。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在相同条件下考虑一个 <span  class="math">\(1 \times n\)</span> 的网格。显然路径有且只有一条。对此构造数组储存路径数，暂且将其命名为 <span  class="math">\(dp1[n]\)</span>，其中每个元素均为 <span  class="math">\(1\)</span>。在 <span  class="math">\(1 \times n\)</span> 的基础上，我们再考虑一个 <span  class="math">\(2 \times n\)</span> 的网格，将其分为两列，显然第一列即为之前讨论的 <span  class="math">\(1 \times n\)</span> 网格，我们用 <span  class="math">\(dp1[n]\)</span> 进行储存，第二列我们用 <span  class="math">\(dp2[n]\)</span> 进行储存。再利用之前讨论出来的规律，我们可以知道对于第二列中的每个方格，其路径数等于左边以及上边方格路径数之和，其左边方格的路径数之和储存在 <span  class="math">\(dp1[n]\)</span> 中，上边方格的路径数储存在 <span  class="math">\(dp2[n]\)</span> 之中，因此对于第二列的每个方格，我们可以用动态规划进行赋值，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="n">dp2</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="c1">//第一行路径数为1
</span><span class="c1"></span><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="n">dp2</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp1</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="cm">/*左边方格路径数*/</span> <span class="o">+</span> <span class="n">dp2</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span> <span class="cm">/*上边方格路径数*/</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以此，我们可以将网格继续扩大，从 <span  class="math">\(2 \times n\)</span> 直到 <span  class="math">\(m \times n\)</span>。利用代码比较直观的实现思路为设置两个数组，大小均为 <span  class="math">\(n\)</span>，其中一个储存当前列的路径数，记为 <span  class="math">\(cur[n]\)</span>，另一个储存之前列的路径数，记为 <span  class="math">\(pre[n]\)</span>。动态规划过程循环可以改为：</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
        <span class="n">cur</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">pre</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">cur</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
    <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;空间复杂度由原来的 <span  class="math">\(O(m \times n)\)</span> 降低至 <span  class="math">\(O(2n)\)</span>，从而大大减小，不过还可以更小。重新审视我们的思路，可以发现，利用 <span  class="math">\(pre\)</span> 储存前一列的路径数是不必要的，因为在动态规划过程中， <span  class="math">\(pre[j]\)</span> 实际上与未改变前的 <span  class="math">\(cur[j]\)</span> 是相等的，即前一列相同行上的数据实际上本就储存在当前位置上，因此，可以再进一步改进循环：</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
        <span class="n">cur</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">cur</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，空间复杂度进一步缩小为 <span  class="math">\(O(n)\)</span>。最终经过优化后的代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">uniquePaths</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后进行总结，此题可以用排列数进行计算，也可以运用动态规划进行计算，使用动态规划方法，时间复杂度为 <span  class="math">\(O(m \times n)\)</span>，空间复杂度可以优化至 <span  class="math">\(O(n)\)</span>。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在解决完这道题之后，我们可以再来看一道相似的题目。</p>

<hr>

<h2 id="原题地址problem-63httpsleetcodecncomproblemsuniquepathsii"><strong><a href="https://leetcode-cn.com/problems/unique-paths-ii/">原题地址：Problem 63</a></strong></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显，这道题就不能直观的由排列数得出答案了，因为加入了障碍，即不可达方块。但仍然可以通过动态规划得出答案。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再从极端情况开始考虑。考虑一个 <span  class="math">\(1 \times n\)</span> 的网格，用 <span  class="math">\(dp[n]\)</span> 储存路径数。显然，当 <span  class="math">\(obstacleGrid[0]\)</span> 里面的元素都为 <span  class="math">\(0\)</span> 时，<span  class="math">\(dp[n]\)</span> 内的元素都为 <span  class="math">\(0\)</span> ；而当 <span  class="math">\(obstacleGrid[0]\)</span> 里面存在一个 <span  class="math">\(1\)</span> 时，即当 <span  class="math">\(obstacleGrid[0][i]\)</span> 为 <span  class="math">\(1\)</span> 时，在 <span  class="math">\(dp[n]\)</span> 中，所有地址小于 <span  class="math">\(i\)</span> 的元素均为 <span  class="math">\(1\)</span> ，大于 <span  class="math">\(i\)</span> 的元素均为 <span  class="math">\(0\)</span> 。由此可以进行如下初始化：</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">obstacle</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">obstacle</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">break</span><span class="o">;</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从而可以得出 <span  class="math">\(1 \times n\)</span> 网格情况下的答案。再将其扩至 <span  class="math">\(2 \times n\)</span> 网格，将其分为两列，第一列与上例相同。在对第二列进行规划时，可以发现，如果存在 <span  class="math">\(obstacleGrid[1][i]\)</span> 为 <span  class="math">\(0\)</span> ，那么 <span  class="math">\(dp[i]\)</span> 也将为 <span  class="math">\(0\)</span> ；若不为零。则与上一题相同，因此只需稍加修改前一题的代码即可。另外，由于上一题中第一行中所有元素均为 <span  class="math">\(1\)</span> 而本题不一定，所以在对每列进行规划之前都要对 <span  class="math">\(dp[0]\)</span> 进行一次判断和赋值。经过修改后的完整代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">uniquePathsWithObstacles</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">obstacleGrid</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">obstacleGrid</span><span class="o">[</span><span class="n">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">obstacleGrid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">break</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">obstacleGrid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">obstacleGrid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
                <span class="k">else</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>时间复杂度 <span  class="math">\(O(m \times n)\)</span>，空间复杂度 <span  class="math">\(O(n)\)</span>，与上题相同。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Feb 12 20:42</span> <a href="/post/leetcode%E9%A2%98%E8%A7%A31%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/">JavaScript的对象继承</a></h1>
            </center>
            <div class="post-content">
                <p><strong>参考书籍：《JavaScript高级程序设计》（第3版）</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>继承</strong>是OO语言（面对对象语言）中的概念。许多OO语言都支持两种继承方式：接口继承（继承方法签名）和实现继承（继承实际方法）。但由于<code>JavaScript</code>中没有签名，因此在<code>ECMAScript</code>中只能实现方法继承。</p>

<ol>
<li><a href="#2019-12-06-1">原型链</a></li>
<li><a href="#2019-12-06-2">借用构造函数</a></li>
<li><a href="#2019-12-06-3">组合继承</a></li>
<li><a href="#2019-12-06-4">原型式继承</a></li>
<li><a href="#2019-12-06-5">寄生式继承</a></li>
<li><a href="#2019-12-06-6">寄生组合式继承</a></li>
</ol>

<hr>

<h2 id="span-id2019120611-原型链span"><span id="2019-12-06-1">1. 原型链</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>原型链</strong>（ <span  class="math">\(prototype\;chaining\)</span> ）是实现继承的主要方法。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">SuperType</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">property</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">SuperType</span><span class="p">.</span><span class="nx">property</span><span class="p">.</span><span class="nx">getSuperValue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">function</span> <span class="nx">SubType</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">subproperty</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//继承SuperType
</span><span class="c1"></span><span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuperType</span><span class="p">();</span>
<span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSubValue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">subproperty</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述代码中定义了两种类型—— <span  class="math">\(SuperType\)</span> 和 <span  class="math">\(SubType\)</span> ，其中 <span  class="math">\(SubType\)</span> 继承了 <span  class="math">\(SuperType\)</span> 。实现的本质是重写 <span  class="math">\(SubType\)</span> 的原型对象，即将一个 <span  class="math">\(SuperType\)</span> 对象赋给 <span  class="math">\(SubType.property\)</span> ，从而使得 <span  class="math">\(SuperType\)</span> 中所有的属性和方法均存在于 <span  class="math">\(SubType\)</span> 中。在实例中，我们也给 <span  class="math">\(SubType\)</span> 添加了一个新方法。此外，还要注意，以此种方式实现的继承中， <span  class="math">\(SubType.constructor\)</span> 指向的是 <span  class="math">\(SuperType\)</span> 。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型链能够实现继承，但也存在问题。由于是直接赋值给原型，因此其中的属性会被所有实例共享。如以下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">SuperType</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;red&#34;</span><span class="p">];</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">SubType</span><span class="p">()</span> <span class="p">{}</span>
<span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuperType</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">instance1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
<span class="nx">instance1</span><span class="p">.</span><span class="nx">colors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;blue&#34;</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">instance1</span><span class="p">.</span><span class="nx">colors</span><span class="p">);</span> <span class="c1">//&#34;red,blue&#34;
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">instance2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">();</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">instance2</span><span class="p">.</span><span class="nx">colors</span><span class="p">);</span> <span class="c1">//&#34;red,blue&#34;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有，不能通过子类调用超类的有参构造函数等。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于种种原因，实践中很少单独使用原型链。</p>

<hr>

<h2 id="span-id2019120622-借用构造函数span"><span id="2019-12-06-2">2. 借用构造函数</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>借用构造函数</strong>（ <span  class="math">\(constructor\;stealing\)</span> ）用于解决原型中包含引用类型值带来的问题。本质是在子类构造函数中调用超类构造函数。可以通过 <span  class="math">\(call(\ )\)</span> 或者 <span  class="math">\(apply(\ )\)</span> 方法实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="s2">&#34;Hello World!&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">SubType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">SuperType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，通过“借调”超类构造函数，子类的每个实例就都具有超类中属性和方法的副本了。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然该种方法避免了引用原型的问题，但对于超类中包含的方法（如上例中所示的 <span  class="math">\(sayHello(\ )\)</span> 方法）也被复制了一份，没有实现函数复用。因此，借用构造函数的方法也很少单独使用。</p>

<hr>

<h2 id="span-id2019120633-组合继承span"><span id="2019-12-06-3">3. 组合继承</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>组合继承</strong>（ <span  class="math">\(combination\;inheritance\)</span> ），也叫伪经典继承。顾名思义，即组合原型链和借用构造函数的技术。本质是利用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">SuperType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>
<span class="kd">function</span> <span class="nx">SubType</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//继承属性
</span><span class="c1"></span>    <span class="nx">SuperType</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//继承方法
</span><span class="c1"></span><span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuperType</span><span class="p">();</span>
<span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">SubType</span><span class="p">;</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，组合继承不仅让子类中的每个实例都拥有自己的属性，还能调用相同的方法。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;组合继承避免了原型链和借用构造函数的缺点，融合了他们的优点，因此成为了<code>JavaScript</code>中最常用的继承方式。而且，通过组合继承， <span  class="math">\(instanceof\)</span> 和 <span  class="math">\(isPrototypeOf(\ )\)</span> 也能用于识别其创建的对象。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="2019-12-06-3-1">组合继承也有其不足，即在任何时候都会调用两次超类构造函数。</span></p>

<hr>

<h2 id="span-id2019120644-原型式继承span"><span id="2019-12-06-4">4. 原型式继承</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>原型式继承</strong>（ <span  class="math">\(prototypal\;inheritance\)</span> ）是一种特殊的继承方式，该方法并没有严格意义上的构造函数，本质是借助原型可以基于已有对象创建新对象，还不必创建自定义类型的特性。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">object</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{}</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">friends</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;Tom&#34;</span><span class="p">];</span>
 <span class="p">};</span>
<span class="kd">var</span> <span class="nx">anotherPerson</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>
<span class="nx">anotherPerson</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;Rob&#34;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">yetAnotherPerson</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>
<span class="nx">yetAnotherPerson</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;Van&#34;</span><span class="p">);</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">friends</span><span class="p">);</span> <span class="c1">//&#34;Tom,Rob,Van&#34;
</span></code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <span  class="math">\(object(\ )\)</span> 函数中，创建了函数 <span  class="math">\(F(\ )\)</span> 作为一个临时构造函数，将传入的对象作为其原型并返回一个新实例。在<code>ECMAScript5</code>中新增了 <span  class="math">\(Object.create(\ )\)</span> 方法规范化了原型式继承。该方法接收两个参数——一个用作新对象的原型，另一个为新对象定义额外属性（可选）。在传入一个参数时，行为与 <span  class="math">\(object(\ )\)</span> 方法相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">friends</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;Tom&#34;</span><span class="p">];</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">anotherPerson</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>
<span class="nx">anotherPerson</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;Rob&#34;</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">friends</span><span class="p">);</span> <span class="c1">//&#34;Tom,Rob&#34;
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">yetAnotherPerson</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;Van&#34;</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">yetAnotherPerson</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//&#34;Van&#34;
</span></code></pre></div>
<hr>

<h2 id="span-id2019120655-寄生式继承span"><span id="2019-12-06-5">5. 寄生式继承</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>寄生式继承</strong>（ <span  class="math">\(parasitic\;inheritance\)</span> ）与原型式继承紧密相关。其思路与寄生构造函数和工厂模式类似，创建一个用于封装继承过程的函数，在函数内部以某种方式增强对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">createAnother</span><span class="p">(</span><span class="nx">original</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">original</span><span class="p">);</span>
    <span class="nx">clone</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">()</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="s2">&#34;Hello World!&#34;</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">clone</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span  class="math">\(createAnother(\ )\)</span> 方法接受一个对象作为新对象的基础对象，再将其赋给 <span  class="math">\(clone\)</span> ，通过 <span  class="math">\(clone\)</span> 对象添加 <span  class="math">\(sayHello(\ )\)</span> 方法，最后返回 <span  class="math">\(clone\)</span> 对象。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与构造函数模式类似，寄生式继承会由于无法做到函数复用而降低效率。</p>

<hr>

<h2 id="span-id2019120666-寄生组合式继承span"><span id="2019-12-06-6">6. 寄生组合式继承</span></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>寄生组合式继承</strong>（ <span  class="math">\(parasitic\;combination\;inheritance\)</span> ）即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。在之前我们谈到了<a href="#2019-12-06-3-1">组合继承的不足</a>,而解决办法就是寄生组合式继承。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">object</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{}</span>
    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">o</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">inheritPrototype</span><span class="p">(</span><span class="nx">subType</span><span class="p">,</span> <span class="nx">superType</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">prototype</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">superType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
    <span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">subType</span><span class="p">;</span>
    <span class="nx">subType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">prototype</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span  class="math">\(inheritPrototype(\ )\)</span> 方法接收两个参数：子类构造函数和超类构造函数。其高效性在于只调用了一次 <span  class="math">\(SuperType\)</span> 构造函数，且避免了在 <span  class="math">\(SubType.prototype\)</span> 上创建不必要的属性，保持原型链不变，还能使用 <span  class="math">\(instanceof\)</span> 和 <span  class="math">\(isPrototypeOf(\ )\)</span> ，开发人员普遍认为寄生组合式继承是引用类型的最理想的继承方式。</p>

<hr>

<h2 id="7-小结">7. 小结</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JavaScript</code>主要通过原型链实现继承。但原型链不适宜单独使用，解决其问题的技术是借用构造函数。使用最多的继承模式是组合继承。此外还可以选择原型式继承、寄生式继承和寄生组合式继承。</p>

            </div>
            <div class="meta post-footer"> <span>2019 Dec 6 22:58</span> <a href="/post/javascript%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


            </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script></main>
    </body>
    <script src=https://z217blog.cn/js/navbutton.js></script>
</html>
