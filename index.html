<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.74.3" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
        
        <a href="http://123.57.12.189"  target="_blank" >
            <i class="fas fa-link fa-sm"></i>
            <span>二站</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm6%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/">JVM（6）：字节码执行引擎</a>
        
        
        <p>深入理解Java虚拟机（6）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Oct 14 17:02
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm5%E7%B1%BB%E5%8A%A0%E8%BD%BD/">JVM（5）：类加载</a>
        
        
        <p>深入理解Java虚拟机（5）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Sep 22 22:20
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%AB%E7%9A%87%E5%90%8E/">回溯算法：八皇后</a>
        
        
        <p>回溯算法的应用，以八皇后为例</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Sep 19 16:11
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Algorithm
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm4class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">JVM（4）：Class文件结构</a>
        
        
        <p>深入理解Java虚拟机（4）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Sep 17 22:58
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/%E5%BF%AB%E9%80%9F%E4%B9%98%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/">快速乘算法简介</a>
        
        
        <p>快速乘算法（俄罗斯农民乘法）简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Sep 15 15:05
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Algorithm
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm6%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/">JVM（6）：字节码执行引擎</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-运行时栈帧">1. 运行时栈帧</h2>
<p>        <code>JVM</code>以方法作为最基本的执行单元，<strong>栈帧</strong> ( $Stack\ \ Frame$ ) 是用于支持虚拟机进行方法调用和方法执行背后的数据结构，也是虚拟机运行时数据区中的<strong>虚拟机栈</strong> ( $Virtual\ \ Machine\ \ Stack$ ) 的栈元素，存储了方法的局部变量表、操作数栈、动态连接和方法返回地址和一些额外的附加信息，方法表的 $Code$ 属性包含了栈帧所需的局部变量表和操作数栈的大小。对于执行引擎来讲，在每个线程中，只有处于调用堆栈栈顶的方法才是正在运行的方法，称为<em><strong>当前栈帧</strong></em> ( $Current\ \ Stack\ \ Frame$ )，与这个栈帧关联的方法称为<em><strong>当前方法</strong></em> ( $Current\ \ Method$ )。</p>
<h3 id="11-局部变量表">1.1 局部变量表</h3>
<p>        <strong>局部变量表</strong> ( $Local\ \ Variable\ \ Table$ ) 是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量，其最大容量由方法 $Code$ 属性中的 $max_-locals$ 数据项决定。局部变量表以<b>变量槽</b> ( $Variable\ \ Slot$ ) 为最小单位，每个变量槽都应该能存放一个 $boolean$ 、$byte$ 、$char$ 、$short$ 、$int$ 、$float$ 、$reference$ 或 $returnAddress$ 类型的数据。这些数据长度一般都为 $32$ 位 ( $reference$ 可能为 $64$ 位 )，也意味着变量槽的长度至少为 $32$ 位。而对于 $64$ 位的数据类型，比如 $long$ 和 $double$ ，会通过高位对齐的方式分配两个连续的变量槽。<br>
        <code>JVM</code>通过索引定位的方式使用局部变量表。对于 $32$ 位数据类型的变量，使用一个索引值；对于 $64$ 位数据类型的变量，使用相邻的两个索引值。当方法被调用时，<code>JVM</code>使用局部变量表将参数值传递到参数变量列表，即从实参到形参。如果方法为实例方法，那么局部变量表第 $0$ 位索引的变量槽默认为传递方法所属对象实例的引用。在参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。因为方法中定义的变量的作用域不一定会覆盖整个方法体，因此变量槽是可以重用的。<br>
        局部变量槽会影响系统的垃圾收集行为，可以观察以下三种情况：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">placeholder</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">64</span> <span class="o">*</span> <span class="n">1024</span> <span class="o">*</span> <span class="n">1024</span><span class="o">];</span>
    <span class="n">System</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">placeholder</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">64</span> <span class="o">*</span> <span class="n">1024</span> <span class="o">*</span> <span class="n">1024</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="n">System</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">placeholder</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">64</span> <span class="o">*</span> <span class="n">1024</span> <span class="o">*</span> <span class="n">1024</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>        在前两种情况中进行垃圾收集并不能回收 $placeholder$ 中的空间，但第三种情况可以。根本原因是局部变量表的变量槽中是否还存在 $placeholder$ 数组对象的引用。局部变量表是<code>GC Roots</code>的一部分，$placeholder$ 是其所关联的对象，因此无法被回收。如果想要回收这种变量，可以通过手动设置为 $null$ 的方法，但是在即时编译中，这种赋值往往会被优化掉。</p>
<h3 id="12-操作数栈">1.2 操作数栈</h3>
<p>        <strong>操作数栈</strong> ( $Operand\ \ Stack$ )，也被称为操作栈。同局部变量表一样，其长度也在编译时被写入 $Code$ 属性的 $max_-stacks$ 数据项之中。操作数栈的每一个元素都可以是任意数据类型，包括 $long$ 和 $double$ 。$32$ 位数据类型所占的栈容量为 $1$ ，$64$ 位数据类型所占的栈容量为 $2$ 。<br>
        在方法执行的开始，它的操作数栈为空。随着方法的执行，各种字节码指令会被压入操作数栈或者从操作数栈中弹出。操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配。在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，应该是完全独立的。但是大多数虚拟机都会进行优化，将上部分栈帧的部分局部变量表与下部分栈帧的部分操作数栈重叠，节省空间的同时还可以实现共用部分数据。</p>
<h3 id="13-动态连接">1.3 动态连接</h3>
<p>        每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的<strong>动态连接</strong> ( $Dynamic\ \ Linking$ )。<code>Class</code>文件常量池中存有大量符号引用，字节码的方法调用指令以其中指向方法的符号引用作为参数。这些符号引用的一部分会在类加载阶段或者第一次被使用时转为直接引用，这种转化称为静态解析。另外未加载的一部分则在运行时期转化为直接引用，这部分就称为动态连接。</p>
<h3 id="14-方法返回地址">1.4 方法返回地址</h3>
<p>        方法在执行后，一种退出方式是遇到方法返回的字节码指令，这种退出方式称为<em><strong>正常调用完成</strong></em> ( $Normal\ \ Method\ \ Invocation\ \ Completion$ )。另一种退出方式是执行过程中遇到未处理的异常，这种退出方式称为<em><strong>异常调用完成</strong></em> ( $Abrupt\ \ Method\ \ Invocation\ \ Completion$ )。无论采用何种方式，方法都需要在栈帧中存储一些信息，用于恢复到上层主调方式的执行状态。一般情况下，以第一种方式退出的方法可以直接将上层方法的<code>PC</code>计数器的值作为返回地址，栈帧中也可能保存这个计数值。而以第二种方式退出的方法就要通过异常处理表确定，栈帧中无法保存。</p>
<h2 id="2-方法调用">2. 方法调用</h2>
<p>        方法调用阶段的任务是确定哪个方法被调用。</p>
<h3 id="21-解析">2.1 解析</h3>
<p>        所有方法的调用目标都是<code>Class</code>文件中一个常量池的符号引用。在类加载的解析阶段，其中一部分符号会转化为直接引用，前提是方法只有一个确定的可调用版本，并且在运行期不改变。这类方法调用称为<strong>解析</strong> ( $Resolution$ )。<br>
        <code>JVM</code>支持以下 $5$ 条方法调用字节码指令，分别是：</p>
<ul>
<li>$invokestatic$ ：调用静态方法；</li>
<li>$invokespecial$ ：调用实例构造器的 &lt;$init$&gt;$(\ )$ 方法、私有方法和父类中的方法；</li>
<li>$invokevirtual$ ：调用所有虚方法；</li>
<li>$invokeinterface$ ：调用接口方法，运行时会确定一个接口实例；</li>
<li>$invokedynamic$ ：由用户设计的引导方法决定，在运行时动态解析出调用点限定符所引用的方法。</li>
</ul>
<p>        能被 $invokestatic$ 和 $invokespecial$ 调用的方法就可以在解析阶段确定版本，包括静态方法、私有方法、实例构造器、父类方法以及被 $final$ 修饰的方法 ( 使用 $invokevirtual$ 指令调用 ) 。这些方法统称为<strong>非虚方法</strong> ( $Non-Virtual\ \ Method$ )，与之对应的方法称为<strong>虚方法</strong> ( $Virtual\ \ Method$ )。</p>
<h3 id="22-分派">2.2 分派</h3>
<h4 id="221-静态分派">2.2.1 静态分派</h4>
<p>        <strong>静态类型</strong> ( $Static\ \ Type$ ) ，也叫<strong>外观类型</strong> ( $Apparent\ \ Type$ ) ，是声明的类型。对象的<strong>实际类型</strong> ( $Actual\ \ Type$ ) 也就是<strong>运行时类型</strong> ( $Runtime\ \ Type$ )。静态类型的变化仅在使用时才发生，并且在编译期可知；而实际类型只有在运行时才可以确定。由于编译阶段只能获取静态类型，因此<code>Javac</code>编译器会根据参数的静态类型决定调用哪个版本的方法，而所有依赖于静态类型的分派都称为静态分派。静态分派最典型的表现方式就是重载。如果存在多个优先级相同的选择，那么会编译失败，并提示<em><strong>类型模糊</strong></em> ( $Type\ \ Ambiguous$ )，这时候就需要使用类型转换显示指定。</p>
<h4 id="222-动态分派">2.2.2 动态分派</h4>
<p>        静态分派与重载相关，而动态分派与重写相关。具体表现为调用类中的重写方法时，会调用实际类型的方法而非静态类型的方法。实现这种模式的关键是 $invokespecial$ 指令，其解析过程可以分为以下几步：</p>
<ul>
<li>找到操作数栈栈顶的第一个元素指向的对象的世界流行，记为 $C$ ；</li>
<li>如果在 $C$ 中找到了与常量中描述符和简单名称都相符的方法，则检验访问权限。如果可以访问则返回该方法，否则抛出 $java.lang.IllegalAccessError$ 异常；</li>
<li>按照继承关系从下往上寻找；</li>
<li>如果没有找到符合的方法，抛出 $java.lang.AbstractMethodError$ 异常。</li>
</ul>
<p>        正因为 $invokevirtual$ 在第一步就是确定运行期中接收者的实际类型，因此会根据接收者的实际类型选择方法版本，这也是<code>Java</code>重写的本质，通过这种方式确定方法版本的分派称为动态分派。需要注意的是，动态分派只对方法起效，对字段不奏效，因为并不存在虚字段的概念。如果子类声明了与父类相同的字段，虽然在内存中两个字段都会存在，但是子类字段会掩盖父类字段。</p>
<h4 id="223-单分派与多分派">2.2.3 单分派与多分派</h4>
<p>        方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为根据一个宗量进行选择的单分派和根据多个宗量进行选择的多分派两种。对于静态分派，选择方法的依据有两个：静态类型和方法参数，因此静态分派属于多分派；对于动态分派，由于在编译期就已经决定了方法签名，唯一影响的因素只有接收者的实际类型，因此动态分派属于单分派。因此<code>Java</code>是一门静态多分派、动态单分派的语言。</p>
<h4 id="224-动态分派的实现">2.2.4 动态分派的实现</h4>
<p>        动态分派要求运行时在接收者类型的方法元数据中搜索合适的目标方法。为了性能考虑，<code>JVM</code>建立了一个<strong>虚方法表</strong> ( $Virtual\ \ Method\ \ Table$ ，$vtable$ )，用来代替元数据查找。虚方法表中存放着各个方法的实际入口地址。如果方法未被重写，那么子类和父类的入口地址相同；如果方法被重写，那么子类虚方法表的入口地址会被替换为子类实现版本的入口地址。为了程序实现的方便，具有相同签名的方法在子类和父类中的索引序号都相同，这样在类型改变时只需要从虚方法表中按索引转换出入口地址即可。虚方法表一般在类加载的连接阶段初始化，在子类的变量初始值准备时一同初始化。除了虚方法表之外，<code>JVM</code>还会使用<em><strong>类型继承关系分析</strong></em> ( $Class\ \ Hierarcht\ \ Analysis$ ，$CHA$ )、<em><strong>守护内联</strong></em> ( $Guarded\ \ Inlining$ )、<em><strong>内联缓存</strong></em> ( $Inline\ \ Cache$ ) 等多种非稳定的激进优化来争取性能空间。</p>
<h2 id="3-动态类型语言支持">3. 动态类型语言支持</h2>
<h3 id="31-javalanginvoke包">3.1 <code>java.lang.invoke</code>包</h3>
<p>        $java.lang.invoke$ 包的目的是为了提供除了依靠符号引用确定调用的目标方法之外的动态确定目标方法的机制，称为<strong>方法句柄</strong> ( $Method\ \ Handle$ )，类似于<code>C</code>/<code>C++</code>中的函数指针。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodHandleTest</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="n">MethodHandle</span> <span class="nf">getPrintlnMH</span><span class="o">(</span><span class="n">Object</span> <span class="n">receiver</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
    <span class="c1">// MethodType代表方法类型，包含了方法的返回值（第一个参数）和具体参数
</span><span class="c1"></span>    <span class="n">MethodType</span> <span class="n">mt</span> <span class="o">=</span> <span class="n">MethodType</span><span class="o">.</span><span class="na">methodType</span><span class="o">(</span><span class="kt">void</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="c1">// lookup()用于查找符合给定的方法名称、类型和调用权限的句柄
</span><span class="c1"></span>    <span class="c1">// 此处查找虚方法并调用，根据Java的规则，方法的第一个参数隐式为this，以前是通过参数列表进行传递，如今可以使用bingTo()方法
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">MethodHandles</span><span class="o">.</span><span class="na">lookup</span><span class="o">().</span><span class="na">findVirtual</span><span class="o">(</span><span class="n">receiver</span><span class="o">.</span><span class="na">getClass</span><span class="o">(),</span> <span class="s">&#34;println&#34;</span><span class="o">,</span> <span class="n">mt</span><span class="o">).</span><span class="na">bindTo</span><span class="o">(</span><span class="n">receiver</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
    <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">%</span> <span class="n">2</span> <span class="o">==</span> <span class="n">0</span> <span class="o">?</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span> <span class="o">:</span> <span class="k">new</span> <span class="n">ClassA</span><span class="o">();</span>
    <span class="n">getPrintlnMH</span><span class="o">(</span><span class="n">obj</span><span class="o">).</span><span class="na">invokeExact</span><span class="o">(</span><span class="s">&#34;icyfenix&#34;</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ClassA</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">println</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        $MethodHandle$ 可以视为方法的一个“引用”。与反射相比，$Reflection$ 是在模拟<code>Java</code>代码层次的调用，而 $MethodHandle$ 是在模拟字节码层次的调用。</p>
<h3 id="32-invokedynamic指令">3.2 <code>invokedynamic</code>指令</h3>
<p>        $invokedynamic$ 是<code>JDK 7</code>中新增的一条字节码指令，用于实现对动态类型语言的支持。动态类型语言的关键特征是类型检查的主体过程是在运行期而不是编译期进行的，因此<code>Java</code>是一门静态类型语言。但是<code>JVM</code>中不只可以运行<code>Java</code>，还有其他语言比如<code>Groovy</code>和<code>Clojure</code>等，它们都是动态类型语言。$invokedynamic$ 的引入是为了更好的支持动态类型语言。从某种意义上，$invokedynamic$ 的作用与 $MethodHandle$ 是一样的，即将查找目标方法的决定权转嫁给用户的具体代码之中。<br>
        每一处含有 $invokedynamic$ 指令的位置都被称为<strong>动态调用点</strong> ( $Dynamically-Computed\ \ Call\ \ Site$ )，该指令的第一个参数不再是 $CONSTANT_-Methodref_-info$ ，而是 $CONSTANT_-InvokeDynamic_-info$ 。该常量包含三项信息：<i><b>引导方法</b></i> ( $Bootstrap\ \ Method$ )、<i><b>方法类型</b></i> ( $MethodType$ ) 和名称。引导方法具有固定参数，并且返回值必定是 $java.lang.invoke.CallSite$ 对象，表示真正要执行的目标方法调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InvokeDynamicTest</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
    <span class="n">INDY_BootstrapMethod</span><span class="o">().</span><span class="na">invokeExact</span><span class="o">(</span><span class="s">&#34;icyfenix&#34;</span><span class="o">);</span> <span class="c1">//
</span><span class="c1"></span>  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testMethod</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;hello String:&#34;</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">CallSite</span> <span class="nf">BootstrapMethod</span><span class="o">(</span><span class="n">MethodHandles</span><span class="o">.</span><span class="na">Lookup</span> <span class="n">lookup</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">MethodType</span> <span class="n">mt</span><span class="o">)</span>
      <span class="kd">throws</span> <span class="n">NoSuchMethodException</span><span class="o">,</span> <span class="n">IllegalAccessException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ConstantCallSite</span><span class="o">(</span><span class="n">lookup</span><span class="o">.</span><span class="na">findStatic</span><span class="o">(</span><span class="n">InvokeDynamicTest</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">mt</span><span class="o">));</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="n">MethodType</span> <span class="nf">MT_BootstrapMethod</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">MethodType</span><span class="o">.</span><span class="na">fromMethodDescriptorString</span><span class="o">(</span>
        <span class="s">&#34;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&#34;</span><span class="o">,</span>
        <span class="kc">null</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="n">MethodHandle</span> <span class="nf">MH_BootstrapMethod</span><span class="o">()</span>
      <span class="kd">throws</span> <span class="n">NoSuchMethodException</span><span class="o">,</span> <span class="n">IllegalAccessException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">MethodHandles</span><span class="o">.</span><span class="na">lookup</span><span class="o">()</span>
        <span class="o">.</span><span class="na">findStatic</span><span class="o">(</span><span class="n">InvokeDynamicTest</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">&#34;BootstrapMethod&#34;</span><span class="o">,</span> <span class="n">MT_BootstrapMethod</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="n">MethodHandle</span> <span class="nf">INDY_BootstrapMethod</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
    <span class="n">CallSite</span> <span class="n">cs</span> <span class="o">=</span>
        <span class="o">(</span><span class="n">CallSite</span><span class="o">)</span>
            <span class="n">MH_BootstrapMethod</span><span class="o">()</span>
                <span class="o">.</span><span class="na">invokeWithArguments</span><span class="o">(</span>
                    <span class="n">MethodHandles</span><span class="o">.</span><span class="na">lookup</span><span class="o">(),</span>
                    <span class="s">&#34;testMethod&#34;</span><span class="o">,</span>
                    <span class="n">MethodType</span><span class="o">.</span><span class="na">fromMethodDescriptorString</span><span class="o">(</span><span class="s">&#34;(Ljava/lang/String;)V&#34;</span><span class="o">,</span> <span class="kc">null</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">cs</span><span class="o">.</span><span class="na">dynamicInvoker</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="4-基于栈的字节码解释引擎">4. 基于栈的字节码解释引擎</h2>
<p>        许多<code>JVM</code>的执行引擎在执行<code>Java</code>代码的时候都有解释执行和编译执行两种选择。在最初的版本，虚拟机大多通过解释执行，但在如今主流的虚拟机中包含了即时编译器后，如何执行<code>Class</code>文件中的代码就变成了因虚拟机决定了。</p>
<h3 id="41-基于栈的指令集与基于寄存器的指令集">4.1 基于栈的指令集与基于寄存器的指令集</h3>
<p>        <code>Javac</code>编译器输出的字节码指令流基本上是一种基于栈的<strong>指令集架构</strong> ( $Instruction\ \ Set\ \ Architecture$ ，$ISA$ )，里面的指令大都是零地址指令，依赖操作数栈进行工作。与之对应的是基于寄存器的指令集，也就是如今主流<code>PC</code>中物理硬件直接支持的指令集架构，依赖于寄存器进行工作。基于栈的指令集的优点是可移植，因为寄存器由硬件提供，容易受到硬件约束。而且基于栈的指令集具有更加紧凑的代码，实现更加简单。但是相应的，缺点就是速度会慢一些，这也是如今主流物理机都是寄存器架构的原因。</p>
<h3 id="42-基于栈的解释器执行过程">4.2 基于栈的解释器执行过程</h3>
<p>        以如下代码为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">calc</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">100</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">200</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">300</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>        使用<code>javap</code>进行反编译后的结果如下：</p>
<pre><code>public int calc();
    descriptor: ()I
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        100
         2: istore_1
         3: sipush        200
         6: istore_2
         7: sipush        300
        10: istore_3
        11: iload_1
        12: iload_2
        13: iadd
        14: iload_3
        15: imul
        16: ireturn
      LineNumberTable:
        line 5: 0
        line 6: 3
        line 7: 7
        line 8: 11
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      17     0  this   Lcom/jvm/execution/Calc;
            3      14     1     a   I
            7      10     2     b   I
           11       6     3     c   I
</code></pre><p>        上述代码表明需要深度为 $2$ 的栈，$4$ 个变量槽，参数数量为 $1$ ( $this$ )。程序计数器从 $0$ 开始，按照偏移量依次执行指令。对上述字节码指令的解释如下：</p>
<ol>
<li>$bipush\ \ 100$ ： 将 $100$ 压入栈内；</li>
<li>$istore_-1$ ：取出栈顶整型值 ( $100$ ) 并存放到第一个变量槽中；</li>
<li>$sipush\ \ 200$ ：将 $200$ 压入栈内；</li>
<li>$istore_-2$ ：取出栈顶整型值并存放到第二个变量槽中；</li>
<li>$sipush\ \ 300$ ：将 $300$ 压入栈内；</li>
<li>$istore_-3$ ：取出栈顶整型值并存放到第三个变量槽中；</li>
<li>$iload_-1$ ：将第一个变量槽中的整型值复制到操作数栈顶；</li>
<li>$iload_-2$ ：将第二个变量槽中的整型值复制到操作数栈顶；</li>
<li>$iadd$ ：取出操作数栈顶的两个元素，将他们相加的结果压入栈内；</li>
<li>$iload_-3$ ：将第三个变量槽中的整型值复制到操作数栈顶；</li>
<li>$imul$ ：取出操作数栈顶的两个元素，将他们相乘的结果压入栈内；</li>
<li>$ireturn$ ：结束方法并将操作数栈顶的整型值返回给该方法的调用者。</li>
</ol>
<p>        当然上述的执行过程只是一种概念模型，<code>JVM</code>可能会对执行过程进行优化，从而提高性能。实际执行的情况会与上述的情况差距很大，根本原因是虚拟机中解析器和即时编译器都会对字节码进行优化。例如<code>HotSpot</code>虚拟机中存在很多以 $fast_-$ 开头的非标准字节码，用于合并、替换输入的字节码，从而提高性能。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Oct 14 17:02</span> <a href="/post/jvm6%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm5%E7%B1%BB%E5%8A%A0%E8%BD%BD/">JVM（5）：类加载</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-类加载的时机">1. 类加载的时机</h2>
<p>        一个类型从被加载到卸载的过程中，会经历<strong>加载</strong> ( $Loading$ )、<strong>验证</strong> ( $Verification$ )、<strong>准备</strong> ( $Preparation$ )、<strong>解析</strong> ( $Resolution$ )、<strong>初始化</strong> ( $Initialization$ )、<strong>使用</strong> ( $Using$ ) 和<strong>卸载</strong> ( $Unloading$ ) 七个阶段，其中可以把验证、准备、解析统称为<strong>连接</strong> ( $Linking$ )。这些阶段之间可以交叉进行。加载、验证、准备、初始化、卸载的顺序是确定的，解析阶段则不一定，可能开始在初始化之后。<br>
        《<code>Java</code>虚拟机规范》中并没有规定什么时候需要进行加载，但是严格规定了有且只有六种情况需要进行初始化：</p>
<ul>
<li>执行 $new$ 、$getstatic$ 、$putstatic$ 、$invokestatic$ 四条字节码指令时，如果类型没有初始化，需要先进行初始化阶段。这四条字节码指令分别对应：使用 $new$ 创建对象实例、读取和设置静态字段 ( $final$ 字段除外，因为它在编译器就已被置入常量池 )、调用静态方法；</li>
<li>对类型进行反射调用时，如果类型没有初始化，需要先进行初始化阶段；</li>
<li>初始化类时如果父类没有初始化，需要先初始化父类；</li>
<li>虚拟机启动时，主类需要先进行初始化；</li>
<li><code>JDK 7</code>之后，如果一个 $java.lang.invoke.MethodHandle$ 实例的解析结果为 $REF_-getStatic$ 、$REF_-putStatic$ 、$REF_-newInvokeSpecial$ 四种类型的方法句柄时，如果该方法句柄对应的类没有初始化，需要先进行初始化阶段；</li>
<li><code>JDK 8</code>之后，接口中包含 $default$ 方法时，在其实现类发生初始化前，需要先进行接口的初始化阶段。</li>
</ul>
<p>        这六种情况触发初始化场景的行为称为主动引用，除此之外的引用称为被动引用。例如通过子类访问父类的静态字段并不会触发子类的初始化，只会触发父类的初始化；声明一个引用数组并不会触发引用类型的初始化，而是初始化一个数组类型。<br>
        与类相同，接口也具有初始化过程。虽然接口中不能使用静态代码块，但是编译器仍然会生成 &lt;$clinit$&gt;$(\ )$ 类构造器，用于初始化成员变量。在前面的六种主动引用触发场景中，只有在初始化父类时才会对接口进行初始化。但是一个接口在初始化时，并不要求其父接口全部初始化，只有在用到时才需要进行初始化。</p>
<h2 id="2-类加载的过程">2. 类加载的过程</h2>
<h3 id="21-加载">2.1 加载</h3>
<p>        类加载过程，虚拟机需要完成以下三件事：</p>
<ul>
<li>通过类的全限定名获取二进制字节流；</li>
<li>将字节流所代表的静态存储结构转为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的 $java.lang.Class$ 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>        由于没有限制获取字节流的位置，因此可以从许多地方以许多方式获取，例如从<code>Jar</code>包、<code>War</code>包获取，从<code>JSP</code>文件获取、从数据库中读取等。相较于其他阶段，非数组类型的类加载的可控性很强，可以通过自定义的类加载器完成。数组类的加载十分特殊，它并不依赖类加载器，而是由<code>JVM</code>在内存中直接构造。但是数组类仍然与类加载器有着密切关系，因为其元素类型仍然需要依赖类加载完成加载。一个数组类的创建规则如下：</p>
<ul>
<li>如果数组的组件类型（数组去掉一个维度的类型）是引用类型，需要依赖类加载器递归加载，并将该数组标识在组件类加载器的类名称空间上；</li>
<li>如果数组的组件类型为基本类型，则数组会被标识为与引导类加载器关联；</li>
<li>数组类的可访问性与组件类型的可访问性一致，如果组件类型为基本类型，则默认为 $public$ 。</li>
</ul>
<p>        加载阶段与连接阶段是交叉进行的，但是一些夹在加载阶段中进行的动作仍然属于连接阶段的一部分。加载阶段与连接阶段保持着一个严格的开始顺序，即前者必须先于后者开始。</p>
<h3 id="22-验证">2.2 验证</h3>
<p>        验证是连接阶段的第一步，确保<code>Class</code>文件中的信息符合要求，保证执行后不会危害虚拟机安全，一些不安全的行为如数组越界访问、不允许的类型转换等会被验证。验证阶段在类加载过程中占了很大一部分比重，但它是值得的，因为保证了<code>JVM</code>的安全。<br>
        虽然验证阶段十分重要，但并非必要执行的，因为一个程序在被发布时往往会进行大量测试和验证，因此可以通过 $-Xverify:none$ 参数关闭大部分类验证措施，从而缩短虚拟机类加载时间。</p>
<h4 id="221-文件格式验证">2.2.1 文件格式验证</h4>
<p>        文件格式验证要验证字节流是否符合<code>Class</code>文件格式的规范，并且能否被当前版本的虚拟机处理。可能包括以下验证点：</p>
<ul>
<li>魔数；</li>
<li>主次版本号；</li>
<li>常量类型；</li>
<li>索引值所指向的常量是否存在或者类型是否合理。</li>
</ul>
<h4 id="222-元数据验证">2.2.2 元数据验证</h4>
<p>        元数据验证是对字节码描述的信息进行语义分析，保证其描述的信息符合要求。可能包括以下验证点：</p>
<ul>
<li>类是否有父类 ( 除了 $java.lang.Object$ )；</li>
<li>类是否继承了不允许被继承的类；</li>
<li>实现类是否实现了抽象类中的抽象方法；</li>
<li>子类是否出现不合规则的重载，是否覆盖了 $final$ 字段。</li>
</ul>
<h4 id="223-字节码验证">2.2.3 字节码验证</h4>
<p>        字节码验证是最复杂的一个阶段，主要通过数据流分析和控制流分析确定语义是否合法、符合逻辑。保证类方法在运行时不会做出危害虚拟机安全的行为也是在这一阶段进行的。可能的验证点包括：</p>
<ul>
<li>操作数栈的数据类型与指令代码序列指定的类型相符；</li>
<li>跳转指令不会跳至方法体外；</li>
<li>类型转换的有效性；</li>
</ul>
<p>        即使一个类通过了字节码验证，也不能保证其是绝对安全的。由于数据流分析和控制流分析的高度复杂性，<code>JDK 6</code>之后方法体<code>Code</code>属性表内添加了一个新属性：$StackMapTable$ ，用于描述所有基本快开始时本地变量表和操作栈应有的状态。这样<code>JVM</code>在验证时只需要检查 $StackMapTable$ 中的记录是否合法即可。</p>
<h4 id="224-符号引用验证">2.2.4 符号引用验证</h4>
<p>        符号引用验证发生在虚拟机将符号引用转换为直接引用时（这个转换发生在解析阶段）。可能包括以下验证点：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否存在对应的类；</li>
<li>指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段；</li>
<li>符号引用中的类、字段和方法的可访问性；</li>
</ul>
<p>        符号引用验证主要是为了保证解析的正常执行。如果无法通过符号引用验证，<code>JVM</code>会抛出 $java.lang.IncompatibleClassChangError$ 的子类的异常，如 $IllegalAccessError$ 、$NoSuchFieldError$ 、$NoSuchMethodError$ 等。</p>
<h3 id="23-准备">2.3 准备</h3>
<p>        准备阶段为类中定义的静态变量分配内存并设置初始值。概念上，变量使用的内存都应该分配在方法区中，<code>JDK 7</code>之前，方法区在永久代中，<code>JDK 8</code>之后，方法区则处于<code>Java</code>堆之中。这里进行赋值的是类变量，而非实例变量，所以通常情况下初始值是零值，因为准备阶段并未执行初始化方法。初始化静态变量是 &lt;$clinit$&gt;$(\ )$ 方法中的 $putstatic$ 指令。如果要使初始值为非零值，那么需要将字段声明为 $final$ 。</p>
<h3 id="24-解析">2.4 解析</h3>
<p>        解析是<code>JVM</code>将常量池内符号引用替换为直接引用的过程。<strong>符号引用</strong> ( $Symboic\ \ References$ ) 可以是任何形式的字面量，其使用一组符号描述其引用目标。符号引用的引用目标并不要求已经加载到虚拟机内存中，不同的虚拟机能接受的符号引用都是一致的。与符号引用相对应的是<strong>直接引用</strong> ( $Direct\ \ References$ )，可以是一个直接指向目标的指针、相对偏移量，或者是一个能间接定位到目标的句柄。直接引用与虚拟机的内存布局直接挂钩，同一个符号引用在不同虚拟机上可能会翻译出不同的直接引用。和符号引用不同，直接引用引用的目标必须是已经加载在虚拟机内存中的。<br>
        《<code>Java</code>虚拟机规范》中规定了在进行操作符号引用的操作之前必须先对符号引用进行解析，但并未规定其具体时机，因此解析可以发生在许多时刻。对同一个符号引用进行多次解析是很常见的，虚拟机可以对第一次解析的结果进行缓存，从而避免重复解析。<br>
        在触发解析的指令中，$invokedynamic$ 是特殊的，因为该指令用于支持动态语言，而动态语言需要在程序运行时解析，因此由该指令触发的解析并不能被其他 $invokedynamic$ 指令使用。与动态解析对应，其余指令触发的解析可以称为静态解析，即在程序运行之前进行解析。</p>
<h4 id="241-类接口的解析">2.4.1 类/接口的解析</h4>
<p>        假设当前代码所处类为 $D$ ，对符号引用 $N$ 进行第一次解析，将其解析为类/接口 $C$ 的直接引用，那么需要进行以下步骤：</p>
<ol>
<li>$C$ 非数组类型，<code>JVM</code>会将 $N$ 的全限定名传递给 $D$ 的类加载器，加载 $C$ ，在这个过程中可能还会加载其他相关类；</li>
<li>$C$ 为数组类型，并且数组元素为非基本数据类型，那么 $N$ 的描述符会是类似于 $[Ljava/lang/Integer$ 的形式，类加载器会加载 $Integer$ 类型，再由<code>JVM</code>生成一个代表该数组维度和元素的数组对象；</li>
<li>如果上两步没有异常，那么<code>JVM</code>中已经生成 $C$ 了，但是还要进行符号引用验证，确认 $D$ 是否具备对 $C$ 的访问权限。</li>
</ol>
<p>        <code>JDK 9</code>中引入的模块化使得 $public$ 类型也并不是可以被任何位置访问了，所以还要检查模块间的访问权限。</p>
<h4 id="242-字段解析">2.4.2 字段解析</h4>
<p>        解析一个字段符号引用，首先会对字段表中 $class_-index$ 项中索引的 $CONSTANT_-Class_-info$ 符号引用进行解析，也就是字段所属的类或接口的符号引用。将该类或接口用 $C$ 表示，接下来会进行以下步骤：</p>
<ol>
<li>如果 $C$ 本身包含了简单名称与字段描述符都与目标匹配的字段，返回字段的直接引用；</li>
<li>如果 $C$ 实现了接口，会按照继承关系由下往上递归搜索接口，直到找到相匹配的字段；</li>
<li>如果 $C$ 不是 $java.lang.Object$ ，按照继承关系由下往上递归搜索父类，直到找到相匹配的字段。</li>
<li>查找失败，抛出 $java.lang.NoSuchFieldError$ 异常。</li>
</ol>
<p>        如果返回引用，则会对字段进行权限验证。实际情况中，往往会采取更加严格的约束，如同名字段出现在不同的接口或者父类中，<code>Javac</code>可能会拒绝编译。</p>
<h4 id="243-方法解析">2.4.3 方法解析</h4>
<p>        解析一个方法符号引用，首先会对字段表中 $class_-index$ 项中索引的方法所属的类或接口的符号引用进行解析。将类或接口用 $C$ 表示，接下来会进行以下步骤：</p>
<ol>
<li>如果 $C$ 为接口，抛出 $java.lang.IncompatibleClassChangeError$ 异常；</li>
<li>在 $C$ 中查找简单名称和描述符都与目标相匹配的方法，如果有则返回方法引用；</li>
<li>在 $C$ 的父类中递归查找相匹配的方法；</li>
<li>在 $C$ 的实现列表及其父接口中递归查找相匹配的方法，如果找到，说明 $C$ 为抽象类，抛出 $java.lang.AbstractMethodError$ 异常；</li>
<li>查找失败，抛出 $java.lang.NoSuchMethodError$ 异常。</li>
</ol>
<p>        如果成功查找到了方法，会对方法进行权限验证。</p>
<h4 id="244-接口方法解析">2.4.4 接口方法解析</h4>
<p>        解析一个接口方法符号引用，首先会对字段表中 $class_-index$ 项中索引的方法所属的类或接口的符号引用进行解析。将类或接口用 $C$ 表示，接下来会进行以下步骤：</p>
<ol>
<li>如果 $C$ 为类，抛出 $java.lang.IncompatibleClassChangeError$ 异常；</li>
<li>在 $C$ 中查找简单名称和描述符都与目标相匹配的方法，如果有则返回；</li>
<li>在 $C$ 的父接口中递归查找，直到 $java.lang.Object$ 类。如果存在多个匹配方法，返回其中一个；</li>
<li>查找失败，抛出 $java.lang.NoSuchMethodError$ 异常。</li>
</ol>
<p>        <code>JDK 9</code>之前接口方法都是 $public$ 的，不存在访问权限问题。<code>JDK 9</code>之后添加了接口的静态私有方法以及模块化访问约束，因此也需要对接口方法进行权限验证。</p>
<h3 id="25-初始化">2.5 初始化</h3>
<p>        初始化是类加载的最后一个步骤。在之前的阶段中，除了用户可以通过自定义类加载器的方式局部参与外，都由<code>JVM</code>主导。而直到初始化阶段，程序代码才真正开始执行，用户才开始拥有了主导权。初始化阶段可以简单的理解为执行类构造器 &lt;$clinit$&gt;$(\ )$ 的过程，这是个由<code>Javac</code>自动生成的方法。</p>
<ul>
<li>&lt;$clinit$&gt;$(\ )$ 方法是由编译器自动收集类中所有类变量的复制动作和静态代码块中的语句合并产生的，顺序由源文件决定。需要注意的是，静态代码块中的语句只能访问到块之前声明的变量，之后的声明的变量可以赋值，但不能访问；</li>
<li>&lt;$clinit$&gt;$(\ )$ 方法不需要显示调用父类构造器，<code>JVM</code>保证父类会在子类之前调用，因此第一个执行的肯定是 $java.lang.Object$ 类；</li>
<li>&lt;$clinit$&gt;$(\ )$ 方法并非必须，如果类中没有静态代码块和变量赋值操作，那么编译器可以不生成；</li>
<li>接口中虽然不存在静态代码块，但是仍然有变量初始化赋值的操作，因此也可以生成 &lt;$clinit$&gt;$(\ )$ 方法。但是与类不同的是，只有父接口中的变量被使用时才会初始化父接口，这个原则同样适用于接口的实现类；</li>
<li>&lt;$clinit$&gt;$(\ )$ 被保证是同步的。当一个线程执行时，其他线程会被阻塞。同一个类加载器下，一个类的初始化方法只会被执行一次。</li>
</ul>
<h2 id="3-类加载器">3. 类加载器</h2>
<p>        <strong>类加载器</strong> ( $Class\ \ Loader$ ) 负责通过类的全限定名获取描述该类的二进制字节流。</p>
<h3 id="31-类与类加载器">3.1 类与类加载器</h3>
<p>        对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同决定其在<code>JVM</code>中的唯一性。每一个类加载器都有一个独立的类名称空间，对于两个类，如果它们来自不同的类加载器，那么它们就不相等。</p>
<h3 id="32-双亲委派模型">3.2 双亲委派模型</h3>
<p>        在<code>JVM</code>看来，只有两种类加载器：<strong>启动类加载器</strong> ( $Bootstrap\ \ ClassLoader$ ) 和其他所有的类加载器。启动类加载器是使用<code>C++</code>实现的，属于虚拟机的一部分。其他所有类加载器由<code>Java</code>实现，且全部继承自 $java.lang.ClassLoader$ 。自<code>JDK 1.2</code>以来，<code>Java</code>一直保持着三层类加载器、双亲委派的类加载架构。在<code>JDK 8</code>之前，绝大多数程序都会使用到以下三个系统提供的类加载器：</p>
<ul>
<li>启动类加载器，负责将存放在 &lt;$JAVA_-HOME$&gt;$\backslash lib$ 目录或者被 $-Xbootclasspath$ 参数指定的路径中存放的能够被<code>JVM</code>识别的类库加载到虚拟机内存中。启动类加载器无法被<code>Java</code>程序直接引用，如果用户需要将加载请求委托给引导类加载器处理，可以直接使用 $null$ ；</li>
<li><strong>扩展类加载器</strong> ( $Extension\ \ Class\ \ Loader$ )，在类 $sun.misc.Launcher\$ExtClassLoader$ 中以<code>Java</code>代码的形式实现，负责加载 $&lt;JAVA_-HOME&gt;\backslash lib\backslash ext$ 目录中，或者被 $java.exit.dirs$ 系统变量指定的路径中所有的类库。<code>JDK 9</code>之后这种扩展机制被模块取代。由于是<code>Java</code>代码实现，因此开发者可以直接使用；</li>
<li><strong>应用程序类加载器</strong> ( $Application\ \ Class\ \ Loader$ )，由 $sun.misc.Launcher\$AppClassLoader$ 实现，是 $ClassLoader.getSystemClassLoader(\ )$ 方法的返回值，负责加载用户类路径 ( $ClassPath$ ) 上所有的类库，开发者同样可以在代码中使用，是程序中默认的类加载器。</li>
</ul>
<p>        <code>JDK 9</code>之前的<code>Java</code>应用都是由这三种类加载器互相配合完成的。用户也可以添加自定义的类加载器，如增加磁盘位置之外的<code>Class</code>文件来源等。<br>
        类加载器的<strong>双亲委派模型</strong> ( $Parents\ \ Delegation\ \ Model$ ) 要求除了顶层的启动类加载器外，其余的类加载器都要有自己的父类加载器。加载器之间的父子关系不是以继承方式实现的，而是以组合关系复用父加载器代码。双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，会将请求委派给父类加载器完成，最终会传送到最顶的启动类加载器。当父类加载器无法完成时会进行反馈，这时子加载器才会尝试自己完成加载。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Sep 22 22:20</span> <a href="/post/jvm5%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%AB%E7%9A%87%E5%90%8E/">回溯算法：八皇后</a></h1>
            </center>
            <div class="post-content">
                <p><a href="https://leetcode-cn.com/problems/n-queens/">原题地址：Problem 51</a></p>
<p>        将 $N$ 个皇后放在 $N \times N$ 的棋盘上，要求皇后不能处于同行、同列、同对角线上。没有什么取巧的方案，只能尝试所有情况后将可行的情况列出，因此可以使用回溯算法。<br>
        此题的难点在于判断皇后之间是否能相互攻击。如果将皇后所处的格子视为 $1$ ，其它格子视为 $0$ ，那么就可以使用位运算来判断。保证皇后不同行的方式很简单，只需要保证每一行只放置一个皇后即可。而如果想要保证皇后不同列，就需要记录之前行的皇后的位置。我们可以通过按位或和按位和进行记录和判断。</p>
<div>
$$
.\ \ Q\ .\ \ .\ \ \\
.\ \ .\ \ .\ \ Q\ \\
Q\ .\ \ .\ \ .\ \ \\
.\ \ .\ \ Q\ .\ \ \\
$$
</div>
<p>        对于上面的例子，第一行我们可以记为 $0100$ 。到第二行通过按位和进行判断：$0100 \And 0001$ ，如果不为 $0$ ，说明发生冲突。如果没有冲突，那么可以通过按位或获取新值：$0100 | 0001 = 0101$ 。重复上述步骤即可保证皇后处于不同列。<br>
        如果要保证皇后不处于同对角线，进行观察可以发现：下一行的皇后不能处于上一行皇后的左一格或者右一格，不能处于上上一行皇后的左二格或者右二格……也就是每过一行，就让之前行的皇后统一左移或者右移一格，然后再使用类似于之前判断皇后是否同列的方法进行判断就行了。我们可以使用两个数字 $left$ 和 $right$，专门用于记录之前行皇后的左移或者右移。再以上面的例子，第二行的 $left$ 为 $1000$ ，第三行为 $0010$ ；第二行的 $right$ 为 $0010$ ，第三行的 $right$ 为 $0001$ 。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="nf">solveNQueens</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">queens</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">backtrack</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">queens</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">backtrack</span><span class="o">(</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">queens</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">visit</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">queens</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">res</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">queens</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">visit</span> <span class="o">&amp;</span> <span class="n">position</span><span class="o">)</span> <span class="o">!=</span> <span class="n">0</span> <span class="o">||</span> <span class="o">(</span><span class="n">left</span> <span class="o">&amp;</span> <span class="n">position</span><span class="o">)</span> <span class="o">!=</span> <span class="n">0</span> <span class="o">||</span> <span class="o">(</span><span class="n">right</span> <span class="o">&amp;</span> <span class="n">position</span><span class="o">)</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
            <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">chars</span><span class="o">,</span> <span class="sc">&#39;.&#39;</span><span class="o">);</span>
            <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="sc">&#39;Q&#39;</span><span class="o">;</span>
            <span class="n">queens</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">chars</span><span class="o">));</span>
            <span class="n">backtrack</span><span class="o">(</span><span class="n">res</span><span class="o">,</span> <span class="n">queens</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">visit</span> <span class="o">|</span> <span class="n">position</span><span class="o">,</span> <span class="o">(</span><span class="n">left</span> <span class="o">|</span> <span class="n">position</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">,</span> <span class="o">(</span><span class="n">right</span> <span class="o">|</span> <span class="n">position</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">);</span>
            <span class="n">queens</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">queens</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>        $visit$ 、$left$ 、$right$ 分别用于判断同列、左对角线和右对角线的冲突。每次递归时，通过按位或以及左移和右移运算符移动之前行皇后的位置。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Sep 19 16:11</span> <a href="/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%85%AB%E7%9A%87%E5%90%8E/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm4class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">JVM（4）：Class文件结构</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-平台无关性">1. 平台无关性</h2>
<p>        <code>Java</code>在刚刚诞生时就有一句非常著名的口号：一次编写，到处运行。这个想法通过虚拟机实现，这些虚拟机都可以执行同一种与平台无关的字节码，从而达到一次编写，到处运行。可以说，字节码就是平台无关性的基石。<code>Java</code>虚拟机并不与<code>Java</code>语言绑定，在其之上还可以运行许多其他语言，如<code>Kotlin</code>、<code>Groovy</code>和<code>Scala</code>等。<code>Java</code>虚拟机唯一绑定的是类似于<code>Class</code>文件这种特殊的二进制文件，其中包含了<code>Java</code>虚拟机的指令集、符号表以及其他辅助信息。通过<code>Class</code>文件，<code>Java</code>虚拟机并不需要关心来源是什么语言，只要这门语言能够生成可以被读取的<code>Class</code>文件，那么它就可以在<code>Java</code>虚拟机上运行。<br>
        <code>Java</code>语言中的各种语法、关键字、常量变量和运算符号的语义最终都会转成字节码指令的组合，这就要求字节码指令的表达能力必须比<code>Java</code>语言的表达能力更强。从而，一些<code>Java</code>语言中并不支持的特性，字节码也能够表达出来。</p>
<h2 id="2-class类文件">2. <code>Class</code>类文件</h2>
<p>        <code>Class</code>文件是一组以 $8$ 个字节为单位的二进制流，数据项目按照顺序紧凑地排列在文件之中。对于 $8$ 字节以上空间的数据项，会按照高位在前的大端序分割存储在若干个 $8$ 字节中。<br>
        <code>Class</code>文件采取一种类似于<code>C</code>语言结构体的伪结构来存储数据，包含两种数据类型：</p>
<ul>
<li>无符号数：即基本数据类型，通过 $u1$ 、$u2$ 、$u3$ 、$u4$ 分别表示 $1$ 个字节、$2$ 个字节、$4$ 个字节和 $8$ 个字节的无符号数，用于表示数字、索引引用、数量值或者<code>UTF-8</code>编码的字符串；</li>
<li>表：由多个无符号数或者其他表构成的复合数据类型，一般以 $_-info$ 结尾，用于表示具有层次关系的数据。可以把整个<code>Class</code>文件都视为表，按照对应类型的数据紧凑排列而成。</li>
</ul>
<p>        当需要描述类型相同但数量不定的数据时，经常会使用一个前置的容器计数器加若干个连续的数据项的形式，称为该类型的集合。</p>
<h3 id="21-魔数和版本号">2.1 魔数和版本号</h3>
<p>        <code>Class</code>文件的头 $4$ 字节称为<strong>魔数</strong> ( $Magic\ \ Number$ )，用于确定该文件能否被虚拟机接受。魔数在很多文件格式中都存在，文件格式制定者可以自定义魔数，只要不会引起混淆。<code>Class</code>文件的魔数为 $0xCAFEBABE$ ，象征着一款咖啡。<br>
        在魔数之后是<code>Class</code>文件的版本号，前两个字节是<strong>次版本号</strong> ( $Minor\ \ Version$ )，后两个字节是<strong>主版本号</strong> ( $Major\ \ Version$ )。<code>Java</code>主版本号从 $45$ 开始，<code>JDK 1.1</code>之后每个大版本都会在之前的基础上加 $1$ 。次版本号在<code>JDK 1.1</code>及以前曾经短暂使用过，在<code>JDK 1.2</code>之后废弃，全部使用 $0$ 代替，直到<code>JDK 12</code>，由于一些复杂特性需要进行公测，于是重新启用了次版本号。</p>
<h3 id="22-常量池">2.2 常量池</h3>
<p>        常量池是<code>Class</code>文件中第一次出现表的数据项目，也是与其他项目关联最多的数据，通常也是最庞大的数据项目之一。常量池入口是一个 $u2$ 类型的数据，是<em><strong>常量池容量计数值</strong></em> ( $constant_-pool_-count$ )，从 $1$ 开始，$0$ 表示不指向常量池中的数据项目。<code>Class</code>文件中只有常量池的容量计数是从 $1$ 开始的。<br>
        常量池中主要存放字面量 ( $Literal$ ) 和符号引用 ( $Symbolic\ \ References$ )。字面量类似于<code>Java</code>中的常量，存放字符串、$final$ 常量等。符号引用则属于编译原理方面的概念，包括：</p>
<ul>
<li>被模块导出或者开放的<strong>包</strong> ( $Package$ )；</li>
<li>类和接口的<strong>全限定名</strong> ( $Fully\ \ Qualified\ \ Name$ )；</li>
<li>字段的名称和<strong>描述符</strong> ( $Descriptor$ )；</li>
<li>方法的名称和描述符；</li>
<li><strong>方法句柄</strong> ( $Method\ \ Handle$ ) 和<strong>方法类型</strong> ( $Method\ \ Type$ )；</li>
<li><strong>动态调用点</strong> ( $Dynamically-Computed\ \ Call\ \ Site$ ) 和<strong>动态常量</strong> ( $Dynamic-Computed\ \ Constant$ )。</li>
</ul>
<p>        <code>Java</code>代码在进行<code>Javac</code>编译时没有连接步骤，而是在虚拟机加载<code>Class</code>文件时进行动态连接，所以<code>Class</code>文件中不会保存方法和字段在内存中的位置信息，需要虚拟机在运行期进行转换。在类加载时，会从常量池中获取对应的符号引用，并在类创建和运行时解析，并翻译到具体内存地址中。<br>
        常量池的每一个常量都是一个表，包含 $17$ 结构不同的表结构数据，起始都是一个 $u1$ 类型标志位表示常量类型。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$CONSTANT_-Utf8_-info$</td>
<td align="center">$1$</td>
<td align="center"><code>UTF-8</code>编码的字符串</td>
</tr>
<tr>
<td align="center">$CONSTANT_-Integer_-info$</td>
<td align="center">$3$</td>
<td align="center">整型字面量</td>
</tr>
<tr>
<td align="center">$CONSTANT_-Float_-info$</td>
<td align="center">$4$</td>
<td align="center">浮点型字面量</td>
</tr>
<tr>
<td align="center">$CONSTANT_-Long_-info$</td>
<td align="center">$5$</td>
<td align="center">长整型字面量</td>
</tr>
<tr>
<td align="center">$CONSTANT_-Double_-info$</td>
<td align="center">$6$</td>
<td align="center">双精度浮点型字面量</td>
</tr>
<tr>
<td align="center">$CONSTANT_-Class_-info$</td>
<td align="center">$7$</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">$CONSTANT_-String_-info$</td>
<td align="center">$8$</td>
<td align="center">字符串类型字面量</td>
</tr>
<tr>
<td align="center">$CONSTANT_-Fieldref_-info$</td>
<td align="center">$9$</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">$CONSTANT_-Methodref_-info$</td>
<td align="center">$10$</td>
<td align="center">类中方法的符号引用</td>
</tr>
<tr>
<td align="center">$CONSTANT_-InterfaceMethodref_-info$</td>
<td align="center">$11$</td>
<td align="center">接口中方法的符号引用</td>
</tr>
<tr>
<td align="center">$CONSTANT_-NameAndType_-info$</td>
<td align="center">$12$</td>
<td align="center">字段或方法的部分符号引用</td>
</tr>
<tr>
<td align="center">$CONSTANT_-MethodHandle_-info$</td>
<td align="center">$15$</td>
<td align="center">方法句柄</td>
</tr>
<tr>
<td align="center">$CONSTANT_-MethodType_-info$</td>
<td align="center">$16$</td>
<td align="center">方法类型</td>
</tr>
<tr>
<td align="center">$CONSTANT_-Dynamic_-info$</td>
<td align="center">$17$</td>
<td align="center">动态计算常量</td>
</tr>
<tr>
<td align="center">$CONSTANT_-InvokeDynamic_-info$</td>
<td align="center">$18$</td>
<td align="center">动态方法调用点</td>
</tr>
<tr>
<td align="center">$CONSTANT_-Module_-info$</td>
<td align="center">$19$</td>
<td align="center">模块</td>
</tr>
<tr>
<td align="center">$CONSTANT_-Package_-info$</td>
<td align="center">$20$</td>
<td align="center">模块中开放或者导出的包</td>
</tr>
</tbody>
</table>
<p>        起初只提供了前 $11$ 种结构，后续为了更好地支持动态语言，额外增加了 $4$ 种，之后又为了支持<code>Java</code><em><strong>模块化系统</strong></em> ( $Jigsaw$ )，又加入了两种。<br>
        我们可以通过 $javap\ \ -verbose$ 命令查看<code>Class</code>文件中常量池的常量。</p>
<h3 id="23-访问标志">2.3 访问标志</h3>
<p>        在常量池之后是<strong>访问标志</strong> ( $access_-flags$ )，由 $2$ 字节组成，用于识别一些类或者接口的访问信息，包括：<code>Class</code>是类还是接口、是否为 $public$ 、是否为 $abstract$ 、是否为 $final$ ( 如果是类 ) 等等。</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">标志值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$ACC_-PUBLIC$</td>
<td align="center">$0x0001$</td>
<td align="center">是否为 $public$</td>
</tr>
<tr>
<td align="center">$ACC_-FINAL$</td>
<td align="center">$0x0010$</td>
<td align="center">是否为 $final$</td>
</tr>
<tr>
<td align="center">$ACC_-SUPER$</td>
<td align="center">$0x0020$</td>
<td align="center">是否允许使用 $invokespecial$ 字节码指令的新语义，在<code>JDK 1.0.2</code>之后都设置为真</td>
</tr>
<tr>
<td align="center">$ACC_-INTERFACE$</td>
<td align="center">$0x0200$</td>
<td align="center">表示接口</td>
</tr>
<tr>
<td align="center">$ACC_-ABSTRACT$</td>
<td align="center">$0x400$</td>
<td align="center">是否为 $abstract$</td>
</tr>
<tr>
<td align="center">$ACC_-SYNTHETIC$</td>
<td align="center">$0x1000$</td>
<td align="center">表示该类并非由用户代码产生</td>
</tr>
<tr>
<td align="center">$ACC_-ANNOTATION$</td>
<td align="center">$0x2000$</td>
<td align="center">表示注解</td>
</tr>
<tr>
<td align="center">$ACC_-ENUM$</td>
<td align="center">$0x4000$</td>
<td align="center">表示枚举</td>
</tr>
<tr>
<td align="center">$ACC_-MODULE$</td>
<td align="center">$0x8000$</td>
<td align="center">表示模块</td>
</tr>
</tbody>
</table>
<h3 id="24-索引">2.4 索引</h3>
<p>        <strong>类索引</strong> ( $this_-class$ ) 和<b>父类索引</b> ( $super_-class$ ) 都是 $u2$ 类型的数据，均指向一个 $CONSTANT_-Class_-info$ 的类描述符常量；<b>接口索引集合</b> ( $interfaces$ ) 是一组 $u2$ 类型的数据的集合，第一项 $u2$ 为接口计数器 ( $interfaces_-count$ )，表示索引表容量，后面的每一项均指向一个 $CONSTANT_-Class_-info$ 的类描述符常量。 <code>Class</code>文件通过这三项数据确定继承关系。类索引确定类的全限定名，父类索引确定类的父类的全限定名。除了 $Java.lang.Object$ 之外，所有的类都具有父类，而在 $Object$ 中，父类索引为 $0$ 。接口索引集合用于表示类实现的接口，按照声明顺序从左到右存储。</p>
<h3 id="25-字段表集合">2.5 字段表集合</h3>
<p>        <strong>字段表</strong> ( $Field_-info$ ) 用于表示接口和类中声明的变量。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$access_-flags$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$descriptor_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$attributes_-count$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$attribute_-info$</td>
<td align="center">$attributes$</td>
<td align="center">$attributes_-count$</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">标志值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$ACC_-PUBLIC$</td>
<td align="center">$0x0001$</td>
<td align="center">是否为 $public$</td>
</tr>
<tr>
<td align="center">$ACC_-PRIVATE$</td>
<td align="center">$0x0002$</td>
<td align="center">是否为 $private$</td>
</tr>
<tr>
<td align="center">$ACC_-PROTECTED$</td>
<td align="center">$0x0004$</td>
<td align="center">是否为 $protected$</td>
</tr>
<tr>
<td align="center">$ACC_-STATIC$</td>
<td align="center">$0x0008$</td>
<td align="center">是否为 $static$</td>
</tr>
<tr>
<td align="center">$ACC_-FINAL$</td>
<td align="center">$0x0010$</td>
<td align="center">是否为 $final$</td>
</tr>
<tr>
<td align="center">$ACC_-VOLATILE$</td>
<td align="center">$0x0040$</td>
<td align="center">是否为 $volatile$</td>
</tr>
<tr>
<td align="center">$ACC_-TRANSIENT$</td>
<td align="center">$0x0080$</td>
<td align="center">是否为 $transient$</td>
</tr>
<tr>
<td align="center">$ACC_-SYNTHETIC$</td>
<td align="center">$0x1000$</td>
<td align="center">是否为编译器自动产生</td>
</tr>
<tr>
<td align="center">$ACC_-ENUM$</td>
<td align="center">$0x4000$</td>
<td align="center">是否为 $enum$</td>
</tr>
</tbody>
</table>
<p>        接口当中的字段必须有 $ACC_-PUBLIC$ 、$ACC_-STATIC$ 、$ACC_-FINAL$ 标志。<br>
        $name_-index$ 和 $descriptor_-index$ 在标志值之后，是常量池的引用，表示字段简单名称以及字段和方法的描述符。在描述符中，基本数据类型以及 $void$ 使用一个大写字母表示，对象类型使用 $L$ 加全限定名表示。</p>
<table>
<thead>
<tr>
<th align="center">标识字符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$B$</td>
<td align="center">$byte$</td>
</tr>
<tr>
<td align="center">$C$</td>
<td align="center">$char$</td>
</tr>
<tr>
<td align="center">$D$</td>
<td align="center">$double$</td>
</tr>
<tr>
<td align="center">$F$</td>
<td align="center">$float$</td>
</tr>
<tr>
<td align="center">$I$</td>
<td align="center">$int$</td>
</tr>
<tr>
<td align="center">$J$</td>
<td align="center">$long$</td>
</tr>
<tr>
<td align="center">$S$</td>
<td align="center">$short$</td>
</tr>
<tr>
<td align="center">$Z$</td>
<td align="center">$boolean$</td>
</tr>
<tr>
<td align="center">$V$</td>
<td align="center">$void$</td>
</tr>
<tr>
<td align="center">$L$</td>
<td align="center">对象类型</td>
</tr>
</tbody>
</table>
<p>        对于数组类型，每一个维度都会使用一个前置的 $[$ 字符表示，例如 $int[\ ][\ ]$ 会表示为 $[[I$ 。对于方法，会按照参数、返回值的方式描述，参数按照顺序放在 $(\ )$ 之中，例如 $int\ \ indexOf(char[]\ \ source,\ \ int\ \ index)$ 表示为 $([CI)I$ 。<br>
        $descriptor_-index$ 之后是属性表计数器，当字段存在额外信息如值时，计数器会记录字段的额外信息个数，并可以在之后的 $attribute_-info$ 中查询。字段表集合不会列出从父类或者父接口中继承而来的字段，但有可能出现原来<code>Java</code>代码之中不存在的字段，譬如内部类中包含的指向外部类实例的字段。</p>
<h3 id="26-方法表集合">2.6 方法表集合</h3>
<p>        <code>Class</code>文件中对字段和方法的描述采取了几乎一样的方式，同样包括 $access_-flags$、$name_-index$、$descriptor_-index$ 和 $attributes$ 。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">标志值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$ACC_-PUBLIC$</td>
<td align="center">$0x0001$</td>
<td align="center">是否为 $PUBLIC$</td>
</tr>
<tr>
<td align="center">$ACC_-PRIVATE$</td>
<td align="center">$0x0002$</td>
<td align="center">是否为 $PRIVATE$</td>
</tr>
<tr>
<td align="center">$ACC_-PROTECTED$</td>
<td align="center">$0x0004$</td>
<td align="center">是否为 $protected$</td>
</tr>
<tr>
<td align="center">$ACC_-STATIC$</td>
<td align="center">$0x0008$</td>
<td align="center">是否为 $static$</td>
</tr>
<tr>
<td align="center">$ACC_-FINAL$</td>
<td align="center">$0x0010$</td>
<td align="center">是否为 $final$</td>
</tr>
<tr>
<td align="center">$ACC_-SYNCHRONIZED$</td>
<td align="center">$0x0020$</td>
<td align="center">是否为 $synchronized$</td>
</tr>
<tr>
<td align="center">$ACC_-BRIDGE$</td>
<td align="center">$0x0040$</td>
<td align="center">是否为编译器产生的桥接方法</td>
</tr>
<tr>
<td align="center">$ACC_-VARARGS$</td>
<td align="center">$0x0080$</td>
<td align="center">是否接受变长参数</td>
</tr>
<tr>
<td align="center">$ACC_-NATIVE$</td>
<td align="center">$0x0100$</td>
<td align="center">是否为 $native$</td>
</tr>
<tr>
<td align="center">$ACC_-ABSTRACT$</td>
<td align="center">$0x0400$</td>
<td align="center">是否为 $abstract$</td>
</tr>
<tr>
<td align="center">$ACC_-STRICT$</td>
<td align="center">$0x0800$</td>
<td align="center">是否为 $strictfp$</td>
</tr>
<tr>
<td align="center">$ACC_-SYNTHETIC$</td>
<td align="center">$0x1000$</td>
<td align="center">是否由编译器自动产生</td>
</tr>
</tbody>
</table>
<p>        方法块内的<code>Java</code>代码，经由<code>Javac</code>编译后，存放在方法属性表集合中名为 $Code$ 的属性内。<code>Java</code>语言重载要求简单名称相同之外，还要拥有一个与原方法不同的特征签名。特征签名包括方法名称、参数顺序及参数类型。也就是说，仅仅改变返回值并不能算重载。但是<code>Class</code>文件中只要描述符不是完全一致，那么就允许多个方法共存，也即允许除了返回值之外其他都相同的方法共存。</p>
<h3 id="27-属性表集合">2.7 属性表集合</h3>
<p>        <strong>属性表</strong> ( $attribute_-info$ ) 在前面已经出现过，<code>Class</code>文件、字段表、方法表都可以包含一个属性表集合。属性表集合对顺序没有严格要求，而且可以在属性名不重复的前提下写入自定义的属性信息。<code>Java</code>虚拟机在运行时会忽略不认识的属性信息。对于每一个属性，它的名称都要从常量池中引用一个 $CONSTANT_-Utf8_-info$ 类型的常量表示。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u1$</td>
<td align="center">$info$</td>
<td align="center">$attribute_-length$</td>
</tr>
</tbody>
</table>
<p>        属性值的结构是完全自定义的，只需要通过一个 $u4$ 类型的属性说明其占用位数即可。</p>
<h4 id="271-code">2.7.1 <code>Code</code></h4>
<p>        $Code$属性存储方法体内的经过<code>Javac</code>编译后产生的字节码指令。接口方法和抽象方法中不存在该属性。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$max_-stack$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$max_-locals$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$code_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u1$</td>
<td align="center">$code$</td>
<td align="center">$code_-length$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$exception_-table_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$exception_-info$</td>
<td align="center">$exception_-table$</td>
<td align="center">$exception_-table_-length$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$attributes_-count$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$attribute_-info$</td>
<td align="center">$attributes$</td>
<td align="center">$attributes_-count$</td>
</tr>
</tbody>
</table>
<p>        $attribute_-name_-index$ 指向 $CONSTANT_-Utf8_-info$ ，固定为 $Code$ 。$attribute_-length$ 表示属性值长度，固定为属性长度减去本身以及上一个属性的长度即 $6$ 个字节。$max_-stack$ 为<b>操作数栈</b> ( $Operand\ \ Stack$ ) 深度的最大值，虚拟机根据这个值分配<b>栈帧</b> ( $Stack\ \ Frame$ ) 中的操作栈深度。$max_-locals$ 表示局部变量所需的空间，单位为<b>变量槽</b> ( $Slot$ )，即虚拟机为局部变量分配内存的最小单位。对于 $32$ 位的数据类型，会使用一个槽；而对于 $64$ 位的数据类型 $double$ 和 $long$ ，则会使用两个槽。方法参数（包括实例方法中的隐藏参数 $this$ ）、异常处理参数、局部变量都要依赖于局部变量表，<code>Javac</code>编译器会根据每个变量的生命周期和类型计算出 $max_-locals$ 的大小。$code_-length$ 和 $code$ 存储字节码指令，每个指令使用 $u1$ 类型的数据大小存储。<br>
        如果方法中存在异常处理块的话，那么异常处理表会跟在字节码指令之后。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$start_-pc$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$end_-pc$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$handler_-pc$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$catch_-type$</td>
<td align="center">$1$</td>
</tr>
</tbody>
</table>
<p>        $start_-pc$ 和 $end_-pc$ 表示出现异常的代码行，$handler_-pc$ 为处理异常的行，当 $catch_-type$ 为 $0$ 时，任何异常都要跳转到 $handler_-pc$ 进行处理。</p>
<h4 id="272-exceptions">2.7.2 <code>Exceptions</code></h4>
<p>        $Exceptions$ 属性列举出方法中可能抛出的<strong>受查异常</strong> ( $Checked\ \ Exceptions$ )，也就是方法声明时在 $throws$ 关键字后面列举的异常。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$number_-of_-exceptions$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$exception_-index_-table$</td>
<td align="center">$number_-of_-exceptions$</td>
</tr>
</tbody>
</table>
<p>        $number_-of_-exceptions$ 表示可能抛出的 $number_-of_-exceptions$ 种异常，每种异常使用一个 $exception_-index_-table$ 表示，指向 $CONSTANT_-Class_-info$ 型常量的索引，代表异常类型。</p>
<h4 id="273-linenumbertable">2.7.3 <code>LineNumberTable</code></h4>
<p>        $LineNumberTable$ 用于描述<code>Java</code>源码行号与字节码行号之间的对应关系，并非运行时的必须属性，可以在<code>Javac</code>中使用 $-g:none$ 或者 $-g:lines$ 来取消或者强制生成该信息。如果取消生成，那么当程序抛出异常时，不会显示出错的行号，并且在调试时也无法在源码处设置断点。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$line_-number_-table_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$line_-number_-info$</td>
<td align="center">$line_-number_-table$</td>
<td align="center">$line_-number_-table_-length$</td>
</tr>
</tbody>
</table>
<p>        $line_-number_-table$ 是一个数量为 $line_-number_-table_-length$ ，类型为 $line_-number_-info$ 的集合。$line_-number_-info$ 包含 $start_pc$ 和 $line_-number$ 两个 $u2$ 类型的数据，前者为字节码行号，后者为源码行号。</p>
<h4 id="274-localvariabletable和localvariabletypetable">2.7.4 <code>LocalVariableTable</code>和<code>LocalVariableTypeTable</code></h4>
<p>        $LocalVariableTable$ 描述栈帧中局部变量表与<code>Java</code>源码中变量的关系，同样并非运行时的必须属性，可以在<code>Javac</code>中使用 $-g:none$ 或者 $-g:vars$ 来取消或者强制生成该信息。如果取消生成，那么当其他人引用该方法时，所有参数名称都会丢失，<code>IDE</code>会使用譬如 $arg0$ 这样的占位符代替参数名。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$local_-variable_-table_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$local_-variable_-info$</td>
<td align="center">$local_-variable_-table$</td>
<td align="center">$local_-variable_-table_-length$</td>
</tr>
</tbody>
</table>
<p>        其中 $local_-variable_-info$ 的结构如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$start_-pc$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$descriptor_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$index$</td>
<td align="center">$1$</td>
</tr>
</tbody>
</table>
<p>        $start_-pc$ 和 $length$ 分别代表局部变量生命周期开始的字节码行数以及作用域长度；$name_-index$ 和 $descriptor_-index$ 指向 $CONSTANT_-Utf8_-info$ 类型的常量，分别代表局部变量的名称以及描述符；$index$ 存储局部变量在栈帧的局部变量表中变量槽的起始位置。<br>
        $LocalVariableTypeTable$ 类似于 $LocalVariableTable$ ，但是将 $descriptor_-index$ 替换为<b>特征签名</b> ( $Signature$ )。对于非泛型类来说，描述符和特征签名相同。但是对于泛型类，由于擦除的存在，需要特征签名来对泛型进行描述。</p>
<h4 id="275-sourcefile和sourcedebugextension">2.7.5 <code>SourceFile</code>和<code>SourceDebugExtension</code></h4>
<p>        $SourceFile$ 用于记录生成<code>Class</code>文件的源码文件名称，同样是可选的，可以在<code>Javac</code>中使用 $-g:none$ 或者 $-g:source$ 来取消或者强制生成信息。对于大多数类来说，类名和文件名一致，但是对于特殊情况如内部类，如果取消生成，那么在抛出异常时不会显示出错代码所在的文件名。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$sourcefile_-index$</td>
<td align="center">$1$</td>
</tr>
</tbody>
</table>
<p>        $sourcefile_-index$ 指向 $CONSTANT_-Utf8_-info$ 类型的常量索引，常量值为源码文件的文件名。<br>
        <code>JDK 5</code>中加入的 $SourceDebugExtension$ 属性存储额外的代码调试信息，为非<code>Java</code>语言编写的，但需要编译成字节码在虚拟机中运行的程序，比如<code>JSP</code>等，提供了一个进行调试的标准机制。通过<code>SourceDebugExtension</code>，可以快速从异常堆栈中定位出<code>JSP</code>中出现问题的行号。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u1$</td>
<td align="center">$debug_-extension[attribute_-length]$</td>
<td align="center">$1$</td>
</tr>
</tbody>
</table>
<p>        $debug_-extension$ 存储的就是额外的调试信息，通过一组变长的<code>UTF-8</code>格式的字符串。一个类最多只允许一个 $SourceDebugExtension$ 属性。</p>
<h4 id="276-constantvalue">2.7.6 <code>ConstantValue</code></h4>
<p>        $ConstantValue$ 用于通知虚拟机自动为静态变量赋值，只有静态变量才能使用该属性。对于非静态变量，会在实例构造器 &lt;$init$&gt;$(\ )$ 方法中赋值；而静态变量可以通过类构造器 &lt;$clinit$&gt;$(\ )$ 或者 $ConstantValue$ 进行赋值。<code>Javac</code>编译器会根据变量是否为 $final$ 以及变量类型来决定是否生成 $ConstantValue$ ：如果为 $final$ 并且类型为基本类型或者 $String$ ，则生成。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$constantvalue_-index$</td>
<td align="center">$1$</td>
</tr>
</tbody>
</table>
<p>        $constantvalue_-index$ 指向常量池中一个字面量常量的引用，可以是 $CONSTANT_-Long_-info$ 、$CONSTANT_-Integer_-info$ 等。</p>
<h4 id="277-innerclasses">2.7.7 <code>InnerClasses</code></h4>
<p>        $InnerClasses$ 用于记录内部类与宿主类之间的关联。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$number_-of_-classes$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$inner_-classes_-info$</td>
<td align="center">$inner_-class$</td>
<td align="center">$number_-of_-classes$</td>
</tr>
</tbody>
</table>
<p>        $inner_-classes_-info$ 的结构如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$inner_-class_-info_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$outer_-class_-info_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$inner_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$inner_-class_-access_flags$</td>
<td align="center">$1$</td>
</tr>
</tbody>
</table>
<p>        $inner_-class_-info_-index$ 和 $outer_-class_-info_-index$ 都指向 $CONSTANT_-Class_-info$ 类型的常量的索引，分别为内部类和宿主类的符号引用。$inner_-name_-index$ 指向 $CONSTANT_-Utf8_-info$ 类型的常量的索引，表示内部类的名称 (匿名内部类值为 $0$ )。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">标志值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$ACC_-PUBLIC$</td>
<td align="center">$0x0001$</td>
<td align="center">是否为 $public$</td>
</tr>
<tr>
<td align="center">$ACC_-PRIVATE$</td>
<td align="center">$0x0002$</td>
<td align="center">是否为 $private$</td>
</tr>
<tr>
<td align="center">$ACC_-PROTECTED$</td>
<td align="center">$0x0004$</td>
<td align="center">是否为 $protected$</td>
</tr>
<tr>
<td align="center">$ACC_-STATIC$</td>
<td align="center">$0x0008$</td>
<td align="center">是否为 $static$</td>
</tr>
<tr>
<td align="center">$ACC_-FINAL$</td>
<td align="center">$0x0010$</td>
<td align="center">是否为 $final$</td>
</tr>
<tr>
<td align="center">$ACC_-INTERFACE$</td>
<td align="center">$0x0020$</td>
<td align="center">是否为接口</td>
</tr>
<tr>
<td align="center">$ACC_-ABSTRACT$</td>
<td align="center">$0x0400$</td>
<td align="center">是否为抽象类</td>
</tr>
<tr>
<td align="center">$ACC_-SYNTHETIC$</td>
<td align="center">$0x1000$</td>
<td align="center">是否为编译器自动生成</td>
</tr>
<tr>
<td align="center">$ACC_-ANNOTATION$</td>
<td align="center">$0x2000$</td>
<td align="center">是否为注解</td>
</tr>
<tr>
<td align="center">$ACC_-ENUM$</td>
<td align="center">$0x4000$</td>
<td align="center">是否为枚举</td>
</tr>
</tbody>
</table>
<h4 id="278-deprecated和synthetic">2.7.8 <code>Deprecated</code>和<code>Synthetic</code></h4>
<p>        $Deprecated$ 和 $Synthetic$ 都是布尔值，分别表示是否废弃和是否由编译器自动产生。后者也可以通过设置标志位 $ACC_-SYNTHETIC$ 代替。当它们存在时，即代表为真。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
</tbody>
</table>
<p>        其中 $attribute_-length$ 的值恒为 $0x00000000$ 。</p>
<h4 id="279-stackmaptable">2.7.9 <code>StackMapTable</code></h4>
<p>        $StackMapTable$ 在<code>JDK 6</code>之后加入<code>Class</code>文件结构中，位于 $Code$ 属性的属性表中，在虚拟机类加载的字节码验证阶段被<em><strong>新类型检查验证器</strong></em> ( $Type\ \ Checker$ ) 使用。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$number_-of_-entries$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$stack_-map_-frame$</td>
<td align="center">$stack_-map_-frame_-entries$</td>
<td align="center">$number_-of_-entries$</td>
</tr>
</tbody>
</table>
<p>        <code>JDK 7</code>后，如果 $Code$ 中没有 $StackMapTable$ ，那么他就具有一个隐式的 $StackMapTable$ 属性，$number_-of_-entries$ 值为 $0$ 。</p>
<h4 id="2710-signature">2.7.10 <code>Signature</code></h4>
<p>        $Signature$ 是一个可选的定长属性，可以出现在类、字段表和方法表结构的属性表中，记录泛型签名信息。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$signature_-index$</td>
<td align="center">$1$</td>
</tr>
</tbody>
</table>
<p>        $signature_-index$ 指向 $CONSTANT_-Utf8_-info$ 类型的常量的索引，表示类签名或者方法类型或者字段类型签名。</p>
<h4 id="2711-bootstrapmethod">2.7.11 <code>BootstrapMethod</code></h4>
<p>        $BootstrapMethod$ 在<code>JDK 7</code>之后添加到<code>Class</code>文件结构中，存储 $invokedynamic$ 指令引用的引导方法限定符。如果某个<code>Class</code>文件常量池中出现过 $CONSTANT_-InvokeDynamic_-info$ 类型的常量，那么这个文件属性表中必须存在一个 $BootstrapMethod$ 属性，且最多只能有一个。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$num_-bootstrap_-methods$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$bootstrap_-method$</td>
<td align="center">$bootstrap_-methods$</td>
<td align="center">$num_-bootstrap_-methods$</td>
</tr>
</tbody>
</table>
<p>        $bootstrap_-method$ 结构如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$bootstrap_-method_-ref$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$num_-bootstrap_-arguments$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$bootstrap_-arguments$</td>
<td align="center">$num_-bootstrap_-arguments$</td>
</tr>
</tbody>
</table>
<p>        $bootstrap_-method_-ref$ 指向 $CONSTANT_-MethodHandle$ 结构的索引值，代表一个引导方法。</p>
<h4 id="2712-methodparameters">2.7.12 <code>MethodParameters</code></h4>
<p>        $MethodParameters$ 在<code>JDK 8</code>之后加入到<code>Class</code>文件结构中，用于记录变长参数中各个形参的名称和信息。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u1$</td>
<td align="center">$parameters_-count$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$parameter$</td>
<td align="center">$parameters$</td>
<td align="center">$parameters_-count$</td>
</tr>
</tbody>
</table>
<p>        其中 $parameter$ 结构如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$access_-flags$</td>
<td align="center">$1$</td>
</tr>
</tbody>
</table>
<p>        $name_-index$ 指向 $CONSTANT_-Utf8_-info$ 类型的常量的索引，表示参数名称。$access_-flags$ 是参数的状态指示器。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">标志值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$ACC_-FINAL$</td>
<td align="center">$0x0010$</td>
<td align="center">参数被 $final$ 修饰</td>
</tr>
<tr>
<td align="center">$ACC_-SYNTHETIC$</td>
<td align="center">$0x1000$</td>
<td align="center">参数是编译器自动生成的</td>
</tr>
<tr>
<td align="center">$ACC_-MANDATED$</td>
<td align="center">$0x8000$</td>
<td align="center">参数是在源文件中隐式定义的（如 $this$ ）</td>
</tr>
</tbody>
</table>
<h4 id="2713-模块化相关属性">2.7.13 模块化相关属性</h4>
<p>        <code>JDK 9</code>中添加了<code>Java</code>的模块化功能，因为模块描述文件 ( $module_-info.java$ ) 最终要编译为<code>Class</code>文件，所以<code>Class</code>文件结构中添加了 $Module$ 、$ModulePackages$ 和 $ModuleMainClass$ 三个属性。<br>
        $Module$ 属性是一个复杂的变长属性。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$module_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$module_-flags$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$module_-version_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$requires_-count$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$require$</td>
<td align="center">$requires$</td>
<td align="center">$requires_-count$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$exports_-count$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$export$</td>
<td align="center">$exports$</td>
<td align="center">$exports_-count$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$opens_-count$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$open$</td>
<td align="center">$opens$</td>
<td align="center">$opens_-count$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$uses_-count$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$use$</td>
<td align="center">$uses_-index$</td>
<td align="center">$uses_-count$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$provides_-count$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$provide$</td>
<td align="center">$provides$</td>
<td align="center">$provides_-count$</td>
</tr>
</tbody>
</table>
<p>        $module_-flags$ 是模块状态指示器。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">标志值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$ACC_-OPEN$</td>
<td align="center">$0x0020$</td>
<td align="center">模块开放</td>
</tr>
<tr>
<td align="center">$ACC_-SYNTHETIC$</td>
<td align="center">$0x1000$</td>
<td align="center">模块是编译器自动生成的</td>
</tr>
<tr>
<td align="center">$ACC_-MANDATED$</td>
<td align="center">$0x8000$</td>
<td align="center">模块是在源文件中隐式定义的</td>
</tr>
</tbody>
</table>
<p>        $module_-versions_-index$ 指向 $CONSTANT_-Utf8_-info$ 类型的常量的索引，表示模块版本号。<br>
        $ModulePackages$ 用于描述模块中所有的包。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$package_-count$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$package_-index$</td>
<td align="center">$package_-count$</td>
</tr>
</tbody>
</table>
<p>        $package_-index$ 指向 $CONSTANT_-Package_-info$ 类型的常量的索引，代表模块中的一个包。<br>
        $ModuleMainClass$ 用于确定模块的主类。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$main_-class_-index$</td>
<td align="center">$1$</td>
</tr>
</tbody>
</table>
<p>        $main_-class_-index$ 指向 $CONSTANT_-Class_-info$ 类型的常量的索引，代表模块的主类。</p>
<h4 id="2714-运行时注解相关属性">2.7.14 运行时注解相关属性</h4>
<p>        <code>Class</code>文件在<code>JDK 5</code>之后增加了 $RuntimeVisibleAnnotation$ 、$RuntimeInvisibleAnnotation$ 、$RuntimeVisibleParameterAnnotations$ 和 $RuntimeInvisibleParameterAnnotations$ 四个属性，用于支持注解。<code>JDK 8</code>之后，又添加了 $RuntimeVisibleTypeAnnotations$ 和 $RuntimeInvisibleTypeAnnotations$ 两个属性。<br>
        $RuntimeVisibleAnnotations$ 记录了类、字段或方法声明上的运行时可见注解，可以通过反射获取这个属性。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$attribute_-name_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u4$</td>
<td align="center">$attribute_-length$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$num_-annotations$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$annotation$</td>
<td align="center">$annotations$</td>
<td align="center">$num_-annotations$</td>
</tr>
</tbody>
</table>
<p>        其中 $annotation$ 的结构如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$u2$</td>
<td align="center">$Type_-index$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$u2$</td>
<td align="center">$num_-element_-value_-pairs$</td>
<td align="center">$1$</td>
</tr>
<tr>
<td align="center">$element_-value_-pair$</td>
<td align="center">$element_-value_-pairs$</td>
<td align="center">$num_-element_-value_-pairs$</td>
</tr>
</tbody>
</table>
<p>        $Type_-index$ 指向 $CONSTANT_-Utf8_-info$ 类型的常量的索引，以字段描述符的形式表示一个注解；$element_-value_-pair$ 以键值对的形式表示注解的参数和值。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Sep 17 22:58</span> <a href="/post/jvm4class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>