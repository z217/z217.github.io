<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.82.1" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src=https://z217blog.cn/js/jquery-3.4.1.min.js></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="https://www.cnblogs.com/meidaoli/"  target="_blank" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">HashMap源码解读</a>
        
        
        <p>HashMap源码解读</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Aug 23 15:01
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">I/O多路复用</a>
        
        
        <p>操作系统I/O多路复用介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Aug 22 15:30
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: OS
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/">缓存一致性协议MESI</a>
        
        
        <p>缓存一致性协议MESI介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Aug 16 11:02
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: OS
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/mysql%E7%AC%94%E8%AE%B0/">MySQL笔记</a>
        
        
        <p>MySQL笔记</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 Jun 21 20:33
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: DBS
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/csapp%E7%AC%94%E8%AE%B0/">CSAPP笔记</a>
        
        
        <p>CSAPP阅读笔记，一些操作系统中有的就不记了</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2021 May 19 15:06
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: OS
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">HashMap源码解读</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-字段">1. 字段</h2>
<p>        字段设置为 $transient$ ，因为 $HashMap$ 通过 $Object.hashCode(\ )$ 获取哈希值，并通过哈希值与桶个数取模确定对象。$Object.hashCode(\ )$ 是一个本地方法，依赖于<code>JVM</code>实现，存在跨平台问题，所有 $HashMap$ 在序列化时会先保存所有 $Key$ ，再在反序列化时重新插入。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 最大容量
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">30</span><span class="o">;</span>

<span class="c1">// 默认负载因子，大小/容量超过这个比例就会扩容
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">float</span> <span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="n">0</span><span class="o">.</span><span class="na">75f</span><span class="o">;</span>

<span class="c1">// 当桶中节点数不小于该值时树化
</span><span class="c1">// 树节点大小是常规节点两倍，应该在有足够的节点后树化
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="n">8</span><span class="o">;</span>

<span class="c1">// 当桶中节点数小于该值时链表化
</span><span class="c1">// 不设为TREEIFY_THRESHOLD，避免抖动
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">UNTREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="n">6</span><span class="o">;</span>

<span class="c1">// 当容量不小于该值时才会树化，否则会优先扩容
</span><span class="c1">// 应当至少为 4 * TREEIFY_THRESHOLD
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MIN_TREEIFY_CAPACITY</span> <span class="o">=</span> <span class="n">64</span><span class="o">;</span>

<span class="c1">// 初次使用时初始化，长度为 2 的幂次
</span><span class="c1"></span><span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>

<span class="c1">// entrySet() 缓存
</span><span class="c1"></span><span class="kd">transient</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;&gt;</span> <span class="n">entrySet</span><span class="o">;</span>

<span class="c1">// 改变次数，每次修改都会增加
</span><span class="c1"></span><span class="kd">transient</span> <span class="kt">int</span> <span class="n">modCount</span><span class="o">;</span>
</code></pre></div><h2 id="2-构造函数">2. 构造函数</h2>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal initial capacity: &#34;</span> <span class="o">+</span>
                                            <span class="n">initialCapacity</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span>
        <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="o">||</span> <span class="n">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal load factor: &#34;</span> <span class="o">+</span>
                                            <span class="n">loadFactor</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="o">;</span>
    <span class="c1">// tableSizeFor会获得不小于当前数字的最小的2的幂次
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">;</span> <span class="c1">// all other fields defaulted
</span><span class="c1"></span><span class="o">}</span>

<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">;</span>
    <span class="n">putMapEntries</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/** 计算大于等于输入参数的最小的 2 的幂次 */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">tableSizeFor</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">1</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">2</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">4</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">8</span><span class="o">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">16</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">1</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">:</span> <span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h2 id="3-内部类">3. 内部类</h2>
<div class="highlight"><pre class="chroma"><code class="language-Java" data-lang="Java"><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>
    <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span>
    <span class="n">V</span> <span class="n">value</span><span class="o">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">^</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="4-插入">4. 插入</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 高低16位异或
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">h</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">())</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">16</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span> <span class="o">}</span>

<span class="c1">// @param onlyIfAbsent 如果为true，则不会改变已存在的value
</span><span class="c1">// @param evict        如果为false，说明处于构造模式
</span><span class="c1"></span><span class="kd">final</span> <span class="n">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
        <span class="c1">// 表为空，创建表
</span><span class="c1"></span>        <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="c1">// 对应位置为空，直接创建节点
</span><span class="c1"></span>        <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="c1">// 碰撞处理
</span><span class="c1"></span>    <span class="k">else</span> <span class="o">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span> <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
            <span class="c1">// 节点key相同
</span><span class="c1"></span>            <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
            <span class="c1">// 树状节点，向树中插入
</span><span class="c1"></span>            <span class="n">e</span> <span class="o">=</span> <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 尾插法
</span><span class="c1"></span>                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="c1">// -1 for 1st
</span><span class="c1"></span>                        <span class="c1">// 超过阈值，树化
</span><span class="c1"></span>                        <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                    <span class="c1">// 节点key相同
</span><span class="c1"></span>                    <span class="k">break</span><span class="o">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// existing mapping for key
</span><span class="c1"></span>            <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="c1">// 更新值
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="c1">// 超过阈值，扩容
</span><span class="c1"></span>        <span class="n">resize</span><span class="o">();</span>
    <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 扩容方法
</span><span class="c1"></span><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="nf">resize</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">oldCap</span> <span class="o">=</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">oldTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">oldThr</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">newCap</span><span class="o">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">oldTab</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">newCap</span> <span class="o">=</span> <span class="n">oldCap</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span>
                    <span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">)</span>
            <span class="c1">// 两倍扩容
</span><span class="c1"></span>            <span class="n">newThr</span> <span class="o">=</span> <span class="n">oldThr</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">;</span> <span class="c1">// double threshold
</span><span class="c1"></span>    <span class="o">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">oldThr</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// initial capacity was placed in threshold
</span><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">oldThr</span><span class="o">;</span>
    <span class="k">else</span> <span class="o">{</span>               <span class="c1">// zero initial threshold signifies using defaults
</span><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span>
        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">newThr</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">newCap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">;</span>
        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">MAXIMUM_CAPACITY</span> <span class="o">?</span>
                    <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">ft</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 设置新阈值并创建新表
</span><span class="c1"></span>    <span class="n">threshold</span> <span class="o">=</span> <span class="n">newThr</span><span class="o">;</span>
    <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">&#34;rawtypes&#34;</span><span class="o">,</span><span class="s">&#34;unchecked&#34;</span><span class="o">})</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">newCap</span><span class="o">];</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 迁移节点
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldCap</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="c1">// 没有碰撞
</span><span class="c1"></span>                    <span class="n">newTab</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">-</span> <span class="n">1</span><span class="o">)]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
                    <span class="c1">// 树分裂，这一步会判断是否链表化
</span><span class="c1"></span>                    <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">e</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">newTab</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">oldCap</span><span class="o">);</span>
                <span class="k">else</span> <span class="o">{</span> <span class="c1">// preserve order
</span><span class="c1"></span>                    <span class="c1">// 链表分裂
</span><span class="c1"></span>                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
                    <span class="k">do</span> <span class="o">{</span>
                        <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">oldCap</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                                <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="k">else</span>
                                <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="k">else</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                                <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="k">else</span>
                                <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">oldCap</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">newTab</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h2 id="5-删除">5. 删除</h2>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">V</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span>
        <span class="kc">null</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// @param value      值
</span><span class="c1">// @param matchValue true表示只有value相同时才会移除
</span><span class="c1">// @param movable    false则移除时不会移动其他节点
</span><span class="c1"></span><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">removeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">,</span>
                            <span class="kt">boolean</span> <span class="n">matchValue</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">movable</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">index</span><span class="o">;</span>
    <span class="c1">// 表存在、节点存在
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
        <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">e</span><span class="o">;</span> <span class="n">K</span> <span class="n">k</span><span class="o">;</span> <span class="n">V</span> <span class="n">v</span><span class="o">;</span>
        <span class="c1">// 查找节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
                <span class="n">node</span> <span class="o">=</span> <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                        <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span>
                            <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span> <span class="o">{</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 找到对应节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">matchValue</span> <span class="o">||</span> <span class="o">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">==</span> <span class="n">value</span> <span class="o">||</span>
                                <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">v</span><span class="o">))))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
                <span class="c1">// 树移除节点，这一步如果红黑树太小会链表化
</span><span class="c1"></span>                <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">node</span><span class="o">).</span><span class="na">removeTreeNode</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">movable</span><span class="o">);</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span>
                <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
            <span class="o">--</span><span class="n">size</span><span class="o">;</span>
            <span class="n">afterNodeRemoval</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h2 id="6-区别">6. 区别</h2>
<ol>
<li><code>JDK1.7</code>使用头插法，<code>JDK1.8</code>使用尾插法，避免多线程同时扩容时的死循环；</li>
<li><code>JDK1.7</code>是先扩容后插入的，<code>JDK1.8</code>反过来，避免无效扩容；</li>
<li><code>JDK1.7</code>只有数组+链表，<code>JDK1.8</code>引入红黑树；</li>
</ol>

            </div>
            <div class="meta post-footer"> <span>2021 Aug 23 15:01</span> <a href="/post/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">I/O多路复用</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-基本概念">1. 基本概念</h2>
<p>        操作系统<strong>内核</strong> ( $kernel$ ) 是操作系统的核心，独立于普通应用程序，可以访问受保护的内存空间，也有权访问所有底层硬件设备。为了保证用户进程不能直接操作内核，操作系统将内存空间划为两部分，内核空间和用户空间。对于<code>linux</code>系统，如果是 $32$ 位系统，虚拟内存中最高的 $1G$ 字节 ( $0xC0000000 \sim 0xFFFFFFFF$ ) 为内核空间；如果是 $64$ 位系统，指针的前 $16$ 位保留，从而只有 $48$ 位寻址空间，于是最高的 $128T$ 字节 ( $0x0000000000000000 \sim 0x00007FFFFFFFF000$ ) 作为系统空间，中间部分 ( $0x00007FFFFFFFFFFF \sim 0xFFFF800000000000$ ) 作为保留，其余部分为用户空间。<br>
        正在执行的进程由于某些期待的事件未发生，如资源请求失败或者等待某些操作完成等，会自动执行阻塞原语，使自己由运行态变为阻塞态。进程的阻塞是一种主动行为，只有处于运行态的进程才可以触发，并且阻塞后不占用<code>CPU</code>资源。<br>
        文件描述符 ( $fd$ ) 是一个指向文件引用的概念，在形式上是一个非负整数，实际上是一个索引值，指向内核打开文件表中的对应记录。打开文件表中记录了文件的属性，包括磁盘位置、访问权限、文件位置指针以及打开计数。<br>
        缓存<code>I/O</code>又称为标准<code>I/O</code>，大多数文件系统的默认<code>I/O</code>操作都是缓存<code>I/O</code>。在<code>Linux</code>中，操作系统会将<code>I/O</code>数据缓存在文件系统的 $Page\ \ Cache$ 中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。<br>
        在<code>BIO</code>模式下，当线程接收一个请求后，在等待<code>I/O</code>的时间内，调用会被阻塞，无法接受其他请求。在多线程环境下，如果想要接受大量请求，就需要创建大量线程，占用大量系统空间，并且线程切换会带来很大的开销。$10000$ 个线程真正发生读写的实际的线程数不会超过 $20\%$ 。<br>
        在<code>NIO</code>模式下，当线程接收一个请求后，会加入 $fd_-set$ 集合，每次轮询集合接收数据，如果没有数据会返回错误。每次都要轮询所有集合，包括未发生实际读写的 $fd$ ，会浪费<code>CPU</code>资源。<br>
        在<code>I/O</code>多路复用模式下，服务端通过 $select$ / $poll$ / $epoll$ 等系统调用获取 $fd$ 列表，遍历有事件的 $fd$ 进行数据接收，可以支持更多并发连接请求。</p>
<ul>
<li><code>I/O</code>多路复用是一种同步<code>I/O</code>模型，多路指网络连接，复用指一个线程，即一个线程可以监视多个文件句柄；</li>
<li>一旦某个文件句柄就绪，就可以通知应用程序进行相应的读写操作；</li>
<li>没有文件句柄就会阻塞线程。</li>
</ul>
<h2 id="2-select">2. <code>select</code></h2>
<p>        $select$ 是仅仅知道了有<code>I/O</code>事件发生，但是无法确定是哪几个流 ( 一个或多个，甚至全部 )，只能无差别的轮询所有流，直到找出所有能读出或写入数据的流，具有 $O(n)$ 的无差别轮询复杂度。</p>
<ol>
<li>使用 $copy_-from_-user$ 从用户空间拷贝 $fd_-set$ 到内核空间；</li>
<li>注册回调函数 $\_\_pollwait$ ，负责将当前进程挂载到设备的等待队列中，在设备收到一条消息或者完成磁盘写入后，会唤醒等待队列上等待的进程；</li>
<li>遍历所有 $fd$ ，调用其对应的 $poll$ 方法，$poll$ 方法的核心就是 $\_\_pollwait$ ，返回一个描述读写操作是否完成的 $mask$ ，根据这个 $mask$ 给 $fd\_set$ 赋值；</li>
<li>如果遍历完所有的 $fd$ 还没有返回一个可读写的 $mask$ ，调用 $schedule_-timeout$ 使调用 $select$ 的进程睡眠；</li>
<li>设备驱动发现自身资源可读写后，唤醒等待队列上的进程。如果超过了 $schedule_-timeout$ 设定的时间，调用 $select$ 的进程会被重新唤醒，重新开始遍历；</li>
<li>把 $fd_-set$ 从内核空间拷贝回用户空间。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// fd_set为数组，通过FD_SETSIZE定义
</span><span class="c1">// readfds、writefds和exceptfds分别对应读、写和异常条件fd
</span><span class="c1">// timeout为超时时间，select会一直阻塞到有事件到达或者等待时间超过timeout
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</code></pre></div><p>        $select$ 本质上是通过设置或者检查存放 $fd$ 标志位的数据结构来进行下一步处理，缺点是：</p>
<ul>
<li>单个进程打开的 $fd$ 是有上限的，通过 $FD_-SETSIZE$ 设置，默认为 $1024$ ；</li>
<li>每次调用 $select$ 都需要把 $fd$ 集合从用户空间拷贝到内核空间；</li>
<li>采用轮询方式进行线性扫描，效率较低。</li>
</ul>
<h2 id="4-poll">4. <code>poll</code></h2>
<p>        $poll$ 本质和 $select$ 一样，也是将 $fd$ 拷贝到内核空间并轮询设备状态，但是没有最大连接数的限制。与 $select$ 的不同之处在于：</p>
<ul>
<li>$select$ 会修改 $fd$ ，$poll$ 不会；</li>
<li>$select$ 的 $fds$ 使用标志位，有数量限制；$poll$ 没有数量限制；</li>
<li>$select$ 会检测每个<code>bit</code>位，无论有没有 $fd$ ；$poll$ 检测数组，效率更高；</li>
<li>$poll$ 提供了更多的事件类型，对 $fd$ 的重复利用比 $select$ 高；</li>
<li>如果一个线程对某个 $fd$ 调用了 $select$ 或者 $poll$ ，另一个线程关闭了该 $fd$ ，会导致结果不确定。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">pollfd</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

    <span class="c1">// 期待事件
</span><span class="c1"></span>    <span class="kt">short</span> <span class="n">events</span><span class="p">;</span>

    <span class="c1">// 监听到的事件
</span><span class="c1"></span>    <span class="kt">short</span> <span class="n">revents</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre></div><p>        缺点是：</p>
<ul>
<li>每次调用都需要把 $fd$ 集合从用户空间拷贝到内核空间；</li>
<li>采用轮询方式进行线性扫描，效率较低。</li>
</ul>
<h2 id="5-epoll">5. <code>epoll</code></h2>
<p>        $epoll$ 可以理解为 $event\ \ poll$ ，不同于忙轮询和无差别轮询，每个流发生了怎样的<code>I/O</code>事件都会通知 $epoll$ ，也就是说 $epoll$ 是事件驱动的，从而将复杂度降低到了 $O(1)$ 。<br>
        当进程调用 $epoll_-create$ 时，<code>Linux</code>内核会创建 $eventpoll$ 结构体，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 每个epoll对象都有一个独立的eventpoll结构体
</span><span class="c1"></span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="p">{</span>
    <span class="c1">// 红黑树根节点，存储所有事件
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">rbr</span><span class="p">;</span>

    <span class="c1">// 双链表存储发生事件
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdlist</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 创建epoll对象
</span><span class="c1"></span><span class="kt">int</span> <span class="n">epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

<span class="c1">// 添加/删除事件
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

<span class="c1">// 检查事件集合，没有可读流则阻塞进程
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>

<span class="c1">// 事件结构
</span><span class="c1"></span><span class="k">struct</span> <span class="n">epitem</span> <span class="p">{</span>
    <span class="c1">// 红黑树节点
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rbn</span><span class="p">;</span>

    <span class="c1">// 双向链表节点
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdllink</span><span class="p">;</span>

    <span class="c1">// 事件句柄
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="n">ffd</span><span class="p">;</span>

    <span class="c1">// 所属eventpoll对象
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

    <span class="c1">// 期待发生的事件类型
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        通过 $epoll_-ctl$ 向 $eventpoll$ 对象中添加的事件都会存储在红黑树中，红黑树的高效性保证了重复事件可以被快速识别出来。所有添加到了 $epoll$ 的事件都会与设备 ( 网卡 ) 驱动程序建立回调关系，当相应事件发生时就会回调 $ep_-poll_-callback$ ，将发生的事件添加到双链表中。$epoll_-wait$ 检查是否有事件发生，即链表是否存在节点，如果存在，则复制回用户空间，并返回事件数量。<br>
        $epoll$ 的优点有：</p>
<ul>
<li>不限制并发连接上限 ( $1G$ 内存上能监听 $10$ 万个端口 )；</li>
<li>非轮询，效率高；</li>
<li>利用 $mmap(\ )$ 的将内核空间的一段区域映射到用户空间，只有第一次调用 $epoll_-ctl$ 时需要拷贝。</li>
</ul>
<p>        $epoll$ 有 $EPOLLLT$ 和 $EPOLLET$ 两种触发模式，$LT$ ( $level-triggered$ ) 是默认模式，$ET$ ( $edge-triggered$ ) 是高速模式。</p>
<ul>
<li>$LT$ ：只要 $fd$ 还有数据可读，每次 $epoll_-wait$ 都会返回该事件，即每次触发；</li>
<li>$ET$ ：每个 $fd$ 只会返回一次事件，直到下次有数据流入，即数据到来触发。</li>
</ul>
<h2 id="6-应用场景">6. 应用场景</h2>
<h3 id="61-对比">6.1 对比</h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$select$</th>
<th style="text-align:center">$poll$</th>
<th style="text-align:center">$epoll$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方式</td>
<td style="text-align:center">轮询</td>
<td style="text-align:center">轮询</td>
<td style="text-align:center">回调</td>
</tr>
<tr>
<td style="text-align:center">数据结构</td>
<td style="text-align:center">$bitmap$</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">红黑树</td>
</tr>
<tr>
<td style="text-align:center">最大连接数</td>
<td style="text-align:center">$1024$ ( $x86$ )/ $2048$ ( $x64$ )</td>
<td style="text-align:center">无上限</td>
<td style="text-align:center">无上限</td>
</tr>
<tr>
<td style="text-align:center">拷贝</td>
<td style="text-align:center">每次调用都需要进行拷贝</td>
<td style="text-align:center">每次调用都需要进行拷贝</td>
<td style="text-align:center">内核空间和用户空间共享一块内存</td>
</tr>
<tr>
<td style="text-align:center">工作模式</td>
<td style="text-align:center">$LT$</td>
<td style="text-align:center">$LT$</td>
<td style="text-align:center">$LT$ / $ET$</td>
</tr>
<tr>
<td style="text-align:center">复杂度</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(1)$</td>
</tr>
</tbody>
</table>
<ul>
<li>$select$ 应用场景
<ul>
<li>$timeout$ 参数精度为微妙，$poll$ 和 $epoll$ 为毫秒，更适用于对实时性要求高的场景；</li>
<li>几乎所有主流平台都支持 $select$ ，移植性更好；</li>
</ul>
</li>
<li>$poll$ 应用场景
<ul>
<li>没有 $fd$ 数量限制，如果没有实时性要求，应该使用 $poll$ ；</li>
</ul>
</li>
<li>$epoll$ 应用场景
<ul>
<li>只能运行在<code>Linux</code>上，如果存在大量 $fd$ ，并且都是长连接，应该使用 $epoll$ ；</li>
<li>如果需要同时监控的 $fd$ 小于 $1000$ 个，就没必要使用 $epoll$ ，连接数量较少的场景无法体现 $epoll$ 的优势；</li>
<li>如果连接数量很多，但都是短连接，也没必要使用 $epoll$ ，因为 $epoll$ 的所有 $fd$ 都存储在内核空间，频繁调用 $epoll_-ctl(\ )$ 改变状态会导致过多的系统调用，降低效率；</li>
<li>$epoll$ 的 $fd$ 存储在内核空间，不利于调试。</li>
</ul>
</li>
</ul>
<h3 id="62-nginx">6.2 <code>Nginx</code></h3>
<p>        <code>Nginx</code>支持多种并发模型，具体实现根据系统平台而有所不同，在支持多种并发模型的平台上会自动选择最高效的模型，也可以通过 $use$ 指令在配置文件中显示指定。</p>
<h3 id="63-redis">6.3 <code>Redis</code></h3>
<p>        <code>Redis</code>采用<code>I/O</code>多路复用保证在多连接时候的吞吐量，主要是基于 $epoll$ 实现的，也提供了 $select$ 和 $kqueue$ 实现，默认采用 $epoll$ 。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Aug 22 15:30</span> <a href="/post/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/">缓存一致性协议MESI</a></h1>
            </center>
            <div class="post-content">
                <p>        <strong>高速缓冲存储器一致性</strong> ( $Cache\ \ coherence$ )，也称缓存一致性，是指在采用层次结构存储系统的计算机系统中，保证告诉缓冲存储器中数据与主存储器中数据相同的机制。在有多个<code>CPU</code>的多处理机系统中特别容易出现高速缓存中数据不一致的问题。<br>
        在<code>CPU</code>缓存设计中，<code>L1</code>高速缓存包含指令缓存和数据缓存，位于<code>CPU</code>芯片上，访问速度几乎和寄存器一样快。<code>L2</code>高速缓存在<code>L1</code>和主存之间，连接到存储器总线或者高速缓存总线上。有些高性能系统还会在存储器总线上设置<code>L3</code>高速缓存。<code>L1</code>和<code>L2</code>是每个<code>CPU</code>内核间独立的，<code>L3</code>是所有<code>CPU</code>内核间共享的。<br>
        对于单核<code>CPU</code>来说，数据更新时缓存更新只用考虑自己的就行了，主要有两种处理方法。<strong>写回法</strong> ( $write\ \ back$ )，是当处理器执行写操作时，信息只写入<code>cache</code>，当<code>cache</code>中的数据被替换出去时写回主存。为了减少内存写操作，<code>cache</code>中通常还会设置一个脏位 ( $dirty\ \ bit$ )，标识该块在被载入后是否发生了更新。<strong>直写法</strong> ( $write\ \ through$ ) 是当处理器执行写操作时，既向<code>cache</code>中写入也向主存中写入。直写法会造成大量写内存操作，需要设置一个缓冲来减少硬件冲突，称为写缓冲器 ( $write\ \ buffer$ )，通常不超过 $4$ 个缓存块的大小，也适用于写回法。<br>
        相比于单核<code>CPU</code>，多核<code>CPU</code>除了要保证<code>L1</code>和<code>L2</code>最新外还要考虑到其他核中<code>L1</code>和<code>L2</code>的实时性和有效性。<code>MESI</code>协议是一个基于失效的缓存一致性协议，是支持写回缓存的最常用协议。该协议对总线上的操作进行监听，即核 $A$ 可以窥探到核 $B$ 对过期值的读操作，并更新主存中的过期值。<code>MESI</code>把<code>cache</code>中的数据分为几个状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">监听</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$Invalid$</td>
<td style="text-align:center">该<code>cache</code>字段失效</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">$Shared$</td>
<td style="text-align:center">字段数据一致并且多核<code>cache</code>共享该字段</td>
<td style="text-align:center">监听其他缓存使该字段无效或者变为 $Exclusive$ 的请求，监听到对应事件后会将该字段设为 $Invalid$</td>
</tr>
<tr>
<td style="text-align:center">$Exclusive$</td>
<td style="text-align:center">字段数据一致并且只在当前核<code>cache</code>中独有</td>
<td style="text-align:center">监听其他缓存读主存中该字段的操作，监听到对应事件后将该字段变为 $Shared$</td>
</tr>
<tr>
<td style="text-align:center">$Modified$</td>
<td style="text-align:center">该字段有效但是与主存不一致，只存在于当前核<code>cache</code>中</td>
<td style="text-align:center">监听所有试图读该字段对应主存字段的操作，该操作会被延迟到当前缓存字段写回主存并将状态设为 $Shared$ 之后执行</td>
</tr>
</tbody>
</table>
<p><img src="/image/2021-08-16-01.png" alt="状态机"></p>
<table>
<thead>
<tr>
<th style="text-align:center">事件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$Local\ \ Read$</td>
<td style="text-align:center">读取本地<code>cache</code>字段</td>
</tr>
<tr>
<td style="text-align:center">$Local\ \ Write$</td>
<td style="text-align:center">写入本地<code>cache</code>字段</td>
</tr>
<tr>
<td style="text-align:center">$Remote\ \ Read$</td>
<td style="text-align:center">其他<code>cache</code>读取字段</td>
</tr>
<tr>
<td style="text-align:center">$Remote\ \ Write$</td>
<td style="text-align:center">其他<code>cache</code>写入字段</td>
</tr>
</tbody>
</table>
<p>        对于 $Modified$ 和 $Exclusive$
状态，数据是精确的，而 $Shared$ 状态可能是非一致的。如果一个处于 $Shared$ 的缓存字段作废了，另一个缓存实际上可能已经独享了该缓存字段，但是该缓存不会转为 $Exclusive$
，因为其他缓存并不会广播他们作废该缓存字段的通知。如果一个<code>CPU</code>想修改一个处于 $Shared$ 状态的缓存字段，总线事务需要将所有该缓存字段的副本变为 $Invalid$ 状态，而修改 $Exclusive$ 状态的缓存字段不需要总线事务。<br>
        缓存的一致性消息传递是需要时间的，这就使其切换时产生延迟。当一个缓存被切换状态时其他缓存收到消息完成各自的切换并且发出回应消息这么长一段时间中<code>CPU</code>都会等待所有缓存响应完成。为了避免这种<code>CPU</code>运算能力的浪费，$Store\ \ Buffer$ 被引入。处理器会将想要写入主存的值写到 $Store\ \ Buffer$ 中再去处理其他事情。为了避免在 $Store\ \ Buffer$ 未保存完时其他核已经完成读取，需要引入内存屏障。写屏障保证处理器在更新数据前必须将所有 $Store\ \ Buffer$ 中的指令执行完毕，读屏障保证处理器在读之前将所有需要设置为 $Invalid$ 的字段设置完毕。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Aug 16 11:02</span> <a href="/post/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEmesi/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/mysql%E7%AC%94%E8%AE%B0/">MySQL笔记</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-架构">1. 架构</h2>
<p>        大体来说，<code>MySQL</code>可以分为<code>Server</code>层和存储引擎层两部分。<code>Server</code>层包括连接器、查询缓存、分析器、优化器、执行器等，以及所有的内置函数，所有跨存储引擎功能都在这一层实现。而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持<code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>等多个引擎。不同的存储引擎共用一个<code>Server</code>层，也就是从连接器到执行器的部分。</p>
<ul>
<li>连接器：连接器负责跟客户端建立连接、获取权限、维持和管理连接。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接。建立连接的过程通常比较复杂，所以应尽量使用长连接。但是全部使用长连接后，有时候<code>MySQL</code>内存占用会很高，因为<code>MySQL</code>在执行过程中临时使用的内存是在连接对象里的，只有在断开连接时才释放。</li>
<li>查询缓存：<code>MySQL</code>会在执行语句之前先在查询缓存中查询。但是查询缓存的失效很频繁，只要有一个表更新，表上所有缓存都会失效。对于更新压力大的数据库来讲，命中率会很低。<code>MySQL</code>在 $8.0$ 版本移除了查询缓存功能。</li>
<li>分析器：分析器会对语句做语法分析，判断语句是否存在错误，同时理解语句要执行的操作。</li>
<li>优化器：优化器是在表中存在多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联时，决定表的连接顺序。</li>
<li>执行器：在开始执行之前，会检查是否对表具有查询权限。如果有权限，就打开表执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</li>
</ul>
<p>        一个<code>InnoDB</code>表包含两个部分，即表结构定义和数据。表结构定义的占用空间很小，在<code>MySQL 8.0</code>版本以前，表结构是存在以 $.frm$ 为后缀的文件里，而<code>MySQL 8.0</code>版本已经允许把表结构定义放在系统数据表中了。表数据既可放在共享表空间里，也可以是单独的文件，从<code>MySQL 5.6.6</code>开始，默认是存储在一个以 $.ibd$ 为后缀的文件中的。对于放在共享表空间中的表，即使通过 $DROP$ 命令删除后，空间也不会回收。在删除的过程中，<code>InnoDB</code>会查找聚簇索引，将对应的记录标记为删除，而不是真正删除，目的是为以后插入新数据时的复用。记录的复用与数据页的复用不同，记录的复用只允许对应范围的新记录复用，而如果删除整个数据页后，数据页的复用可以允许复用到任何位置。如果相邻的两个数据页的利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另一个数据页就被标记为可复用。<br>
        重建表即将原来表的记录读取出来，一行一行地插入到新表中。原来的表在删除和插入时会产生很多空洞，数据利用率不高，而重建表就可以解决这个问题。<code>MySQL 5.6</code>引入了 $Online\ \ DDL$ ，会先建立一个临时文件，保存原来表中的聚簇索引。在建立临时文件的过程中，在之后对原表的操作会被记录到日志文件中，并在临时文件建立完成后重新应用到临时文件中，从而允许重建表过程中的读写。<br>
        在不同的引擎中，$COUNT(*)$ 有不同的实现方式，<code>MyISAM</code>把表的行数存在了磁盘上，可以直接返回；<code>InnoDB</code>会把数据一行一行地读出来然后计数。由于<code>MVCC</code>的存在，在某个时间段表有多少行是不确定的，因此<code>InnoDB</code>并不能简单地将行数存起来。<code>MySQL</code>对此的优化策略是，如果表存在多个索引，那么会选择较小的一颗索引树进行扫描。<br>
        <code>MySQL</code>会给每个线程分配一块内存用于排序，称为 $sort_-buffer$。在 $sort_-buffer$ 里面的字段，会每次从数据库中取出数据并存到里面。当取出所有数据后再进行快速排序，如果内存空间不足，会使用外部排序。如果单行长度超过排序的最大长度，那么会将要排序的字段与<code>ID</code>关联，在排序完成后再通过<code>ID</code>回查。如果现有索引覆盖了需要排序的字段，那么会直接使用索引。对于使用聚集函数的排序，<code>MySQL</code>可能会使用临时表。临时表默认是在内存中的，如果超过了内存临时表的大小，就会转成磁盘临时表。<br>
        内存表指的是使用<code>Memory</code>引擎的表，这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。临时表可以使用各种引擎类型，如果是使用<code>InnoDB</code>或者<code>MyISAM</code>引擎的临时表，写数据的时候是写到磁盘上的。一个临时表只能被创建它的 $session$ 访问，可以与普通表同名。</p>
<h2 id="2-日志">2. 日志</h2>
<p>        更新语句的执行过程其实与查询语句一样，但是会涉及日志模块。<br>
        <code>redo log</code>记录将要修改的记录，使用了<code>WAL</code> ( $Write-Ahead\ \ Logging$ ) 技术，即先写日志，再写磁盘。当有一条记录需要更新时，<code>InnoDB</code>会先把记录写到<code>redo log</code>中，并更新内存，之后在适当的时候，将这个操作记录更新到磁盘中，往往是在磁盘比较空闲的时候。<br>
        <code>InnoDB</code>的<code>redo log</code>是固定大小的，写到末尾时就循环回到开头重新写。$write\ \ pos$ 是当前记录的位置，随着数据写入后移。$check\ \ point$ 是当前要擦除的位置，在擦除之前要把记录更新到数据文件。$write\ \ pos$ 和 $check\ \ point$ 之间的部分可以记录新的操作。如果之间没有空白部分，需要等待执行记录。<br>
        <code>InnoDB</code>通过<code>redo log</code>，可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，称为 $crash-safe$ 。<br>
        <code>binlog</code>与<code>redo log</code>的区别有：</p>
<ol>
<li><code>redo log</code>是<code>InnoDB</code>特有的，<code>binlog</code>是<code>MySQL</code>的<code>Server</code>层实现的；</li>
<li><code>redo log</code>是物理日志，记录对某个数据页的修改；<code>binlog</code>是逻辑日志，记录语句的原始逻辑；</li>
<li><code>redo log</code>是循环写入的，<code>binlog</code>是可以追加写入的，即当文件达到一定空间后切换到下一个文件。</li>
</ol>
<p>        每当引擎将新数据更新到内存中时，就会把更新操作记录到<code>redo log</code>中，此时<code>redo log</code>处于 $prepare$ 状态。当执行器执行完成后，会生成操作的<code>binlog</code>。当事务提交之后，引擎会把刚写入的<code>redo log</code>改成 $commit$ 状态，完成更新。<br>
        写<code>redo log</code>的时候，可以通过 $innodb_-flush_-log_-at_-trx_-commit$ 参数设置：</p>
<ul>
<li>该值为 $0$ 时，事务提交时只是把<code>redo log</code>留在 $redo\ \ log\ \ buffer$ 中；</li>
<li>该值为 $1$ 时，每次事务提交都会把数据同步到磁盘上；</li>
<li>该值为 $2$ 时，在事务提交时只做写到 $page\ \ cache$ 。</li>
</ul>
<p>        <code>InnoDB</code>后台有一个线程，每隔 $1$ 秒，就会把 $redo\ \ log\ \ buffer$ 中的日志调用 $write$ 写到 $page\ \ cache$ 中，然后调用 $fsync$ 持久化到磁盘。事务执行中间过程的<code>redo log</code>也是直接写在 $redo\ \ log\ \ buffer$ 中的，也就是说，一个没有提交的事务也是可能已经持久化到磁盘的。<br>
        <code>binlog</code>会记录所有的逻辑操作，如果要恢复到以前的某个状态，可以通过取出<code>binlog</code>并重放操作。<code>binlog</code>的写入逻辑是先写到 $binlog\ \ cache$ ，在事务提交的时候清空 $binlog\ \ cache$ 并写到<code>binlog</code>文件中。事务的<code>binlog</code>不能拆开，要保证一次性写入。每个线程都有自己的 $binlog\ \  cache$ ，但是共用同一份<code>binlog</code>。通过参数 $sync_-binlog$ 控制写磁盘方式：</p>
<ul>
<li>该值为 $0$ 时，每次提交都会写到 $page\ \ cache$ ，不会写到磁盘；</li>
<li>该值为 $1$ 时，每次提交都会写到磁盘；</li>
<li>该值为 $N$ 时，每次提交都会写到 $page\ \ cache$ ，累计 $N$ 次后写到磁盘。</li>
</ul>
<p>        <code>redo log</code>和<code>binlog</code>是两个独立的逻辑，如果不使用两阶段提交，要么就是写完<code>redo log</code>再写<code>binlog</code>，或者反过来，但这会带来问题：</p>
<ul>
<li>先写<code>redo log</code>再写<code>binlog</code>。假设在<code>redo log</code>写完，<code>binlog</code>还没有写完时出现异常重启，那么<code>binlog</code>中会缺少对应数据，从而在之后备份恢复时缺少数据；</li>
<li>先写<code>binlog</code>再写<code>redo log</code>。如果在<code>binlog</code>写完后出现异常，那么由于<code>redo log</code>没写，事务无效，从而在之后备份恢复时多出新事务。</li>
</ul>
<p>        <code>binlog</code>存在三种格式：$statement$ 、$row$ 和 $mixed$ 。$statement$ 格式会记录操作的语句，$row$ 格式会记录操作的行，$mixed$ 格式则由<code>MySQL</code>自己判断是使用 $statement$ 还是 $row$ 。<br>
        在更新方面，<code>MySQL</code>引入 $change\ \ buffer$ 的概念。当需要更新一个数据页时，如果数据页在内存中就会直接更新，如果不在内存中，在不影响一致性的前提下，<code>InnoDB</code>会将更新操作缓存在 $change\ \ buffer$ 中，在下次查询访问改数据页时进行更新。$change\ \ buffer$ 是可持久化的数据，既在内存中有拷贝，也会被写到磁盘上。将 $change\ \ buffer$ 中的操作应用到原数据页的操作称为 $merge$ ，除了访问数据页外，系统也会有后台线程定期进行 $merge$ ，在数据库正常关闭的过程中，也会执行 $merge$ 。<br>
        $change\ \ buffer$ 和<code>redo log</code>的关系在于，$change\ \ buffer$ 中所做的更改会被写入到<code>redo log</code>当中，也就是<code>redo log</code>的记录先于 $change\ \ buffer$ 写入。<code>redo log</code>的目的是减少随机写磁盘的<code>I/O</code>消耗，即转换成顺序写；$change\ \ buffer$ 的目的是节省随机读磁盘的<code>I/O</code>消耗，如果数据在内存中，那么被更改后的数据可以直接从内存中获得。<br>
        当内存数据页与磁盘数据页内容不一致时，内存页就被称为脏页。在内存页被写入磁盘后，数据就一致了，这时内存页就是干净页。在<code>MySQL</code>查询的过程中，有时候会抖动一下，就是在刷脏页 ( $flush$ ) 的过程。引发 $flush$ 的情况有：<code>redo log</code>写满、系统内存不足需要淘汰脏页、系统空闲自动更新、<code>MySQL</code>正常关闭。一般情况下，$flush$ 都是由于系统内存不足导致的。<code>InnoDB</code>使用缓冲池 ( $buffer\ \ pool$ ) 管理内存，使用策略是尽量使用内存，因此对于一个长时间执行的数据库来说，未被使用的页面很少。当要读入的数据页不在内存时，就必须到缓冲池中申请数据页，即淘汰页面。<code>InnoDB</code>会控制一个脏页比例，以避免一次要淘汰过多的脏页。在默认情况下，如果<code>MySQL</code>在刷一个脏页的时候发现其相邻的下一个页面也是脏页，那么就会顺带刷掉，这种连坐机制可以很好的利用顺序<code>I/O</code>，减少随机<code>I/O</code> ( 在<code>MySQL 8.0</code>中默认不开启 ) 。<br>
        <code>InnoDB</code>的内存管理使用的是<code>LRU</code>算法，用链表实现。因为数据库经常会有全表读或者大范围扫描的需求，如果直接采用<code>LRU</code>，当我们对一些使用不太频繁的大表进行全表扫描，一段时间之后，$buffer\ \ pool$ 的命中率会明显下降。实际上，<code>InnoDB</code>对<code>LRU</code>算法做了改进，按照 $5:3$ 的比例把整个<code>LRU</code>链表分成了 $young$ 区域和 $old$ 区域，即靠近链表头部的 $\large\frac{5}{8}$ 是 $young$ 区域，靠近链表尾部的 $\large\frac{3}{8}$ 是 $old$ 区域。每次访问一个不存在于当前链表的数据页，依然淘汰链表尾部的数据页，新插入的数据页会放在 $old$ 区域的头部，并且在 $1$ 秒内对这个数据页的访问不会移动该数据页 ( 可以通过 $innodb_-old_-blocks_-time$ 控制 )。如果超过了 $1$ 秒，就会把它移到整个链表的头部。</p>
<h2 id="3-事务">3. 事务</h2>
<p>        当数据库上有多个事务同时执行的时候，就可能出现脏读 ( $dirty\ \ read$ )、不可重复读 ( $non-repeatable\ \ read$ )、幻读 ( $phantom\ \ read$ ) 的问题。</p>
<ul>
<li>未提交读。一个事务所做的变更在未提交时就能被其他事务看到。</li>
<li>提交读。一个事务所做的变更在提交后才能被其他事务看到。</li>
<li>可重复读。一个事务执行过程中看到的数据总是与事务启动时看到的数据一致。</li>
<li>串行化。对读写进行加锁，当出现读写冲突时，后一个事务必须等待前一个事务执行完成。</li>
</ul>
<p>        在实现上，数据库会创建一个视图，访问的时候以视图的逻辑结果为准。在可重复读的隔离级别下，这个视图在事务启动时创建，并且在整个事务的过程中一直使用。在提交读的隔离级别下，视图会在每个<code>SQL</code>语句开始执行时创建。<br>
        在<code>MySQL</code>中，每条记录在更新时都会记录一条回滚操作，即<code>undo log</code>，记录上的最新值通过回滚操作都可以得到前一个状态的值。在回滚段中的日志分为 $insert\ \ undo\ \ log$ 和 $update\ \ undo\ \ log$ ，前者是 $INSERT$ 时产生的，在事务提交后就可以丢弃；后者是 $DELETE$ 和 $UPDATE$ 时产生的，不仅在事务回滚时需要，一致性读也需要，只有当数据库所使用的视图中不存在比回滚日志更早的读视图时才会被删除，因此长事务的存在会导致日志长时间存在，占用大量存储空间。<br>
        <code>InnoDB</code>里面每个事务都有一个唯一的事务<code>ID</code> ( $trasaction\ \ id$ )，在事务开始时向<code>InnoDB</code>事务系统申请，按照申请顺序严格递增。每行数据都会对应一个事务版本，每次事务更新数据时都会把事务<code>ID</code>赋给这个数据作为版本，记为 $row\ \ trx_-id$ 。同时，旧的数据版本会被保留。在<code>undo log</code>中记录的每条数据都会有一个指向上一个版本数据的指针，每当需要获取之前某个版本的数据时，就会通过最新版本进行访问。<br>
        <code>InnoDB</code>存储引擎在数据库每行数据的后面添加了三个字段：</p>
<ul>
<li>$6$ 字节的事务<code>ID</code> ( $row\ \ trx_-id$ ) ：标识最近一次对本行记录做修改 ( $INSERT$ / $UPDATE$ ) 的事务的标识符，即最后一次修改本行记录的事务<code>ID</code>；</li>
<li>$7$ 字节的回滚指针字段：写入<code>undo log</code>中的记录指针；</li>
<li>$6$ 字节的 $row_-id$ 字段：包含一个随着新行插入而单调递增的 $row_-id$ ，如果表中没有指定主键或者唯一索引，<code>InnoDB</code>会使用该行的值作为主键生成聚簇索引。如果指定了主键或者唯一索引，聚簇索引中就不会包含该行数据。</li>
</ul>
<p>        在视图的实现上，<code>InnoDB</code>为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在活跃的所有事务<code>ID</code>。数组里面事务<code>ID</code>的最小值记为低水位，当前系统里面已经创建过的事务<code>ID</code>的最大值加 $1$ 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图 ( $read-view$ )。对于当前事务的启动瞬间来说，一个数据版本 $row\ \ trx_-id$ ，有以下几种可能：</p>
<ul>
<li>如果小于低水位，代表这个版本是已提交事务或者是当前事务自己生成的，是可见的；</li>
<li>如果大于高水位，表示这个版本是由将来启动的事务生成的，是不可见的；</li>
<li>如果介于低水位和高水位之间，存在两种情况：
<ul>
<li>如果 $row\ \ trx_-id$ 在数组中，表示这个版本是由未提交的事务生成的，不可见；</li>
<li>如果 $row\ \ trx_-id$ 不在数组中，表示这个版本是由已提交的事务生成的，可见。</li>
</ul>
</li>
</ul>
<p>        此外，对于更新语句会有特殊情况。更新数据都是先读后写的，读只能读到当前值，称为当前读 ( $current\ \ read$ )。在更新的过程中会对要更新的数据进行加锁，因此如果存在多个事务对同一个数据进行更新，那么需要先获取锁。而如果对 $select$ 语句进行加锁的话，也是当前读。<br>
        幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的，因此幻读在提交读下才会出现。为了解决幻读问题，<code>InnoDB</code>引入了间隙锁 ( $Gap\ \ Lock$ )。间隙锁和行锁合称 $next-key\ \ lock$，每个 $next-key\ \ lock$ 是前开后闭区间。对同个区间的多个间隙锁不会冲突，这会导致一个区间可能会被多个<code>session</code>加锁，从而造成死锁。</p>
<h2 id="4-索引">4. 索引</h2>
<p>        三种常见的索引：哈希表、有序数组和搜索树。<br>
        哈希表是一种以键值对方式存储数据的结构，只适用于等值查询，当出现哈希碰撞时采用拉链法解决。有序数组采用递增顺序存储索引数据，但是只适用于静态存储引擎，因为在数组中插入和删除数据的代价很大。<br>
        <code>InnoDB</code>采用<code>B+</code>树作为索引。在<code>InnoDB</code>中，表都是根据主键顺序以索引的形式存放的，这种存储方式称为索引组织表。主键索引的叶子节点存储整行数据，也被称为聚簇索引 ( $clustered\ \ index$ )。非主键索引的叶子结点存储主键值，也被称为二级索引 ( $secondary\ \ index$ )。也就是说，基于非主键索引的查询需要多扫描一次索引树。<br>
        为了维护索引的有序性，在插入和删除的时候索引可能需要分裂或者合并。对于自增主键，由于可以保证上一条数据的主键值小于下一条数据，因此不会挪动其他记录。而有业务逻辑的字段做主键，往往不容易保证有序插入，成本相对较高。<br>
        最左前缀原则可以用于在索引中定位记录。但是对于不满足最左前缀原则的条件，<code>MySQL 5.6</code>引入了索引下推优化 ( $index\ \ condition\ \ pushdown$ )，可以在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。<br>
        唯一索引保证了每条数据在表中只会出现一次，主键默认是唯一的。与普通索引相比，唯一索引在查询方面的性能相差几乎没有，因为<code>InnoDB</code>以页为单位读取数据，而大部分情况下普通索引相比于唯一索引仅仅多做了一次查询而已。对于唯一索引来说，所有的更新操作都要先判断是否违反唯一性约束，如果数据页不在内存中，会要求将数据页读入内存，而这时无法使用 $change\ \ buffer$ ；相比之下，普通索引可以用到 $change\ \ buffer$ 。如果要更新的页面存在于内存中，那么唯一索引和普通索引的更新时间几乎没有区别；但是如果不在内存中，唯一索引会要求将数据页读入内存中，这时唯一索引比起普通索引来讲性能就会差很多。<br>
        <code>MySQL</code>在执行语句之前无法精确的知道满足这个条件的记录有多少条，只能根据统计信息来估算记录数，这个统计信息就是区分度。一个索引上不同的值越多，这个索引的区分度就越好。一个索引上不同值的个数称为基数 ( $cardinality$ )。<code>MySQL</code>通过采样统计获取索引的基数，默认选择 $N$ 个数据页，统计页面上不同值得到平均值，然后乘以这个索引的页面值，从而得到基数。当变更的数据行数超过 $1/M$ 的时候，就会自动触发一次索引统计。对于持久化的索引统计，$N$ 默认是 $20$ ，$M$ 是 $10$ ；对于非持久化的统计，$N$ 默认是 $8$ ，$M$ 是 $16$ 。由于 $N$ 比较小，因此很容易不准确。由于不确定性的存在，所以<code>MySQL</code>优化器有时候会选择更差的索引进行搜索。<br>
        对于字符串数据，可以使用前缀索引减少查询次数，但是会损失一些区分度，而且无法使用覆盖索引。对于一些长字符串，前缀索引的效率较差，可以考虑使用倒序索引，或者建立一个哈希字段，再对哈希字段进行索引。</p>
<h2 id="5-锁">5. 锁</h2>
<p>        根据加锁范围，<code>MySQL</code>的锁大致可以分为全局锁、表级锁和行锁。<br>
        全局锁就是对整个数据库进行加锁，在加锁后整个数据库就处于只读状态。全局锁的典型使用场景是做全库逻辑备份，也就是把整库每个表都 $select$ 出来存成文本。对于支持可重复读的引擎，通过事务可以完成备份。而对于不支持可重复读的引擎比如<code>MyISAM</code>，就需要通过全局锁来进行备份。全局锁会在客户端断开时自动释放。<br>
        <code>MySQL</code>里面表级锁有两种：一种是表锁，一种是元数据锁 ( $meta\ \ data\ \ lock$, $MDL$ )。与全局锁一样，表锁会在客户端连接断开时自动释放。对于不支持更细粒度的引擎，表锁是最常用的处理并发的方式。而对于<code>InnoDB</code>这种支持行锁的引擎，则一般不实用。与表锁相比，<code>MDL</code>不需要显式使用，在访问一个表的时候会被自动加上，用于保证读写的正确性。当要对一个表做增删改查操作时，会加<code>MDL</code>读锁；当要对一个表做结构变更操作时，会加<code>MDL</code>写锁。读锁和写锁、写锁和写锁之间是互斥的，因此不能同时对一个表进行结构变更。<br>
        在<code>InnoDB</code>事务中，行锁是在需要的时候才加上，在事务结束的时候释放。如果事务需要多个锁，要把最可能造成锁冲突、最可能影响并发度的锁放在后面。出现死锁的时候，<code>InnoDB</code>提供了两种策略，第一种是等待超时，默认超时时间是 $50s$ ，第二种是进行死锁检测。每一个新来的进入阻塞状态的线程在发现行上有锁后都要进行死锁检测，如果不会产生死锁才会执行。</p>
<h2 id="6-分布式">6. 分布式</h2>
<h3 id="61-cap理论">6.1 <code>CAP</code>理论</h3>
<p>        <code>CAP</code>理论是指在分布式系统中，$C$ ( $Consistency$ )、$A$ ( $Availability$ )、$P$ ( $Partition\ \ Tolerance$ ) 这三个特征不能同时满足。在分布式系统中，现在的网络基础设施无法做到始终保持稳定，网络分区难以避免，牺牲 $P$ 相当于放弃使用分布式系统，因此在分布式系统中不能牺牲 $P$ 。对于涉及钱的交易，数据的一致性非常重要，因此保 $CP$ 弃 $A$ 是最佳选择。对于其他场景，大多数情况下的做法是选择 $AP$ 牺牲 $C$ ，因为很多情况下不需要太强的一致性，只要满足最终一致性即可。</p>
<h3 id="62-分布式数据存储">6.2 分布式数据存储</h3>
<p>        哈希是一种非常常用的数据分布式方法，其核心思想是确定一个哈希函数，通过计算得到对应的存储节点。哈希算法的一个优点是，只要哈希函数设置得当，可以很好地保证数据均匀性，缺点是稳定性较差。如果需要新增节点，那么原有节点中的数据就需要重新计算，即大规模数据迁移，降低稳定性。所以，哈希适用于同类型节点且节点数量比较固定的场景。<br>
        一致性哈希是指将存储节点和数据都映射到一个首尾相连的哈希环上，数据先通过哈希函数计算其在哈希环中的位置，存储节点可以根据<code>IP</code>地址再进行哈希，然后数据通过顺时针方向寻找的方式，来确定自己所属的存储节点。一致性哈希是对哈希的改进，在数据存储时采用哈希方式确定存储位置的基础上，又增加了一层哈希，也就是在数据存储前，对存储节点预先进行了哈希。这种改进可以很好地解决哈希方法存在的稳定性问题，当节点加入或退出时，仅影响该节点在哈希环上顺时针相邻的后继节点。比如前一个节点发生故障需要移除时，需要把该节点数据移到后一个节点，避免了大规模数据迁移。所以，一致性哈希方法比较适合同类型节点、节点规模会发生变化的场景。<br>
        带有限负载的一致性哈希方法的核心原理是给每个存储节点设置了一个存储上限值来控制存储节点添加或移除造成的数据不均匀。当数据按照一致性哈希算法找到相应的存储节点时，要先判断该存储节点是否达到了存储上限，如果达到上限，则继续寻找存储节点。<br>
        其实，哈希、一致性哈希、带有限负载的一致性哈希，都没有考虑节点异构性的问题。如果存储节点的性能好坏不一，数据分布方案还按照这些方法的话，还是没做到数据的均匀分布。带虚拟节点的一致性哈希方法，核心思想是根据每个节点的性能，为每个节点划分不同数量的虚拟节点，并将这些虚拟节点映射到哈希环中，然后再按照一致性哈希算法进行数据映射。带虚拟节点的一致性哈希方法比较适合异构节点，节点规模会发生变化的场景。</p>
<h3 id="63-分布式数据复制">6.3 分布式数据复制</h3>
<p>        从库与主库之间维持一个长连接，主库内部有一个线程，专门用于服务从库的长连接。完整的同步过程为：</p>
<ol>
<li>在从库上通过 $change\ \ master$ 命令，设置主库的<code>IP</code>、端口、用户名、密码以及<code>binlog</code>的起始位置 ( 文件名和偏移量 )；</li>
<li>在从库上执行 $start\ \ slave$ 命令，从库会启动一个 $io_-thread$ 和多个 $sql_-thread$ ，前者负责与主库建立连接；</li>
<li>主库校验完用户名和密码后，根据位置读取<code>binlog</code>并发送给从库；</li>
<li>从库将<code>binlog</code>写到<code>relay log</code>中；</li>
<li>$sql_-thread$ 读取<code>relay log</code>，解析命令并执行。</li>
</ol>
<p>        对于分布式存储系统中的数据复制技术来讲，也需要在一致性和可用性之间作出一些权衡。<br>
        同步复制技术是指，当用户请求更新数据时，主数据库必须要同步到备数据库之后才可以给用户返回，即如果主数据库没有同步到备数据库，用户的更新操作会一直阻塞。这种方式保证了 $CP$ ，牺牲了 $A$ 。由于性能不佳，影响用户体验，同步复制技术经常用于分布式数据库主备场景或对数据一致性有严格要求的场景，比如金融、交易之类的场景。<br>
        异步复制技术是指当用户请求更新数据时，主数据库处理完请求后可以直接给用户响应，而不必等待备数据库完成同步，即备数据库会异步进行数据的同步，用户的更新操作不会因为备数据库未完成数据同步而导致阻塞。显然，这种方式保证了<code>AP</code> ，牺牲了 $C$ 。异步复制技术大多应用在对用户请求响应时延要求很高的场景。<br>
        同步复制技术会满足数据的强一致性，但会牺牲可用性；异步复制技术会满足高可用，但会在一定程度上牺牲数据的一致性。半同步复制技术则介于两者之间。半同步复制技术是，用户发出写请求后，主数据库会执行写操作，并给备数据库发送同步请求，但主数据库不需要等待所有备数据库回复数据同步成功便可以响应用户，也就是说主数据库可以等待一部分备数据库同步完成后响应用户写操作执行成功。半同步复制技术通常有两种方式：</p>
<ol>
<li>当主数据库收到多个备数据库中的某一个回复数据同步成功后，便可以给用户响应写操作完成；</li>
<li>另一种是，主数据库等待超过一半节点 ( 包括主数据库
) 回复数据更新后，再给用户响应写操作成功。</li>
</ol>
<p>        <code>MySQL</code>集群在一主多备的场景下，也支持半同步复制模式，一般采用的是第一种半同步复制模式。普通的半同步是在主库事务提交后再等待从库同步，而增强型半同步会在主库事务提交前等待从库同步，避免了主从数据不一致的问题。</p>

            </div>
            <div class="meta post-footer"> <span>2021 Jun 21 20:33</span> <a href="/post/mysql%E7%AC%94%E8%AE%B0/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2021, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
        if (tocFlag) tocInit();
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>