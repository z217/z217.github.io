<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.74.3" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="http://123.57.12.189"  target="_blank" >
            <i class="fas fa-link fa-sm"></i>
            <span>二站</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/">Java类型信息</a>
        
        
        <p>Java类型信息简单介绍</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 30 16:50
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Java
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/">JVM（3）：性能监控和故障处理</a>
        
        
        <p>深入理解Java虚拟机（3）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 25 20:11
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">JVM（2）：垃圾收集器</a>
        
        
        <p>深入理解Java虚拟机（2）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 23 16:33
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/">JVM（1）：技术体系与内存区域</a>
        
        
        <p>深入理解Java虚拟机（1）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 19 19:42
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84jdk%E7%BC%96%E8%AF%91/">从零开始的JDK编译</a>
        
        
        <p>Linux下JDK的编译</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2020 Aug 19 05:40
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: JVM
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <center>
                <h1><a href="/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/">Java类型信息</a></h1>
            </center>
            <div class="post-content">
                <p>        <strong>运行时类型信息</strong> ( $RTTI$ ) 可以让我们在程序运行时发现和使用类型信息，主要有两种方式：传统<code>RTTI</code>，假定在编译时就已经知道了所有类型；以及反射，允许在运行时发现和使用类型信息。</p>
<h2 id="1-rtti">1. <code>RTTI</code></h2>
<p>        传统的<code>RTTI</code>在<code>Java</code>语句执行过程中也发挥着作用。</p>
<p><img src="/image/2020-08-30-01.png" alt="Shape基类和Circle子类"></p>
<p>        我们定义了一个 $Circle$ 对象，将其存储在一 $List&lt;Shape&gt;$ 容器之中。那么当对象被放入容器时，会向上转型为 $Shape$ ；而在取出时，由于 $List$ 容器会将所有对象当作 $Object$ 类型持有，因此会再次转换为 $Shape$ 对象。</p>
<h3 id="11-class对象">1.1 <code>Class</code>对象</h3>
<p>        $Class$ 对象负责表示运行时的类型信息，<code>Java</code>通过 $Class$ 对象执行<code>RTTI</code>。每个类都拥有一个 $Class$ 对象，当它被编译时，就会通过类加载器产生一个 $.class$ 文件，存储其 $Class$ 对象。<br>
        所有的类都是在被第一次使用时动态地被加载到<code>JVM</code>当中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。也就是说构造器也是静态的，因此使用 $new$ 创建对象就会创建一个对静态构造器的引用，从而使得这个类被加载。当类的 $Class$ 对象被载入后，这个类的所有对象都会使用 $Class$ 对象创建。$Class$ 对象还有一些常用方法：</p>
<ul>
<li>$forName(\ )$ ：通过全类名获取对应类的 $Class$ 对象；</li>
<li>$getName(\ )$ ：获取全限定的类名；</li>
<li>$getSimpleName(\ )$ ：获取不含包名的类名；</li>
<li>$getInterfaces(\ )$ ：$Class$ 对象中实现的接口；</li>
<li>$getSuperclass(\ )$ ：获取基类的 $Class$ 对象。</li>
</ul>
<p>        $Class.newInstance(\ )$ 方法允许你在不知道确切类型的情况下创建对象。通过该方法你可以得到一个 $Object$ 对象，要想正确地使用该对象，你需要对其进行转型。使用 $newInstance$ 创建对象的要求是该对象拥有一个默认构造器。<br>
        除了通过 $forName$ 获取 $Class$ 对象之外，还可以直接通过类字面常量获取，即访问一个类型的 $class$ 字段。而且因为这种方式在编译阶段就会受到检查，因此不需要对异常进行处理，所以也更高效。对于基本数据类型的包装类如 $Integer$ 这种，还拥有一个标准字段 $TYPE$ 。访问 $TYPE$ 就相当于访问对应基本类型的 $class$ 字段，即 $Integer.TYPE$ 相当于 $int.class$ 。<br>
        普通的 $Class$ 对象可以被重新赋值为任何其他的类型的 $Class$ 对象。而要想避免这种再次赋值，可以通过泛型进行限定。<br>
        在类型转换的过程中，<code>Java</code>要执行类型检查。如果执行了一个错误的类型转换，就会抛出一个 $ClassCastException$ 异常。<code>RTTI</code>还可以通过 $instanceof$ 进行检查，它用于判断某个对象是否是某个类型的实例，返回一个布尔值。</p>
<h2 id="2-反射">2. 反射</h2>
<p>        通过<code>RTTI</code>，我们可以知道某个对象的确切类型，但这是建立在编译时已知类型的前提下。如果获取了一个不在你的程序空间的对象引用，那么就无法使用<code>RTTI</code>获取其类型了。反射提供了一种获取对象可用方法以及方法名的机制。<br>
        $Class$ 对象与 $java.lang.reflect$ 类库一起对反射概念进行了支持，类库包含 $Field$ , $Method$ 以及 $Constructor$ 类（均实现了 $Member$ 接口），分别用于表示类里面不同类型的成员。这样我们就可以通过 $Constructor$ 创建对象，$Field$ 的 $get(\ )$ 和 $set(\ )$ 方法读取和修改字段，通过 $invoke(\ )$ 方法调用 $Method$ 对象关联的方法。这三种类型的对象分别通过 $Class$ 对象的 $getFields(\ )$ , $getMethods(\ )$ 和 $getConstructors(\ )$ 方法获取。<br>
        要获取类信息，就需要通过类的 $Class$ 对象，也即获取其 $.class$ 文件。反射与<code>RTTI</code>的不同之处在于，<code>RTTI</code>是在编译时检查 $.class$ 文件；而反射无法在编译时获取 $.class$ 文件，是在运行时检查。<br>
        虽然反射可以让我们获取类中字段、方法和构造器的信息，但它也带来了隐患：通过反射可以访问所有方法，甚至是 $private$ 方法。只需要取得方法关联的 $Method$ 对象，然后设置 $setAccessible(true)$ ，即可调用。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Aug 30 16:50</span> <a href="/post/java%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/">JVM（3）：性能监控和故障处理</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-基础故障处理工具">1. 基础故障处理工具</h2>
<p>        基础故障处理工具是<code>JDK</code>自带的一些位于 $/bin$ 目录下的小工具。这些工具主要用于监视虚拟机运行状态和进行故障处理，根据软件可用性和授权的不同，可以分为三类：</p>
<ul>
<li><strong>商业授权工具</strong>：主要是<code>JMC</code> ( $Java\ \ Mission\ \ Control$ ) 及其使用的<code>JFR</code> ( $Java\ \ Flight\ \ Recorder$ )。自<code>JDK 7</code>开始集成，在<code>JDK 11</code>前都无需独立下载，但是商业使用需要收费。</li>
<li><strong>正式支持工具</strong>：长期支持的工具，可能在不同平台和版本之间存在差异。</li>
<li><strong>实验性工具</strong>：没有技术支持，具有实验性质的工具，但通常很稳定且具有强大功能。</li>
</ul>
<h3 id="11-jps虚拟机进程状况工具">1.1 <code>jps</code>：虚拟机进程状况工具</h3>
<p>        <code>jps</code> ( $JVM\ \ Process\ \ Status\ \ Tool$ ) 的名字类似于<code>UNIX</code>系统中的 $ps$ 命令，功能也和其类似：列出正在运行的虚拟机进程，并显示主类名称和<em><strong>本地虚拟机唯一</strong></em><code>ID</code> ( $Local\ \ Virtual\ \ Machine\ \ Identifier$, $LVMID$ )。作为使用频率最高的<code>JDK</code>命令行工具，是其他工具查询进程的方法。对于本地虚拟机进程来说，<code>LVMID</code>与操作系统进程<code>ID</code> ( $Process\ \ Identifier$, $PID$ ) 是一致的，使用<code>Windows</code>任务管理器也可以查询到。但是如果存在多个虚拟机进程，使得无法通过进程定位时，<code>jps</code>命令显示的主类信息就可以帮助我们定位。</p>
<pre><code>jps [options] [hostid]
</code></pre><table>
<thead>
<tr>
<th align="center">$options$</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$-q$</td>
<td align="center">输出<code>LVMID</code>，省略主类信息</td>
</tr>
<tr>
<td align="center">$-m$</td>
<td align="center">输出主类 $main$ 函数参数</td>
</tr>
<tr>
<td align="center">$-l$</td>
<td align="center">输出主类全名，如果为<code>JAR</code>包则输出路径</td>
</tr>
<tr>
<td align="center">$-v$</td>
<td align="center">输出<code>JVM</code>参数</td>
</tr>
</tbody>
</table>
<p>        $hostid$ 为<code>RMI</code>注册表中注册的主机名，<code>jps</code>可以通过<code>RMI</code>协议查询开启<code>RMI</code>服务的远程虚拟机进程状态。</p>
<h3 id="12-jstat虚拟机统计信息监视工具">1.2 <code>jstat</code>：虚拟机统计信息监视工具</h3>
<p>        <code>jstat</code> ( $JVM\ \ Statistics\ \ Monitoring\ \ Tool$ ) 用于监视本地或者远程虚拟机的各种运行状态信息，包括类加载、内存、垃圾收集、即时编译等。</p>
<pre><code>jstat [option vmid [interval [s|ms] [count]]]
</code></pre><p>        如果为本地虚拟机进程，那么 $vmid$ 就是<code>LVMID</code>。如果是远程，那么格式应为：</p>
<pre><code>[protocol:][//]lvmid[@hostname[:port]/servername]
</code></pre><p>        $interval$ 和 $count$ 标识查询间隔和次数，默认为一次。在不加单位时，$interval$ 默认以 $ms$ 为单位。<br>
        通过 $jstat\ \ options$ 命令可以查询选项，选项对应的作用如下：</p>
<table>
<thead>
<tr>
<th align="center">$options$</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$-class$</td>
<td align="center">监视类加载、卸载数量，类的总空间，以及类装载时间</td>
</tr>
<tr>
<td align="center">$-compiler$</td>
<td align="center">输出即时编译器编译过的方法、耗时等信息</td>
</tr>
<tr>
<td align="center">$-gc$</td>
<td align="center">监视<code>Java</code>堆中各个区域的容量、使用情况和垃圾收集时间等</td>
</tr>
<tr>
<td align="center">$-gccapacity$</td>
<td align="center">与 $-gc$ 基本相同，但是输出更关注各个区域使用的最大和最小空间</td>
</tr>
<tr>
<td align="center">$-gccause$</td>
<td align="center">与 $-gcutil$ 基本相同，但是会输出上次垃圾收集的原因</td>
</tr>
<tr>
<td align="center">$-gcmetacapacity$</td>
<td align="center">输出元数据空间信息</td>
</tr>
<tr>
<td align="center">$-gcnew$</td>
<td align="center">监视新生代垃圾收集状况</td>
</tr>
<tr>
<td align="center">$-gcnewcapacity$</td>
<td align="center">与 $-gcnew$ 基本相同，但是输出更关注使用的最大和最小空间</td>
</tr>
<tr>
<td align="center">$-gcold$</td>
<td align="center">监视老年代垃圾收集状况</td>
</tr>
<tr>
<td align="center">$-gcoldcapacity$</td>
<td align="center">与 $-gcold$ 基本相同，但是输出更关注使用的最大和最小空间</td>
</tr>
<tr>
<td align="center">$-gcutil$</td>
<td align="center">与 $-gc$ 基本相同，但是输出更关注已使用的空间占比</td>
</tr>
<tr>
<td align="center">$-printcompilation$</td>
<td align="center">输出已被即时编译的方法</td>
</tr>
</tbody>
</table>
<p>        使用 $jcstat\ \ -gcutil\ \ [vmid]$ 获得了一次结果如下：</p>
<table>
<thead>
<tr>
<th align="center">$S0$</th>
<th align="center">$S1$</th>
<th align="center">$E$</th>
<th align="center">$O$</th>
<th align="center">$M$</th>
<th align="center">$CCS$</th>
<th align="center">$YGC$</th>
<th align="center">$YGCT$</th>
<th align="center">$FGC$</th>
<th align="center">$FGCT$</th>
<th align="center">$GCT$</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$100.00$</td>
<td align="center">$0.00$</td>
<td align="center">$63.72$</td>
<td align="center">$72.36$</td>
<td align="center">$95.44$</td>
<td align="center">$93.29$</td>
<td align="center">$190$</td>
<td align="center">$0.966$</td>
<td align="center">$10$</td>
<td align="center">$1.028$</td>
<td align="center">$1.994$</td>
</tr>
</tbody>
</table>
<p>        $E$ 表示<code>Eden</code>区，使用了 $63.72$% 的空间；$S0$ 和 $S1$ 表示两个<code>Survivor</code>区，分别使用了 $100.00$% 和 $0.00$% ；$O$ 表示老年代，使用了 $72.36$% ；$M$ 表示方法区，使用了 $95.44$% ；$YGC$ 是程序运行以来进行<code>Minor GC</code>的次数，为 $190$ 次；$YGCT$ 是<code>Minor GC</code>的总耗时，为 $0.966$ 秒；$FGC$ 是程序运行以来的<code>Full GC</code>次数，为 $10$ 次；$FGCT$ 是<code>Full GC</code>总耗时，为 $1.028$ 秒；$GCT$ 是所有<code>GC</code>的总耗时，为 $1.994$ 秒。</p>
<h3 id="13-jinfojava配置信息工具">1.3 <code>jinfo</code>：<code>Java</code>配置信息工具</h3>
<p>        <code>jinfo</code> ( $Configuration\ \ Info\ \ for\ \ Java$ ) 用于实时查看和调整虚拟机的各项参数。虽然通过 $jps\ \ -v$ 就能看到<code>JVM</code>参数，但是如果想要查看没有显示指定的系统默认值，就只能使用 $jinfo -flag$ 了。</p>
<pre><code>jinfo [option] &lt;pid&gt;
</code></pre><table>
<thead>
<tr>
<th align="center">$options$</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$-flag\ \ &lt;name&gt;$</td>
<td align="center">查询指定参数</td>
</tr>
<tr>
<td align="center">$-flag\ \ [+/-]&lt;name&gt;$</td>
<td align="center">启用或禁用指定参数</td>
</tr>
<tr>
<td align="center">$-flag\ \ &lt;name&gt;=&lt;value&gt;$</td>
<td align="center">设置指定参数值</td>
</tr>
<tr>
<td align="center">$-flags$</td>
<td align="center">查询所有参数</td>
</tr>
<tr>
<td align="center">$-sysprops$</td>
<td align="center">查询<code>Java</code>系统属性，即 $System.getProperties(\ )$ 方法的值</td>
</tr>
</tbody>
</table>
<h3 id="14-jmapjava内存映像工具">1.4 <code>jmap</code>：<code>Java</code>内存映像工具</h3>
<p>        <code>jmap</code> ( $Memory\ \ Map\ \ for\ \ Java$ ) 用于生成<em><strong>堆转储快照</strong></em> ( $heapdump$ / $dump$ )，类似功能也可以通过设置 $-XX:+HeapDumpOnOutOfMemoryError$ 实现。此外，也可以通过 $-XX:+HeapDumpOnCtrlBreak$ 实现通过 $Ctrl+Break$ 键生成堆转储快照文件。在<code>Linux</code>系统下还可以通过 $kill\ \ -3$ 命令得到。除了获取堆转储快照外，<code>jmap</code>还可以查询 $finalize$ 执行队列、<code>Java</code>堆和方法区的详细信息。</p>
<pre><code>jmap [option] &lt;pid&gt;
</code></pre><table>
<thead>
<tr>
<th align="center">$options$</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$-heap$</td>
<td align="center">显示<code>Java</code>堆信息</td>
</tr>
<tr>
<td align="center">$-histo$</td>
<td align="center">显示堆中对象的统计信息，如类和实例数量、容量等</td>
</tr>
<tr>
<td align="center">$-clstats$</td>
<td align="center">显示类加载器信息</td>
</tr>
<tr>
<td align="center">$-finalizerinfo$</td>
<td align="center">在<code>F-Queue</code>中等待执行 $finalize$ 的对象</td>
</tr>
<tr>
<td align="center">$-dump$</td>
<td align="center">生成堆转储快照，格式为 $-dump:[live,]format=b,file=&lt;filename&gt;$ ，分别表示是否去除死亡对象，二进制格式和文件名</td>
</tr>
<tr>
<td align="center">$-F$</td>
<td align="center">强制生成堆转储快照</td>
</tr>
</tbody>
</table>
<p>        <code>jmap</code>有部分功能在<code>Windows</code>下受限，除了 $-dump$ 和 $-histo$ 外都不能使用。</p>
<h3 id="15-jhat虚拟机堆转储快照分析工具">1.5 <code>jhat</code>：虚拟机堆转储快照分析工具</h3>
<p>        <code>jhat</code> ( $JVM\ \ Heap\ \ Analysis\ \ Tool$ ) 与<code>jmap</code>搭配使用，用于分析堆转储快照。<code>jhat</code>内置了一个微型的<code>Web</code>服务器，分析完成后可以直接在浏览器中查看。但是一般情况下是不会在服务器上分析堆转储快照的，因为分析工作会占用大量资源，而且现在已经有了专门的图形化工具用于分析堆转储快照，并且功能也比<code>jhat</code>提供的要多。</p>
<h3 id="16-jstackjava堆栈跟踪工具">1.6 <code>jstack</code>：<code>Java</code>堆栈跟踪工具</h3>
<p>        <code>jstack</code> ( $Stack\ \ Trace\ \ for\ \ Java$ ) 用于生成虚拟机当前时刻的线程快照 ( $threaddump$ / $javacore$ )，即每一条线程正在执行的方法集合。线程快照可以用于定位线程问题，如死锁、死循环和请求外部资源导致的长时间挂起等。</p>
<pre><code>jstack [option] &lt;vmid&gt;
</code></pre><table>
<thead>
<tr>
<th align="center">$options$</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$-F$</td>
<td align="center">强制输出线程堆栈</td>
</tr>
<tr>
<td align="center">$-l$</td>
<td align="center">除堆栈外，显示锁信息</td>
</tr>
<tr>
<td align="center">$-m$</td>
<td align="center">如果有调用本地方法，可以用于显示<code>C/C++</code>堆栈</td>
</tr>
</tbody>
</table>
<p>        在<code>JDK 5</code>之后，通过 $java.lang.Thread.getAllStackTraces(\ )$ 方法可以获取所有线程的 $StackTraceElement$ 对象，从而实现<code>jstack</code>的大部分功能。</p>
<h2 id="2-可视化故障处理工具">2. 可视化故障处理工具</h2>
<h3 id="21-jhsdb基于服务性代理的调试工具">2.1 <code>JHSDB</code>：基于服务性代理的调试工具</h3>
<p>        <code>JDK</code>中提供了<code>JCMD</code>和<code>JHSDB</code>两个集成式的多功能工具箱，不仅整合了所有基础工具提供的而功能，而且还对他们进行了优化。</p>
<table>
<thead>
<tr>
<th align="center">基础工具</th>
<th align="center"><code>JCMD</code></th>
<th align="center"><code>JHSDB</code></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$jps\ \ -lm$</td>
<td align="center">$jcmd$</td>
<td align="center">$N/A$</td>
</tr>
<tr>
<td align="center">$jmap\ \ -dump\ \ &lt;pid&gt;$</td>
<td align="center">$jcmd\ \ &lt;pid&gt;\ \ GC.heap_-dump$</td>
<td align="center">$jhsdb\ \ jmap\ \ &ndash;binaryheap$</td>
</tr>
<tr>
<td align="center">$jmap\ \ -histo\ \ &lt;pid&gt;$</td>
<td align="center">$jcmd\ \ &lt;pid&gt;\ \ GC.class_-histogram$</td>
<td align="center">$jhsdb\ \ jmap\ \ &ndash;histo$</td>
</tr>
<tr>
<td align="center">$jstack\ \ &lt;pid&gt;$</td>
<td align="center">$jcmd\ \ &lt;pid&gt;\ \ Thread.print$</td>
<td align="center">$jhsdb\ \ jstack\ \ &ndash;locks$</td>
</tr>
<tr>
<td align="center">$jinfo\ \ -sysprops\ \ &lt;pid&gt;$</td>
<td align="center">$jcmd\ \ &lt;pid&gt;\ \ VM.system_-properties$</td>
<td align="center">$jhsdb\ \ info\ \ &ndash;sysprops$</td>
</tr>
<tr>
<td align="center">$jinfo\ \ -flags\ \ &lt;pid&gt;$</td>
<td align="center">$jcmd\ \ &lt;pid&gt;\ \ VM.flags$</td>
<td align="center">$jhsdb\ \ jinfo\ \ &ndash;flags$</td>
</tr>
</tbody>
</table>
<p>        <code>JHSDB</code>是一款基于<em><strong>服务性代理</strong></em> ( $Serviceability\ \ Agent$, $SA$ ) 实现的进程外调试工具。服务性代理是<code>HotSpot</code>虚拟机中一组用于映射<code>Java</code>虚拟机运行信息的<code>API</code>集合，将<code>C++</code>数据抽象出<code>Java</code>对象。通过服务性代理的<code>API</code>，可以在一个独立的<code>Java</code>虚拟机进程内分析其他<code>HotSpot</code>虚拟机的内部数据，或者从转出快照中还原其运行细节。<br>
        在使用 $jps$ 获取到进程<code>ID</code>后，可以通过</p>
<pre><code>jhsdb hsdb --pid &lt;pid&gt;;
</code></pre><p>        进入<code>JHSDB</code>的图形化模式。</p>
<h3 id="22-jconsolejava监视与管理控制台">2.2 <code>JConsole</code>：<code>Java</code>监视与管理控制台</h3>
<p>        <code>JConsole</code> ( $Java\ \ Monitoring\ \ and\ \ Management\ \ Console$ ) 是一款基于<code>JMX</code> ( $Java\ \ Management\ \ Extensions$ ) 的可视化监视、管理工具，主要通过<code>JMX</code>的<code>MBean</code> ( $Managed\ \ Bean$ ) 对系统进行信息收集和参数动态调整。<br>
        <code>JConsole</code>的启动很简单，通过 $/bin$ 目录下的 $jconsole.exe$ 即可启动，在启动后会自动扫描虚拟机进程，也可以通过远程连接对远程虚拟机进行监控。</p>
<h3 id="23-visualvm多合一故障处理工具">2.3 <code>VisualVM</code>：多合一故障处理工具</h3>
<p>        <code>VisualVM</code> ( $All-in-One\ \ Java\ \ Troubleshooting\ \ Tool$ ) 是功能最强大的运行监视和故障处理程序之一。除了常规的运行监视和故障处理之外，它还提供了<em><strong>性能分析</strong></em> ( $Profiling$ ) 等功能。<code>VisualVM</code>基于<code>NetBeans</code>平台开发工具，支持插件扩展。在<a href="https://visualvm.github.io/pluginscenters.html">官网</a>上下载包后，可以直接导入。当然，<code>VisualVM</code>也提供了自动安装功能，能够找到大部分插件。<br>
        <code>VisualVM</code>支持生成和浏览堆转储快照。虽然也支持性能分析功能，但是因为对运行有较大影响，因此一般不在生产环境使用，或者改用更强大、影响更小的<code>JMC</code>完成。通过插件，<code>VisualVM</code>中可以导入<code>BTrace</code>。<code>BTrace</code>可以在不中断程序的前提下加入调试代码。</p>
<h3 id="24-java-mission-control可持续在线的监控工具">2.4 <code>Java Mission Control</code>：可持续在线的监控工具</h3>
<p>        <code>JFR</code> ( $Java\ \ Flight\ \ Recorder$ ) 是一套内建在<code>HotSpot</code>虚拟机里面的监控和基于事件的信息搜集框架，具有<em><strong>可持续在线</strong></em> ( $Always-On$ ) 的特性。在监控过程中，它都是可动态的，不需要重启应用。<code>JMC</code> ( $Java\ \ Mission\ \ Control$ ) 使用<code>JMX</code>协议与虚拟机进行通信，显示<code>MBean</code>提供的数据，还可以作为<code>JFR</code>的分析工具，展示其数据。<code>JFR</code>的基本工作逻辑是开启一系列事件的录制，即使不考虑性能影响的优势，<code>JFR</code>的数据质量通常也比其他通过代理或者通过<code>MBean</code>获取的数据要高。</p>
<h2 id="3-hotspot虚拟机插件及工具">3. <code>HotSpot</code>虚拟机插件及工具</h2>
<p>        <code>HotSpot</code>虚拟机也含有很多插件和辅助工具：</p>
<ul>
<li><code>Ideal Graph Visualizer</code>：可视化展示<code>C2</code>即时编译器是如何将字节码转化为理想图，再转化为机器码的。</li>
<li><code>Client Compiler Visualizer</code>：查看<code>C1</code>即时编译器生成<strong>高级中间表示</strong> ( $HIR$ )，转换成<strong>低级中间表示</strong> ( $LIR$ ) 和做物理寄存器分配的过程。</li>
<li><code>MakeDeps</code>：处理<code>HotSpot</code>的编译依赖。</li>
<li><code>Project Creator</code>：生成<code>Visual Studio</code>的 $.project$ 文件。</li>
<li><code>LogCompilation</code>：将 $-XX:+LogCompilation$ 输出整理成更易阅读的形式。</li>
<li><code>HSDIS</code>：即时编译器的反汇编插件。</li>
</ul>
<h3 id="31-hsdisjit生成代码反汇编">3.1 <code>HSDIS</code>：<code>JIT</code>生成代码反汇编</h3>
<p>        <code>HSDIS</code>插件通过<code>HotSpot</code>的 $-XX:+PrintAssembly$ 指令调用，将即时编译器动态生成的本地代码还原为汇编代码输出，并产生注释。可以在<a href="http://lafo.ssw.uni-linz.ac.at/hsdis/att/">http://lafo.ssw.uni-linz.ac.at/hsdis/att/</a>上下载已编译好的<code>HSDIS</code>，如果为<code>Product</code>版虚拟机，还需要设置 $-XX:+UnlockDiagnosticVMOptions$ 。<br>
        在代码不多的时候，还可以直接查看输出，但是在大量代码中，显然无法直接查看。这时候就需要<code>JITWatch</code>的辅助。可以在<a href="https://github.com/AdoptOpenJDK/jitwatch">Github</a>上下载源码进行编译。<code>JITWatch</code>是用于分析日志的可视化工具，因此要将日志输出。输出日志可使用以下参数：</p>
<pre><code>-XX:+UnlockDiagnosticVMOptions
-XX:+TraceClassLoading
-XX:+LogCompilation
-XX:LogFile=/tmp/logfile.log
-XX:+PrintAssembly
-XX:+TraceClassLoading
</code></pre><p>        日志会输出到 $/tmp/logfile.log$ 文件中，在<code>JITWatch</code>上加载后，即可看到各种使用过的对象类型、方法，以及源代码、字节码和汇编代码了。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Aug 25 20:11</span> <a href="/post/jvm3%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">JVM（2）：垃圾收集器</a></h1>
            </center>
            <div class="post-content">
                <p>        相比于程序计数器、虚拟机栈和本地方法栈这种应分配的内存大小在类确定时就已固定下来的内存区域，<code>Java</code>堆和方法区这两个区域有着不确定性：一个接口可能有多个实现类，一个方法可能有多个分支。垃圾收集器所关注的也就是这部分不确定的内存。</p>
<h2 id="1-对象状态">1. 对象状态</h2>
<p>        在进行垃圾收集之前，垃圾收集器需要对对象的状态进行判断，即判断其是否仍在被使用。</p>
<h3 id="11-引用计数算法">1.1 引用计数算法</h3>
<p>        <strong>引用计数</strong> ( $Reference\ \ Counting$ ) 算法，可以简单的解释为在对象中添加一个引用计数器，当对象被引用时计数器便加一，反之减一。如此往复，当对象的引用计数器为零时，可以认为其不再被使用。虽然这种算法简单而且效率很高，但是因为存在着很多例外情况，因此不被主流的<code>JVM</code>所采纳。比较简单的例子就比如存在对象 $A$ 和 $B$ ，它们都存在着一个字段互相引用对方，这样它们的引用计数器就都为 $1$ 。但实际上，除了互相引用之外，它们没有被其他对象引用，可以认为是无用的对象，应该被垃圾收集。另一方面，它们的引用计数又不为 $0$ ，无法触发垃圾收集。因此，引用计数算法需要配合大量额外处理才能保证正常工作。</p>
<h3 id="12-可达性分析算法">1.2 可达性分析算法</h3>
<p>        <strong>可达性分析</strong> ( $Reachability\ \ Analysis$ ) 算法，基本思路就是通过一系列的称为<code>GC Roots</code>的跟对象出发，不断搜索引用关系，搜索路径称为<em><strong>引用链</strong></em> ( $Reference\ \ Chain$ )。当一个对象没有被搜索到，或者称不可达时，就认为这个对象不再被使用。在<code>Java</code>技术体系里固定可作为<code>GC Roots</code>的对象包括：</p>
<ul>
<li>虚拟机栈中的引用对象</li>
<li>方法区中类静态属性的引用对象</li>
<li>方法区中常量引用对象</li>
<li>本地方法栈中<code>JNI</code> ( 即 $Native$ 方法 ) 的引用对象</li>
<li><code>JVM</code>内部引用，如基本数据类型对应的 $Class$ 对象，一些常驻的异常对象等，还有系统类加载器</li>
<li>同步锁 ( $synchronized$ 关键字 ) 持有的对象</li>
<li>反应<code>JVM</code>内部情况的<code>JMXBean</code>、<code>JVMTI</code>中注册的回调、本地代码缓存等</li>
</ul>
<p>        除此之外，根据用户选择的垃圾收集器以及当前收集的内存区域，还会有临时对象的加入。譬如要针对某个特定区域进行垃圾收集时，不仅要加入该区域的，还要加入关联区域的其他对象。虽然现在查找引用链的过程已经可以做到并发，但迄今为止，所有收集器在根节点枚举这一步骤都要暂停用户线程。</p>
<h3 id="13-对象引用">1.3 对象引用</h3>
<p>        在<code>JDK 1.2</code>之前，<code>Java</code>对应用的定义为：如果 $reference$ 类型的数据中存储的数值代表的是另一块内存的起始地址，就称其代表某块内存或某块对象的引用。而在<code>JDK 1.2</code>之后，<code>Java</code>扩充了引用的概念，分为 $4$ 种引用强度：</p>
<ul>
<li><strong>强引用</strong> ( $Strong\ \ Reference$ )：强引用是最传统的引用方式，即指引用赋值。</li>
<li><strong>软引用</strong> ( $Soft\ \ Reference$ )：软引用指一些有用但非必须的对象。当系统将发生内存溢出时，软引用对象会被回收。<code>JDK 1.2</code>之后提供了 $SoftReference$ 类实现软引用。</li>
<li><strong>弱引用</strong> ( $Weak\ \ Reference$ )：弱引用指非必须对象，但强度比软引用更弱。无论内存是否足够，都会被回收。<code>JDK 1.2</code>之后提供了 $WeakReference$ 类实现弱引用。</li>
<li><strong>虚引用</strong> ( $Phantom\ \ Reference$ )：虚引用是最弱的引用关系，不会对对象生命周期造成影响，也不能通过虚引用取得对象实例。关联虚引用只是为了在对象被回收之前获得系统通知。<code>JDK 1.2</code>之后提供了 $PhantomReference$ 类实现虚引用。</li>
</ul>
<h3 id="14-对象死亡">1.4 对象死亡</h3>
<p>        一个对象的死亡至少需要经历两次标记过程：第一次为可达性分析，第二次为筛选，筛选覆盖了 $finalize(\ )$ 方法或者执行过 $finalize(\ )$ 方法的对象。如果 $finalize(\ )$ 方法未被覆盖或者未被执行，那么对象会进入 $F-Queue$ 队列，并在之后由一条自动建立的低优先级的 $Finalizer$ 线程执行其 $finalize(\ )$ 方法。稍后收集器会检查队列中的对象，如果对象在 $finalize(\ )$ 方法中建立了与其他对象的关联，那么它就会被移出队列。需要注意的是，为了避免长时间等待或者进入死循环，收集器并不会等待对象的 $finalize(\ )$ 方法执行完毕，而且一个对象的 $finalize(\ )$ 方法只能调用一次，因此有可能在下次对象回收时该对象不能再次自救。</p>
<h3 id="15-方法区回收">1.5 方法区回收</h3>
<p>        正如之前所说的，方法区可以不实现垃圾收集，而且方法区进行垃圾收集的性价比也不高。方法区的垃圾收集包括废弃常量和不再使用的类型。相比于前者，后者的判定难度就大得多了。判断一个类型不再使用需要满足以下条件：</p>
<ul>
<li>该类所有实例均已回收。</li>
<li>该类的类加载器已回收。</li>
<li>该类的 $Class$ 对象没有被引用，无法通过反射方式访问该类方法。</li>
</ul>
<p>        是否对类型进行回收，<code>HotSpot</code>虚拟机中可以通过 $+Xnoclassgc$ 参数控制，还可以使用 $-verbose:class$、$-XX:+TraceClassLoading$、$-XX:+TraceClassUnLoading$ 查看类加载和卸载信息，前两者可以在<code>Product</code>版中使用，后者需要在<code>FastDebug</code>版中使用。</p>
<h2 id="2-垃圾收集算法">2. 垃圾收集算法</h2>
<p>        垃圾收集算法可以分为引用计数式垃圾收集和追踪式垃圾收集两大类，它们也被称作直接垃圾收集和间接垃圾收集。</p>
<h3 id="21-分代收集理论">2.1 分代收集理论</h3>
<p>        分代收集理论建立在两个假说上：</p>
<ul>
<li><strong>弱分代假说</strong> ( $Weak\ \ Generational\ \ Hypothesis$ )：绝大多数对象都是朝生夕灭的。</li>
<li><strong>强分代假说</strong> ( $Strong\ \ Generational\ \ Hypothesis$ )：经过越多次垃圾收集的对象越难以消亡。</li>
</ul>
<p>        根据这两个假说，多款垃圾收集器中都给<code>Java</code>堆中划分出不同的区域，每次回收根据对象的年龄，将对象分配到不同区域中。在划分出不同的区域后，垃圾收集器可以每次只回收某个或某些特定区域。在<code>Hotspot</code>虚拟机中，<code>Java</code>堆被分为<strong>新生代</strong> ( $Young\ \ Generation$ ) 和<strong>老年代</strong> ( $Old\ \ Generation$ ) 两个区域。但是分代收集并没有想象的那么简单，因为对象不是孤立的，跨代引用是存在的。在此基础上有了第三条经验法则:</p>
<ul>
<li><strong>跨代引用假说</strong> ( $Intergenerational\ \ Reference\ \ Hypothesis$ )：跨代引用相对于同代引用来说仅占少数。</li>
</ul>
<p>        隐含推论是：互相引用的两个对象，倾向于同时生存或者同时消亡。因此没必要再为跨代引用去扫描老年代，只需要在新生代上建立一个全局数据结构，称为<em><strong>记忆集</strong></em> ( $Remembered\ \ Set$ )，将老年代划分为若干小块，标识其中存在跨代引用的小块。在之后进行局限于新生代的垃圾收集 ( $Minor\ \ GC$ ) 时，只需要将这些小块中的对象加入<code>GC Roots</code>即可。</p>
<h3 id="22-标记-清除算法">2.2 标记-清除算法</h3>
<p>        <strong>标记-清除</strong> ( $Mark-Sweep$ ) 算法，首先标记处需要回收的对象，在标记完成后统一收集标记的对象，也可以反过来标记不应清除的对象。标记-清除算法的缺点主要有两个：效率不稳定以及会导致内存碎片化。</p>
<h3 id="23-标记-复制算法">2.3 标记-复制算法</h3>
<p>        标记-复制算法是为了解决标记-清除算法在面对大量可回收对象时的效率低下问题而提出的。首先是<em><strong>半区复制</strong></em> ( $Semispace\ \ Copying$ ) 算法，它将可用内存分为大小相等的两块，每次只使用一块。当其中一块使用完之后，将其中存活的对象移到另一块，再将这块内存清理掉。虽然实现简单，运行高效，但是可用内存缩小为一半，浪费了大量空间。之后又提出了 $Appel$ 式回收，它将新生代分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间，每次分配内存只使用<code>Eden</code>和一块<code>Survivor</code>。在垃圾收集时将它们中的存活对象复制到另一块<code>Survivor</code>中，然后清理自身空间。<code>HotSpot</code>虚拟机中<code>Eden</code>和<code>Survivor</code>的比例为 $8:1$ 。如果<code>Survivor</code>空间无法容纳存活对象，那么就需要其他内存区域进行<strong>分配担保</strong> ( $Handle\ \ Promotion$ )。</p>
<h3 id="24-标记-整理算法">2.4 标记-整理算法</h3>
<p>        标记-复制算法在面对大量存货对象时效率较低，所以不适用于老年代。<strong>标记-整理</strong> ( $Mark-Compact$ ) 算法，其标记过程和标记-复制算法一样，但不进行复制，而是将存活对象向内存一端移动，再清理掉边界外内存。但是对于老年代这种存在大量存活对象的内存区，移动需要耗费大量时间，而且必须暂停用户程序。</p>
<h2 id="3-hotspot虚拟机算法">3. <code>HotSpot</code>虚拟机算法</h2>
<p>        在可达性分析算法的根节点收集这一步中，用户线程必须暂停。为了减小这段暂停的时间，<code>HotSpot</code>虚拟机中有一组称为 $OopMap$ 的数据结构。当类加载完成时，<code>HotSpot</code>会把对象内偏移量对应的数据类型计算出来，并在即时编译过程中记录栈和寄存器中的引用位置。这样扫描器在扫描时就不需要慢慢查找了，可以直接获取这些信息。但是如果给每一条指令都建立一个 $OopMap$ ，那么会占用大量存储空间。因此引入了<strong>安全点</strong> ( $Safepoint$ ) 的概念。只有程序执行到安全点后，虚拟机才会生成 $OopMap$ 。同样，也只有执行到安全点后，程序才能开始垃圾收集。安全点的选取要以能否让程序长时间执行为标准，譬如方法调用、循环跳转、异常跳转这些需要指令序列的复用的地方就可以作为安全点。<br>
        在多线程环境下，每个线程的执行速度不同，可能会出现当一个线程到达安全点之后其他线程还未到达的情况，因此需要采取不同策略。这里有两种方案可以选择：<strong>抢占式中断</strong> ( $Preemptive\ \ Suspension$ ) 和<strong>主动式中断</strong> ( $Voluntary\ \ Suspension$ )，几乎所有虚拟机都采用了主动式中断的方案。抢占式中断会在垃圾收集发生时直接中断所有线程，如果这时某条线程不在安全点上，就恢复其执行，直到其在安全点上。主动式中断设置了一个标志位，线程们会不断轮询这个标志位，当其为真时，线程会执行到最近的一个安全点上然后中断。轮询点包括安全点、创建对象的地方和其他需要在<code>Java</code>堆上分配内存的地方，以避免因为内存不够而导致的无法分配问题。在<code>HotSpot</code>虚拟机中采用了内存保护陷阱的方式，使得轮询操作只需要一条汇编指令即可执行，从而保证了高效性。<br>
        虽然安全点的引入解决了停顿线程的问题，但是无法在程序不执行的状态下运行。这时候就引入了<strong>安全区域</strong> ( $Safe\ \ Region$ ) 的概念。安全区域指代一块代码段，在这段代码中，引用关系不会发生改变，因此可以在这段代码的任意地点开始垃圾收集。当线程进入安全区域，会标识其已进入安全区域，这样在垃圾收集时虚拟机就不会管这些线程。当线程离开时，如果仍在进行根节点枚举这种需要暂停用户线程的步骤，那么就要等待直到完成。<br>
        在进行<em><strong>部分区域收集</strong></em> ( $Partial\ \ GC$ ) 时，可能会存在跨代引用问题，因此引入了记忆集的概念。记忆集专门用于记录非收集区域指向收集区域的指针集合。设计者在设计记忆集时，可以选择不同的记忆精度，比较常见的有：</p>
<ul>
<li><strong>字长精度</strong>：每个记录精确到一个机器字长，即处理器的寻址长度。</li>
<li><strong>对象精度</strong>：每个记录精确到一个对象。</li>
<li><strong>卡精度</strong>：每个记录精确到一块内存区域。</li>
</ul>
<p>        卡精度通过一种称为<em><strong>卡表</strong></em> ( $Card\ \ Table$ ) 的方式实现，也是目前最常用的实现方式。最简单的卡表形式可以是一个字节数组，这也是<code>HotSpot</code>虚拟机中的实现方式。字节数组中的每一个元素都标识一块内存区域，称为<em><strong>卡页</strong></em> ( $Card\ \ Page$ )。当卡页中存在跨代指针时，就要将卡页标识为 $1$ ，称为元素变<em><strong>脏</strong></em> ( $Dirty$ )。在垃圾收集时，只需要筛选变脏的卡页，然后加入<code>GC Roots</code>即可。卡表变脏显然是需要虚拟机负责维护的，但是经过即时编译后的代码已经是一条条机器指令了，这时就需要一种手段可以将维护卡表的操作放到引用赋值之中。<code>HotSpot</code>虚拟机通过<em><strong>写屏障</strong></em> ( $Write\ \ Barrier$ ) 维护卡表状态。写屏障可以看作在虚拟机层面堆“引用类型字段赋值&quot;这个动作的<code>AOP</code>切面，在引用赋值时产生一个<em><strong>环形</strong></em> ( $Around$ ) 通知，供程序执行额外动作。赋值前的部分叫<em><strong>写前屏障</strong></em> ( $Pre-Write\ \ Barrier$ )，赋值后的部分叫做<em><strong>写后屏障</strong></em> ( $Post-Write\ \ Barrier$ )。写前屏障可以应用于<code>SATB</code>算法中，而写后屏障可以用于更新卡表中。<br>
        在对象标记的过程中，我们引入<em><strong>三色标记</strong></em> ( $Tri-color\ \ Marking$ ) 来辅导。白色指未被访问的对象，黑色指所有引用都被扫描过的对象，灰色指部分引用还未被扫描的对象。而在对象标记的过程中，如果用户线程仍在执行，那么可能会触发对象消失问题，即原本存活的对象被标记为死亡。当且仅当以下条件同时满足时，就会产生对象消失问题：</p>
<ul>
<li>赋值器插入了一条或多条从黑色到白色的新引用。</li>
<li>赋值器删除了全部从灰色到白色的直接或间接引用。</li>
</ul>
<p>        而要避免这种情况，实现并发标记，那么就要破坏这两个条件的任意一个。对此有两种方案：<em><strong>增量更新</strong></em> ( $Increment\ \ Update$ ) 和<em><strong>原始快照</strong></em> ( $Snapshot\ \ At\ \ The\ \ Beginning$, $SATB$ )。增量更新破坏第一个条件，即记录黑色到白色的新引用，在扫描结束后再以它们为根重新进行一次扫描。原始快照破坏第二个条件，即记录灰色对象删除指向白色对象的引用，在扫描结束后以其中灰色对象为根再进行一次扫描。在<code>HotSpot</code>虚拟机中，这两种方案都有应用。</p>
<h2 id="4-经典垃圾收集器">4. 经典垃圾收集器</h2>
<h3 id="41-serial收集器">4.1 <code>Serial</code>收集器</h3>
<p>        <code>Serial</code>是最基础、历史最悠久的收集器。它是一个单线程收集器，也就是说在其进行垃圾收集时，其他所有工作都要暂停。对新生代的收集会采用复制算法，对老年代的收集会采用标记-整理算法。<code>Serial</code>收集器虽然是单线程，但是它相比于其他收集器有着简单高效的特点。对于内存资源受限的环境，它的内存消耗是最小的，而且内存资源小往往也意味着需要收集的对象少，因此停顿时间也不会很多。</p>
<h3 id="42-parnew收集器">4.2 <code>ParNew</code>收集器</h3>
<p>        <code>ParNew</code>收集器本质上是<code>Serial</code>收集器的多线程版本，也就是除了使用多条线程并行扫描新生代外，其余的包括算法、控制参数和回收策略等都和<code>Serial</code>收集器一致。<code>ParNew</code>收集器和<code>Serial</code>收集器是仅有的能够与<code>CMS</code>收集器一起配合工作的收集器，其中<code>ParNew</code>是激活<code>CMS</code>后的默认收集器。</p>
<h3 id="43-parallel-scavenge收集器">4.3 <code>Parallel Scavenge</code>收集器</h3>
<p>        <code>Parallel Scavenge</code>收集器是一款新生代收集器，同样基于标记-复制算法实现，支持并行收集。它的目标是使处理器达到一个可控的<em><strong>吞吐量</strong></em> ( $Throughput$ )，即用户代码运行时间与处理器运行时间的比值。由于与吞吐量密切相关，因此也被称作吞吐量优先收集器。<code>Parallel Scavenge</code>收集器提供了一种自适应的调节策略，允许虚拟机根据当前系统的运行情况实现动态调整<code>Java</code>堆中各个区域的大小。</p>
<h3 id="44-serial-old收集器">4.4 <code>Serial Old</code>收集器</h3>
<p>        <code>Serial Old</code>是<code>Serial</code>收集器的老年代版本，同样也是一个单线程收集器，使用标记-整理算法。在服务器模式下可能有两种用途：在<code>JDK 5</code>之前版本中与<code>Parallel Scavenge</code>收集器搭配使用，或者作为<code>CMS</code>收集器发生失败时后备预案。</p>
<h3 id="45-parallel-old收集器">4.5 <code>Parallel Old</code>收集器</h3>
<p>        <code>Parallel Old</code>是<code>Parallel Scavenge</code>的老年代版本，同样支持多线程，基于标记-整理算法。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑<code>Parallel Scavenge</code>和<code>Parallel Old</code>这个组合。</p>
<h3 id="46-cms收集器">4.6 <code>CMS</code>收集器</h3>
<p>        <code>CMS</code> ( $Concurrent\ \ Mark\ \ Sweep$ ) 收集器是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法。在<code>JDK 8</code>之后，<code>CMS</code>收集器逐渐被<code>G1</code>收集器所取代。它的运行过程分为四步：</p>
<ul>
<li><strong>初始标记</strong> ( $initial\ \ mark$ )：记录<code>GC Roots</code>的直接关联对象，需要停顿用户线程</li>
<li><strong>并发标记</strong> ( $concurrent\ \ mark$ )：从<code>GC Roots</code>的直接关联对象开始遍历对象图</li>
<li><strong>重新标记</strong> ( $remark$ )：修正并发标记期间因用户线程持续运作导致的标记变动，需要停顿用户线程</li>
<li><strong>并发清除</strong> ( $concurrent\ \ sweep$ )：删除已死亡的对象</li>
</ul>
<p>        <code>CMS</code>具有并发收集、低停顿的优点。但是具有三个明显的缺点：</p>
<ul>
<li>占用处理器资源。并发阶段虽然不会使用户线程停顿，但会因为占用线程而导致程序变慢，降低吞吐量。</li>
<li>无法处理<em><strong>浮动垃圾</strong></em> ( $Floating\ \ Garbage$ )，可能出现<em><strong>并发失败</strong></em> ( $Concurrent\ \ Mode\ \ Failure$ )。并发阶段，用户可能还在产生垃圾对象。但这部分对象出现在标记结束后，<code>CMS</code>无法收集，只能等待下次垃圾收集。同样也是由于并发执行，<code>CMS</code>不能像其他收集器那样直到老年代快被填满时才开始垃圾收集，只能设置一个阈值。而如果这部分预留的空间无法满足，就会出现并发失败。这时虚拟机只能冻结用户线程，临时启用<code>Serial Old</code>收集器。阈值可以通过 $-XX:CMSInitiatingOccu-pancyFraction$ 来设置。</li>
<li>产生空间碎片。基于标记-清除算法，因此收集结束会产生碎片，不利于之后大对象的分配。为此，<code>CMS</code>默认开启了碎片整理功能，会在进入<code>Full GC</code>时开始碎片整理。</li>
</ul>
<h3 id="47-garbage-first收集器">4.7 <code>Garbage First</code>收集器</h3>
<p>        <code>Garbage First</code>，简称<code>G1</code>收集器开创了收集器面向局部收集的设计思路和基于<code>Region</code>的内存布局形式，是一款主要面向服务端应用的垃圾收集器。在<code>G1</code>之前，收集器范围要么是新生代 ( <code>Minor GC</code> )，要么是老年代 ( <code>Major GC</code> )，要么是整个<code>Java</code>堆 ( <code>Full GC</code> )。而<code>G1</code>可以面向堆内存的任何部分组成<em><strong>回收集</strong></em> ( $Collection\ \ Set$, $CSet$ ) 进行回收，称为<code>Mixed GC</code>。实现这个的关键是基于<code>Region</code>的堆内存布局。<code>G1</code>不是按照固定大小和固定数量的分代区域划分，而是将<code>Java</code>堆分为多个等大连续的区域，可以通过参数 $-XX:G1HeapRegionSize$ 设置，大小应为 $2$ 的 $N$ 次幂，每一个区域都可以作为<code>Eden</code>、<code>Survivor</code>或者老年代。<code>Region</code>中有一特殊的<code>Humongous</code>区域，专门用于存储大对象，而对应超过<code>Region</code>的大对象，会用几个连续的<code>Humongous</code>存放。<code>G1</code>的大多数行为都会把<code>Humongous</code>作为老年代看待。<code>Region</code>是每次收集的最小单元，这样可以避免<code>Full GC</code>。收集器会跟踪每个<code>Region</code>里的垃圾价值，并在后台维护一个优先级列表，每次根据用户设定收集允许停顿时间，通过 $-XX:MaxGCPauseMillis$ 设置，优先处理价值大的<code>Region</code>。<br>
        <code>G1</code>收集器的每个<code>Region</code>都会维护一个记忆集，以哈希表的形式，$Key$ 为其他指向自己的<code>Region</code>的起始地址，$Value$ 为一个存储着卡表索引号的集合，代表着 $Key$ 指向<code>Region</code>的范围。也因为这种复杂的卡表，<code>G1</code>比其他垃圾收集器有着更高的内存占用。<br>
        为了保证标记的正确进行，<code>CMS</code>收集器使用了增量更新算法，而<code>G1</code>使用了原始快照算法。此外，<code>G1</code>收集器为每个<code>Region</code>设计了两个<code>TAMS</code> ( $Top\ \ at\ \ Mark\ \ Start$ ) 指针，并发回收时的新分配对象必须要在这两个指针的位置上，<code>G1</code>会默认它们是存活的。<code>G1</code>收集器仍然存在于<code>CMS</code>相同的并发失败问题，一旦发生并发失败，那么同样也需要停顿用户线程。<br>
        <code>G1</code>提供的 $-XX:MaxGCPauseMillis$ 参数可以设定允许停顿的时间，为此需要可靠的停顿预测模型，即预测停顿时间。<code>G1</code>通过<em><strong>衰减均值</strong></em> ( $Decaying\ \ Average$ ) 理论，记录每个<code>Region</code>的回收耗时、脏卡数量等，由此得出统计信息，从而得到平均状态。<br>
        可以将<code>G1</code>收集器的运作过程分为四步：</p>
<ul>
<li><strong>初始标记</strong> ( $Initial\ \ Marking$ )：标记<code>GC Roots</code>能直接关联到的对象，并修改<code>TAMS</code>指针的值，需要停顿用户线程，但耗时很短。</li>
<li><strong>并发标记</strong> ( $Concurrent\ \ Marking$ )：进行可达性分析，扫描完成后再处理<code>SATB</code>记录下的变动对象。</li>
<li><strong>最终标记</strong> ( $Final\ \ Marking$ )：处理并发阶段后仍然遗留的小部分<code>SATB</code>记录，需要短暂停顿用户线程。</li>
<li><strong>筛选回收</strong> ( $Live\ \ Data\ \ Counting\ \ and\ \ Evacuation$ )：更新<code>Region</code>的统计数据，对<code>Region</code>的回收价值和成本进行排序。根据用户的期望停顿时间，制定回收计划，会将决定回收部分的<code>Region</code>的存活对象复制到空<code>Region</code>中，清空原<code>Region</code>。存活对象移动的过程需要暂停用户线程。</li>
</ul>
<p>        从整体上看，<code>G1</code>基于标记-整理算法，但从局部上看，又是基于标记-复制算法，但无论如何，都意味着不会产生内存碎片。再者，由于<code>G1</code>的卡表复杂，因此不能像<code>CMS</code>那样通过写后屏障更新卡表，而是使用类似于消息队列的方式，再在之后异步处理。自<code>G1</code>开始，垃圾收集器的设计导向开始变为追求内存<em><strong>分配速率</strong></em> ( $Allocation\ \ Rate$ )，而非清理干净，所以可以说<code>G1</code>是收集器技术发展的一个里程碑。</p>
<h2 id="5-低延迟垃圾收集器">5. 低延迟垃圾收集器</h2>
<p>        衡量垃圾收集器最重要的三个指标：<em><strong>内存占用</strong></em> ( $Footprint$ )、<em><strong>吞吐量</strong></em> ( $Throughput$ ) 和<em><strong>延迟</strong></em> ( $Latency$ )。随着硬件的发展，延迟越来越重要。对于一些只进行短暂停顿的垃圾收集器，我们称为<strong>低延迟垃圾收集器</strong> ( $Low-Latency\ \ Garbage\ \ Collector$ / $Low-Pause-Time\ \ Garbage\ \ Collector$ )。</p>
<h3 id="51-shenandoah收集器">5.1 <code>Shenandoah</code>收集器</h3>
<p>        <code>Shenandoah</code>收集器是第一款不由<code>Oracle</code>公司的虚拟机团队领导开发的<code>HotSpot</code>垃圾收集器，被<code>OracleJDK</code>所排斥在外，只有<code>OpenJDK</code>才会包含，成为<code>OpenJDK 12</code>的正式特性之一。<code>Shenandoah</code>与<code>G1</code>有着很多相似性，包括堆内存布局，初始标记、并发标记等阶段的处理思路等。但是它支持并发整理算法，即可以多线程回收；没有分代，即不存在新生代和老年代；摒弃了记忆集，改为<em><strong>连接矩阵</strong></em> ( $Connection\ \ Matrix$ )。<code>Shenandoah</code>收集器工作过程可以划分为九个阶段：</p>
<ul>
<li><strong>初始标记</strong> ( $Initial\ \ Marking$ )：标记与<code>GC Roots</code>直接关联的对象，需要停顿用户线程。</li>
<li><strong>并发标记</strong> ( $Concurrent\ \ Marking$ )：遍历对象图，标记可达对象。</li>
<li><strong>最终标记</strong> ( $Final\ \ Marking$ )：处理剩余的<code>SATB</code>扫描，统计<code>Region</code>价值，需要停顿用户线程。</li>
<li><strong>并发清理</strong> ( $Concurrent\ \ Cleanup$ )：清理没有存活对象的<code>Region</code>。</li>
<li><strong>并发回收</strong> ( $Concurrent\ \ Evacuation$ )：将回收集的存活对象复制到未使用的<code>Region</code>中，但是要并发执行。</li>
<li><strong>初始引用更新</strong> ( $Initial\ \ Update\ \ Reference$ )：创建一个线程集合点，确保回收阶段中的线程都已完成任务，产生一个短暂的停顿。</li>
<li><strong>并发引用更新</strong> ( $Concurrent\ \ Update\ \ Reference$ )：将旧对象引用修正为新地址。</li>
<li><strong>最终引用更新</strong> ( $Final\ \ Update\ \ Reference$ )：修正<code>GC Roots</code>中的引用，需要停顿用户线程。</li>
<li><strong>并发清理</strong> ( $Concurrent\ \ Cleanup$ )：回收集中的<code>Region</code>已无存活对象，称为 $Immediate\ \ Garbage\ \ Regions$ ，清理这些区域。</li>
</ul>
<p>        <code>Shenandoah</code>收集器做到短停顿的关键在于实现并发对象移动。在之前，要实现并发移动，通常是在被移动对象内存上设置<em><strong>保护陷阱</strong></em> ( $Memory\ \ Protection\ \ Trap$ )，用户访问旧对象时会产生自陷中段，进入异常处理器中，再由异常处理器转发到新对象上。但是这种方案需要操作系统层面的支持，用户态要频繁地切换到核心态。<code>Shenandoah</code>使用了<code>Brooks Pointer</code>的概念，在对象结构前添加一个引用字段，在没有进行并发移动时指向自己，在并发移动时将其指向新对象。缺点也很明显，访问对象需要进行两次转发。此外，还要对转发指针进行同步，因为对旧对象进行写操作是无意义的，写操作只能对新对象进行，<code>Shenandoah</code>使用<em><strong>比较并交换</strong></em> ( $Compare\ \ And\ \ Swap$, $CAS$ ) 操作来保证并发时对象的访问正确性。</p>
<h3 id="52-zgc收集器">5.2 <code>ZGC</code>收集器</h3>
<p>        <code>ZGC</code> ( $Z\ \ Garbage\ \ Collector$ ) 是<code>JDK 11</code>中加入的低延迟垃圾收集器，但是与<code>Shenandoah</code>的实现思路具有显著差异。它基于<code>Region</code>内存布局，（暂时）不设分代，使用读屏障、<em><strong>染色指针</strong></em> ( $Colored\ \ Pointer$ ) 和内存多重映射等技术实现并发的标记-整理算法。<code>ZGC</code>中的<code>Region</code>/<code>Page</code>可以动态创建和摧毁，具有动态大小，其中小型和中型<code>Region</code>容量固定，用于存放小对象，而大型<code>Region</code>容量不定，存放大对象。染色指针是一种直接将少量信息存放在指针的技术。$64$ 位<code>Linux</code>系统中高 $18$ 位不能寻址，染色指针技术从剩余的 $46$ 位中提取 $4$ 位作为标志位，也因此该技术限制了内存大小，也不支持 $32$ 位平台。染色指针很好的解决了写屏障的问题，因为不需要再去专门记录对象指针的变动。但是也带来了新问题：操作系统无法识别标志位。<code>Linux/x86-64</code>平台上的<code>ZGC</code>使用了<em><strong>多重映射</strong></em> ( $Multi-Mapping$ )，将多个不同的虚拟内存地址映射到同一物理内存地址上，即多对一映射。以此，染色指针中的标志位可以视为分段符，只需要将这些地址段都映射到同一物理内存空间，就可以正常寻址了。<br>
        <code>ZGC</code>的工作流程可以分为四个阶段，全部都可以并发执行：</p>
<ul>
<li><strong>并发标记</strong> ( $Concurrent\ \ Mark$ )：遍历对象图做可达性分析，前后也需要进行初始标记和最终标记，并有短暂停顿。不同之处在于，标记阶段更新的是指针中的标志位。</li>
<li><strong>并发预备重分配</strong> ( $Concurrent\ \ Prepare\ \ for\ \ Relocate$ )：根据统计得出要清理的<code>Region</code>，组成<em><strong>重分配集</strong></em> ( $Relocation\ \ Set$ )。不同于记忆集，<code>ZGC</code>每次都会扫描全堆。</li>
<li><strong>并发重分配</strong> ( $Concurrent\ \ Relocate$ )：将重分配集中的存活对象复制到其他<code>Region</code>，并为集合中的每个<code>Region</code>维护一个<em><strong>转发表</strong></em> ( $Forward\ \ List$ )，用于记录旧对象到新对象的转向关系。当对象被访问时，如果其指针标志位标识其处于重分配集中，那么就会通过这个转发表转发到新对象地址，同时修正引用值，这种行为称为<em><strong>自愈</strong></em> ( $Self-Healing$ )。因为要保证自愈能力，所以重分配集中的<code>Region</code>在被清理时会保留转发表，直到其相关的指针引用修正完毕。</li>
<li><strong>并发重映射</strong> ( $Concurrent\ \ Remap$ )：修正堆中指向重分配集中旧对象的所有引用。由于指针具有自愈能力，所以这个阶段并不是非常必要的。因此<code>ZGC</code>中这一阶段并到了下一次垃圾收集的并发标记阶段，在每次遍历对象时修正对象引用。在所有指针修正完成后，释放原来的转发表。</li>
</ul>
<p>        虽然<code>ZGC</code>给用户线程带来的负担很小，但它不能承受太高的对象分配速率，因为它会将垃圾收集期间的新对象都视为存活对象，从而在过高的分配速率下产生大量的浮动垃圾。</p>
<h2 id="6-垃圾收集器的选择">6. 垃圾收集器的选择</h2>
<p>        衡量垃圾收集器的三个最重要的指标：内存占用、吞吐量和延迟。不同的垃圾收集器对这三个方面有不同的侧重点，同样的，不同的程序也对这三方面有着不同的要求。因此，可以根据这三方面进行选择。除此之外，收集器的选择还受到操作系统以及<code>JDK</code>发行商和版本的限制。</p>
<h3 id="61-epsilon收集器">6.1 <code>Epsilon</code>收集器</h3>
<p>        <code>Epsilon</code>是一款<em><strong>无操作的垃圾收集器</strong></em> ( $No-Op\ \ Garbage\ \ Collector$ )，因为它并不能进行垃圾收集，更准确的工作应该是负责内存管理，即堆内存管理布局、对象分配、与解释器和编译器的协作等。<code>Epsilon</code>的主要应用在一些小型<code>Java</code>程序中，即只需要运行几分钟甚至数秒的程序，而<code>Epsilon</code>得工作就是保证虚拟机正确分配内存，使程序能在内存耗尽前退出。</p>
<h3 id="62-虚拟机以及垃圾收集器日志">6.2 虚拟机以及垃圾收集器日志</h3>
<p>        每个收集器的日志格式可能都不一样，而且在<code>JDK 9</code>之前，<code>HotSpot</code>并没有提供统一日志框架，因此在其之前的日志系统很混乱。<code>JDK 9</code>之后，<code>HotSpot</code>将所有日志功能收归到了 $-Xlog$ 参数下。</p>
<pre><code>-Xlog[:[selector][:[output][:[decorator][:output-options]]]]
</code></pre><p>        $Selector$ 用于选取日志输出，由标签和日志级别组成，标签可以视为虚拟机中某个功能模块的名字，垃圾收集器的标签名为 $gc$。日志级别分为六级：$Trace$, $Debug$, $Info$, $Warning$, $Error$, $Off$ 。$Decorator$ 用于附加额外内容，如时间、进程<code>ID</code>等。</p>
<h2 id="7-内存分配与回收策略">7. 内存分配与回收策略</h2>
<ol>
<li>大多数情况下，对象在新生代<code>Eden</code>区中分配，当<code>Eden</code>中没有足够空间时，就会发起一次<code>Minor GC</code>。</li>
<li>大对象容易导致垃圾收集提前触发，同时具有高昂的复制开销，通过 $-XX:PretenureSizeThreshold$ 参数 ( 只对<code>Serial</code>和<code>ParNew</code>有效 )，所有大于指定值的对象都会直接分配在老年代，从而减少复制操作。</li>
<li>虚拟机给每个对象定义了一个年龄计数器，存储在对象头中。通常对象在<code>Eden</code>区中诞生，每经历一次<code>Minor GC</code>并且进入<code>Survivor</code>区，年龄便加一。到一定程度 ( 默认为 $15$ )，就会晋升至老年代，可以通过 $-XX:MaxTenuringThreshold$ 设置。不过为了更好的适应不同程序的内存状况，当<code>Survivor</code>中某个年龄的对象内存总和达到一半以上时，所有大于等于该年龄的对象都可以进行老年代。</li>
<li>在<code>Minor GC</code>之前，虚拟机要检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果为真，那么可以认为这次<code>Minor GC</code>是安全的；否则，查看 $-XX:HandlePromotionFailure$ 参数是否允许担保失败。如果允许，那么检查之前的最大可用连续空间是否大于历次晋升到老年对象的平均大小，如果小于将会尝试一次<code>Minor GC</code>。如果不允许，改为<code>Full GC</code>。但是在<code>JDK 6</code>之后，这个参数不再被使用，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行<code>Minor GC</code>，否则进行<code>Full GC</code>。</li>
</ol>

            </div>
            <div class="meta post-footer"> <span>2020 Aug 23 16:33</span> <a href="/post/jvm2%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
        <div class="post">
            
            <center>
                <h1><a href="/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/">JVM（1）：技术体系与内存区域</a></h1>
            </center>
            <div class="post-content">
                <h2 id="1-java技术体系">1. <code>Java</code>技术体系</h2>
<p>        从广义上来讲，<code>Kotlin</code>、<code>Clojure</code>、<code>JRuby</code>、<code>Groovy</code>等运行于<code>Java</code>虚拟机上的编程语言及其相关的程序都属于<code>Java</code>技术体系中的一员。从传统意义上来看，<code>JCP</code>官方所定义的<code>Java</code>技术体系包括以下几个部分：</p>
<ul>
<li><code>Java</code>程序设计语言</li>
<li>各种硬件平台上的<code>Java</code>虚拟机实现</li>
<li><code>Class</code>文件格式</li>
<li><code>Java</code>类库<code>API</code></li>
<li>来自商业机构和开源社区的第三方<code>Java</code>类库</li>
</ul>
<p>        我们可以把<code>Java</code>程序设计语言、<code>Java</code>虚拟机、<code>Java</code>类库这三部分统称为<code>JDK</code> ( $Java\ \ Development\ \ Kit$ ) ，<code>JDK</code>是用于支持<code>Java</code>程序开发的最小环境。可以把<code>Java</code>类库<code>API</code>中的<code>Java SE API</code>子集和<code>Java</code>虚拟机这两部分统称为<code>JRE</code> ( $Java\ \ Runtime\ \ Environment$ )，<code>JRE</code>是支持<code>Java</code>程序运行的标准环境。<br>
        以上是按照<code>Java</code>组成部分来进行划分，如果按照技术领域来划分，则可以分为以下四条：</p>
<ul>
<li><code>Java Card</code></li>
<li><code>Java ME</code></li>
<li><code>Java SE</code></li>
<li><code>Java EE</code></li>
</ul>
<h2 id="2-自动内存管理">2. 自动内存管理</h2>
<p>        <code>JVM</code>在执行<code>Java</code>程序的过程中会将内存划分为若干个不同的数据区域。</p>
<h3 id="21-程序计数器">2.1 程序计数器</h3>
<p>        <strong>程序计数器</strong> ( $Program\ \ Counter\ \ Register$ ) 是一块比较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。程序的分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器。在<code>JVM</code>中，一个处理器只会处理一个线程，多线程通过轮流切换来实现，因此每个线程都会有一个程序计数器。对于每个线程之间独立存储的内存，我们称之为“线程私有”内存。<br>
        <code>Java</code>中存在 $native$ 关键字，用于指示本地方法。通过 $native$ 关键字，<code>Java</code>程序可以调用本地应用（或库），也可以被其他程序调用。对于本地方法，在执行过程中，程序计数器的值为空 ( $Undefined$ )。而对于<code>Java</code>方法 ( 也就是字节码 ) ，程序计数器的值为正在执行的虚拟机字节码的指令地址。</p>
<h3 id="22-java虚拟机栈">2.2 <code>Java</code>虚拟机栈</h3>
<p>        <code>Java</code><strong>虚拟机栈</strong> ( $Java\ \ Virtual\ \ Machine\ \ Stack$ ) 描述的是<code>Java</code>方法执行的线程内存模型。与程序计数器一样，它也是线程私有的。在每个方法被执行时，<code>JVM</code>都会同步创建一个<strong>栈帧</strong> ( $Stack\ \ Frame$ ) 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。在方法被调用时，这个栈帧会被压入<code>Java</code>虚拟机栈。当方法执行完毕时，其对应的栈帧也会被从<code>Java</code>虚拟机栈中弹出。如果将<code>Java</code>的内存区域像<code>C</code>/<code>C++</code>那样简单地划分为<em><strong>堆内存</strong></em> ( $Heap$ ) 和<em><strong>栈内存</strong></em> ( $Stack$ )，那么这里的虚拟机栈就可以视为栈内存。<br>
        局部变量表中存储基本数据类型、对象引用以及 $returnAddress$ 类型 ( 指向一条字节码指令的地址 )。这些数据类型在局部变量表中以局部变量槽 ( $Slot$ ) 表示。对于 $64$ 位长度的 $long$ 和 $double$ 类型，它们将会占用两个槽。其余数据类型只占用一个。局部变量表的大小是在进入方法时就已确定的，不会随着运行而改变。<br>
        当线程请求的栈深度大于虚拟机允许的深度时就会抛出 $StackOverflowError$ 异常。<code>Java</code>虚拟机栈的容量允许动态扩展。如果在扩展时无法申请到足够内存，那么就会抛出 $OutOfMemoryError$ 异常。</p>
<h3 id="23-本地方法栈">2.3 本地方法栈</h3>
<p>        <strong>本地方法栈</strong> ( $Native\ \ Method\ \ Stacks$ ) 类似于虚拟机栈，但不同之处在于其为本地方法服务。《<code>Java</code>虚拟机规范》中并未规定如何实现，因此在不同的虚拟机中，其实现可能都是不同的。甚至有的虚拟机直接将其与<code>Java</code>虚拟机栈合二为一。本地方法栈抛出的异常的条件和类型也与<code>Java</code>虚拟机栈一样。</p>
<h3 id="24-java堆">2.4 <code>Java</code>堆</h3>
<p>        <code>Java</code><strong>堆</strong> ( $Java\ \ Heap$ ) 是虚拟机管理内存中最大的一块，在虚拟机启动时创建，被所有线程所共享，用于存放对象实例。<code>Java</code>堆也被叫做<code>GC</code>堆 ( $Garbage\ \ Collected\ \ Heap$ )，因为它是垃圾收集器所管理的内存区域。类似于磁盘空间，<code>Java</code>堆在物理上可以是不连续的内存空间，但在逻辑上是连续的。<code>Java</code>堆可以是固定的，也可以是可扩展的，分别通过 $+Xmx$ 和 $+Xms$ 设置。在实例分配的过程中，如果没有足够的内存去分配，也无法再扩展时，就会抛出 $OutOfMemoryError$ 异常。</p>
<h3 id="25-方法区">2.5 方法区</h3>
<p>        <strong>方法区</strong> ( $Method\ \ Area$ ) 也是一块多线程共享区域，用于存储已被加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存等数据。在《<code>Java</code>虚拟机规范》中，方法区是堆的一个逻辑部分，但是为了与堆区分，它有个别名叫<em><strong>非堆</strong></em> ( $Non-Heap$ )。和<code>Java</code>堆一样，方法区可以是固定大小，也可以扩展。但与之不同的是，方法区可以不实现垃圾收集。如果方法区无法满足新内存的分配需求，就会抛出 $OutOfMemoryError$ 异常。</p>
<h3 id="26-运行时常量池">2.6 运行时常量池</h3>
<p>        <strong>运行时常量池</strong> ( $Runtime\ \ Constant\ \ Pool$ ) 是方法区的一部分。<code>Class</code>文件中除了类的版本、字段、方法、接口等信息外，还包括<em><strong>常量池表</strong></em> ( $Constant\ \ Pool\ \ Table$ )，用于存放编译期生成的字面量与符号引用。这部分内容会存放在运行时常量池中。除了存储符号引用外，还可以存储由符号引用直接翻译过来的直接引用。相比于<code>Class</code>文件常量池，运行时常量池是动态的，即允许运行期间产生的常量放入运行时常量池。最为常见的例子就是 $String.intern(\ )$ 方法。该方法将在常量池中查找字符串并返回，对于没有的字符串则会创建。当常量池无法再申请到内存时，会抛出 $OutOfMemoryError$ 异常。</p>
<h3 id="27-直接内存">2.7 直接内存</h3>
<p>        在 $java.nio$ 中引入了一种基于<em><strong>通道</strong></em> ( $Channel$ ) 与<em><strong>缓冲区</strong></em> ( $Buffer$ ) 的<code>I/O</code>方式，可以使用 $Native$ 函数库直接分配堆外内存，然后通过一个存储在<code>Java</code>堆内的 $DirectByteBuffer$ 对象作为内存引用进行操作。<strong>直接内存</strong> ( $Direct\ \ Memory$ ) 指的就是这块由本机直接分配，不受<code>Java</code>堆大小限制的内存，它并不是虚拟机运行时数据区的一部分。虽然不会受到<code>Java</code>堆大小限制，但仍然会受到本机内存大小和寻址空间的限制。在配置虚拟机参数时，如果直接根据实际内存来设置<code>JVM</code>内存，忽略了可能存在的直接内存，那么就会出现各内存区域总和大于物理内存的情况，就会抛出 $OutOfMemoryError$ 异常。</p>
<h2 id="3-hotspot虚拟机对象">3. <code>HotSpot</code>虚拟机对象</h2>
<h3 id="31-对象创建">3.1 对象创建</h3>
<p>        当<code>JVM</code>遇到 $new$ 时，会检查其参数能否定位到一个类的符号引用，再去检查该引用是否已被加载、解析和初始化。如果没有，那么就会执行类加载过程。在类加载完毕后，虚拟机将为对象分配内存。内存分配完毕后，<code>JVM</code>会将内存空间除对象头之外的内容都设为零值。之后，<code>JVM</code>还要设置对象信息，比如实例信息、元数据信息、哈希码、<code>GC</code>分代年龄等信息。这一部分信息称为<strong>对象头</strong> ( $Object\ \ Header$ ) 信息。一般情况下，接下来对象的构造函数，也即<code>Class</code>文件的 &lt;$init$&gt;$(\ \ )$ 方法会被调用，这时一个对象才算真正创建完毕。<br>
        在类加载的过程中，对象所需的内存空间就已确定。如果<code>Java</code>堆是规整的，即已被分配的内存未被分配的内存分置于两边，中间使用一指针隔开，那么分配内存的时候只需要将指针向未被分配的内存方向移动需分配的内存大小即可，这种分配方式称为<strong>指针碰撞</strong> ( $Bump\ \ The\ \ Pointer$ )。相反，如果<code>Java</code>堆是散乱的，即已被分配和未被分配的内存之间交错分布，那么就需要一个列表来记录哪些内存块已被分配，哪些内存块未被分配，这种分配方式称为<strong>空闲列表</strong> ( $Free\ \ List$ )。要想保证<code>Java</code>堆的规整，那么垃圾收集器就要有<em><strong>空间压缩整理</strong></em> ( $Compact$ ) 能力。与之对应的是<em><strong>清除</strong></em> ( $Sweep$ ) 算法的收集器，并不能保证<code>Java</code>堆的规整。<br>
        对象创建是一个非常频繁的行为，如果不能保证同步，那么可能就会出现在前一块内存还未分配给该指针时，后一块内存就准备分配给该指针的情况。解决方案有两种：同步分配内存的操作，或者通过线程将分配内存的操作划分在不同空间中进行。后一种方案称为<strong>本地线程分配缓冲</strong> ( $Thread\ \ Local\ \ Allocation\ \ Buffer$, $TLAB$ ) ，即预先在<code>Java</code>堆中给每个线程分布一小块内存，在对象创建时会先在这块本地缓冲区中分配，这样就避免了同步问题。当本地缓冲区不够时，才进行同步操作。可以通过 $-XX:+/-UserTLAB$ 来设定是否使用 $TLAB$ 。如果使用了 $TLAB$ ，将已分配的内存空间清零的操作也可以提前到分配本地缓冲区时进行。</p>
<h3 id="32-对象内存">3.2 对象内存</h3>
<p>        对象内存可以划分为三部分：<strong>对象头</strong> ( $Header$ )、<strong>实例数据</strong> ( $Instance\ \ Data$ ) 和<strong>对齐填充</strong> ( $Padding$ )。<br>
        对象头包括运行时数据和类型指针。运行时数据如哈希码、<code>GC</code>分代年龄、锁状态标志、线程锁、偏向线程<code>ID</code>、偏向时间戳等，在 $32$ 位和 $64$ 位虚拟机中分别为 $32$ 位和 $64$ 位的 $Bitmap$ 结构，称为 $Mark\ \ Word$ 。$Mark\ \ Word$ 被设计为动态的，含有两个标志位，用于标识其存储内容。在不同状态下，改变标志位即可表明存储内容。类型指针是一个指向对象元数据的指针，<code>JVM</code>通过该指针来确定对象是哪个类的实例。但并不是所有虚拟机都会保留类型指针。此外，如果对象是一个数组，那么对象头中还会有一块区域记录数组长度，因为通过元数据只能确定对象的大小，但在不知道数组长度的情况下是无法知道整个数组的大小的。<br>
        实例数据部分，即对象真正储存信息的部分。对象中的字段，无论是继承的，还是子类中定义的，都要记录。存储顺序受到<code>JVM</code>的分配策略的影响，通过 $-XX:FieldsAllocationStyle$ 参数可以设置分配策略。默认的分配顺序为 $longs$ / $doubles$、$ints$ 、$shorts$ / $chars$、$bytes$ / $booleans$、$oops$ ( $Ordinary\ \ Object\ \ Pointers$ )，也即相同长度的字段会存放在一起。在这个前提下，父类字段会在子类字段之前。$+XX:CompactFields$ 参数默认为 $true$ ，代表允许子类中较短的字段插入父类中较长字段的缝隙中。<br>
        对齐填充并非必要，仅仅作为占位符使用。因为<code>HotSpot</code>虚拟机中对象的起始地址必须是八字节整数，因此需要对齐填充来保证对象的长度足够。</p>
<h3 id="33-对象访问">3.3 对象访问</h3>
<p>        《<code>Java</code>虚拟机规范》中并未定义 $reference$ 类型应该如何去定位和访问对象，因此对象访问方式是由虚拟机决定的。主要的访问方式有句柄和直接指针。如果使用句柄，<code>Java</code>堆中会划出来一块句柄池，$reference$ 指向句柄地址，句柄中包含了对象实例数据和类型数据的地址。如果使用直接指针，对象数据就会直接存放在<code>Java</code>堆中，$reference$ 就直接指向对象地址。<code>HotSpot</code>虚拟机中使用的是直接指针。</p>
<h2 id="4-outofmemoryerror">4. <code>OutOfMemoryError</code></h2>
<h3 id="41-java堆">4.1 <code>Java</code>堆</h3>
<p>        <code>Java</code>堆的 $OutOfMemoryError$ 异常是实际应用中最常见的内存溢出异常：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
</code></pre><p>        异常堆栈信息 $java.lang.OutOfMemoryError$ 之后会跟随 $Java\ \ heap\ \ space$ 。最常规的解决方案是通过内存映像分析工具 ( $Eclipse\ \ Memory\ \ Analyzer$ ) 对 $Dump$ 出的堆转储快照进行分析。要让虚拟机在内存溢出时 $Dump$ 出内存堆转储快照，可以通过参数 $-XX:+HeapDumpOnOutOfMemoryError$ 进行设置。第一步要先分清楚是<strong>内存泄漏</strong> ( $Memory\ \ Leak$ ) 还是<strong>内存溢出</strong> ( $Memory\ \ Overflow$ )。如果是内存泄漏，可以通过进一步工具找到泄露位置。而如果是内存溢出，那么就要检查虚拟机堆参数 ( $+Xmx$ 和 $+Xms$ )，再检查代码，尽量减少不合理的内存消耗。</p>
<h3 id="42-虚拟机栈和本地方法栈">4.2 虚拟机栈和本地方法栈</h3>
<p>        <code>HotSpot</code>虚拟机并没有区分虚拟机栈和本地方法栈，因此设置本地方法栈大小的参数 $+Xoss$ 虽然可以使用，但是没有任何效果。虚拟机栈和本地方法栈只能通过 $+Xss$ 参数设定。如之前讲述的一样，虚拟机栈和本地方法栈可能抛出 $StackOverflowError$ 和 $OutOfMemoryError$ 。<code>HotSpot</code>虚拟机不支持动态扩展栈，因此出现 $OutOfMemoryError$ 的情况只有最初创建线程时就无法申请到足够的内存的情况。在一般情况下，使用<code>HotSpot</code>虚拟机的默认参数下，对于一般的方法调用是足够的。但是如果是因为多线程导致的溢出，就需要减小最大堆和减小栈容量换取更多线程。当出现这种问题，报错信息会注明 $possibly\ \ out\ \ of\ \ memory\ \ or\ \ process/resource\ \ limits\ \ reached$ 。</p>
<h3 id="43-方法区和运行时常量池">4.3 方法区和运行时常量池</h3>
<p>        在<code>JDK6</code>之前的<code>HotSpot</code>虚拟机中，常量池都是分配在永久代中的，使用 $+XX:PermSize$ 和 $+XX:MaxPermSize$ 可以限制永久代大小。在这种情况下，异常信息会注明 $PermGEn\ \ space$ 。自<code>JDK7</code>起，字符串常量池被移至<code>Java</code>堆中。方法区溢出的条件比较苛刻，可能会出现在需要生成大量动态类的场景中。<code>JDK8</code>之后，永久代不再使用，元空间取而代之。<code>HotSpot</code>提供了一些参数：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">$+XX:MaxMetaspaceSize$</td>
<td align="left">元空间最大值，默认为 $-1$ ，即不限制。</td>
</tr>
<tr>
<td align="center">$+XX:MetaspaceSize$</td>
<td align="left">元空间初始大小，单位为字节，超过了该值就会触发垃圾收集。</td>
</tr>
<tr>
<td align="center">$+XX:MinMetaspaceFreeRatio$</td>
<td align="left">垃圾收集后元空间的最小剩余容量百分比。</td>
</tr>
<tr>
<td align="center">$+XX:MaxMetaspaceFreeRatio$</td>
<td align="left">垃圾收集后元空间的最大剩余容量百分比。</td>
</tr>
</tbody>
</table>
<h3 id="44-直接内存">4.4 直接内存</h3>
<p>        直接内存可以通过 $+X:MaxDirectMemorySize$ 参数指定，未指定则默认等同于<code>Java</code>堆 ( $+Xmx$ ) 大小。由直接内存溢出导致的异常，在 $Heap\ \ Dump$ 文件中不会有任何明显异常情况。如果发现 $Dump$ 文件很小，同时程序中又使用了例如 $NIO$ 等类，那么可能就是直接内存溢出导致的异常。</p>

            </div>
            <div class="meta post-footer"> <span>2020 Aug 19 19:42</span> <a href="/post/jvm1%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%8E%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"><i
                        class="fas fa-link"></i> link</a></div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2020, z217 and the Hugo Authors; all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>


<script type="text/javascript" async
    src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>
<script src=https://z217blog.cn/js/navbutton.js></script>
<script src=https://z217blog.cn/js/tocbutton.js></script>

</html>