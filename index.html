<!DOCTYPE html>
<html><head>
	<meta name="generator" content="Hugo 0.92.2" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A personal blog of z217">
  <meta name="Author" content="z217">
  <meta name="keywords" content="hugo blog">
  <link rel="icon" type="image/x-icon" href=https://z217blog.cn/favicon.ico>
  <link rel="stylesheet" href=https://z217blog.cn/css/syntax.css>
  <link rel="stylesheet" href=https://z217blog.cn/css/style.css>
  <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
  
  <title>z217&#39;s blog</title>
</head><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
    integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src=https://z217blog.cn/js/navbutton.js></script>

<body><aside id="sidenav">
    <header>
        
        <a href=https://z217blog.cn><img src="https://z217blog.cn/avatar.png" alt="avatar"></a>

        

        <a id="branding" href=https://z217blog.cn>
            
            z217&#39;s blog
            
        </a>
    </header>

    <nav>
        
        
        <a href="/" >
            <i class="fas fa-home fa-ms"></i>
            <span>首页</span>
        </a>
        
        
        <a href="/post/" >
            <i class="fas fa-keyboard fa-ms"></i>
            <span>文章</span>
        </a>
        
        
        <a href="/tags" >
            <i class="fas fa-tags fa-sm"></i>
            <span>标签</span>
        </a>
        
        
        <a href="/about" >
            <i class="fas fa-user fa-ms"></i>
            <span>关于</span>
        </a>
        
        
        <a href="https://github.com/z217"  target="_blank" >
            <i class="fab fa-github fa-ms"></i>
            <span>Github</span>
        </a>
        
        
        <a href="/index.xml" >
            <i class="fas fa-rss fa-sm"></i>
            <span>RSS</span>
        </a>
        
        
        <a href="/friend" >
            <i class="fas fa-map fa-sm"></i>
            <span>友链</span>
        </a>
        
    </nav>
</aside><main id="main">
        <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
        <div class="content">




<div class="section">
    <div class="section-title">recent</div>
    
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B17/">Unix网络编程（17）：消息队列</a>
        
        
        <p>《Unix网络编程》读书笔记（17）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 20 14:01
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B16/">Unix网络编程（16）：管道和FIFO</a>
        
        
        <p>《Unix网络编程》读书笔记（16）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 19 14:31
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/">Unix网络编程补充：套接字选项</a>
        
        
        <p>《Unix网络编程》读书笔记补充</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 18 18:28
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B15/">Unix网络编程（15）：程序设计范式</a>
        
        
        <p>《Unix网络编程》读书笔记（15）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 18 14:37
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
    <div class="list-item">
        <a class="entry-title" href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B14/">Unix网络编程（14）：线程</a>
        
        
        <p>《Unix网络编程》读书笔记（14）</p>
        
        <div class="meta">
            
            <i class="far fa-calendar-alt"></i> 2022 Feb 17 14:28
            
            <br>
            
            <i class="fas fa-tags"></i>
            Tags: Web, C&C++
            
        </div>
    </div>
    
</div>



<div class="section">
    <div class="section-title">μblog</div>
    <div class="posts">
        
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B17/">Unix网络编程（17）：消息队列</a></h1>
            <div class="post-content">
                <p>        消息队列可认为是一个消息链表，有足够写权限的线程可往队列中放置消息，有足够读权限的线程可从队列中取走消息。每个消息都是一个记录，它由发送者赋予一个优先级。与管道和<code>FIFO</code>不同，在某个进程往一个队列写入消息前，并不需要另外某个进程在该队列上等待消息到达。</p>
<h2 id="1-mq_openmq_close和mq_unlink函数">1. <code>mq_open</code>、<code>mq_close</code>和<code>mq_unlink</code>函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回消息队列描述符，出错返回-1
</span><span class="c1"></span><span class="n">mqd_t</span> <span class="nf">mq_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="p">...</span>
  <span class="cm">/* mode_t mode, struct aq_attr *attr */</span> <span class="p">);</span>

<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_close</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">);</span>

<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_unlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</code></pre></div><p>        $oflag$ 参数是 $O_-RDONLY$ 、$O_-WRONLY$ 或 $O_-RDWR$ 之一，并且可以按位或 $O_-CREAT$ 、$O_-EXCL$ 或 $O_-NONBLOCK$ 。当实际操作是创建一个新队列时 ( 指定 $O_-CREAT$ 且请求的消息队列不存在 )，需要 $mode$ 和 $attr$ 参数。$mq_-close$ 调用类似于 $close$ 调用，调用之后消息队列不会从系统中删除。当一个进程终止时，它的所有打开着的消息队列会被关闭。如果要从系统中删除一个消息队列，则需要调用 $mq_-unlink$ ，类似于 $unlink$ ，当一个消息队列的打开计数大于 $0$ 时，不会立即删除，而是直到该消息队列真正被关闭时才会删除。<code>POSIX</code>消息队列至少具备随内核的持续性，这意味着即使当前没有进程打开着消息队列，其中的消息也将一直存在，直到被删除。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
  <span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>

  <span class="n">flags</span> <span class="o">=</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">Getopt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&#34;e&#34;</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;e&#39;</span><span class="o">:</span>
      <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_EXCL</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">optind</span> <span class="o">!=</span> <span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqcreate [ -e ] &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="n">mql</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">optind</span><span class="p">],</span> <span class="n">flags</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">Mq_close</span><span class="p">(</span><span class="n">mqd</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        允许有一个排他选项 $-e$ 创建消息队列。通过 $getopt$ 获取这个选项，$getopt$ 会在 $optind$ 中存放待处理的下一个参数的下标。</p>
<h2 id="2-mq_getattr和mq_setattr函数">2. <code>mq_getattr</code>和<code>mq_setattr</code>函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_getattr</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">);</span>

<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_setattr</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mq_attr</span> <span class="o">*</span><span class="n">oattr</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">mq_attr</span> <span class="p">{</span>
  <span class="kt">long</span> <span class="n">mq_flags</span><span class="p">;</span>  <span class="c1">// message queue flag: 0, O_NONBLOCK
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">mq_maxmsg</span><span class="p">;</span>  <span class="c1">// max number of messages allowed on queue
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">mq_msgsize</span><span class="p">;</span>  <span class="c1">// max size of a message (in bytes)
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">mq_curmsgs</span><span class="p">;</span>  <span class="c1">// number of messages currently on queue
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><p>        $mq_-attr$ 结构指针可以作为 $mq_-open$ 的第四个参数传递，从而允许我们在该函数的实际操作是创建一个新队列时，为它指定 $mq_-maxmsg$ 和 $mq_-msgsize$ 属性，其他两个属性会被忽略。$mq_-setattr$ 为所指队列设置属性，但是只使用 $mq_-flags$ ，用于设置或清除非阻塞标志。另外，如果 $oattr$ 非空，当前队列的先前属性会返回到 $oattr$ 中。</p>
<h2 id="3-mq_send和mq_receive函数">3. <code>mq_send</code>和<code>mq_receive</code>函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_send</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">);</span>

<span class="c1">// 成功返回消息字节数，出错返回-1
</span><span class="c1"></span><span class="n">ssize_t</span> <span class="nf">mq_receive</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">priop</span><span class="p">);</span>
</code></pre></div><p>        这两个函数分别用于往消息队列放置一个消息和从消息队列中取出一个消息。每个消息都对应一个优先级 $prio$ ，它是一个小于 $MQ_-PRIO_-MAX$ 的无符号整数，<code>POSIX</code>要求这个上限最小为 $32$ 。$mq_-receive$ 总是会取出队列中优先级最高的最早发送的消息，并且该优先级会和消息长度一起返回。$mq_-receive$ 的 $len$ 不能小于消息队列中的消息最大大小，如果小于，会返回 $EMSGSIZE$ 错误。如果应用不必使用优先级不同的消息，可以统一将优先级指定为 $0$ ，并将 $mq_-receive$ 的最后一个参数指定为 $NULL$ 。</p>
<h2 id="4-消息队列限制">4. 消息队列限制</h2>
<p>        消息队列存在两个限制，都是在创建队列时指定的：</p>
<ul>
<li>$mq_-mqxmsg$ ：队列中的最大消息数；</li>
<li>$mq_-msgsize$ ：给定消息的最大字节数。</li>
</ul>
<p>        消息队列的实现定义了另外两个限制：</p>
<ul>
<li>$MQ_-OPEN_-MAX$ ：一个进程能够同时拥有的打开着的消息队列的最大数目 ( <code>POSIX</code>要求至少为 $8$ )；</li>
<li>$MQ_-PRIO_-MAX$ ：任意消息的最大优先级加 $1$ ( <code>POSIX</code>要求至少为 $32$ )。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;MQ_OPEN_MAX = %ld, MQ_PRIO_MAX = %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
    <span class="n">Sysconf</span><span class="p">(</span><span class="n">_SC_MQ_OPEN_MAX</span><span class="p">),</span> <span class="n">Sysconf</span><span class="p">(</span><span class="n">_SC_MQ_PRIO_MAX</span><span class="p">));</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="5-mq_notify函数">5. <code>mq_notify</code>函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;mqueue.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mq_notify</span><span class="p">(</span><span class="n">mqd_t</span> <span class="n">mqdes</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sigevent</span> <span class="o">*</span><span class="n">notification</span><span class="p">);</span>
</code></pre></div><p>        <code>POSIX</code>消息队列允许<strong>异步事件通知</strong> ( $asynchronous$ $event$ $notification$ )，用于告知何时有一个消息被放置到空的消息队列中。这种通知有两种方式可以选择：</p>
<ul>
<li>产生一个信号；</li>
<li>创建一个线程来执行一个指定的函数。</li>
</ul>
<p>        $mq_-notify$ 为指定的消息队列建立或删除异步事件通知。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">union</span> <span class="n">sigval</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sival_int</span><span class="p">;</span>  <span class="c1">// integer value
</span><span class="c1"></span>  <span class="kt">void</span> <span class="o">*</span><span class="n">sival_ptr</span><span class="p">;</span>  <span class="c1">// pointer value
</span><span class="c1"></span><span class="p">};</span>

<span class="k">struct</span> <span class="n">sigevent</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sigev_notify</span><span class="p">;</span>  <span class="c1">// SIGEV_{NONE, SIGNAL, THREAD}
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">sigev_signo</span><span class="p">;</span>  <span class="c1">// signal number if SIGEV_SIGNAL
</span><span class="c1"></span>  <span class="k">union</span> <span class="n">sigval</span> <span class="n">sigev_value</span><span class="p">;</span>  <span class="cm">/* passed to signal handler or thread
</span><span class="cm">                                following two if SIGEV_THREAD */</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sigev_notifiy_function</span><span class="p">)(</span><span class="k">union</span> <span class="n">sigval</span><span class="p">);</span>
  <span class="n">pthread_attr_t</span> <span class="o">*</span><span class="n">sigev_notify_attributes</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div><ol>
<li>如果 $notification$ 非空，那么当前进程希望在有一个消息到达前得到通知；</li>
<li>如果 $notification$ 为空，而且当前进程已被注册接收指定队列的通知，那么撤销先前的注册；</li>
<li>任意时刻只有一个进程可以被注册接收某个指定队列的通知；</li>
<li>当有一个消息到达某个先前为空的队列，而且已有一个进程被注册为接收该队列的通知时，只有在没有任何线程阻塞在该队列的 $mq_-receive$ 调用的前提下，通知才会发出。即，$mq_-receive$ 优于注册通知；</li>
<li>当通知被发送给注册进程时，注册即被撤销。如果想要再次接收通知，需要再次注册。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifysig1 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// open queue, get attributes, allocate read buffer
</span><span class="c1"></span>  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

  <span class="c1">// establish signal handler, enable notification
</span><span class="c1"></span>  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr1</span><span class="p">);</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">SIGUSR1</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span>
    <span class="n">pause</span><span class="p">();</span>  <span class="c1">// signal hadler does everything
</span><span class="c1"></span>  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">vodi</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>

  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister first
</span><span class="c1"></span>  <span class="n">n</span> <span class="o">=</span> <span class="n">Mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;SIGUSR1 received, read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="51-异步信号安全函数">5.1 异步信号安全函数</h3>
<p>        上述程序的问题是它在信号处理程序中调用 $mq_-notify$ 、$mq_-receive$ 和 $printf$ 。这些函数实际上都不可以在信号处理程序中调用。<code>POSIX</code>使用<strong>异步信号安全</strong> ( $async-signal-safe$ ) 这个术语描述可以在信号处理函数中调用的函数。</p>
<p>$$
\begin{array}{|c|c|c|c|}
\hline
access &amp; fpathconf &amp; rename &amp; sysconf\\
aio_-return &amp; fstat &amp; rmdir &amp; tcdrian \\
aio_-suspend &amp; fsync &amp; sem_-post &amp; tcflow \\
alarm &amp; getegid &amp; setgit &amp; tcflush \\
cfgetispeed &amp; geteuid &amp; setpgid &amp; tcgetattr \\
cfgetospeed &amp; getpgrp &amp; sigaction &amp; tcsetattr \\
chdir &amp; getpid &amp; sigaddset &amp; tcsetpgrp \\
chmod &amp; getppid &amp; sigdelset &amp; time \\
chown &amp; getuid &amp; sigemptyset &amp; timer_-getoverrun \\
clock_-gettime &amp; kill &amp; sigfillset &amp; timer_-gettime \\
close &amp; link &amp; sigismember &amp; timer_-settime \\
creat &amp; lseek &amp; signal &amp; times \\
dup &amp; mkdir &amp; sigpause &amp; umask \\
dup2 &amp; mkfifo &amp; sigpending &amp; uname \\
execle &amp; open &amp; sigprocmask &amp; unlink \\
execve &amp; pathconf &amp; sigqueue &amp; utim \\
_-exit &amp; pause &amp; sigset &amp; wait \\
fcntl &amp; pipe &amp; sigsuspend &amp; waitpid \\
fdatasync &amp; raise &amp; sleep &amp; write \\
fork &amp; read &amp; stat \\
\hline
\end{array}
$$</p>
<p>        没有列在上表中的函数不能在信号处理函数中调用。注意所有标准<code>I/O</code>函数和 $pthread_-XXX$ 函数都没有列在其中。<code>IPC</code>相关函数只有 $sem_-post$ 、$read$ 和 $write$ 在其中。<br>
        避免从信号处理程序中掉哟该任何函数的办法之一是让处理函数仅仅设置一个全局标志，再由某个线程检查该标志以确定何时收到消息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">volatile</span> <span class="n">sig_atomic_t</span> <span class="n">mqflag</span><span class="p">;</span> <span class="c1">// set nonzero by signal handler
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">sigset_t</span> <span class="n">zeromask</span><span class="p">,</span> <span class="n">newmask</span><span class="p">,</span> <span class="n">oldmask</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifysig2 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// open queue, get attributes, allocate read buffer
</span><span class="c1"></span>  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>  <span class="c1">// no signals block
</span><span class="c1"></span>  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmask</span><span class="p">);</span>
  <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

  <span class="c1">// establish signal handler, enable notification
</span><span class="c1"></span>  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr1</span><span class="p">);</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">SIGUSR1</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">);</span>  <span class="c1">// block SIGUSR1
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">mqflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>
    <span class="n">mqflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// reset flag
</span><span class="c1"></span>
    <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister first
</span><span class="c1"></span>    <span class="n">n</span> <span class="o">=</span> <span class="n">Mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// unblock SIGUSR1
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">mqflag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="52-非阻塞的信号通知">5.2 非阻塞的信号通知</h3>
<p>        上面的程序还存在一个问题，那就是<code>Unix</code>的信号是不排队的，如果有两个消息到达，我们的程序只会处理一个。解决办法是使用非阻塞模式读取消息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">sigset_t</span> <span class="n">zeromask</span><span class="p">,</span> <span class="n">newmask</span><span class="p">,</span> <span class="n">oldmask</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifysig3 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// open queue, get attributes, allocate read buffer
</span><span class="c1"></span>  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>  <span class="c1">// no signals blocked
</span><span class="c1"></span>  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldmask</span><span class="p">);</span>
  <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

  <span class="c1">// establish signal handler, enable notification
</span><span class="c1"></span>  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr1</span><span class="p">);</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">SIGUSR1</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldmask</span><span class="p">);</span>  <span class="c1">// block SIGUSR1
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">mqflag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span><span class="p">);</span>
    <span class="n">mqflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// reset flag
</span><span class="c1"></span>
    <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister first
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span>
      <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;mq_receive error&#34;</span><span class="p">);</span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// unblock SIGUSR1
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="53-sigwait函数">5.3 <code>sigwait</code>函数</h3>
<p>        上述程序尽管正确，但是效率还可以更高。因为我们的程序是通过 $sigsuspend$ 阻塞的，直到 $mqflag$ 非零，更高效的办法是只等待 $SIGUSR1$ 而不是任意一个信号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回非负错误码
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">sigwait</span><span class="p">(</span><span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sig</span><span class="p">);</span>
</code></pre></div><p>        $sigwait$ 会阻塞等待信号集 $set$ 中的某个信号返回，返回时设置 $sig$ ，标识产生的信号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">signo</span><span class="p">;</span>
  <span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">sigset_t</span> <span class="n">newmask</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifysig4 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// open queue, get attributes, allocate read buffer
</span><span class="c1"></span>  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

  <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">);</span>
  <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>
  <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// block SIGUSR1
</span><span class="c1"></span>
  <span class="c1">// establish signal handler, enable notification
</span><span class="c1"></span>  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">SIGUSR1</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Sigwait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">signo</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGUSR1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister first
</span><span class="c1"></span>      <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;mq_receive error&#34;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="54-select函数">5.4 <code>select</code>函数</h3>
<p>        消息队列描述符 $mqd_-t$ 不能用于 $select$ 或 $poll$ 。然而我们可以通过管道结合 $mq_-notify$ 使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">nfds</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">fd_set</span> <span class="n">rset</span><span class="p">;</span>
  <span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifysig5 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="c1">// open queue, get attributes, allocate read buffer
</span><span class="c1"></span>  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>

  <span class="n">Pipe</span><span class="p">(</span><span class="n">pipefd</span><span class="p">);</span>

  <span class="c1">// establish signal handler, enable notification
</span><span class="c1"></span>  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_usr1</span><span class="p">);</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_SIGNAL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_signo</span> <span class="o">=</span> <span class="n">SIGUSR1</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rset</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">FD_SET</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">);</span>
    <span class="n">nfds</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">Read</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister first
</span><span class="c1"></span>      <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;mq_receive error&#34;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_usr1</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Write</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// one byte of 0
</span><span class="c1"></span>  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="55-线程">5.5 线程</h3>
<p>        异步事件通知的另一种方式是把 $sigev_-notify$ 指定为 $SIGEV_-THREAD$ ，这会创建一个新线程。线程属性由 $sigev_-notify_-attributes$ 指定，调用 $sigev_-notify_-function$ 函数，参数为 $sigev_-value$ 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">mqd_t</span> <span class="n">mqd</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">mq_attr</span> <span class="n">attr</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">sigevent</span> <span class="n">sigev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">notify_thread</span><span class="p">(</span><span class="k">union</span> <span class="n">sigval</span><span class="p">);</span>  <span class="c1">// our thread function
</span><span class="c1"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: mqnotifythread1 &lt;name&gt;&#34;</span><span class="p">);</span>

  <span class="n">mqd</span> <span class="o">=</span> <span class="n">Mq_open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
  <span class="n">Mq_getattr</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify</span> <span class="o">=</span> <span class="n">SIGEV_THREAD</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_value</span><span class="p">.</span><span class="n">sival_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify_function</span> <span class="o">=</span> <span class="n">notify_thread</span><span class="p">;</span>
  <span class="n">sigev</span><span class="p">.</span><span class="n">sigev_notify_attributes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span>
    <span class="n">pause</span><span class="p">();</span>  <span class="c1">// each new thread does everything
</span><span class="c1"></span>  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">notify_thread</span><span class="p">(</span><span class="k">union</span> <span class="n">sigval</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;notify_thread started</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="n">buff</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">);</span>
  <span class="n">Mq_notify</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigev</span><span class="p">);</span>  <span class="c1">// reregister
</span><span class="c1"></span>
  <span class="k">while</span> <span class="p">((</span><span class="n">m</span> <span class="o">=</span> <span class="n">mq_receive</span><span class="p">(</span><span class="n">mqd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">mq_msgsize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read %ld bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">n</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span>
    <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;mq_receive error&#34;</span><span class="p">);</span>

  <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="6-posix实时信号">6. <code>POSIX</code>实时信号</h2>
<p>        信号可划分为两组：</p>
<ol>
<li>值在 $SIGRTMIN$ 和 $SIGTRMAX$ 之间 ( 包括两者 ) 的实时信号，<code>POSIX</code>要求至少提供 $RTSIG_-MAX$ 种实时信号，最小为 $8$ ；</li>
<li>其他信号，比如 $SIGALRM$ 、$SIGINT$ 和 $SIGKILL$ 等。</li>
</ol>
<p>        接收某个信号的进程的 $sigaction$ 调用中是否制定了新的 $SA_-SIGINFO$ 标志会带来差异。</p>
<table>
  <thead>
    <tr>
      <th rowspan="2" style="text-align: center;">信号</th>
      <th colspan="2" style="text-align: center;">$sigaction$ 调用</th>
    </tr>
    <tr>
      <th style="text-align: center;">指定 $SA_-SIGINFO$</th>
      <th style="text-align: center;">未指定 $SA_-SIGINFO$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center;">$SIGRTMIN$ $\sim$ $SIGRTMAX$</td>
      <td style="text-align: center;">已指定实时行为</td>
      <td style="text-align: center;">未指定实时行为</td>
    </tr>
    <tr>
      <td style="text-align: center;">其他信号</td>
      <td style="text-align: center;">未指定实时行为</td>
      <td style="text-align: center;">未指定实时行为</td>
    </tr>
  </tbody>
</table>
<p>        未指定实时行为意味着有些实现可能提供实时行为，有些不提供。如果需要实时行为，我们必须使用 $SIGRTMIN$ $\sim$ $SIGRTMAX$ 之间的信号，并且在调用 $sigaction$ 时指定 $SA_-SIGINFO$ 。实时行为意味着：</p>
<ul>
<li>信号是排队的；</li>
<li>当有多个解阻塞信号排队时，值较小的信号优于值较大信号递交；</li>
<li>某个非实时信号递交时，传递给它的信号处理程序的唯一参数是信号值。而实时信号可以传递更多信息。</li>
<li>一些新信号定义成使用实时信号工作。例如，$sigqueue$ 函数代替 $kill$ 函数向某个进程发送信号，该新函数允许发送者随所发送信号传递一个 $sigval$ 。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">si_signo</span><span class="p">;</span>  <span class="c1">// same value as signo argument
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">si_code</span><span class="p">;</span>  <span class="c1">// SI_{USER, QUEUE, TIMER, ASYNCIO, MEGEQ}
</span><span class="c1"></span>  <span class="k">union</span> <span class="n">sigval</span> <span class="n">si_value</span><span class="p">;</span>  <span class="c1">// integer or pointer value from sender
</span><span class="c1"></span><span class="p">}</span> <span class="n">siginfo_t</span><span class="p">;</span>
</code></pre></div><p>        $context$ 参数所指的内容依赖于具体实现。</p>
<ul>
<li>$SI_-ASYNCIO$ ：信号由某个异步<code>I/O</code>请求产生，即<code>POSIX</code>的 $aio_-XXX$ 函数；</li>
<li>$SI_-MESGQ$ ：信号在有一个消息被放置到某个空消息队列时产生；</li>
<li>$SI_-QUEUE$ ：信号由 $timer_-settime$ 函数设置的定时器产生；</li>
<li>$SI_-USER$ ：信号由 $kill$ 函数产生。</li>
</ul>
<p>        如果信号由其他事件产生，$si_-code$ 的值就会被设置成不同于上述的值。而 $siginfo_-t$ 结构的 $si_-value$ 成员只有 $si_-code$ 是上述所列的值之一时才启用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="k">volatile</span> <span class="n">siginfo_t</span> <span class="n">arrival</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="k">static</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">nsig</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_rt</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
  <span class="n">sigset_t</span> <span class="n">newset</span><span class="p">;</span>
  <span class="k">union</span> <span class="n">sigval</span> <span class="n">val</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;SIGRTMIN = %d, SIGRTMAX = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">SIGRTMIN</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">SIGRTMAX</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// child: block three realtime signals
</span><span class="c1"></span>    <span class="n">Sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>
    <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="n">SIGRTMAX</span><span class="p">);</span>
    <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="n">SIGRTMAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">Sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="n">SIGRTMAX</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// establish signal handler with SA_SIGINFO set
</span><span class="c1"></span>    <span class="n">Signal_rt</span><span class="p">(</span><span class="n">SIGRTMAX</span><span class="p">,</span> <span class="n">sig_rt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>
    <span class="n">Signal_rt</span><span class="p">(</span><span class="n">SIGRTMAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sig_rt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>
    <span class="n">Signal_rt</span><span class="p">(</span><span class="n">SIGRTMAX</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sig_rt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newset</span><span class="p">);</span>

    <span class="n">sleep</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>  <span class="c1">// let parent send all the signals
</span><span class="c1"></span>
    <span class="n">Sigprocmask</span><span class="p">(</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// unblock
</span><span class="c1"></span>    <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  <span class="c1">// let all queued signals be delivered
</span><span class="c1"></span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nsig</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;received signal #%d, code = %d, ival = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
        <span class="n">arrival</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">si_signo</span><span class="p">,</span> <span class="n">arrival</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">si_code</span><span class="p">,</span>
        <span class="n">arrival</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">si_value</span><span class="p">.</span><span class="n">sival_int</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// parent sends nine signals to child
</span><span class="c1"></span>  <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  <span class="c1">// let child block add signals
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">SIGRTMAX</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">SIGRTMAX</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">val</span><span class="p">.</span><span class="n">sival_int</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
      <span class="n">Sigqueue</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;sent signal %d, val = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sig_rt</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">arrival</span><span class="p">[</span><span class="n">nsig</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>  <span class="c1">// save info for child to print
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>        首先输出最小和最大实时信号值，查看系统支持的实时信号数量。然后派生一个子进程，阻塞我们需要的实时信号。接着子进程调用 $signal_-rt$ 函数建立信号处理程序，父进程则等待 $6$ 秒后发送信号，最后子进程输出接收到的所有信号。</p>
<h3 id="61-sinal_rt函数">6.1 <code>sinal_rt</code>函数</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="nf">Sigfunc_rt</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="n">Sigfunc_rt</span> <span class="o">*</span><span class="nf">signal_rt</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="n">Sigfunc_rt</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">act</span><span class="p">,</span> <span class="n">oact</span><span class="p">;</span>

  <span class="n">act</span><span class="p">.</span><span class="n">sa_sigaction</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>  <span class="c1">// must store function addr here
</span><span class="c1"></span>  <span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span> <span class="o">=</span> <span class="o">*</span><span class="n">mask</span><span class="p">;</span>  <span class="c1">// signals to block
</span><span class="c1"></span>  <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_SIGINFO</span><span class="p">;</span>  <span class="c1">// must specify this for realtime
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">signo</span> <span class="o">==</span> <span class="n">SIGALRM</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef SA_INTERRUPT
</span><span class="cp"></span>    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_INTERRUPT</span><span class="p">;</span>  <span class="c1">// SunOS 4.x
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef SA_RESTART
</span><span class="cp"></span>    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_RESTART</span><span class="p">;</span>  <span class="c1">// SVR4, 44BSD
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">signo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oact</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Sigfunc_rt</span> <span class="o">*</span><span class="p">)</span> <span class="n">SIG_ERR</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">oact</span><span class="p">.</span><span class="n">sa_sigaction</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        加入实时信号支持后，$sigaction$ 发生了变化，添加了 $sa_-sigaction$ 成员。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">sigaction</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sa_handler</span><span class="p">)();</span>  <span class="c1">// SIG_DFL, SIG_IGN or add of signal handler
</span><span class="c1"></span>  <span class="n">sigset_t</span> <span class="n">sa_mask</span><span class="p">;</span>  <span class="c1">// additional signals to block
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">sa_flags</span><span class="p">;</span>  <span class="c1">// signal options: SA_xxx
</span><span class="c1"></span>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sa_sigaction</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="n">siginfo_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>  <span class="c1">// addr of signal handler if SA_SIGINFO set
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><ul>
<li>如果 $sa_-flags$ 成员设置了 $SA_-SIGINFO$ 标志，那么 $sa_-sigaction$ 成员会指定信号处理函数地址；</li>
<li>如果 $sa_-flags$ 成员没有设置 $SA_-SIGINFO$ 标志，那么 $sa_-handler$ 成员会指定信号处理函数地址；</li>
<li>给某个信号指定默认行为或忽略信号，应该把 $sa_-handler$ 设置为 $SIG_-DFL$ 或 $SIG_-IGN$ 并不设置 $SA_-SIGINFO$ 标志。</li>
</ul>

            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 20 14:01</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B17/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B16/">Unix网络编程（16）：管道和FIFO</a></h1>
            <div class="post-content">
                <h2 id="1-管道">1. 管道</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</code></pre></div><p>        该函数返回两个文件描述符 $fd[0]$ 和 $fd[1]$ ，前者用于读，后者用于写。宏 $S_-IFFIFO$ 可用于确定一个描述符是文件、管道还是<code>FIFO</code>，它的唯一参数是 $stat$ 结构的 $st_-mode$ 成员，计算结果或为真 ( 非零值 )，或为假 ( $0$ )。对于管道来说，这个 $stat$ 结构是由 $fstat$ 函数填写的；对于<code>FIFO</code>来说，这个结构是由 $fstat$ 、$lstat$ 或 $stat$ 函数填写的。<br>
        管道的典型用途是为两个不同的进程 ( 父进程和子进程 ) 提供进程间通信。首先，由一个进程 ( 父进程 ) 创建一个管道，然后调用 $fork$ 派生一个副本 ( 子进程 )。接着，父进程关闭这个管道的读端 ( $fd[0]$ )，子进程关闭管道的写端 ( $fd[1]$ )，这样就在父子进程间建立了一个单向数据流。我们在<code>Unix</code> <code>shell</code>中输入如下命令时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">who <span class="p">|</span> sort
</code></pre></div><p>        将会创建一个管道，$who$ 进程通过输出端将数据发送给 $sort$ 进程，$sort$ 进程通过读入端读入 $who$ 进程发送的数据。<br>
        管道是单向的，如果需要双向传输数据，我们必须创建两个管道，每个方向一个：</p>
<ol>
<li>创建管道 $fd1$ 和管道 $fd2$ ，并 $fork$ 一个子进程；</li>
<li>父进程关闭 $fd1[0]$ 和 $fd2[1]$ ；</li>
<li>子进程关闭 $fd1[1]$ 和 $fd2[0]$ 。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">client</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="n">server</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">pipe1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pipe2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">pid_t</span> <span class="n">childpid</span><span class="p">;</span>

  <span class="n">Pipe</span><span class="p">(</span><span class="n">pipe1</span><span class="p">);</span>
  <span class="n">Pipe</span><span class="p">(</span><span class="n">pipe2</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">childpid</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// child
</span><span class="c1"></span>    <span class="n">Close</span><span class="p">(</span><span class="n">pipe1</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">Close</span><span class="p">(</span><span class="n">pipe2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="n">server</span><span class="p">(</span><span class="n">pipe1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pipe2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// parent
</span><span class="c1"></span>  <span class="n">Close</span><span class="p">(</span><span class="n">pipe1</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">pipe2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="n">clinet</span><span class="p">(</span><span class="n">pipe2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pipe1</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">Waitpid</span><span class="p">(</span><span class="n">childpid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// wait for child to terminate
</span><span class="c1"></span>  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">client</span><span class="p">(</span><span class="kt">int</span> <span class="n">readfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">writefd</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">len</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

  <span class="c1">// read pathname
</span><span class="c1"></span>  <span class="n">Fgets</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
  <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>  <span class="c1">// fgets() guarantees null byte at end
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
    <span class="n">len</span><span class="o">--</span><span class="p">;</span>  <span class="c1">// delete newline from fgets()
</span><span class="c1"></span>
  <span class="c1">// write pathname to IPC channel
</span><span class="c1"></span>  <span class="n">Write</span><span class="p">(</span><span class="n">writefd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

  <span class="c1">// read from IPC, write to standard output
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">Read</span><span class="p">(</span><span class="n">readfd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">server</span><span class="p">(</span><span class="kt">int</span> <span class="n">readfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">writefd</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="n">MAXLINE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

  <span class="c1">// read pathname from IPC channel
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">Read</span><span class="p">(</span><span class="n">readfd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;end-of-file while reading pathname&#34;</span><span class="p">);</span>
  <span class="n">buff</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>  <span class="c1">// null terminate pathname
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// error: must tell client
</span><span class="c1"></span>    <span class="n">snprintf</span><span class="p">(</span><span class="n">buff</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="s">&#34;: can&#39;t open, %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
      <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">writefd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// open succeeded: copy file to IPC channel
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">Read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">Write</span><span class="p">(</span><span class="n">writefd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">Close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        子进程在往管道写入最终数据后调用 $exit$ 终止，随后变为<strong>僵尸进程</strong> ( $zombie$ )：自身终止但父进程仍在运行且未等待该子进程。子进程终止时，内核会给父进程发送一个 $SIGCHILD$ 信号，但是父进程忽略了这个信号。随后父进程调用 $waitpid$ 取得子进程的终止状态。如果父进程没有调用 $waitpid$ 就终止，那么子进程变为孤儿进程，其父进程将变为 $init$ 进程，由 $init$ 进程获取其终止状态。</p>
<h2 id="2-popen和pclose函数">2. <code>popen</code>和<code>pclose</code>函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功为文件指针，出错为NULL
</span><span class="c1"></span><span class="n">FILE</span> <span class="o">*</span><span class="nf">popen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span><span class="p">,</span> <span class="n">cosnt</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>

<span class="c1">// 成功为shell终止状态，出错为-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">pclose</span><span class="p">(</span><span class="n">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</code></pre></div><p>        $popen$ 函数创建一个管道并启动另外一个进程，该进程要么从该管道读出标准输入，要么往该管道写入标准输出。$command$ 是一个<code>shell</code>命令，$type$ 可以是 $r$ 或者 $w$ ，分别对应着读入 $command$ 的标准输出和写到 $command$ 的标准输入。$pclose$ 函数则负责关闭由 $popen$ 创建的标准<code>I/O</code>流 $stream$ ，等待命令终止并返回<code>shell</code>终止状态。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#inlcude &#34;unpipc.h&#34;
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">command</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

  <span class="c1">// read pathname
</span><span class="c1"></span>  <span class="n">Fgets</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>  <span class="c1">// fgets() guarantees null byte at end
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
    <span class="n">n</span><span class="o">--</span><span class="p">;</span>  <span class="c1">// delete newline from fgets
</span><span class="c1"></span>
  <span class="n">snprintf</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">command</span><span class="p">),</span> <span class="s">&#34;cat %s&#34;</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>
  <span class="n">fp</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="s">&#34;r&#34;</span><span class="p">);</span>

  <span class="c1">// copy from pipe to standard output
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">Fgets</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">Fputs</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>

  <span class="n">Pclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="3-fifo">3. <code>FIFO</code></h2>
<p>        <code>FIFO</code>指<strong>先进先出</strong> ( $first$ $in$ $first$ $out$ )，类似于管道，是一个单向的数据流。不同于管道的是，每个<code>FIFO</code>都有一个路径名与之关联，从而允许无亲缘关系的进程访问同一个<code>FIFO</code>，也被称为<strong>有名管道</strong> ( $named$ $pipe$ )。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">mkfifo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
</code></pre></div><p>        $pathname$ 是一个普通的<code>Unix</code>路径名，是<code>FIFO</code>的名字。$mode$ 指定文件权限，类似于 $open$ 的第二个参数，定义在 &lt;$sys/stat.h$&gt; 头文件中。</p>
<table>
<thead>
<tr>
<th style="text-align:center">常值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$S_-IRUSR$</td>
<td style="text-align:left">用户 ( 属主 ) 读</td>
</tr>
<tr>
<td style="text-align:center">$S_-IWUSR$</td>
<td style="text-align:left">用户 ( 属主 ) 写</td>
</tr>
<tr>
<td style="text-align:center">$S_-IRGRP$</td>
<td style="text-align:left">( 属 ) 组成员读</td>
</tr>
<tr>
<td style="text-align:center">$S_-IWGRP$</td>
<td style="text-align:left">( 属 ) 组成员写</td>
</tr>
<tr>
<td style="text-align:center">$S_-IROTH$</td>
<td style="text-align:left">其他用户读</td>
</tr>
<tr>
<td style="text-align:center">$S_-IWOTH$</td>
<td style="text-align:left">其他用户写</td>
</tr>
</tbody>
</table>
<p>        $mkfifo$ 隐式指定 $O_-CREAT$ | $O_-EXCL$ ，意味着要么创建一个新的<code>FIFO</code>，要么返回 $EEXIST$ 错误。如果不希望创建一个新的<code>FIFO</code>，那么应该调用 $open$ 或者 $fopen$ 。由于<code>FIFO</code>是半双工的，所以不能以读写方式打开，并且对其的 $lseek$ 调用也会报错，返回 $ESPIPE$ 错误。我们定义默认的<code>FIFO</code>权限如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define FILE_MODE (S_IRUSR |  S_IWUSR | S_IRGRP | S_IROTH)
</span></code></pre></div><hr>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define FIFO1 &#34;/tmp/fifo.1&#34;
</span><span class="cp">#define FIFO2 &#34;/tmp/fifo.2&#34;
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">client</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="n">server</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">readfd</span><span class="p">,</span> <span class="n">writefd</span><span class="p">;</span>
  <span class="n">pid_t</span> <span class="n">childpid</span><span class="p">;</span>

  <span class="c1">// create two FIFOs; OK if they already exist
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">((</span><span class="n">mkfifo</span><span class="p">(</span><span class="n">FIFO1</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EEXIST</span><span class="p">))</span>
    <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;can&#39;t create %s&#34;</span><span class="p">,</span> <span class="n">FIFO1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">mkfifo</span><span class="p">(</span><span class="n">FIFO2</span><span class="p">,</span> <span class="n">FILE_MODE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EEXIST</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">unlink</span><span class="p">(</span><span class="n">FIFO1</span><span class="p">);</span>
    <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;can&#39;t create %s&#34;</span><span class="p">,</span> <span class="n">FIFO2</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">childpid</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// child
</span><span class="c1"></span>    <span class="n">readfd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">FIFO1</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">writefd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">FIFO2</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">server</span><span class="p">(</span><span class="n">readfd</span><span class="p">,</span> <span class="n">writefd</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// parent
</span><span class="c1"></span>  <span class="n">writefd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">FIFO1</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">readfd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">FIFO2</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">client</span><span class="p">(</span><span class="n">readfd</span><span class="p">,</span> <span class="n">writefd</span><span class="p">);</span>
  <span class="n">Waitpid</span><span class="p">(</span><span class="n">childpid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// wait for child to terminate
</span><span class="c1"></span>
  <span class="n">Close</span><span class="p">(</span><span class="n">readfd</span><span class="p">);</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">writefd</span><span class="p">);</span>

  <span class="n">Unlink</span><span class="p">(</span><span class="n">FIFO1</span><span class="p">);</span>
  <span class="n">Unlink</span><span class="p">(</span><span class="n">FIFO2</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        没有正确使用<code>FIFO</code>的程序会产生问题，例如上述代码中调换父进程的两个 $open$ 的顺序，程序就会被阻塞，因为在以读方式打开<code>FIFO</code>的时候，没有其他进程以写方式打开相同的<code>FIFO</code>，从而就会阻塞。</p>
<h2 id="4-管道和fifo的额外属性">4. 管道和<code>FIFO</code>的额外属性</h2>
<table>
  <thead>
    <tr>
      <th rowspan="2" style="text-align: center;">当前操作</th>
      <th rowspan="2" style="text-align: center;">目标管道或<code>FIFO</code>的模式</th>
      <th colspan="2" style="text-align: center;">返回</th>
    </tr>
    <tr>
      <th style="text-align: center;">阻塞 ( 默认 )</th>
      <th style="text-align: center;">$O_-NONBLOCK$ 设置</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2" style="text-align: center;">$open$ <code>FIFO</code>只读</td>
      <td style="text-align: left;">写模式打开的<code>FIFO</code></td>
      <td style="text-align: left;">成功</td>
      <td style="text-align: left;">成功</td>
    </tr>
    <tr>
      <td style="text-align: left;">非写模式打开的<code>FIFO</code></td>
      <td style="text-align: left;">阻塞直到<code>FIFO</code>被以写模式打开</td>
      <td style="text-align: left;">成功</td>
    </tr>
    <tr>
      <td rowspan="2" style="text-align: center;">$open$ <code>FIFO</code>只写</td>
      <td style="text-align: left;">读模式打开的<code>FIFO</code></td>
      <td style="text-align: left;">成功</td>
      <td style="text-align: left;">成功</td>
    </tr>
    <tr>
      <td style="text-align: left;">非读模式打开的<code>FIFO</code></td>
      <td style="text-align: left;">阻塞直到<code>FIFO</code>被以读模式打开</code>
      <td style="text-align: left;">返回 $ENXIO$ 错误</td>
    </tr>
    <tr>
      <td rowspan="2" style="text-align: center;">$read$ 空管道或<code>FIFO</code></td>
      <td style="text-align: left;">写模式打开的管道或<code>FIFO</code></td>
      <td style="text-align: left;">阻塞直到管道或<code>FIFO</code>中有数据 / 管道或<code>FIFO</code>不再以写模式打开</td>
      <td style="text-align: left;">返回 $EAGAIN$ 错误</td>
    </tr>
    <tr>
      <td style="text-align: left;">非写模式打开的管道或<code>FIFO</code></td>
      <td style="text-align: left;">$read$ 返回 $0$</td>
      <td style="text-align: left;">$read$ 返回 $0$</td>
    </tr>
    <tr>
      <td rowspan="2" style="text-align: left;">$write$ 管道或<code>FIFO</code></td>
      <td style="text-align: left;">读模式打开的管道或<code>FIFO</code></td>
      <td style="text-align: left;">见后续</td>
      <td style="text-align: left;">见后续</td>
    </tr>
    <tr>
      <td style="text-align: left;">非读模式打开的管道或<code>FIFO</code></td>
      <td style="text-align: left;">给线程产生 $SIGPIPE$</td>
      <td style="text-align: left;">给线程产生 $SIGPIPE$</td>
    </tr>
  </tbody>
</table>
<p>        描述符可以通过 $open$ 或者 $fcntl$ 来设置为非阻塞式。对于管道或<code>FIFO</code>的读写，有以下规则：</p>
<ul>
<li>如果请求读的数据量大于现有可用数据量，那么只会返回这些可用的数据；</li>
<li>如果请求写的字节数小于或等于 $PIPE_-BUF$ ( 一个<code>POSIX</code>限制值 )，那么 $write$ 操作是原子的；</li>
<li>$O_-NONBLOCK$ 标志的设置对 $write$ 操作的原子性没有影响；</li>
<li>在非阻塞模式下，如果待写字节数小于等于 $PIPE_-BUF$ ：
<ol>
<li>如果该管道或<code>FIFO</code>中有足够的空间，写入所有数据；</li>
<li>如果该管道或<code>FIFO</code>中没有足够的空间，立即返回 $EAGAIN$ 错误；</li>
</ol>
</li>
<li>在非阻塞模式下，如果待写字节数大于 $PIPE_-BUF$ ：
<ol>
<li>如果该管道或<code>FIFO</code>中至少有 $1$ 字节空间，那么内核将尽可能写入剩余空间，并将写入字节数作为返回值；</li>
<li>如果该管道或<code>FIFO</code>已满，返回 $EAGAIN$ 错误；</li>
</ol>
</li>
<li>向一个以非读模式打开的管道或<code>FIFO</code>写，内核将产生 $SIGPIPE$ 信号；
<ol>
<li>如果调用进程没有捕获也没有忽略 $SIGPIPE$ ，那么默认行为是终止进程；</li>
<li>如果调用进程忽略了 $SIGPIPE$ ，或者捕获并从信号处理程序中返回，$write$ 将返回 $EPIPE$ 错误。</li>
</ol>
</li>
</ul>
<h2 id="5-字节流与消息">5. 字节流与消息</h2>
<p>        到此为止的所有例子都是使用的字节流<code>I/O</code>模型，这是<code>Unix</code>的原生<code>I/O</code>模型。这种模型不存在记录边界，读写操作不会检查数据。有时候应用希望对所发送的数据加上某种结构，读出者可以通过结构确认消息边界。有三种方式可以实现这个目的：</p>
<ol>
<li>带内特殊终止序列。许多<code>Unix</code>应用程序使用换行符来分隔消息。写进程会给每个消息添加一个换行符，读进程则每次读出一行。这种方式也要求对一般数据中出现的分隔符转义处理；</li>
<li>显式长度。每个记录前标记长度；</li>
<li>每次连接一个记录。应用通过关闭与对端的连接来指示一个记录的结束。</li>
</ol>
<p>        我们也可以给消息增加一些结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define MAXMESGDATA (PIPE_BUF - 2 * sizeof(long))
</span><span class="cp">#define MESGHDRSIZE (sizeof(struct mymesg) - MAXMESGDATA)
</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">mymesg</span> <span class="p">{</span>
  <span class="kt">long</span> <span class="n">mesg_len</span><span class="p">;</span>  <span class="c1">// # bytes in mesg_data, can be 0
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">mesg_type</span><span class="p">;</span>  <span class="c1">// message type, must be &gt; 0
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">mesg_data</span><span class="p">[</span><span class="n">MAXMESGDATA</span><span class="p">];</span>
<span class="p">};</span>

<span class="n">ssize_t</span> <span class="nf">mesg_send</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mymesg</span> <span class="o">*</span><span class="p">);</span>
<span class="n">ssize_t</span> <span class="nf">mesg_recv</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mymesg</span> <span class="o">*</span><span class="p">);</span>

<span class="n">ssize_t</span> <span class="nf">mesg_send</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mymesg</span> <span class="o">*</span><span class="n">mptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">mptr</span><span class="p">,</span> <span class="n">MESGHDRSIZE</span> <span class="o">+</span> <span class="n">mptr</span><span class="o">-&gt;</span><span class="n">mesg_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ssize_t</span> <span class="nf">mesg_recv</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mymesg</span> <span class="o">*</span><span class="n">mptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">len</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>

  <span class="c1">// read message header first, to get len of data that follows
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">Read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">mptr</span><span class="p">,</span> <span class="n">MESGHDRSIZE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// end of file
</span><span class="c1"></span>  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">MESGHDRSIZE</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;message header: expected %d, got %d&#34;</span><span class="p">,</span> <span class="n">MESGHDRSIZE</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">mptr</span><span class="o">-&gt;</span><span class="n">mesg_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">Read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">mptr</span><span class="o">-&gt;</span><span class="n">mesg_data</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
      <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;message data: expected %d, got %d&#34;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="6-管道和fifo限制">6. 管道和<code>FIFO</code>限制</h2>
<p>        系统加于管道和<code>FIFO</code>的唯一限制为：</p>
<ul>
<li>$OPEN_-MAX$ ：一个进程可以打开的最大描述符数；</li>
<li>$PIPE_-BUF$ ：可以原子地往管道或<code>FIFO</code>写入的最大数据量。</li>
</ul>
<p>        $OPEN_-MAX$ 的值可以通过 $sysconf$ 得到，$PIPE_-BUF$ 的值可以通过 $pathconf$ 或 $fpathconf$ 得到。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpipc.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: pipeconf &lt;pathname&gt;&#34;</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;PIPE_BUF = %ld, OPEN_MAX = %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
    <span class="n">Pathconf</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_PC_PIPE_BUF</span><span class="p">),</span> <span class="n">Sysconf</span><span class="p">(</span><span class="n">_SC_OPEN_MAX</span><span class="p">));</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 19 14:31</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B16/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/">Unix网络编程补充：套接字选项</a></h1>
            <div class="post-content">
                <h2 id="1-getsockopt和setsockop函数">1. <code>getsockopt</code>和<code>setsockop</code>函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">getsockopt</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">optlen</span><span class="p">);</span>

<span class="c1">// 成功返回0，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">setsockopt</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">optlen</span><span class="p">);</span>
</code></pre></div><p>        这两个函数仅适用于套接字。$sockfd$ 指向一个打开的套接字描述符，$level$ 指定系统中解释选项的代码或为通用套接字代码，或为某个特定于协议的代码。$optval$ 是一个指向某个变量的指针，$setsockopt$ 从 $optval$ 中获取设置，$getoptval$ 向 $optval$ 中写入设置。$optval$ 的大小由 $optlen$ 指定。套接字选项粗分为两大基本类型：一是启用或禁用某个特性的二元选项 ( 标志选项 )，二是取得并返回我们可以设置或检查的特定值的选项 ( 值选项 )。对于标志选项，$optval$ 是一个整数，$1$ 标识启用，$0$ 表示禁用。</p>
<table>
  <thead>
    <tr>
      <th style="text-align: center;">$level$</th>
      <th style="text-align: center;">$optname$</th>
      <th style="text-align: center;">$get$</th>
      <th style="text-align: center;">$set$</th>
      <th style="text-align: center;">说明</th>
      <th style="text-align: center;">标志选项</th>
      <th style="text-align: center;">数据类型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="17" style="text-align: left;">$SOL_-SOCKET$</td>
      <td style="text-align: left;">$SO_-BROADCAST$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">允许发送广播数据报</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-DEBUG$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">开启调试跟踪</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-DONTROUTE$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">绕过外出路由表查询</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-ERROR$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">获取待处理错误并清除</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-KEEPALIVE$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">周期性测试连接是否仍存活</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-LINGER$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">若有数据待发送则延迟关闭</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$linger\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-OOBINLINE$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">让接收到的带外数据在线存留</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-RCVBUF$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">接收缓冲区大小</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-SNDBUF$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">发送缓冲区大小</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-RCVLOWAT$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">接收缓冲区低水位标记</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-SNDLOWAT$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">发送缓冲区低水位标记</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-RCVTIMEO$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">接收超时</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$timeval\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-SNDTIMEO$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">发送超时</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$timeval\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-REUSEADDR$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">允许重用本地地址</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-REUSEPORT$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">允许重用本地端口</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-TYPE$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">取得套接字类型</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$SO_-USELOOPBACK$</td>
      <td style="text-algin: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">路由套接字取得所发送数据的副本</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td rowspan="15" style="text-align: left;">$IPPROTO_-IP$</td>
      <td style="text-align: left;">$IP_-HDRINCL$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">随数据包含的<code>IP</code>首部</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-OPTIONS$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;"><code>IP</code>首部选项</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">见后续</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-RECVDSTADDR$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">返回目的<code>IP</code>地址</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-RCVIF$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">返回接收接口索引</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-TOS$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">服务类型和优先权</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-TTL$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">存活时间</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-MULTICAST_-IF$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">指定外出接口</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$in_-addr\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-MULTICAST_-TTL$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">指定外出 $TTL$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$u_-char$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-MULTICAST_-LOOP$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">指定是否环回</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$u_-char$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-ADD_-MEMBERSHIP$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">加入多播组</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$ip_-mreq\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-DROP_-MEMBERSHIP$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">离开多播组</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$ip_-mreq\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-BLOCK_-SOURCE$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">阻塞多播源</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$ip_-mreq_-source\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-UNBLOCK_-SOURCE$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">开通多播源</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$ip_-mreq_-source\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-ADD_-SOURCE_-MEMBERSHIP$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">加入源特定多播组</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$ip_-mreq_-source\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IP_-DROP_-SOURCE_-MEMBERSHIP$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">离开源特定多播组</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$ip_-mreq_-source\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPPROTO_-ICMPV6$</td>
      <td style="text-align: left;">$ICMP6_-FILTER$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">指定待传递的<code>ICMPv6</code>消息类型</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$icmp6_-filter\{\}$</td>
    </tr>
    <tr>
      <td rowspan="21" style="text-align: left;">$IPPROTO_-IPV6$</td>
      <td style="text-align: left;">$IPV6_-CHECKSUM$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">用于原始套接字的校验和字段偏移</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-CHECKSUM$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">用于原始套接字的校验和字段偏移</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-DONTFRAG$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">丢弃大的分组而将其分片</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-NEXTHOP$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">指定下一跳地址</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$sockaddr_-in6\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-PATHMTU$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">获取当前路径 $MTU$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$ip6_-mtuinfo\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-RECVDSTOPTS$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">接收目的地选项</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-RECVHOPLIMIT$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">接收单播跳限</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-RECVHOPOPTS$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">接收步跳选项</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-RECVPATHMTU$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">接收路径 $MTU$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-RECVPKTINFO$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">接收分组信息</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-RECVRTHDR$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">接收源路径</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-RECVTCLASS$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">接收流通类型</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-UNICAST_-HOPS$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">默认单播跳限</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-USE_-MIN_-MTU$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">使用最小 $MTU$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-V6ONLY$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">禁止<code>v4</code>兼容</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-XXX$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">黏附性辅助数据</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">见后续</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-MULTICAST_-IF$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">指定外出接口</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$u_-int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-MULTICAST_-HOPS$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">指定外出跳限</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-MULTICAST_-LOOP$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">指定是否环回</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$u_-int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-JOIN_-GROUP$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">加入多播组</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$ipv6_-mreq\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$IPV6_-LEAVE_-GROUP$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">离开多播组</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$ipv6_-mreq\{\}$</td>
    </tr>
    <tr>
      <td rowspan="6" style="text-align: left;">$IPPROTO_-IP$ 或 $IPPROTO_-IPV6$</td>
      <td style="text-align: left;">$MCAST_-JOIN_-GROUP$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">加入多播组</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$group_-req\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$MCAST_-LEAVE_-GROUP$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">离开多播组</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$group_-source_-req\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$MCAST_-BLOCK_-SOURCE$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">阻塞多播源</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$group_-source_-req\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$MCAST_-UNBLOCK_-SOURCE$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">开通多播源</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$group_-source_-req\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$MCAST_-JOIN_-SOURCE_-GROUP$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">加入源特定多播组</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$group_-source_-req\{\}$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$MCAST_-LEAVE_-SOURCE_-GROUP$</td>
      <td style="text-align: center;"></td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">离开源特定多播组</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$group_-source_-req\{\}$</td>
    </tr>
    <tr>
      <td rowspan="2" style="text-align: left;">$IPPROTO_-TCP$</td>
      <td style="text-align: left;">$TCP_-MAXSEG$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;"><code>TCP</code>最大分节大小</td>
      <td style="text-align: center;"></td>
      <td style="text-align: left;">$int$</td>
    </tr>
    <tr>
      <td style="text-align: left;">$TCP_-NODELAY$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">禁止 $Nagle$ 算法</td>
      <td style="text-align: center;">$\checkmark$</td>
      <td style="text-align: left;">$int$</td>
    </tr>
  </tbody>
</table>
<h2 id="2-通用套接字选项">2. 通用套接字选项</h2>
<h3 id="21-so_debug">2.1 <code>SO_DEBUG</code></h3>
<p>        本选项仅由<code>TCP</code>支持。当给一个<code>TCP</code>套接字开启本选项时，内核将为<code>TCP</code>在该套接字发送和接收的所有分组保留详细跟踪信息。这些信息保存在内核的某个环形缓冲区中，并可使用 $trpt$ 程序进行检查。</p>
<h3 id="22-so_dontroute">2.2 <code>SO_DONTROUTE</code></h3>
<p>        本选项规定外出的分组将绕过底层协议的正常路由机制。例如，<code>IPv4</code>情况下外出分组将被定向到合适的本地接口，也就是由目的地址的网络和子网部分确定的本地接口。如果这样的本地接口无法由目的地址确定，会返回 $ENETUNREACH$ 错误。路由守护进程 ( $routed$ 和 $gated$ ) 常使用本选项来绕过路由表 ( 路由表不正确的情况下 )，用于强制将分组从特定接口发出。</p>
<h3 id="23-so_error">2.3 <code>SO_ERROR</code></h3>
<p>        当一个套接字上发生错误时，源自 $Berkeley$ 的内核中的协议模块将该套接字的 $so_-error$ 变量设置为错误码中的一个，称为<strong>待处理错误</strong> ( $pending$ $error$ )。内核能够以两种方式通知进程这个错误：</p>
<ol>
<li>如果进程阻塞在对该套接字的 $select$ 错误上，那么无论是检查可读条件还是可写条件，$select$ 均返回并设置其中一个或所有两个条件；</li>
<li>如果进程使用信号驱动式<code>I/O</code>，那么会产生一个 $SIGIO$ 信号。</li>
</ol>
<p>        进程可以通过访问 $SO_-ERROR$ 选项来获取 $so_-error$ 的值，随后 $so_-error$ 会被复位为 $0$ 。当进程调用 $read$ 且没有数据返回时，如果 $so_-error$ 为非 $0$ 值，那么 $read$ 返回 $-1$ 且 $errno$ 被设置为 $so_-error$ 的值，随后 $so_-error$ 被设置为 $0$ 。同样的，如果在进程调用 $write$ 时 $so_-error$ 非 $0$ ，也会进行上述操作。</p>
<h3 id="24-so_keepalive">2.4 <code>SO_KEEPALIVE</code></h3>
<p>        给一个<code>TCP</code>套接字设置该选项后，如果 $2$ 小时内在该套接字的任一方向上都没有数据交换，<code>TCP</code>就会自动给对端发送一个<em><strong>保持存活探测分节</strong></em> ( $keep-alive$ $probe$ )。这是一个对端必须相应的<code>TCP</code>分节，会导致三种情况之一：</p>
<ol>
<li>对端响应<code>ACK</code>，应用进程不会收到通知；</li>
<li>对端响应<code>RST</code>，本端<code>TCP</code>收到通知后得知对端已经崩溃且重新启动，设置 $ECONNRESET$ 错误并关闭套接字；</li>
<li>对端没有响应，源自 $Berkeley$ 的<code>TCP</code>实现将会重新发送 $8$ 个探测分节，两两相隔 $75$ 秒。如果还是没有响应则放弃，设置 $ETIMEOUT$ 错误并关闭套接字；如果收到一个<code>ICMP</code>错误，则会返回相应的错误。</li>
</ol>
<h3 id="25-so_linger">2.5 <code>SO_LINGER</code></h3>
<p>        本选项指定 $close$ 函数如何处理面向连接的协议 ( <code>TCP</code>和<code>SCTP</code>等 )。默认操作是 $close$ 立即返回，如果有数据残留，会尝试将这些数据发送给对端。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">linger</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">l_onoff</span><span class="p">;</span>  <span class="c1">// 0=off, nonzero=on
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">l_linger</span><span class="p">;</span>  <span class="c1">// linger time, POSIX specifies units as seconds
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div><ul>
<li>如果 $l_-onoff$ 为 $0$ ，$l_-linger$ 的值将被忽略，默认配置将生效；</li>
<li>如果 $l_-onoff$ 非 $0$ 且 $l_-linger$ 为 $0$ ，那么 $close$ 某个连接时<code>TCP</code>将终止连接，丢弃所有留存在发送缓冲区中的数据，并给对端发送<code>RST</code>。这样一来就避免了 $TIME_-WAIT$ 阶段，但是如果在 $2MSL$ 时间内创建了该连接的分身，会导致来自刚被终止的连接上的旧的重复分节被不正确地传递到新的分身上；</li>
<li>如果 $l_-onff$ 非 $0$ 且 $l_-linger$ 也非 $0$ ，那么当套接字关闭时内核将维持一段时间的连接。如果此时发送缓冲区中仍有数据，进程将休眠，直到所有数据发送完成且被确认或者到达时间上限。如果到达时间上限返回，会设置 $EWOULDBLOCK$ 错误，且丢弃发送缓冲区中的数据。如果套接字是非阻塞的，它将不等待 $close$ 完成。</li>
</ul>
<h3 id="26-so_reuseaddr和so_reuseport">2.6 <code>SO_REUSEADDR</code>和<code>SO_REUSEPORT</code></h3>
<p>        $SO_-REUSEADDR$ 选项有以下作用：</p>
<ol>
<li>允许重启一个监听服务器并绑定众所周知的端口，即使以前建立的使用这个端口的进程仍然存在。一般情况下，在同一个端口重复绑定会失败，但是如果该服务器在绑定前指定了该选项，绑定将会成功。所有<code>TCP</code>服务器都应该指定这个选项，从而允许服务器在这种情形下被重新启动；</li>
<li>允许在同一个端口上启动同一服务器的多个实例，只要每个实例绑定不同的<code>IP</code>地址；</li>
<li>允许单个进程绑定同一端口到多个套接字上，只要每次绑定指定不同的本地<code>IP</code>地址即可；</li>
<li>允许完全重复的绑定：当一个<code>IP</code>地址和端口已绑定到某个套接字上时，如果传输协议支持，同样的<code>IP</code>地址和端口还可以捆绑到另一个套接字上。一般来说，本特性仅支持<code>UDP</code>套接字；</li>
</ol>
<p>        随着多播的加入，$SO_-REUSEPORT$ 也被引入：</p>
<ol>
<li>允许完全重复的绑定，不过只有在绑定了同一<code>IP</code>地址和端口的套接字都指定了该选项时才可以；</li>
<li>如果被绑定的<code>IP</code>地址是多播地址，那么与 $SO_-REUSEADDR$ 等效。</li>
</ol>
<h2 id="3ipv4套接字选项">3.<code>IPv4</code>套接字选项</h2>
<h3 id="31-ip_options">3.1 <code>IP_OPTIONS</code></h3>
<p>        本选项允许我们在<code>IPv4</code>首部中设置<code>IP</code>选项，要求我们熟悉<code>IP</code>首部中的<code>IP</code>选项格式。</p>
<h3 id="32-ip_recvdstaddr">3.2 <code>IP_RECVDSTADDR</code></h3>
<p>        本选项导致收到<code>UDP</code>数据报的目的<code>IP</code>地址由 $recvmsg$ 函数作为辅助数据返回。</p>
<h3 id="33-ip_recvif">3.3 <code>IP_RECVIF</code></h3>
<p>        本选项导致收到<code>UDP</code>数据报的接收接口索引由 $recvmsg$ 韩硕作为辅助数据返回。</p>
<h2 id="4-ipv6套接字选项">4. <code>IPv6</code>套接字选项</h2>
<h3 id="41-ipv6_recvdstopts">4.1 <code>IPV6_RECVDSTOPTS</code></h3>
<p>        本选项会导致任何接收到的<code>IPv6</code>目的地选项都将由 $recvmsg$ 作为辅助数据返回。</p>
<h3 id="42-ipv6_recvhoplimit">4.2 <code>IPV6_RECVHOPLIMIT</code></h3>
<p>        本选项会导致任何接收到的跳限字段都将由 $recvmsg$ 作为辅助数据返回。</p>
<h3 id="43-ipv6_recvhopopts">4.3 <code>IPV6_RECVHOPOPTS</code></h3>
<p>        本选项会导致任何接收到的<code>IPv6</code>步跳选项都将由 $recvmsg$ 作为辅助数据返回。</p>
<h3 id="44-ipv6_recvpathmtu">4.4 <code>IPV6_RECVPATHMTU</code></h3>
<p>        本选项会导致某跳路径 $MTU$ 在发生变化时由 $recvmsg$ 作为辅助数据返回。</p>
<h3 id="45-ipv6_recvpktinfo">4.5 <code>IPV6_RECVPKTINFO</code></h3>
<p>        本选项会导致接收到的<code>IPv6</code>数据报的目的<code>IPv6</code>地址和到达接口索引由 $recvmsg$ 作为辅助数据返回。</p>
<h3 id="46-ipv6_recvrthdr">4.6 <code>IPV6_RECVRTHDR</code></h3>
<p>        本选项会导致接收到的<code>IPv6</code>路由首部将由 $recvmsg$ 作为辅助数据返回。</p>
<h3 id="47-ipv6_recvtclass">4.7 <code>IPV6_RECVTCLASS</code></h3>
<p>        本选项会导致接收到的流通类别将由 $recvmsg$ 作为辅助数据返回。</p>
<h3 id="48-ipv6_use_min_mtu">4.8 <code>IPV6_USE_MIN_MTU</code></h3>
<p>        设置为 $1$ 会关闭路径 $MTU$ 发现功能，使用<code>IPv6</code>的最小 $MTU$ 发送；设置为 $0$ 会对所有目的地执行路径 $MTU$ 发现；设置为 $-1$ 则路径 $MTU$ 发现仅对单播目的地执行，多播目的地使用最小 $MTU$ 。本选项默认值为 $-1$ 。</p>
<h2 id="5-fcntl函数">5. <code>fcntl</code>函数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">// 成功则返回cmd命令的结果，出错返回-1
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">fcntl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* int arg */</span><span class="p">);</span>
</code></pre></div><p>        $fcntl$ 函数可以执行各种描述符控制操作。如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">$fcntl$</th>
<th style="text-align:left">$ioctl$</th>
<th style="text-align:left">路由套接字</th>
<th style="text-align:left"><code>POSIX</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">设置套接字为非阻塞式<code>I/O</code></td>
<td style="text-align:left">$F_-SETFL$ ，$O_-NONBLOCK$</td>
<td style="text-align:left">$FIONBIO$</td>
<td style="text-align:left"></td>
<td style="text-align:left">$fcntl$</td>
</tr>
<tr>
<td style="text-align:left">设置套接字为信号驱动式<code>I/O</code></td>
<td style="text-align:left">$F_-SETFL$ ，$O_-ASYNC$</td>
<td style="text-align:left">$FIOASYNC$</td>
<td style="text-align:left"></td>
<td style="text-align:left">$fcntl$</td>
</tr>
<tr>
<td style="text-align:left">设置套接字属主</td>
<td style="text-align:left">$F_-SETOWN$</td>
<td style="text-align:left">$SIOCSPGRP$ / $FIOSETOWN$</td>
<td style="text-align:left"></td>
<td style="text-align:left">$fcntl$</td>
</tr>
<tr>
<td style="text-align:left">获取套接字属主</td>
<td style="text-align:left">$F_-GETOWN$</td>
<td style="text-align:left">$SIOCGPGRP$ / $FIOGETOWN$</td>
<td style="text-align:left"></td>
<td style="text-align:left">$fcntl$</td>
</tr>
<tr>
<td style="text-align:left">获取套接字接收缓冲区中的字节数</td>
<td style="text-align:left"></td>
<td style="text-align:left">$FIONREAD$</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">测试套接字是否处于带外标志</td>
<td style="text-align:left"></td>
<td style="text-align:left">$SIOCATMARK$</td>
<td style="text-align:left"></td>
<td style="text-align:left">$sockatmark$</td>
</tr>
<tr>
<td style="text-align:left">获取接口列表</td>
<td style="text-align:left"></td>
<td style="text-align:left">$SIOCGIFCONF$</td>
<td style="text-align:left">$sysctl$</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">接口操作</td>
<td style="text-align:left"></td>
<td style="text-align:left">$SIOCGIFxxx$ / $SIOSIFxxx$</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>ARP</code>高速缓存操作</td>
<td style="text-align:left"></td>
<td style="text-align:left">$SIOCxARP$</td>
<td style="text-align:left">$RTM_-xxx$</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">路由表操作</td>
<td style="text-align:left"></td>
<td style="text-align:left">$SIOCxxxRT$</td>
<td style="text-align:left">$RTM_-xxx$</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>        <code>POSIX</code>一栏指出<code>POSIX</code>规定的首选操作。$F_-SETOWN$ 命令的整数类型参数 $arg$ 既可以是一个正整数，指出接收信号的进程<code>ID</code>，也可以是一个负整数，其绝对值指出接收信号的进程组<code>ID</code>。同样的，$F_-GETOWN$ 命令既可以返回代表进程<code>ID</code>的正值，也可以返回代表进程组<code>ID</code>的负值。使用 $socket$ 函数新创建的套接字没有属主，然而如果一个新的套接字是从监听套接字创建而来的，那么这个新的套接字属主将从监听套接字继承而来。</p>

            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 18 18:28</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A1%A5%E5%85%85%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
        <div class="post">
            
            <h1 style="text-align: center;"><a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B15/">Unix网络编程（15）：程序设计范式</a></h1>
            <div class="post-content">
                <p>        开发一个<code>Unix</code>服务器程序时，我们有如下类型的进程控制可选：</p>
<ul>
<li><strong>迭代服务器</strong> ( $iterative$ $server$ ) 程序，在一个主循环内处理所有客户服务。这种类型的适用情形极为有限，因为这样的服务器在完成当前客户的服务之前无法处理后续等待的客户；</li>
<li><strong>并发服务器</strong> ( $concurrent$ $server$ ) 程序，它为每个客户调用 $fork$ 派生一个子进程。传统上大多数<code>Unix</code>服务器程序属于这种类型；</li>
<li>通过 $select$ 处理任意多个客户的服务器；</li>
<li><strong>预先派生子进程</strong> ( $preforking$ ) 程序，它让服务器在启动阶段调用 $fork$ 创建一个子进程池，每个客户请求由当前可用子进程池中的某个闲置子进程处理；</li>
<li><strong>预先创建线程</strong> ( $prethreading$ ) 程序，它让服务器在启动阶段创建一个线程池，每个客户由当前可用线程池中的某个闲置线程处理。</li>
</ul>
<p>        <code>TCP</code>客户程序则有以下范式：</p>
<ul>
<li>以停-等方式运作的客户程序，进程在被阻塞以等待用户输入期间，看不到诸如对端关闭连接等网络事件，而且批处理效率极低；</li>
<li>调用 $select$ 监听的客户程序，可以得到网络事件通知；</li>
<li>非阻塞式<code>I/O</code>客户程序；</li>
<li>多进程客户程序；</li>
<li>多线程客户程序。</li>
</ul>
<h2 id="1-tcp预先派生子进程服务器程序accept无上锁保护">1. <code>TCP</code>预先派生子进程服务器程序，<code>accept</code>无上锁保护</h2>
<p>        这种技术的优点在于无须引入父进程执行 $fork$ 的开销就能处理新客户，缺点是父进程必须在服务器启动阶段配置预先派生子进程数量。可选的改进方案是增加一些代码，让父进程监听可用子进程数，一旦降低到某个阈值就派生额外的子进程；同样的，一旦可用子进程数增加到某个阈值就终止一些过剩的子进程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unp.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define MAXN 16384  </span><span class="c1">// max # bytes client can request
</span><span class="c1"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nchildren</span><span class="p">;</span>
<span class="k">static</span> <span class="n">pid_t</span> <span class="o">*</span><span class="n">pids</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="n">pid_t</span> <span class="n">child_make</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Tcp_listen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">.</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Tcp_listen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: serv02 [ &lt;host&gt; ] &lt;port#&gt; &lt;#children&gt;&#34;</span><span class="p">);</span>
  <span class="n">nchildren</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="n">pids</span> <span class="o">=</span> <span class="n">Calloc</span><span class="p">(</span><span class="n">nchildren</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pid_t</span><span class="p">));</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_make</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">listendfd</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>  <span class="c1">// parent returns
</span><span class="c1"></span>
  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span>
    <span class="n">pause</span><span class="p">();</span>  <span class="c1">// everything done by children
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">sig_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="c1">// terminate all children
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">kill</span><span class="p">(</span><span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">SIGTERM</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">// wait for all children
</span><span class="c1"></span>    <span class="k">continue</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">ECHILD</span><span class="p">)</span>
    <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;wait error&#34;</span><span class="p">);</span>

  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">pid_t</span> <span class="nf">child_make</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">child_main</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>  <span class="c1">// parent
</span><span class="c1"></span>
  <span class="n">child_main</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>  <span class="c1">// never returns
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">child_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">web_child</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="n">socklen_t</span> <span class="n">clilen</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">cliaddr</span><span class="p">;</span>

  <span class="n">cliaddr</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">addrlen</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;child %ld starting</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">getpid</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
    <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>
    <span class="n">web_child</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// process the request
</span><span class="c1"></span>    <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">web_child</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">ntowrite</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">nread</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">nread</span> <span class="o">=</span> <span class="n">Realine</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>  <span class="c1">// connection closed by other end
</span><span class="c1"></span>
    <span class="c1">// line from client specifies #bytes to write back
</span><span class="c1"></span>    <span class="n">ntowrite</span> <span class="o">=</span> <span class="n">atol</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">ntowrite</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ntowrite</span> <span class="o">&gt;</span> <span class="n">MAXN</span><span class="p">))</span>
      <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;client request for %d bytes&#34;</span><span class="p">,</span> <span class="n">ntowrite</span><span class="p">);</span>

    <span class="n">Writen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">ntowrite</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        父进程在派生任何子进程之前创建监听套接字，从而每次 $fork$ 时，所有描述符也被复制。服务器进程在程序启动阶段派生 $N$ 个子进程，它们各自调用 $accept$ 并处于休眠状态。当客户连接到达时，所有子进程均被唤醒，因为它们使用同一个监听描述符，但是只有最先运行的子进程会获得连接，其余子进程会重新休眠。这就是<em><strong>惊群</strong></em> ( $thundering$ $herd$ ) 问题，尽管只有一个子进程获得连接，所有的子进程却都被唤醒了，这样会导致性能受损。<br>
        与这个例子相关的另一种现象是 $select$ 冲突。如果我们通过 $select$ 来 $accept$ 新客户，那么内核会唤醒所有在阻塞在 $select$ 并且等待同一个监听套接字的进程，从而产生冲突。从以上问题，我们可以得出：如果有多个进程阻塞在引用同一个实体的描述符上，最好直接阻塞在 $accept$ 等函数中，而不是 $select$ 上。</p>
<h2 id="2-tcp预先派生子进程服务器程序accept使用文件上锁保护">2. <code>TCP</code>预先派生子进程服务器程序，<code>accept</code>使用文件上锁保护</h2>
<p>        允许多个进程在引用同一个监听套接字的描述上调用 $accept$ 仅适用于在内核中实现 $accept$ 的源自 $Berkeley$ 的内核。在其他内核，解决办法是让应用程序在调用 $accept$ 前后使用锁，从而在任意时刻最多只有一个进程阻塞在 $accept$ 调用上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 派生子进程之前初始化锁
</span><span class="c1"></span><span class="n">my_lock_init</span><span class="p">(</span><span class="s">&#34;/tmp/lock.XXXXXX&#34;</span><span class="p">);</span>  <span class="c1">// one lock file for all children
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="n">pids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_make</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>  <span class="c1">// parent returns
</span><span class="c1"></span>
<span class="c1">// 子进程调用accept前后加锁
</span><span class="c1"></span><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
  <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
  <span class="n">my_lock_wait</span><span class="p">();</span>
  <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>
  <span class="n">my_lock_release</span><span class="p">();</span>

  <span class="n">web_child</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// process request
</span><span class="c1"></span>  <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unp.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">flock</span> <span class="n">lock_it</span><span class="p">,</span> <span class="n">unlock_it</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lock_fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="c1">// fcntl() will fail if my_lock_init() not called
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">my_lock_init</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">lock_file</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

  <span class="c1">// must copy caller&#39;s string, incase is&#39;s a constant
</span><span class="c1"></span>  <span class="n">strncpy</span><span class="p">(</span><span class="n">lock_file</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lock_file</span><span class="p">));</span>
  <span class="n">lock_fd</span> <span class="o">=</span> <span class="n">Mkstemp</span><span class="p">(</span><span class="n">lock_file</span><span class="p">);</span>

  <span class="n">Unlink</span><span class="p">(</span><span class="n">lock_file</span><span class="p">);</span>  <span class="c1">// but lock_fd remains open
</span><span class="c1"></span>
  <span class="n">lock_it</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">F_WRLCK</span><span class="p">;</span>
  <span class="n">lock_it</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">SEEK_SET</span><span class="p">;</span>
  <span class="n">lock_it</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">lock_it</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">unlock_it</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">;</span>
  <span class="n">unlock_it</span><span class="p">.</span><span class="n">l_whence</span> <span class="o">=</span> <span class="n">SEEK_SET</span><span class="p">;</span>
  <span class="n">unlock_it</span><span class="p">.</span><span class="n">l_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">unlock_it</span><span class="p">.</span><span class="n">l_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>        调用者将一个路径名模版指定为 $my_-lock_-init$ 函数的参数，$mktemp$ 函数根据该模版创建一个唯一路径名。本函数随后创建一个具备该路径名的文件并立即 $unlink$ 掉，这样以后程序崩溃，这个临时文件也会消失。然而只要有一个进程打开着这个文件，这个文件就不会消失。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">my_lock_wait</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">lock_fd</span><span class="p">,</span> <span class="n">F_SETLKW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock_it</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;fcntl error for my_lock_wait&#34;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_lock_release</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fcntl</span><span class="p">(</span><span class="n">lock_fd</span><span class="p">,</span> <span class="n">F_SETLKW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unlock_it</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">err_sys</span><span class="p">(</span><span class="s">&#34;fcntl error for my_lock_release&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="3-tcp预先派生子进程服务器程序accept使用线程上锁保护">3. <code>TCP</code>预先派生子进程服务器程序，<code>accept</code>使用线程上锁保护</h2>
<p>        我们有多种方法实现进程上锁，<code>POSIX</code>文件上锁方法可移植到所有<code>POSIX</code>兼容系统，不过因为涉及文件操作，可能比较耗时。在不同进程之间使用线程上锁，要求：(a)互斥锁变量必须存放在由所有进程共享的内存中；(b)必须告知线程函数库这是在不同进程之间共享的互斥锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mptr</span><span class="p">;</span>  <span class="c1">// actual mutex will be in shared memory
</span><span class="c1"></span>
<span class="kt">void</span> <span class="nf">my_lock_init</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="n">pthread_mutexattr_t</span> <span class="n">mattr</span><span class="p">;</span>

  <span class="n">fd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="s">&#34;/dev/zero&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">mptr</span> <span class="o">=</span> <span class="n">Mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
              <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

  <span class="n">Pthread_mutexattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mattr</span><span class="p">);</span>
  <span class="n">Pthread_mutexattr_setpshared</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mattr</span><span class="p">,</span> <span class="n">PTHREAD_PROCESS_SHARED</span><span class="p">);</span>
  <span class="n">Pthread_mutex_init</span><span class="p">(</span><span class="n">mptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mattr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>        打开 $/dev/zero$ 然后调用 $mmap$ ，映射的字节数是一个 $pthread_-mutex_-t$ 类型的变量大小。随后关闭描述，因为该描述符已经被内存映射了。在先前的互斥锁中，我们使用 $PTHREAD_-MUTEX_-INTIALIZER$ 初始化全局或静态互斥锁变量。然而对于一个存放在共享内存区的互斥锁，必须调用一些 $pthread$ 库函数告知该函数库这是一个位于共享内存区的互斥锁，用于不同进程间上锁。我们首先为该互斥锁以默认属性初始化一个 $pthread_-mutexattr_-t$ 结构，然后赋予该结构 $PTHREAD_-PROCESS_-SHARED$ 属性 ( 该结构默认属性为 $PTHREAD_-PROCESS_-PRIVATE$ ，即只能在进程内使用 )。最后调用 $pthread_-mutex_-init$ 函数初始化共享内存区的互斥锁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">my_lock_wait</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="n">mptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_lock_release</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="n">mptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="4-tcp预先派生子进程服务器程序传递描述符">4. <code>TCP</code>预先派生子进程服务器程序，传递描述符</h2>
<p>        这个版本是让父进程调用 $accept$ ，然后将描述符传递给子进程。这种技术会使代码变得有点复杂，因为父进程必须跟踪子进程的忙闲状态。为了实现这个机制，我们必须为每个子进程维护一个信息结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">pid_t</span> <span class="n">child_pid</span><span class="p">;</span>  <span class="c1">// process ID;
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">child_pipefd</span><span class="p">;</span>  <span class="c1">// parent&#39;s stream pipe to/from child
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">child_status</span><span class="p">;</span>  <span class="c1">// 0 = ready
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">child_count</span><span class="p">;</span>  <span class="c1">// # connections handled
</span><span class="c1"></span><span class="p">}</span> <span class="n">Child</span><span class="p">;</span>

  <span class="n">Child</span> <span class="o">*</span><span class="n">cptr</span><span class="p">;</span>  <span class="c1">// array of Child structures; calloc&#39; ed
</span></code></pre></div><p>        我们在该结构中存放子进程<code>ID</code>、父进程中连接到子进程的字节流管道描述符、子进程状态和子进程已处理客户的计数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">pid_t</span> <span class="nf">child_make</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sockfd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">child_main</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

  <span class="n">Socketpair</span><span class="p">(</span><span class="n">AF_LOCAL</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">Fork</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span> <span class="o">=</span> <span class="n">sockfd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>  <span class="c1">// parent
</span><span class="c1"></span>  <span class="p">}</span>

  <span class="n">Dup2</span><span class="p">(</span><span class="n">sockfd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">STDERR_FILENO</span><span class="p">);</span>  <span class="c1">// child&#39;s stream pipe to parent
</span><span class="c1"></span>  <span class="n">Close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span>  <span class="c1">// child does not need this open
</span><span class="c1"></span>  <span class="n">child_main</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>  <span class="c1">// never returns
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>        $child_-make$ 函数在调用 $fork$ 前先创建一个字节流管道。派生出子进程后，父进程关闭其中一个描述符 $sockfd[1]$ ，子进程关闭另一个描述符 $sockfd[0]$ 。子进程还把流管道的自身拥有端 $sockfd[1]$ 复制到标准错误输出，这样每个子进程就通过读写标准错误输出和父进程通信。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unp.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;child.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nchildren</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">navail</span><span class="p">,</span> <span class="n">maxfd</span><span class="p">,</span> <span class="n">nsel</span><span class="p">,</span> <span class="n">connfd</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="n">pid_t</span> <span class="n">child_make</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">fd_set</span> <span class="n">rset</span><span class="p">,</span> <span class="n">masterset</span><span class="p">;</span>
  <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">,</span> <span class="n">clilen</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">cliaddr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Tcp_listen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Tcp_listen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: serv05 [ &lt;host&gt; ] &lt;potr#&gt; &lt;#children&gt;&#34;</span><span class="p">);</span>

  <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">masterset</span><span class="p">);</span>
  <span class="n">FD_SET</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">masterset</span><span class="p">);</span>
  <span class="n">maxfd</span> <span class="o">=</span> <span class="n">listenfd</span><span class="p">;</span>
  <span class="n">cliaddr</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">addrlen</span><span class="p">);</span>

  <span class="n">nchildren</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="n">navail</span> <span class="o">=</span> <span class="n">nchildren</span><span class="p">;</span>
  <span class="n">cptr</span> <span class="o">=</span> <span class="n">Calloc</span><span class="p">(</span><span class="n">nchildren</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Child</span><span class="p">));</span>

  <span class="c1">// prefork all the children
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">child_make</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>  <span class="c1">// parent returns
</span><span class="c1"></span>    <span class="n">FD_SET</span><span class="p">(</span><span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">masterset</span><span class="p">);</span>
    <span class="n">maxfd</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxfd</span><span class="p">,</span> <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">rset</span> <span class="o">=</span> <span class="n">masterset</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">navail</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">FD_CLR</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">);</span>  <span class="c1">// turn off if no available children
</span><span class="c1"></span>    <span class="n">nsel</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="n">maxfd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// check for new connections
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
      <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>

      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span>  <span class="c1">// available
</span><span class="c1"></span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nchildren</span><span class="p">)</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;no available children&#34;</span><span class="p">);</span>
      <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// mark child as busy
</span><span class="c1"></span>      <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_count</span><span class="o">++</span><span class="p">;</span>
      <span class="n">navail</span><span class="o">--</span><span class="p">;</span>

      <span class="n">n</span> <span class="o">=</span> <span class="n">Write_fd</span><span class="p">(</span><span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">connfd</span><span class="p">);</span>
      <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nsel</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>  <span class="c1">// all done with select() results
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="c1">// find any newly-available children
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nchildren</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rset</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">Read</span><span class="p">(</span><span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_pipefd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
          <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;child %d terminated unexpectedly&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">cptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">child_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">navail</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nsel</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span>  <span class="c1">// all done with select() results
</span><span class="c1"></span>      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        $navail$ 跟踪当前可用的子进程数，如果为 $0$ ，关闭 $select$ 读描述符集中监听套接字对应的位。这种情况下，内核仍然会处理外来连接，将它们入队，直到达到 $backlog$ 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">child_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">web_child</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;child %ld starting</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">getpid</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">Read_fd</span><span class="p">(</span><span class="n">STDERR_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">connfd</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;read_fd returned 0&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">connfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;no descriptor from read_fd&#34;</span><span class="p">);</span>

    <span class="n">web_child</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// process request
</span><span class="c1"></span>    <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>

    <span class="n">Write</span><span class="p">(</span><span class="n">STDERR_FILENO</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// tell parent we&#39;re ready again
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        $child_-main$ 在处理完一个客户后，通过该子进程的字节流管道拥有端向父进程写回单个字节。父进程读入这单个字节，把子进程标记为可用，并递增 $navail$ 。当子进程意外终止，它的字节流管道拥有端会被关闭，从而 $read$ 会返回 $0$ 。父进程察觉到之后就会停止运行，不过更好的办法是登记这个错误并重新派生一个子进程。</p>
<h2 id="5-tcp并发服务器程序每个客户一个线程">5. <code>TCP</code>并发服务器程序，每个客户一个线程</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">doit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
  <span class="n">pthread_t</span> <span class="n">pid</span><span class="p">;</span>
  <span class="n">socklen_t</span> <span class="n">clilen</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">cliaddr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Tcp_listen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Tcp_listen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: serv06 [ &lt;host&gt; ] &lt;port#&gt;&#34;</span><span class="p">);</span>
  <span class="n">cliaddr</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">addrlen</span><span class="p">);</span>

  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
    <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>
    <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doit</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">connfd</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">doit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">web_child</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

  <span class="n">Pthread_detach</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">());</span>
  <span class="n">web_child</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
  <span class="n">Close</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="6-tcp预先创建线程服务器程序每个线程各自accept">6. <code>TCP</code>预先创建线程服务器程序，每个线程各自<code>accept</code></h2>
<p>        在支持线程的系统上，我们有理由在服务器启动阶段先创建一个线程池。本服务器的基本设计是预先创建一个线程池，并让每个线程各自调用 $accept$ ，同时使用互斥锁保证任何时刻只有一个线程在调用 $accept$ 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">thread_tid</span><span class="p">;</span>  <span class="c1">// thread id
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">thread_count</span><span class="p">;</span>  <span class="c1">// # connections handled
</span><span class="c1"></span><span class="p">}</span> <span class="n">Thread</span><span class="p">;</span>
<span class="n">Thread</span> <span class="o">*</span><span class="n">tptr</span><span class="p">;</span>  <span class="c1">// array of Thread structures; calloc &#39;ed
</span><span class="c1"></span>
<span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">nthreads</span><span class="p">;</span>
<span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">;</span>
<span class="n">pthread_mutex_t</span> <span class="n">mlock</span><span class="p">;</span>
</code></pre></div><hr>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;pthread07.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">pthread_mutex_t</span> <span class="n">mlock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">thread_make</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Tcp_listen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Tcp_listen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: serv07 [ &lt;host&gt; ] &lt;port#&gt; &lt;#threads&gt;&#34;</span><span class="p">);</span>
  <span class="n">nthreads</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="n">tprt</span> <span class="o">=</span> <span class="n">Calloc</span><span class="p">(</span><span class="n">nthreads</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Thread</span><span class="p">));</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">thread_make</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// only main thread returns
</span><span class="c1"></span>
  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span>
    <span class="n">pause</span><span class="p">();</span>  <span class="c1">// everything done by threads
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><hr>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;pthread07.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">thread_make</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">thread_main</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">thread_tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_main</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">i</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>  <span class="c1">// main thread returns
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_main</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">web_child</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="n">socklen_t</span> <span class="n">clilen</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">cliaddr</span><span class="p">;</span>

  <span class="n">cliaddr</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">addrlen</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;thread %d starting</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
    <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlock</span><span class="p">);</span>
    <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>
    <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlock</span><span class="p">);</span>
    <span class="n">tprt</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">].</span><span class="n">thread_count</span><span class="o">++</span><span class="p">;</span>

    <span class="n">web_child</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// process request
</span><span class="c1"></span>    <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="7-tcp预先创建线程服务器程序主线程统一accept">7. <code>TCP</code>预先创建线程服务器程序，主线程统一<code>accept</code></h2>
<p>        本设计范式的问题在于主线程如何把一个已连接套接字传递给线程池中某个可用线程。这里有多个实现手段。可以像之前那样使用描述符传递，但是没有必要，因为多个线程之间描述符是共享的，接收线程只需要知道已连接套接字描述符的值即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">thread_tid</span><span class="p">;</span>  <span class="c1">// thread id
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">thread_count</span><span class="p">;</span>  <span class="c1">// # connections handled
</span><span class="c1"></span><span class="p">}</span> <span class="n">Thread</span><span class="p">;</span>
<span class="n">Thread</span> <span class="o">*</span><span class="n">tptr</span><span class="p">;</span>  <span class="c1">// array of Thread structures; calloc&#39;ed
</span><span class="c1"></span>
<span class="cp">#define MAXNCLI 32
</span><span class="cp"></span><span class="kt">int</span> <span class="n">clifd</span><span class="p">[</span><span class="n">MAXNCLT</span><span class="p">],</span> <span class="n">iget</span><span class="p">,</span> <span class="n">iput</span><span class="p">;</span>
<span class="n">pthread_mutex_t</span> <span class="n">clifd_mutex</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">clifd_cond</span><span class="p">;</span>
</code></pre></div><p>        $clifd$ 数组会存储线程已经接受的已连接套接字描述符，$iget$ 为下一个待取出描述符元素所在的下标，$iput$ 为下一个待写入描述符元素所在的下标。我们使用互斥锁和条件变量确保这个数组被安全地修改。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;pthread08.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nthreads</span><span class="p">;</span>
<span class="n">pthread_mutex_t</span> <span class="n">clifd_mutex</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">clifd_cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INTIALIZER</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">sig_int</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">thread_make</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">,</span> <span class="n">clilen</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">cliaddr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Tcp_listen</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Tcp_listen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;usage: serv08 [ &lt;host&gt; ] &lt;port#&gt; &lt;#threads&gt;&#34;</span><span class="p">);</span>
  <span class="n">cliaddr</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">addrlen</span><span class="p">);</span>

  <span class="n">nthreads</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="n">tprt</span> <span class="o">=</span> <span class="n">Calloc</span><span class="p">(</span><span class="n">nthreads</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Thread</span><span class="p">));</span>
  <span class="n">iget</span> <span class="o">=</span> <span class="n">iput</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// create all the threads
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">thread_make</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// only main thread returns
</span><span class="c1"></span>
  <span class="n">Signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_int</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">clilen</span> <span class="o">=</span> <span class="n">addrlen</span><span class="p">;</span>
    <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span>

    <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_mutex</span><span class="p">);</span>
    <span class="n">clifd</span><span class="p">[</span><span class="n">iput</span><span class="p">]</span> <span class="o">=</span> <span class="n">connfd</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">iput</span> <span class="o">==</span> <span class="n">MAXNCLI</span><span class="p">)</span>
      <span class="n">iput</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iput</span> <span class="o">==</span> <span class="n">iget</span><span class="p">)</span>
      <span class="n">err_quit</span><span class="p">(</span><span class="s">&#34;iput = iget = %d&#34;</span><span class="p">,</span> <span class="n">iput</span><span class="p">);</span>
    <span class="n">Pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_cond</span><span class="p">);</span>
    <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_mutex</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><hr>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;unpthread.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;pthread08.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">thread_make</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">thread_main</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

  <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tptr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">thread_tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_main</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">i</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>  <span class="c1">// main thread returns
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_main</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">web_child</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;thread %d starting</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_mutex</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">iget</span> <span class="o">==</span> <span class="n">iput</span><span class="p">)</span>
      <span class="n">Pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clifd_mutex</span><span class="p">);</span>
    <span class="n">connfd</span> <span class="o">=</span> <span class="n">clifd</span><span class="p">[</span><span class="n">iget</span><span class="p">];</span>  <span class="c1">// connected socket to service
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">iget</span> <span class="o">==</span> <span class="n">MAXNCLI</span><span class="p">)</span>
      <span class="n">iget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clifd_mutex</span><span class="p">);</span>
    <span class="n">tptr</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span> <span class="n">arg</span><span class="p">].</span><span class="n">thread_count</span><span class="o">++</span><span class="p">;</span>

    <span class="n">web_child</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// process request
</span><span class="c1"></span>    <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>        这个版本的慢于之前的每个线程各自 $accept$ 的版本，因为同时需要互斥锁和条件变量。</p>

            </div>
            <div class="meta post-footer"> 
                <span>2022 Feb 18 14:37</span> 
                <a href="https://z217blog.cn/post/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B15/"><i class="fas fa-link"></i> link</a>
            </div>
        </div>
        
    </div>
</div>


        </div><footer>
    <div class="footer-content">
        
        <div class="contact-info">
            
            <div class="footer-github">
                <i class="fab fa-github fa-ms"></i> <a target="_blank" href="https://github.com/z217">github.com/z217</a>
            </div>
            
            
            <div class="footer-mail">
                <i class="far fa-envelope"></i> <a href="mailto:mailto:zihan.zhouchn@outlook.com">mailto:zihan.zhouchn@outlook.com</a> </div>
            
            
        </div>
        
        
        <p class="copyright meta">Copyright © 2020–2022, z217 and the hugo authors, all rights reserved. Theme: <a target="_blank"
                href="https://github.com/ahmedsaadxyzz/npq-hugo">npq-hugo</a></p>
        
    </div>
</footer>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [
                ['$', '$'],
                ['\\(', '\\)']
            ],
            displayMath: [
                ['$$', '$$'],
                ['\[\[', '\]\]']
            ],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });

    MathJax.Hub.Queue(function () {
        let all = MathJax.Hub.getAllJax(),
            i;
        
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<style>
    code.has-jax {
        font: inherit;
        font-size: 100%;
        background: inherit;
        border: inherit;
        color: #515151;
    }
</style></main>
</body>

</html>